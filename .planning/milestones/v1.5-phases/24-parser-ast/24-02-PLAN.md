---
phase: 24-parser-ast
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/lib.rs
autonomous: true
requirements:
  - PARSE-01
  - PARSE-02
  - PARSE-03
  - PARSE-04

must_haves:
  truths:
    - "aqprod(q,q,infinity,20) parses into FuncCall with name 'aqprod' and 4 args: Q, Q, Infinity, Integer(20)"
    - "f := etaq(1,1,20) parses into Assign with name 'f' and value FuncCall"
    - "f + g parses into BinOp(Add, Variable(f), Variable(g)) and similarly for -, *, /"
    - "-f parses into Neg(Variable(f)) and 3*f parses into BinOp(Mul, Integer(3), Variable(f))"
    - "3/4 parses as BinOp(Div, Integer(3), Integer(4)) -- division, not rational literal"
    - "2^3^4 is a parse error (non-associative exponentiation)"
    - "f := etaq(1,1,20); g := etaq(2,1,20); f * g parses into 3 Stmts with correct terminators (Semi, Semi, Implicit)"
    - "% parses as LastResult atom in any expression position"
    - "Empty input and double semicolons do not crash"
  artifacts:
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "tokenize() function: &str -> Result<Vec<SpannedToken>, ParseError>"
      exports: ["tokenize"]
      min_lines: 60
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "parse() and parse_line() functions: &str -> Result<Vec<Stmt>, ParseError>"
      exports: ["parse"]
      min_lines: 100
  key_links:
    - from: "crates/qsym-cli/src/lexer.rs"
      to: "crates/qsym-cli/src/token.rs"
      via: "produces SpannedToken values"
      pattern: "SpannedToken"
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/lexer.rs"
      via: "calls tokenize() to get token stream"
      pattern: "tokenize"
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "produces AstNode and Stmt values"
      pattern: "(AstNode|Stmt)"
    - from: "crates/qsym-cli/src/lib.rs"
      to: "lexer.rs, parser.rs"
      via: "pub mod declarations"
      pattern: "pub mod (lexer|parser)"
---

<objective>
Implement the complete lexer (tokenizer) and Pratt parser for the Maple-style grammar, with comprehensive tests covering all expression types, operator precedence, statement chaining, and error cases.

Purpose: This is the core parsing engine. After this plan, any valid Maple-style expression can be parsed into an AST that Phase 25 (evaluator) will interpret. The parser must handle every construct a q-series researcher would type: function calls with keyword arguments (infinity, q), arithmetic on series, variable assignment, multi-statement lines, and the % ditto operator.

Output: Working lexer + parser with 30+ tests covering the full grammar, all PARSE-* requirements satisfied.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-parser-ast/24-RESEARCH.md
@.planning/phases/24-parser-ast/24-01-SUMMARY.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/error.rs
@crates/qsym-cli/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement the lexer (tokenizer)</name>
  <files>
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/lib.rs
  </files>
  <action>
1. Create `crates/qsym-cli/src/lexer.rs` with a public function:
   `pub fn tokenize(input: &str) -> Result<Vec<SpannedToken>, ParseError>`

2. Implementation details:
   - Iterate over `input.as_bytes()` with a `pos: usize` cursor
   - Skip ASCII whitespace (space, tab -- NOT newlines, but newlines won't appear in REPL single-line input)
   - Single-character tokens: `+` -> Plus, `-` -> Minus, `*` -> Star, `/` -> Slash, `^` -> Caret, `%` -> Percent, `(` -> LParen, `)` -> RParen, `,` -> Comma, `;` -> Semi
   - Two-character greedy match for `:`: if next char is `=`, emit Assign (`:=`); otherwise emit Colon
   - Numeric literals: consume consecutive ASCII digits. Try `str::parse::<i64>()`. On success -> `Token::Integer(n)`. On overflow -> `Token::BigInteger(s.to_string())`
   - Identifiers/keywords: start with `[a-zA-Z_]`, continue with `[a-zA-Z0-9_]`. After consuming the word:
     - "infinity" -> `Token::Infinity`
     - "q" -> `Token::Q`
     - anything else -> `Token::Ident(word.to_string())`
   - Unknown characters: return `ParseError` with message "unexpected character '{c}'" and span pointing at the character
   - After the loop, append `SpannedToken { token: Token::Eof, span: Span { start: pos, end: pos } }`
   - Each token gets a `Span { start, end }` recording its byte range in the source

3. Add `pub mod lexer;` to `lib.rs` (alongside existing ast, token, error modules).

4. Write tests in `lexer.rs` (`#[cfg(test)] mod tests`):
   - `test_simple_tokens`: tokenize `"+ - * / ^ % ( ) , ; :"` -> correct token sequence
   - `test_assign_vs_colon`: tokenize `"f := 5"` -> [Ident("f"), Assign, Integer(5), Eof]; tokenize `"f:"` -> [Ident("f"), Colon, Eof]
   - `test_integer`: tokenize `"42"` -> [Integer(42), Eof]
   - `test_big_integer`: tokenize `"99999999999999999999999"` -> [BigInteger("99999999999999999999999"), Eof]
   - `test_keywords`: tokenize `"q infinity"` -> [Q, Infinity, Eof]
   - `test_identifiers`: tokenize `"aqprod etaq ETAR partition_count f"` -> correct Ident tokens
   - `test_function_call_tokens`: tokenize `"aqprod(q,q,infinity,20)"` -> [Ident("aqprod"), LParen, Q, Comma, Q, Comma, Infinity, Comma, Integer(20), RParen, Eof]
   - `test_assignment_tokens`: tokenize `"f := etaq(1,1,20)"` -> correct token sequence
   - `test_multi_statement`: tokenize `"f := 5; g := 10:"` -> includes Semi and Colon terminators
   - `test_unknown_char`: tokenize `"f @ g"` -> Err with "unexpected character '@'"
   - `test_empty_input`: tokenize `""` -> [Eof]
   - `test_whitespace_handling`: tokenize `"  q  "` -> [Q, Eof] (whitespace stripped)
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- lexer 2>&1`
All lexer tests pass. No compiler warnings.
  </verify>
  <done>The tokenize() function correctly converts any Maple-style input string into a token stream with byte spans, handling all 17 token types, the := vs : ambiguity, integer overflow to BigInteger, keyword recognition (q, infinity), and unknown character errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement the Pratt parser with comprehensive tests</name>
  <files>
    crates/qsym-cli/src/parser.rs
    crates/qsym-cli/src/lib.rs
  </files>
  <action>
1. Create `crates/qsym-cli/src/parser.rs` with:

   A public convenience function:
   `pub fn parse(input: &str) -> Result<Vec<Stmt>, ParseError>`
   - Calls `tokenize(input)?` to get token stream
   - Creates a `Parser` struct and calls `parse_line()`

   A `Parser` struct (private):
   ```
   struct Parser {
       tokens: Vec<SpannedToken>,
       pos: usize,
       source: String,  // for error rendering context
   }
   ```

   Helper methods on Parser:
   - `peek(&self) -> &Token` -- returns token at current pos (or Eof)
   - `peek_span(&self) -> Span` -- returns span at current pos
   - `advance(&mut self) -> SpannedToken` -- consume and return current token
   - `expect(&mut self, expected: Token) -> Result<SpannedToken, ParseError>` -- consume if matching, else error with descriptive message like "expected ')' to close function call, found ';'"
   - `at_end(&self) -> bool` -- true if peek is Eof

   `parse_line(&mut self) -> Result<Vec<Stmt>, ParseError>`:
   - Loop while not at Eof:
     - Skip consecutive Semi/Colon tokens (handle empty statements like `;;`)
     - If now at Eof, break
     - Parse expression via `expr_bp(0)`
     - Determine terminator: Semi -> advance + Terminator::Semi, Colon -> advance + Terminator::Colon, Eof -> Terminator::Implicit, anything else -> error "expected ';', ':', or end of input"
     - Push Stmt { node, terminator }
   - Return collected stmts

   `expr_bp(&mut self, min_bp: u8) -> Result<AstNode, ParseError>`:
   Pratt parser with the following binding powers:

   Prefix (nud):
   - `Integer(n)` -> advance, AstNode::Integer(n)
   - `BigInteger(s)` -> advance, AstNode::BigInteger(s)
   - `Q` -> advance, AstNode::Q
   - `Infinity` -> advance, AstNode::Infinity
   - `Percent` -> advance, AstNode::LastResult
   - `Ident(name)` -> advance, AstNode::Variable(name)
   - `Minus` -> advance, parse expr_bp(7), wrap in AstNode::Neg
   - `LParen` -> advance, parse expr_bp(0), expect RParen, return inner (grouping)
   - anything else -> error "expected expression, found {token}"

   Infix/Postfix loop (led):
   - Check if next token is an operator with binding power >= min_bp
   - `LParen` (postfix, l_bp=11): Only if lhs is AstNode::Variable. advance, parse comma-separated arg list (parse_arg_list), expect RParen. Produce AstNode::FuncCall. Handle zero-arg calls like `f()`.
   - `Assign` (infix, l_bp=2, r_bp=1): Only if lhs is AstNode::Variable. advance, parse expr_bp(1). Produce AstNode::Assign. If lhs is not Variable, error "left side of := must be a variable name".
   - `Plus` (l=3, r=4): left-assoc. advance, parse expr_bp(4). BinOp::Add.
   - `Minus` (l=3, r=4): left-assoc. advance, parse expr_bp(4). BinOp::Sub.
   - `Star` (l=5, r=6): left-assoc. advance, parse expr_bp(6). BinOp::Mul.
   - `Slash` (l=5, r=6): left-assoc. advance, parse expr_bp(6). BinOp::Div.
   - `Caret` (l=9, r=10): advance, parse expr_bp(10). BinOp::Pow. THEN check if next token is also Caret -- if so, return error "ambiguous exponentiation: use parentheses, e.g., (a^b)^c or a^(b^c)". This enforces non-associativity per Maple convention.
   - Any other token or l_bp < min_bp -> break loop

   `parse_arg_list(&mut self) -> Result<Vec<AstNode>, ParseError>`:
   - If next token is RParen, return empty vec (zero-arg call)
   - Parse first arg via expr_bp(0)
   - While next token is Comma: advance, parse expr_bp(0), push to vec
   - Return args

   Binding power helper functions (free functions or methods):
   - `infix_bp(token: &Token) -> Option<(u8, u8)>`:
     - Plus|Minus -> Some((3, 4))
     - Star|Slash -> Some((5, 6))
     - Caret -> Some((9, 10))
     - _ -> None
   - Assign is handled separately in the loop (l_bp=2, r_bp=1)
   - Prefix minus has r_bp=7
   - Function call postfix has l_bp=11

2. Add `pub mod parser;` to `lib.rs`.

3. Write comprehensive tests in `parser.rs` (`#[cfg(test)] mod tests`):

   **PARSE-01 (Function calls):**
   - `test_simple_function_call`: parse `"aqprod(q,q,infinity,20)"` -> single Stmt with FuncCall { name: "aqprod", args: [Q, Q, Infinity, Integer(20)] }, Terminator::Implicit
   - `test_zero_arg_function`: parse `"f()"` -> FuncCall { name: "f", args: [] }
   - `test_nested_function_call`: parse `"f(g(1))"` -> FuncCall with arg that is itself a FuncCall
   - `test_partition_count`: parse `"partition_count(50)"` -> FuncCall with Integer(50) arg

   **PARSE-02 (Assignment):**
   - `test_simple_assignment`: parse `"f := 5"` -> Assign { name: "f", value: Integer(5) }
   - `test_assignment_with_function`: parse `"f := etaq(1,1,20)"` -> Assign with FuncCall value
   - `test_assignment_prints`: parse `"f := 5;"` -> terminator is Semi (displays assigned value per Maple)
   - `test_assignment_suppresses`: parse `"f := 5:"` -> terminator is Colon (suppresses)
   - `test_assign_non_variable_error`: parse `"3 := 5"` -> error about left side

   **PARSE-03 (Arithmetic):**
   - `test_addition`: parse `"f + g"` -> BinOp(Add, Variable("f"), Variable("g"))
   - `test_subtraction`: parse `"f - g"` -> BinOp(Sub, ...)
   - `test_multiplication`: parse `"f * g"` -> BinOp(Mul, ...)
   - `test_division`: parse `"3 / 4"` -> BinOp(Div, Integer(3), Integer(4))
   - `test_unary_negation`: parse `"-f"` -> Neg(Variable("f"))
   - `test_scalar_mul`: parse `"3*f"` -> BinOp(Mul, Integer(3), Variable("f"))
   - `test_precedence_add_mul`: parse `"a + b * c"` -> BinOp(Add, a, BinOp(Mul, b, c))
   - `test_precedence_neg_mul`: parse `"-3*f"` -> BinOp(Mul, Neg(Integer(3)), Variable("f"))
   - `test_exponentiation`: parse `"q^5"` -> BinOp(Pow, Q, Integer(5))
   - `test_non_assoc_caret`: parse `"2^3^4"` -> error about ambiguous exponentiation
   - `test_parens_override`: parse `"(a + b) * c"` -> BinOp(Mul, BinOp(Add, a, b), c)
   - `test_complex_expr`: parse `"3 * aqprod(q,q,infinity,20) + 1"` -> correct tree

   **PARSE-04 (Literals and keywords):**
   - `test_integer_literal`: parse `"50"` -> Integer(50)
   - `test_big_integer_literal`: parse `"99999999999999999999999"` -> BigInteger(...)
   - `test_infinity`: parse `"infinity"` -> Infinity
   - `test_q_keyword`: parse `"q"` -> Q
   - `test_percent_last_result`: parse `"%"` -> LastResult
   - `test_percent_in_expr`: parse `"% + 1"` -> BinOp(Add, LastResult, Integer(1))

   **Statement chaining:**
   - `test_multi_statement_semi`: parse `"f := 5; g := 10"` -> 2 Stmts, first Semi, second Implicit
   - `test_multi_statement_mixed`: parse `"f := etaq(1,1,20); g := etaq(2,1,20); f * g"` -> 3 Stmts (Semi, Semi, Implicit)
   - `test_colon_suppresses`: parse `"f := 5: g := 10;"` -> 2 Stmts (Colon, Semi)
   - `test_double_semicolon`: parse `"f := 5;; g := 10"` -> 2 Stmts (empty between semis is skipped)
   - `test_trailing_semicolon`: parse `"f := 5;"` -> 1 Stmt with Semi terminator
   - `test_empty_input`: parse `""` -> 0 Stmts (empty vec)

   **Error cases:**
   - `test_error_unexpected_token`: parse `")"` -> error "expected expression"
   - `test_error_missing_rparen`: parse `"f(1,2"` -> error about expected ')'
   - `test_error_has_span`: verify error span points to correct byte offset
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1`
All tests pass (lexer + parser + type tests from Plan 01). No compiler warnings. Expected: 40+ tests total.

Also run: `cargo test -p qsym-cli -- --nocapture parser::tests::test_simple_function_call 2>&1` to visually verify the aqprod parse tree.
  </verify>
  <done>The parse() function correctly handles all Maple-style constructs: function calls with positional arguments including q and infinity (PARSE-01), variable assignment with := and variable references (PARSE-02), arithmetic with correct precedence including non-associative ^ (PARSE-03), and integer/big-integer/infinity/q/%  literals (PARSE-04). Multi-statement lines with ;/: terminators parse into Vec&lt;Stmt&gt; with correct Terminator variants. Error messages include byte spans and caret rendering.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` passes all 40+ tests
2. `cargo check --workspace` succeeds (no workspace breakage)
3. All 4 PARSE-* requirements are covered:
   - PARSE-01: test_simple_function_call, test_nested_function_call, test_partition_count, test_zero_arg_function
   - PARSE-02: test_simple_assignment, test_assignment_with_function, test_assignment_prints, test_assignment_suppresses
   - PARSE-03: test_addition through test_complex_expr (11 tests covering +, -, *, /, ^, unary -, precedence, parens)
   - PARSE-04: test_integer_literal, test_big_integer_literal, test_infinity, test_q_keyword, test_percent_last_result
4. Operator precedence matches research spec: := (2,1) < +/- (3,4) < */ (5,6) < unary- (7) < ^ (9,10) < funcall (11)
5. Non-associative ^ is enforced (2^3^4 is parse error)
6. Multi-statement parsing with ;/: terminators works correctly
7. Empty input and double semicolons do not crash
</verification>

<success_criteria>
- parse("aqprod(q,q,infinity,20)") returns FuncCall with 4 correct args
- parse("f := etaq(1,1,20)") returns Assign with FuncCall value
- parse("f + g") and all arithmetic variants produce correct BinOp trees
- parse("3/4") produces BinOp(Div, 3, 4) -- division per discretion decision
- parse("2^3^4") is an error -- non-associative per Maple convention
- parse("f := 5; g := 10:") produces 2 statements with correct terminators
- All error messages include byte spans
- Parser is ready for Phase 25 (evaluator) to consume
</success_criteria>

<output>
After completion, create `.planning/phases/24-parser-ast/24-02-SUMMARY.md`
</output>
