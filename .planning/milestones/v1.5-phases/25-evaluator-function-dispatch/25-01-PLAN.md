---
phase: 25-evaluator-function-dispatch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/environment.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-cli/src/lib.rs
autonomous: true
requirements:
  - SESS-01
  - OUT-01

must_haves:
  truths:
    - "Variables assigned in one statement are retrievable in subsequent statements"
    - "Last result is accessible via % reference"
    - "Series display as human-readable text (1 - q - q^2 + q^5 + O(q^20))"
    - "Integers display as plain numbers"
    - "List literals [a, b, c] parse and evaluate correctly"
    - "Arithmetic on series (add, sub, mul, div, pow, neg) produces correct series"
    - "Arithmetic on integers/rationals produces correct numeric results"
    - "Unknown variable references produce descriptive error"
    - "Panics from qsym-core are caught and reported as errors without crashing"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value enum, eval_stmt, eval_expr, eval_stmt_safe with panic catching"
      min_lines: 200
    - path: "crates/qsym-cli/src/environment.rs"
      provides: "Environment struct with variables HashMap, last_result, SymbolRegistry, sym_q"
      min_lines: 40
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_value function for all Value variants"
      min_lines: 60
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/environment.rs"
      via: "&mut Environment parameter on eval_stmt/eval_expr"
      pattern: "env:\\s*&mut Environment"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qsym_core::series::arithmetic"
      via: "arithmetic::add/sub/mul/negate/scalar_mul/invert calls"
      pattern: "arithmetic::(add|sub|mul|negate|scalar_mul|invert)"
    - from: "crates/qsym-cli/src/format.rs"
      to: "eval.rs Value enum"
      via: "match on Value variants"
      pattern: "Value::(Series|Integer|Rational|List|Dict|Pair|Bool|None)"
---

<objective>
Build the evaluator core that walks AstNode trees, manages a variable environment with session state, performs arithmetic on Values, catches panics, and formats results as text. Also extend the parser with [...] list literal support needed by function dispatch (Plan 02/03).

Purpose: This is the foundation layer -- Plan 02 and 03 plug function dispatch into the dispatch point created here.
Output: eval.rs (Value enum + eval_stmt + eval_expr + panic catching), environment.rs (Environment struct), format.rs (output formatting), parser extensions for [...] lists.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-evaluator-function-dispatch/25-RESEARCH.md
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/error.rs
@crates/qsym-cli/src/lib.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/symbol.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser extension for list literals and evaluator foundation types</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/ast.rs
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/parser.rs
    crates/qsym-cli/src/environment.rs
    crates/qsym-cli/src/format.rs
    crates/qsym-cli/src/lib.rs
  </files>
  <action>
  **Parser extension for [...] list literals:**

  1. In `token.rs`, add two new Token variants:
     - `LBracket` for `[`
     - `RBracket` for `]`

  2. In `ast.rs`, add a new AstNode variant:
     - `List(Vec<AstNode>)` -- list literal: `[expr1, expr2, ...]`

  3. In `lexer.rs`, add `[` and `]` to the single-character token match:
     - `b'[' => Some(Token::LBracket)`
     - `b']' => Some(Token::RBracket)`

  4. In `parser.rs`:
     - Add `LBracket` as a prefix/NUD case in `expr_bp`: when `Token::LBracket` is seen, advance, parse comma-separated expressions (reuse the comma-parsing pattern from `parse_arg_list`), expect `Token::RBracket`, return `AstNode::List(items)`. Empty list `[]` is valid.
     - Add `Token::LBracket` and `Token::RBracket` to the `token_name` function for error messages.
     - Add tests: `[1, 2, 3]` parses to `AstNode::List`, `[f, g]` with variables, `[]` empty list, nested `[[1,2], [3,4]]`, list as function argument `findlincombo(target, [f, g], 20)`.

  **Environment module:**

  5. Create `crates/qsym-cli/src/environment.rs`:
     ```rust
     use std::collections::HashMap;
     use qsym_core::symbol::{SymbolId, SymbolRegistry};
     ```
     - `pub struct Environment` with fields:
       - `pub variables: HashMap<String, Value>` (user-defined variables)
       - `pub last_result: Option<Value>` (for `%` reference)
       - `pub symbols: SymbolRegistry` (owns interning)
       - `pub sym_q: SymbolId` (cached "q" symbol)
       - `pub default_order: i64` (default truncation, initially 20)
     - `impl Environment`:
       - `pub fn new() -> Self`: creates SymbolRegistry, interns "q", sets default_order=20
       - `pub fn set_var(&mut self, name: &str, val: Value)`: inserts into variables
       - `pub fn get_var(&self, name: &str) -> Option<&Value>`: looks up variable
     - Import `Value` from `super::eval::Value` (forward reference -- eval.rs created in Task 2)

  **Format module:**

  6. Create `crates/qsym-cli/src/format.rs`:
     - `pub fn format_value(val: &Value) -> String` matching on all Value variants:
       - `Value::Series(fps)` -> `format!("{}", fps)` (uses FPS Display impl which gives `1 - q + O(q^20)`)
       - `Value::Integer(n)` -> `format!("{}", n)` (plain number)
       - `Value::Rational(r)` -> `format!("{}", r)` (fraction like `3/7`)
       - `Value::List(items)` -> `[item1, item2, ...]` with recursive format_value on each element; for list-of-lists (matrix), put each inner list on its own line
       - `Value::Dict(entries)` -> `{key1: val1, key2: val2}` with recursive format_value
       - `Value::Pair(a, b)` -> `(formatted_a, formatted_b)`
       - `Value::Bool(b)` -> `"true"` or `"false"`
       - `Value::None` -> `"NONE"`
       - `Value::Infinity` -> `"infinity"`
     - Add tests for each variant.

  **Lib.rs update:**

  7. In `lib.rs`, add the three new modules:
     ```rust
     pub mod eval;
     pub mod environment;
     pub mod format;
     ```
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all existing parser tests pass plus new list literal tests pass.
  </verify>
  <done>
  - `[1, 2, 3]` parses to `AstNode::List(vec![Integer(1), Integer(2), Integer(3)])`
  - `[]` parses to `AstNode::List(vec![])`
  - Environment::new() creates a working environment with sym_q interned
  - format_value produces correct output for all Value variants
  - All 68 existing parser tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Evaluator core with Value enum, expression evaluation, arithmetic, and panic catching</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
  Create `crates/qsym-cli/src/eval.rs` with:

  **Value enum:**
  ```rust
  use qsym_core::number::{QInt, QRat};
  use qsym_core::series::FormalPowerSeries;

  #[derive(Clone, Debug)]
  pub enum Value {
      Series(FormalPowerSeries),
      Integer(QInt),
      Rational(QRat),
      List(Vec<Value>),
      Dict(Vec<(String, Value)>),
      Pair(Box<Value>, Box<Value>),
      Bool(bool),
      None,
      Infinity,
  }
  ```
  Add `Value::type_name(&self) -> &'static str` helper returning human-readable type names ("series", "integer", etc.).

  **EvalError enum:**
  ```rust
  #[derive(Debug)]
  pub enum EvalError {
      UnknownVariable { name: String },
      UnknownFunction { name: String, suggestions: Vec<String> },
      WrongArgCount { function: String, expected: String, got: usize, signature: String },
      ArgType { function: String, arg_index: usize, expected: &'static str, got: String },
      TypeError { operation: String, left: String, right: String },
      NoLastResult,
      Panic(String),
      Other(String),
  }
  ```
  Implement `Display` for `EvalError` with user-friendly messages. For `WrongArgCount`: `"Error: {function} expects {expected} arguments ({signature}), got {got}"`. For `UnknownFunction`: `"Error: unknown function '{name}'. Did you mean: {suggestions joined by ', '}?"`. For `Panic`: `"Error: computation failed: {msg}"`.

  **Argument extraction helpers** (used by dispatch in Plans 02/03):
  - `pub fn expect_args(name: &str, args: &[Value], expected: usize) -> Result<(), EvalError>`
  - `pub fn expect_args_range(name: &str, args: &[Value], min: usize, max: usize) -> Result<(), EvalError>` -- for functions with optional params
  - `pub fn extract_i64(name: &str, args: &[Value], index: usize) -> Result<i64, EvalError>` -- handles both Integer (via QInt.0.to_i64()) and BigInteger-as-error
  - `pub fn extract_qrat(name: &str, args: &[Value], index: usize) -> Result<QRat, EvalError>` -- accepts Integer (promote to QRat) or Rational
  - `pub fn extract_series(name: &str, args: &[Value], index: usize) -> Result<FormalPowerSeries, EvalError>` -- clones out the FPS
  - `pub fn extract_series_list(name: &str, args: &[Value], index: usize) -> Result<Vec<FormalPowerSeries>, EvalError>` -- expects Value::List of Series
  - `pub fn extract_bool(name: &str, args: &[Value], index: usize) -> Result<bool, EvalError>`

  **Core evaluator functions:**

  1. `pub fn eval_stmt(stmt: &Stmt, env: &mut Environment) -> Result<Option<Value>, EvalError>`:
     - If `Stmt.node` is `AstNode::Assign { name, value }`: evaluate value expression, store in `env.variables`, set `env.last_result`, return the value (or None if Colon terminator).
     - Otherwise: evaluate expression, set `env.last_result`, return the value.
     - Respect Terminator: Semi/Implicit -> return `Some(value)`, Colon -> return `None`.

  2. `pub fn eval_expr(node: &AstNode, env: &mut Environment) -> Result<Value, EvalError>`:
     Walk AST recursively:
     - `AstNode::Integer(n)` -> `Value::Integer(QInt::from(*n))`
     - `AstNode::BigInteger(s)` -> `Value::Integer(QInt(rug::Integer::from_str_radix(s, 10).unwrap()))`
     - `AstNode::Q` -> Create a monomial series: q^1 + O(q^{default_order}). Use `FormalPowerSeries::monomial(QRat::one(), 1, env.sym_q, env.default_order)`.
     - `AstNode::Infinity` -> `Value::Infinity`
     - `AstNode::LastResult` -> Clone `env.last_result` or error `NoLastResult`
     - `AstNode::Variable(name)` -> Look up `env.get_var(name)`, clone it, or error `UnknownVariable`
     - `AstNode::List(items)` -> Evaluate each item, collect into `Value::List`
     - `AstNode::Neg(inner)` -> Evaluate inner, then negate:
       - `Value::Series(fps)` -> `Value::Series(arithmetic::negate(&fps))`
       - `Value::Integer(n)` -> `Value::Integer(-n)`
       - `Value::Rational(r)` -> `Value::Rational(-r)`
       - Other -> TypeError
     - `AstNode::BinOp { op, lhs, rhs }` -> Evaluate both sides, then dispatch arithmetic (see below)
     - `AstNode::FuncCall { name, args }` -> Evaluate all args, then call `dispatch(name, &evaluated_args, env)` (stub for now that returns `EvalError::UnknownFunction` -- Plans 02/03 fill it in)
     - `AstNode::Assign { name, value }` -> Evaluate value, store in env, return value

  3. **Arithmetic dispatch** (`eval_binop`):
     Handle all combinations per the research table:
     - Series + Series -> `arithmetic::add`
     - Series - Series -> `arithmetic::sub`
     - Series * Series -> `arithmetic::mul`
     - Integer/Rational * Series (or Series * Integer/Rational) -> convert scalar to QRat, `arithmetic::scalar_mul`
     - Series / Series -> `arithmetic::mul(a, arithmetic::invert(b))`
     - Series ^ Integer(n) -> if n >= 0: repeated mul (or `FormalPowerSeries::one()` for n=0); if n < 0: invert then power
     - Integer +/-/*/^ Integer -> QInt arithmetic
     - Integer / Integer -> QRat (promote both to QRat, divide)
     - Rational +/-/*// Rational -> QRat arithmetic
     - Integer op Rational (or vice versa) -> promote Integer to Rational, then QRat arithmetic
     - **Series + Integer/Rational** -> convert scalar to constant FPS (`FormalPowerSeries::constant()`), then `arithmetic::add`. This matches Maple behavior.
     - Other combinations -> TypeError with descriptive message

  4. `pub fn eval_stmt_safe(stmt: &Stmt, env: &mut Environment) -> Result<Option<Value>, EvalError>`:
     Wrap `eval_stmt` in `std::panic::catch_unwind(AssertUnwindSafe(|| ...))`. On panic, extract message from payload (downcast to `&str` or `String`), return `EvalError::Panic(msg)`.

  5. **Dispatch stub**: Create a `pub fn dispatch(name: &str, args: &[Value], env: &mut Environment) -> Result<Value, EvalError>` that for now just returns `UnknownFunction` with empty suggestions. Plans 02 and 03 will replace the body. Include the `resolve_alias` helper (case-insensitive lookup from a static alias table) and `find_similar_names` (Levenshtein edit distance) so the error messages work immediately.

  **Alias table**: Create `fn resolve_alias(name: &str) -> String` with a match on lowercase name covering all 16 Maple aliases from the research (numbpart, rankgf, crankgf, qphihyper, qpsihyper, qgauss, proveid, qZeil, qzeilberger, qPetkovsek, qpetkovsek, qgosper, findlincombo_modp, findhom_modp, findhomcombo_modp, search_id). Return canonical q-Kangaroo name. If no alias matches, return input unchanged.

  **Fuzzy matching**: Create `fn find_similar_names(unknown: &str) -> Vec<String>` using Levenshtein edit distance. Include `fn edit_distance(a: &str, b: &str) -> usize` (standard DP implementation, ~15 lines). Collect all 79 canonical function names (hard-coded list) plus alias names. Filter by edit distance <= 3 or substring containment. Return top 3 sorted by distance.

  **Tests** (in eval.rs `#[cfg(test)]` module):
  - Evaluate `AstNode::Integer(42)` -> `Value::Integer(42)`
  - Evaluate `AstNode::Q` -> `Value::Series` with q^1 coefficient
  - Evaluate `AstNode::Variable("f")` with f in env -> correct value
  - Evaluate `AstNode::Variable("f")` without f -> UnknownVariable error
  - Evaluate `AstNode::LastResult` with no last result -> NoLastResult error
  - Evaluate `AstNode::BinOp Add` on two integers -> correct sum
  - Evaluate `AstNode::BinOp Mul` on integer * integer -> correct product
  - Evaluate `AstNode::Neg` on integer -> negated value
  - Evaluate assignment stores variable in environment
  - Colon terminator returns None from eval_stmt
  - Levenshtein: edit_distance("etaq", "etaq") == 0, edit_distance("etaq", "eta") == 1
  - find_similar_names("etaq2") includes "etaq"
  - resolve_alias("numbpart") == "partition_count"
  - resolve_alias("aqprod") == "aqprod" (no alias, passthrough)
  - eval_stmt_safe catches a deliberate panic and returns EvalError::Panic
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all tests pass including new eval tests.
  </verify>
  <done>
  - Value enum supports Series, Integer, Rational, List, Dict, Pair, Bool, None, Infinity
  - eval_expr correctly evaluates all AstNode variants
  - Arithmetic on Series uses qsym_core::series::arithmetic functions
  - Arithmetic on integers/rationals uses QInt/QRat operations
  - Series + Integer promotes integer to constant FPS
  - eval_stmt_safe catches panics and returns EvalError::Panic
  - resolve_alias maps all 16 Maple names to canonical names
  - find_similar_names returns relevant suggestions for misspelled function names
  - Assignment stores value in Environment.variables and sets last_result
  - All argument extraction helpers work correctly
  </done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
cargo test -p qsym-cli -- eval --nocapture  # Verify eval-specific tests
```
</verification>

<success_criteria>
- All existing 68 parser tests pass (no regressions)
- New list literal parser tests pass
- eval.rs compiles and tests pass for integer arithmetic, variable lookup, last result, panic catching
- format_value produces correct strings for all Value types
- Environment persists variables across eval_stmt calls
- Alias resolution and fuzzy matching work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/25-evaluator-function-dispatch/25-01-SUMMARY.md`
</output>
