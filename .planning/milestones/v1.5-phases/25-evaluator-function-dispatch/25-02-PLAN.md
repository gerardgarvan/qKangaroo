---
phase: 25-evaluator-function-dispatch
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements:
  - FUNC-01
  - FUNC-02
  - FUNC-03
  - FUNC-04

must_haves:
  truths:
    - "aqprod(1,1,1,infinity,20) computes (q;q)_inf and returns a series"
    - "etaq(1,1,20) computes eta(q) and returns a series"
    - "jacprod(1,5,20) computes J(1,5) and returns a series"
    - "tripleprod(1,1,1,20) computes the Jacobi triple product"
    - "quinprod(1,1,1,20) computes the quintuple product"
    - "winquist(1,1,1,1,1,1,20) computes Winquist's product"
    - "theta2(20), theta3(20), theta4(20) each return a series"
    - "partition_count(50) returns 204226"
    - "partition_gf(20) returns the partition generating function series"
    - "distinct_parts_gf(20), odd_parts_gf(20), bounded_parts_gf(5,20) return series"
    - "rank_gf(1,1,20) and crank_gf(1,1,20) return series"
    - "qbin(5,2,20) returns a q-binomial coefficient series"
    - "sift(series, 5, 4) extracts congruence subsequence"
    - "prodmake(series, 20) returns a Dict with product form"
    - "etamake(series, 20), jacprodmake(series, 20), mprodmake(series, 20), qetamake(series, 20) return Dicts"
    - "qfactor(series) returns a Dict with factorization"
    - "qdegree(series) and lqdegree(series) return integers or NONE"
    - "Wrong argument count shows expected signature"
    - "Wrong argument type shows descriptive error"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "dispatch function with groups 1-4 filled in (q-Pochhammer, partitions, theta, series analysis)"
      contains: "\"aqprod\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::aqprod"
      via: "match arm calling qseries::aqprod with extracted args"
      pattern: "qseries::aqprod"
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::prodmake"
      via: "match arm calling qseries::prodmake with series arg"
      pattern: "qseries::prodmake"
---

<objective>
Wire function dispatch groups 1-4 into the evaluator's dispatch function: q-Pochhammer/products (6 functions), partitions (7 functions), theta (3 functions), and series analysis (9 functions) -- 25 functions total covering FUNC-01 through FUNC-04.

Purpose: After this plan, users can call any of the core q-series generation and analysis functions and see computed results.
Output: Updated eval.rs with 25 dispatch arms in the match table.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-evaluator-function-dispatch/25-RESEARCH.md
@.planning/phases/25-evaluator-function-dispatch/25-01-SUMMARY.md
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/qseries/qbinomial.rs
@crates/qsym-core/src/qseries/partitions.rs
@crates/qsym-core/src/qseries/theta.rs
@crates/qsym-core/src/qseries/rank_crank.rs
@crates/qsym-core/src/qseries/utilities.rs
@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/qseries/factoring.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Function dispatch for groups 1-2 (q-Pochhammer/products + partitions)</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
  In the `dispatch` function's match table in eval.rs, add match arms for the following 13 functions. Each arm validates arguments using the extraction helpers, calls the corresponding qsym-core function, and wraps the result in a Value variant.

  **Group 1: q-Pochhammer and Products (FUNC-01) -- 6 functions:**

  1. `"aqprod"` -- Pattern A (session-implicit):
     - REPL signature: `aqprod(coeff_num, coeff_den, power, n_or_infinity, order)`
     - 5 args required. Extract coeff_num (i64), coeff_den (i64), power (i64), then check arg[3]: if `Value::Infinity` -> `PochhammerOrder::Infinite`, else extract i64 -> `PochhammerOrder::Finite(n)`. Extract order (i64) from arg[4].
     - Build `QMonomial::new(QRat::from((coeff_num, coeff_den)), power)`.
     - Call `qseries::aqprod(&monomial, env.sym_q, poch_order, order)`.
     - Return `Value::Series(result)`.
     - Signature hint for errors: `"(coeff_num, coeff_den, power, n_or_infinity, order)"`.

  2. `"qbin"` -- Pattern A:
     - REPL: `qbin(n, k, order)` -- 3 args, all i64.
     - Call `qseries::qbin(n, k, env.sym_q, order)`.
     - Return `Value::Series`.

  3. `"etaq"` -- Pattern A:
     - REPL: `etaq(b, t, order)` -- 3 args, all i64.
     - Call `qseries::etaq(b, t, env.sym_q, order)`.
     - Return `Value::Series`.

  4. `"jacprod"` -- Pattern A:
     - REPL: `jacprod(a, b, order)` -- 3 args, all i64.
     - Call `qseries::jacprod(a, b, env.sym_q, order)`.
     - Return `Value::Series`.

  5. `"tripleprod"` -- Pattern A:
     - REPL: `tripleprod(coeff_num, coeff_den, power, order)` -- 4 args.
     - Build QMonomial from first 3 args. Extract order from arg[3].
     - Call `qseries::tripleprod(&monomial, env.sym_q, order)`.
     - Return `Value::Series`.

  6. `"quinprod"` -- Pattern A:
     - REPL: `quinprod(coeff_num, coeff_den, power, order)` -- 4 args.
     - Same pattern as tripleprod.
     - Call `qseries::quinprod(&monomial, env.sym_q, order)`.
     - Return `Value::Series`.

  7. `"winquist"` -- Pattern A:
     - REPL: `winquist(a_cn, a_cd, a_p, b_cn, b_cd, b_p, order)` -- 7 args.
     - Build two QMonomials from args[0..3] and args[3..6]. Extract order from arg[6].
     - Call `qseries::winquist(&a, &b, env.sym_q, order)`.
     - Return `Value::Series`.

  **Group 2: Partitions (FUNC-02) -- 7 functions:**

  8. `"partition_count"` -- Pattern B (no session):
     - REPL: `partition_count(n)` -- 1 arg, i64.
     - Call `qseries::partition_count(n)`.
     - Return `Value::Integer(QInt::from(result))` -- partition_count returns i64.
     - Note: actually check the return type. If it returns `QInt` directly, wrap that.

  9. `"partition_gf"` -- Pattern A:
     - REPL: `partition_gf(order)` -- 1 arg, i64.
     - Call `qseries::partition_gf(env.sym_q, order)`.
     - Return `Value::Series`.

  10. `"distinct_parts_gf"` -- Pattern A:
      - REPL: `distinct_parts_gf(order)` -- 1 arg, i64.
      - Call `qseries::distinct_parts_gf(env.sym_q, order)`.

  11. `"odd_parts_gf"` -- Pattern A:
      - REPL: `odd_parts_gf(order)` -- 1 arg, i64.
      - Call `qseries::odd_parts_gf(env.sym_q, order)`.

  12. `"bounded_parts_gf"` -- Pattern A:
      - REPL: `bounded_parts_gf(max_part, order)` -- 2 args, both i64.
      - Call `qseries::bounded_parts_gf(max_part, env.sym_q, order)`.

  13. `"rank_gf"` -- Pattern A:
      - REPL: `rank_gf(z_num, z_den, order)` -- 3 args.
      - Build `QRat::from((z_num, z_den))` from first two args.
      - Call `qseries::rank_gf(&z, env.sym_q, order)`.

  14. `"crank_gf"` -- Pattern A:
      - REPL: `crank_gf(z_num, z_den, order)` -- 3 args.
      - Same as rank_gf pattern.
      - Call `qseries::crank_gf(&z, env.sym_q, order)`.

  **Signature hints** -- Create a `fn get_signature(name: &str) -> String` function that returns human-readable signatures for error messages, e.g.:
  - `"aqprod"` -> `"(coeff_num, coeff_den, power, n_or_infinity, order)"`
  - `"etaq"` -> `"(b, t, order)"`
  - `"partition_count"` -> `"(n)"`
  (Cover all functions added in this task.)

  **Tests:**
  - Test `dispatch("etaq", &[Value::Integer(1), Value::Integer(1), Value::Integer(20)], &mut env)` returns a Value::Series
  - Test `dispatch("partition_count", &[Value::Integer(5)], &mut env)` returns Value::Integer with value 7
  - Test `dispatch("aqprod", ...)` with infinity argument returns Series
  - Test wrong arg count: `dispatch("etaq", &[Value::Integer(1)], &mut env)` returns WrongArgCount error containing "etaq expects 3 arguments"
  - Test wrong arg type: `dispatch("etaq", &[Value::Bool(true), ...])` returns ArgType error
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all tests pass.
  </verify>
  <done>
  - All 7 q-Pochhammer/product functions dispatch correctly and return Value::Series
  - All 7 partition functions dispatch correctly (partition_count returns Integer, rest return Series)
  - Wrong argument count errors show expected signature
  - Wrong argument type errors are descriptive
  </done>
</task>

<task type="auto">
  <name>Task 2: Function dispatch for groups 3-4 (theta + series analysis)</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
  Continue filling the dispatch match table with groups 3 and 4.

  **Group 3: Theta Functions (FUNC-03) -- 3 functions:**

  1. `"theta2"` -- Pattern A:
     - REPL: `theta2(order)` -- 1 arg, i64.
     - Call `qseries::theta2(env.sym_q, order)`.
     - Return `Value::Series`.

  2. `"theta3"` -- Pattern A:
     - REPL: `theta3(order)` -- 1 arg, i64.
     - Call `qseries::theta3(env.sym_q, order)`.

  3. `"theta4"` -- Pattern A:
     - REPL: `theta4(order)` -- 1 arg, i64.
     - Call `qseries::theta4(env.sym_q, order)`.

  **Group 4: Series Analysis (FUNC-04) -- 9 functions:**

  4. `"sift"` -- Pattern C (series-input):
     - REPL: `sift(series, m, j)` -- 3 args.
     - Extract series from arg[0], m (i64) from arg[1], j (i64) from arg[2].
     - Call `qseries::sift(&fps, m, j)`.
     - Return `Value::Series`.

  5. `"qdegree"` -- Pattern C:
     - REPL: `qdegree(series)` -- 1 arg.
     - Extract series from arg[0].
     - Call `qseries::qdegree(&fps)`.
     - Returns `Option<i64>`: if Some(n) -> `Value::Integer(QInt::from(n))`, if None -> `Value::None`.

  6. `"lqdegree"` -- Pattern C:
     - REPL: `lqdegree(series)` -- 1 arg.
     - Same pattern as qdegree.
     - Call `qseries::lqdegree(&fps)`.

  7. `"prodmake"` -- Pattern C:
     - REPL: `prodmake(series, max_n)` -- 2 args.
     - Extract series and max_n (i64).
     - Call `qseries::prodmake(&fps, max_n)`.
     - Returns `InfiniteProductForm` which has `exponents: BTreeMap<i64, QRat>`. Convert to `Value::Dict` with entries like `("exponents", Value::Dict([(key.to_string(), Value::Rational(val))...]))`.

  8. `"etamake"` -- Pattern C:
     - REPL: `etamake(series, max_n)` -- 2 args.
     - Call `qseries::etamake(&fps, max_n)`.
     - Returns `EtaQuotient` -- convert to Dict with eta factor entries.

  9. `"jacprodmake"` -- Pattern C:
     - REPL: `jacprodmake(series, max_n)` -- 2 args.
     - Call `qseries::jacprodmake(&fps, max_n)`.
     - Returns `JacobiProductForm` -- convert to Dict.

  10. `"mprodmake"` -- Pattern C:
      - REPL: `mprodmake(series, max_n)` -- 2 args.
      - Call `qseries::mprodmake(&fps, max_n)`.
      - Returns the same type as prodmake. Convert to Dict.

  11. `"qetamake"` -- Pattern C:
      - REPL: `qetamake(series, max_n)` -- 2 args.
      - Call `qseries::qetamake(&fps, max_n)`.
      - Returns `QEtaForm` -- convert to Dict.

  12. `"qfactor"` -- Pattern C:
      - REPL: `qfactor(series)` -- 1 arg.
      - Extract series from arg[0].
      - Call `qseries::qfactor(&fps)`.
      - Returns `QFactorization` with `scalar`, `factors: BTreeMap<i64, i64>`, `is_exact`. Convert to `Value::Dict` with entries: `("scalar", Value::Rational(scalar))`, `("factors", Value::Dict(...))`, `("is_exact", Value::Bool(is_exact))`.

  **Conversion helpers** -- Create private helper functions for converting qsym-core result types to Value::Dict:
  - `fn infinite_product_form_to_value(ipf: &InfiniteProductForm) -> Value`
  - `fn eta_quotient_to_value(eq: &EtaQuotient) -> Value`
  - `fn jacobi_product_form_to_value(jpf: &JacobiProductForm) -> Value`
  - `fn q_eta_form_to_value(qef: &QEtaForm) -> Value`
  - `fn q_factorization_to_value(qf: &QFactorization) -> Value`

  Each reads the struct's public fields and builds a Value::Dict with human-readable keys. Check each struct's fields by reading the source files (prodmake.rs, factoring.rs).

  **Add signatures** to `get_signature`:
  - `"theta2"` -> `"(order)"`
  - `"sift"` -> `"(series, m, j)"`
  - `"prodmake"` -> `"(series, max_n)"`
  - `"qfactor"` -> `"(series)"`
  - etc.

  **Tests:**
  - Test `dispatch("theta3", &[Value::Integer(20)], &mut env)` returns Value::Series
  - Test `dispatch("sift", &[series_val, Value::Integer(5), Value::Integer(0)], &mut env)` returns Value::Series
  - Test `dispatch("prodmake", &[series_val, Value::Integer(20)], &mut env)` returns Value::Dict
  - Test `dispatch("qfactor", &[series_val], &mut env)` returns Value::Dict with "is_exact" key
  - Test `dispatch("qdegree", &[series_val], &mut env)` returns Value::Integer or Value::None
  - Integration test: parse and evaluate `etaq(1,1,20)` end-to-end through eval_stmt -> returns Value::Series formatted as `1 - q - q^2 + ...`
  - Integration test: parse and evaluate `f := etaq(1,1,20); prodmake(f, 10)` -> variable persistence + analysis function
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all tests pass.
  </verify>
  <done>
  - theta2/3/4 all return Value::Series
  - sift extracts subsequences correctly
  - qdegree/lqdegree return Integer or None
  - prodmake/etamake/jacprodmake/mprodmake/qetamake return Dict with product form data
  - qfactor returns Dict with scalar, factors, is_exact
  - End-to-end: parse("etaq(1,1,20)") -> eval -> Value::Series -> format_value gives human-readable series text
  - Variable persistence works across eval_stmt calls
  </done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
# End-to-end integration test via specific test names:
cargo test -p qsym-cli -- dispatch --nocapture
cargo test -p qsym-cli -- integration --nocapture
```
</verification>

<success_criteria>
- All 25 functions in groups 1-4 are callable via dispatch and return correct Value types
- Series functions return Value::Series, partition_count returns Value::Integer, analysis functions return Value::Dict
- Argument count/type errors produce descriptive messages with expected signatures
- End-to-end test: `parse("etaq(1,1,20)")` -> `eval_stmt` -> `Value::Series` -> `format_value` produces series text
- End-to-end test: variable assignment + function call works across statements
</success_criteria>

<output>
After completion, create `.planning/phases/25-evaluator-function-dispatch/25-02-SUMMARY.md`
</output>
