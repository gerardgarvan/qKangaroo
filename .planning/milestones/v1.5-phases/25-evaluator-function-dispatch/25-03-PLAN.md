---
phase: 25-evaluator-function-dispatch
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements:
  - FUNC-05
  - FUNC-06
  - FUNC-07
  - FUNC-08

must_haves:
  truths:
    - "findlincombo(target, [f, g, h], 20) finds a linear combination and returns a coefficient list"
    - "findhom([f, g], 2, 20) finds a homogeneous relation and returns a list"
    - "findpoly(x, y, 3, 3, 20) finds a polynomial relation and returns a Dict"
    - "findcong(series, [5, 7, 11]) finds congruences and returns a list of Dicts"
    - "findmaxind([f, g, h], 20) returns a list of indices"
    - "findprod([f, g], 2, 3) searches for product relations"
    - "All modp variants (findlincombomodp, findhommodp, findhomcombomodp) work"
    - "phi(upper_list, lower_list, z_n, z_d, z_p, order) computes a basic hypergeometric series"
    - "psi(upper_list, lower_list, z_n, z_d, z_p, order) computes a bilateral series"
    - "try_summation returns a series or NONE"
    - "heine1/2/3 return a pair (prefactor, result)"
    - "All 20 mock theta functions return series"
    - "appell_lerch_m(a_pow, z_pow, order) returns a series"
    - "g2(a_pow, order) and g3(a_pow, order) return series"
    - "bailey_weak_lemma returns a pair of series"
    - "q_gosper returns a Dict describing the algorithm result"
    - "q_zeilberger returns a Dict"
    - "verify_wz returns a Dict"
    - "q_petkovsek returns a list of result Dicts"
    - "prove_eta_id returns a Dict with proof result"
    - "search_identities returns a list of matching entries"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Complete dispatch function with all 79 functions"
      contains: "\"mock_theta_f3\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::findlincombo"
      via: "match arm extracting series list and calling findlincombo"
      pattern: "qseries::findlincombo"
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::eval_phi"
      via: "match arm building HypergeometricSeries and calling eval_phi"
      pattern: "eval_phi"
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::mock_theta_f3"
      via: "match arm for mock_theta_f3"
      pattern: "mock_theta_f3"
    - from: "crates/qsym-cli/src/eval.rs dispatch"
      to: "qsym_core::qseries::q_gosper"
      via: "match arm building HypergeometricSeries and calling q_gosper"
      pattern: "q_gosper"
---

<objective>
Wire function dispatch groups 5-8 into the evaluator: relation discovery (15 functions), hypergeometric (9 functions), mock theta/Appell-Lerch/Bailey (27 functions), and identity proving (8 functions) -- 59 functions total covering FUNC-05 through FUNC-08. This completes all 79 function dispatch arms.

Purpose: After this plan, every q-Kangaroo function is callable from the evaluator.
Output: Updated eval.rs with all 79 dispatch arms complete.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-evaluator-function-dispatch/25-RESEARCH.md
@.planning/phases/25-evaluator-function-dispatch/25-01-SUMMARY.md
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/relations.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mock_theta.rs
@crates/qsym-core/src/qseries/appell_lerch.rs
@crates/qsym-core/src/qseries/bailey.rs
@crates/qsym-core/src/qseries/gosper.rs
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/petkovsek.rs
@crates/qsym-core/src/qseries/nonterminating.rs
@crates/qsym-core/src/qseries/identity/prove.rs
@crates/qsym-core/src/qseries/identity/database.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Function dispatch for groups 5-6 (relation discovery + hypergeometric)</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
  Add dispatch match arms for groups 5 (relation discovery) and 6 (hypergeometric).

  **Group 5: Relation Discovery (FUNC-05) -- 15 functions:**

  Pattern D (target + list of candidates):

  1. `"findlincombo"` -- `findlincombo(target, [candidates...], topshift)` -- 3 args.
     - Extract target series from arg[0], candidate series list from arg[1] (using extract_series_list), topshift i64 from arg[2].
     - Call `qseries::findlincombo(&target, &refs, topshift)` where `refs` is `Vec<&FPS>` built from the extracted list.
     - Returns `Option<Vec<QRat>>`: if Some(coeffs) -> `Value::List(coeffs.into_iter().map(Value::Rational).collect())`, if None -> `Value::None`.

  2. `"findhomcombo"` -- `findhomcombo(target, [candidates...], degree, topshift)` -- 4 args.
     - Extract target, candidate list, degree (i64), topshift (i64).
     - Call `qseries::findhomcombo(...)`.
     - Returns `Option<Vec<QRat>>` -> same as findlincombo.

  3. `"findnonhomcombo"` -- `findnonhomcombo(target, [candidates...], degree, topshift)` -- 4 args.
     - Same pattern as findhomcombo.
     - Call `qseries::findnonhomcombo(...)`.

  4. `"findlincombomodp"` -- `findlincombomodp(target, [candidates...], p, topshift)` -- 4 args.
     - Extract target, candidates, p (i64), topshift (i64).
     - Call `qseries::findlincombomodp(...)`.
     - Returns `Option<Vec<QRat>>`.

  5. `"findhomcombomodp"` -- `findhomcombomodp(target, [candidates...], p, degree, topshift)` -- 5 args.
     - Call `qseries::findhomcombomodp(...)`.

  Pattern E (list of series):

  6. `"findhom"` -- `findhom([series...], degree, topshift)` -- 3 args.
     - Extract series list from arg[0], degree (i64), topshift (i64).
     - Call `qseries::findhom(&refs, degree, topshift)`.
     - Returns `Vec<Vec<QRat>>` (matrix). Convert to `Value::List(rows.map(|row| Value::List(row.map(Value::Rational))))`.

  7. `"findnonhom"` -- `findnonhom([series...], degree, topshift)` -- 3 args.
     - Same as findhom.
     - Call `qseries::findnonhom(...)`.

  8. `"findhommodp"` -- `findhommodp([series...], p, degree, topshift)` -- 4 args.
     - Call `qseries::findhommodp(...)`.

  9. `"findmaxind"` -- `findmaxind([series...], topshift)` -- 2 args.
     - Extract series list, topshift.
     - Call `qseries::findmaxind(&refs, topshift)`.
     - Returns `Vec<usize>`. Convert to `Value::List(indices.map(|i| Value::Integer(QInt::from(i as i64))))`.

  10. `"findprod"` -- `findprod([series...], max_coeff, max_exp)` -- 3 args.
      - Extract series list, max_coeff (i64), max_exp (i64).
      - Call `qseries::findprod(...)`.
      - Returns result -- check return type. Convert appropriately to Value::List or Value::Dict.

  11. `"findcong"` -- `findcong(series, [moduli...])` -- 2 args.
      - Extract series from arg[0]. Extract moduli as a list of i64 from arg[1] (List of Integers).
      - Call `qseries::findcong(&fps, &moduli)`.
      - Returns `Vec<Congruence>`. Each Congruence has modulus, residue, divisor fields. Convert to `Value::List` of `Value::Dict` entries.

  Pattern F (two series):

  12. `"findpoly"` -- `findpoly(x, y, deg_x, deg_y, topshift)` -- 5 args.
      - Extract two series, three i64s.
      - Call `qseries::findpoly(&x, &y, dx, dy, ts)`.
      - Returns `Option<PolynomialRelation>`. Convert to Value::Dict or Value::None.

  **Group 6: Hypergeometric (FUNC-06) -- 9 functions:**

  For hypergeometric functions, the user passes lists of `(num, den, power)` tuples as the upper and lower parameter lists. In the REPL, these are list-of-lists: `[(1,1,2), (1,1,3)]` parses as nested lists since (x,y,z) inside [...] evaluates to a parenthesized expression. Actually, since the parser has no tuple syntax, the user will use `[[1,1,2], [1,1,3]]` -- a list of 3-element lists.

  Create a helper: `fn extract_monomial_list(name: &str, args: &[Value], index: usize) -> Result<Vec<QMonomial>, EvalError>` that:
  - Expects `Value::List` at the given index
  - Each element must be a `Value::List` of exactly 3 integers: [num, den, power]
  - Builds `QMonomial::new(QRat::from((num, den)), power)` for each
  - Error if not a list, or inner elements aren't 3-integer lists

  Also create a helper to build a `HypergeometricSeries` from upper params, lower params, and z monomial:
  `fn build_hypergeometric(name: &str, args: &[Value], env: &Environment) -> Result<(HypergeometricSeries, i64), EvalError>` -- extracts upper_list (arg[0]), lower_list (arg[1]), z_num (arg[2]), z_den (arg[3]), z_pow (arg[4]), order (arg[5]). Returns the series struct + order.

  13. `"phi"` -- Pattern G:
      - REPL: `phi(upper_list, lower_list, z_num, z_den, z_pow, order)` -- 6 args.
      - Build HypergeometricSeries using helper. Call `qseries::eval_phi(&series, env.sym_q, order)`.
      - Return `Value::Series`.

  14. `"psi"` -- Pattern G:
      - REPL: `psi(upper_list, lower_list, z_num, z_den, z_pow, order)` -- 6 args.
      - Build BilateralHypergeometricSeries. Call `qseries::eval_psi(&series, env.sym_q, order)`.
      - Return `Value::Series`.

  15. `"try_summation"` -- Pattern G:
      - REPL: `try_summation(upper_list, lower_list, z_num, z_den, z_pow, order)` -- 6 args.
      - Build HypergeometricSeries. Call `qseries::try_all_summations(&series, env.sym_q, order)`.
      - Returns `Option<SummationResult>`. If Some -> Value::Series (the closed-form result), if None -> Value::None.

  16-18. `"heine1"`, `"heine2"`, `"heine3"` -- Pattern G:
      - Same 6-arg signature.
      - Build HypergeometricSeries. Call `qseries::heine_transform_1/2/3(...)`.
      - Returns `TransformationResult` which has a prefactor (FPS) and result (FPS). Convert to `Value::Pair(Box::new(Value::Series(prefactor)), Box::new(Value::Series(result)))`.

  19. `"sears_transform"`:
      - Same 6-arg pattern.
      - Call `qseries::sears_transform(...)`.
      - Returns TransformationResult -> Value::Pair.

  20. `"watson_transform"`:
      - Same 6-arg pattern.
      - Call `qseries::watson_transform(...)`.
      - Returns TransformationResult -> Value::Pair.

  21. `"find_transformation_chain"`:
      - REPL: `find_transformation_chain(src_upper, src_lower, src_z_n, src_z_d, src_z_p, tgt_upper, tgt_lower, tgt_z_n, tgt_z_d, tgt_z_p, max_depth, order)` -- 12 args.
      - Build source and target HypergeometricSeries. Extract max_depth (usize), order.
      - Call `qseries::find_transformation_chain(&source, &target, max_depth, order, env.sym_q)`.
      - Returns TransformationChainResult -> convert to Value::Dict.

  Add all signatures to get_signature for error messages.

  **Tests:**
  - Test dispatch("findlincombo", ...) with proper series list returns Value::List or Value::None
  - Test dispatch("findhom", ...) returns Value::List (matrix)
  - Test dispatch("findcong", ...) returns Value::List of Dicts
  - Test dispatch("phi", ...) with simple upper/lower lists returns Value::Series
  - Test dispatch("try_summation", ...) returns Value::Series or Value::None
  - Test dispatch("heine1", ...) returns Value::Pair
  - Test wrong arg count for hypergeometric functions shows correct error
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all tests pass.
  </verify>
  <done>
  - All 15 relation discovery functions dispatch correctly with proper argument extraction
  - findlincombo/findhomcombo/findnonhomcombo return coefficient lists or None
  - findhom/findnonhom return matrices (list of lists)
  - findcong returns list of congruence dicts
  - findpoly returns dict or None
  - All 9 hypergeometric functions dispatch correctly
  - phi/psi return series, try_summation returns series or None
  - heine1/2/3 and sears/watson return Pair(prefactor, result)
  - Monomial list extraction works for [[1,1,2],[1,1,3]] syntax
  </done>
</task>

<task type="auto">
  <name>Task 2: Function dispatch for groups 7-8 (mock theta/Bailey + identity proving) and final integration tests</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
  Add dispatch match arms for groups 7 (mock theta, Appell-Lerch, Bailey) and 8 (identity proving). Then add comprehensive integration tests proving all 79 functions are wired.

  **Group 7: Mock Theta / Appell-Lerch / Bailey (FUNC-07) -- 27 functions:**

  Pattern I (session-implicit, 1-2 args):

  All 20 mock theta functions follow the same pattern:
  - REPL: `mock_theta_XXX(order)` -- 1 arg, i64.
  - Call `qseries::mock_theta_XXX(env.sym_q, order)`.
  - Return `Value::Series`.

  Functions (match arms needed for each):
  1. `"mock_theta_f3"`, 2. `"mock_theta_phi3"`, 3. `"mock_theta_psi3"`, 4. `"mock_theta_chi3"`,
  5. `"mock_theta_omega3"`, 6. `"mock_theta_nu3"`, 7. `"mock_theta_rho3"`,
  8. `"mock_theta_f0_5"`, 9. `"mock_theta_f1_5"`, 10. `"mock_theta_cap_f0_5"`, 11. `"mock_theta_cap_f1_5"`,
  12. `"mock_theta_phi0_5"`, 13. `"mock_theta_phi1_5"`, 14. `"mock_theta_psi0_5"`, 15. `"mock_theta_psi1_5"`,
  16. `"mock_theta_chi0_5"`, 17. `"mock_theta_chi1_5"`,
  18. `"mock_theta_cap_f0_7"`, 19. `"mock_theta_cap_f1_7"`, 20. `"mock_theta_cap_f2_7"`.

  Since all 20 follow the exact same pattern, use a macro or a helper to avoid 20 near-identical blocks:
  ```rust
  macro_rules! dispatch_mock_theta {
      ($name:expr, $func:ident, $args:expr, $env:expr) => {{
          expect_args($name, $args, 1)?;
          let order = extract_i64($name, $args, 0)?;
          Ok(Value::Series(qseries::$func($env.sym_q, order)))
      }};
  }
  ```
  Then in the match: `"mock_theta_f3" => dispatch_mock_theta!("mock_theta_f3", mock_theta_f3, args, env),`

  Appell-Lerch (3 functions):

  21. `"appell_lerch_m"` -- `appell_lerch_m(a_pow, z_pow, order)` -- 3 args, all i64.
      - Call `qseries::appell_lerch_m(a_pow, z_pow, env.sym_q, order)`.
      - Return `Value::Series`.
      - Note: Check the actual signature of `appell_lerch_m`. The research says it takes `a_pow` and `z_pow` as i64.

  22. `"g2"` (alias for `universal_mock_theta_g2`) -- `g2(a_pow, order)` -- 2 args.
      - Call `qseries::universal_mock_theta_g2(a_pow, env.sym_q, order)`.
      - Return `Value::Series`.

  23. `"g3"` (alias for `universal_mock_theta_g3`) -- `g3(a_pow, order)` -- 2 args.
      - Call `qseries::universal_mock_theta_g3(a_pow, env.sym_q, order)`.
      - Return `Value::Series`.

  Bailey (4 functions):

  24. `"bailey_weak_lemma"` -- Pattern J:
      - REPL: `bailey_weak_lemma(pair_name, a_num, a_den, a_pow, max_n, order)` -- 6 args.
      - arg[0]: pair name. Accept `Value::Integer` or variable identifier mapped to a string. The simplest approach: treat arg[0] as a string identifier. Since the parser produces `AstNode::Variable("rogers_ramanujan")` which evaluates to `Value::UnknownVariable` error, we need a different approach. SOLUTION: Check if arg[0] is a string-like value. Actually, since we don't have string literals, use an integer code or just match specific known pair names. BETTER SOLUTION: In the evaluator, when processing `bailey_weak_lemma(rogers_ramanujan, ...)`, the first arg evaluates to UnknownVariable. Instead, for functions that take "pair name" arguments, intercept at the dispatch level: look at the RAW AST args before evaluation. SIMPLEST SOLUTION: Add a `Value::String(String)` variant to Value, and in `eval_expr` for `AstNode::Variable(name)`, if the variable is not found in env AND we're inside a function call context, return it as a string. Actually this is too complex. PRAGMATIC SOLUTION: Accept an integer code (0=Unit, 1=RogersRamanujan, 2=QBinomial) for bailey pair names. Map in dispatch: 0 -> BaileyPairType::Unit, 1 -> BaileyPairType::RogersRamanujan, 2 -> BaileyPairType::QBinomial.
      - Extract pair_type from arg[0] (i64 -> match to BaileyPairType). Build a_monomial from args[1..4]. Extract max_n and order.
      - Get canonical pair from `BaileyDatabase::new().get(pair_type)`.
      - Call `qseries::weak_bailey_lemma(&pair, &a_monomial, max_n, env.sym_q, order)`.
      - Returns `(FPS, FPS)` -> `Value::Pair`.

  25. `"bailey_apply_lemma"` -- Pattern J:
      - REPL: `bailey_apply_lemma(pair_name, a_n, a_d, a_p, b_n, b_d, b_p, c_n, c_d, c_p, max_n, order)` -- 12 args.
      - Extract pair_type (i64), build 3 QMonomials (a, b, c), extract max_n and order.
      - Call `qseries::bailey_lemma(...)`.
      - Returns result -> convert to Value::Dict.

  26. `"bailey_chain"` -- Pattern J:
      - REPL: `bailey_chain(pair_name, a_n, a_d, a_p, b_n, b_d, b_p, c_n, c_d, c_p, depth, max_n, order)` -- 13 args.
      - Call `qseries::bailey_chain(...)`.
      - Returns Vec of results -> convert to Value::List of Dicts.

  27. `"bailey_discover"` -- Pattern J:
      - REPL: `bailey_discover(lhs, rhs, a_n, a_d, a_p, max_depth, order)` -- 7 args.
      - Extract two series (lhs, rhs), build a_monomial, extract max_depth and order.
      - Create `BaileyDatabase::new()`.
      - Call `qseries::bailey_discover(&lhs, &rhs, &db, &a, max_depth, env.sym_q, order)`.
      - Returns DiscoveryResult -> convert to Value::Dict.

  **Group 8: Identity Proving (FUNC-08) -- 8 functions:**

  Pattern H (identity proving):

  28. `"prove_eta_id"`:
      - REPL: `prove_eta_id(terms_list, level)` -- 2 args.
      - arg[0]: a list encoding the identity terms. Each term is a list `[coeff_num, coeff_den, [[delta1, exp1], [delta2, exp2], ...]]`. The evaluator builds `EtaIdentity::new(terms, level)`.
      - This is complex. Create a helper `fn extract_eta_identity(name: &str, args: &[Value]) -> Result<EtaIdentity, EvalError>` that parses the nested list structure.
      - Call `qseries::prove_eta_identity(&identity)`.
      - Returns `ProofResult` -> convert to Value::Dict with fields like proved (bool), level, sturm_bound, etc.

  29. `"search_identities"`:
      - REPL: `search_identities(query_int, search_type_int)` -- 2 args, both integers.
      - Since we can't pass strings, use integer codes: search_type 0=by_tag, 1=by_function, 2=by_pattern. For the query, this is tricky without string support. PRAGMATIC SOLUTION: For now, use integer indices into a predefined list of common search terms, or skip the string-based search and only support search_by_tag with integer tag codes (0="classical", 1="partition", 2="theta", etc.). SIMPLER: Just always search all entries and return them. Or accept that this function has limited REPL support and return an error suggesting to use the Python API for string-based searches.
      - Create `IdentityDatabase::classical()` (or `new()` + populate), call `search_by_tag/function/pattern`.
      - Returns list of IdentityEntry -> convert to Value::List of Value::Dict.

  Pattern K (algorithmic summation):

  30. `"q_gosper"`:
      - REPL: `q_gosper(upper_list, lower_list, z_n, z_d, z_p, q_n, q_d)` -- 7 args.
      - Build HypergeometricSeries from args[0..5]. Build q_val as QRat from args[5..7].
      - Call `qseries::q_gosper(&series, &q_val)`.
      - Returns `QGosperResult` -> convert to Value::Dict with fields (success, certificate, etc.).

  31. `"q_zeilberger"`:
      - REPL: `q_zeilberger(upper_list, lower_list, z_n, z_d, z_p, n, q_n, q_d, max_order)` -- 9 args.
      - Build HypergeometricSeries. Extract n (i64), q_val (QRat from args[6..8]), max_order (i64 -> usize).
      - Call `qseries::q_zeilberger(&series, n, &q_val, max_order)`.
      - Returns `QZeilbergerResult` -> convert to Value::Dict.

  32. `"verify_wz"`:
      - REPL: `verify_wz(upper_list, lower_list, z_n, z_d, z_p, n, q_n, q_d, max_order, max_k)` -- 10 args.
      - Build HypergeometricSeries. Extract n, q_val, max_order, max_k.
      - Call `qseries::verify_wz_certificate(...)`.
      - Returns result -> convert to Value::Dict.

  33. `"q_petkovsek"`:
      - REPL: `q_petkovsek(coeff_list, q_n, q_d)` -- 3 args.
      - Extract coefficient list from arg[0] (List of Rationals -> Vec<QRat>). Build q_val.
      - Call `qseries::q_petkovsek(&coefficients, &q_val)`.
      - Returns `Vec<QPetkovsekResult>` -> convert to Value::List of Value::Dict.

  Pattern L (nonterminating):

  34. `"prove_nonterminating"`:
      - This function takes builder closures in qsym-core, which can't be passed from the REPL. For the REPL, provide a simplified interface or mark as "advanced / Python-only". PRAGMATIC: Return `EvalError::Other("prove_nonterminating requires closure arguments; use the Python API for this function")`. This is honest and the right tradeoff -- 78/79 functions work, this one needs Python.

  35. `"find_transformation_chain"` -- already handled in Task 1 above (Pattern G, 12 args).

  **Add all remaining signatures to get_signature.**

  **Conversion helpers for Group 7-8 result types:**
  - `fn q_gosper_result_to_value(r: &QGosperResult) -> Value`
  - `fn q_zeilberger_result_to_value(r: &QZeilbergerResult) -> Value`
  - `fn q_petkovsek_result_to_value(r: &QPetkovsekResult) -> Value`
  - `fn proof_result_to_value(r: &ProofResult) -> Value`
  - `fn discovery_result_to_value(r: &DiscoveryResult) -> Value`
  - `fn bailey_lemma_result_to_value(...)` -- check the return type of bailey_lemma

  Read the actual struct definitions in gosper.rs, zeilberger.rs, petkovsek.rs, identity/prove.rs, bailey.rs to know exactly which fields to include in the Dict.

  **Comprehensive integration tests (end-to-end through parser + evaluator):**

  Create an integration test helper:
  ```rust
  fn eval_line(input: &str, env: &mut Environment) -> Result<Option<Value>, EvalError> {
      let stmts = parse(input).expect("parse failed");
      let mut last = None;
      for stmt in &stmts {
          last = eval_stmt_safe(stmt, env)?;
      }
      Ok(last)
  }
  ```

  Tests:
  1. `eval_line("aqprod(1,1,1,infinity,20)", &mut env)` -> Value::Series with nonzero coefficients
  2. `eval_line("partition_count(50)", &mut env)` -> Value::Integer, format_value gives "204226"
  3. `eval_line("f := etaq(1,1,20)", &mut env)` then `eval_line("f", &mut env)` -> same series (variable persistence, SESS-01)
  4. `eval_line("f := etaq(1,1,20); g := etaq(2,1,20); f * g", &mut env)` -> Value::Series (arithmetic on series)
  5. `eval_line("theta3(20)", &mut env)` -> Value::Series
  6. `eval_line("mock_theta_f3(20)", &mut env)` -> Value::Series
  7. `eval_line("etaq(1,1,20)", &mut env)` -> format_value result starts with "1 - q" (OUT-01)
  8. Test unknown function: `eval_line("etaq2(20)", &mut env)` -> EvalError::UnknownFunction with suggestions containing "etaq"
  9. Test wrong arg count: `eval_line("etaq(1)", &mut env)` -> EvalError containing "expects 3 arguments"
  10. Test Maple alias: `eval_line("numbpart(50)", &mut env)` -> same as partition_count(50)
  11. Test `%` reference: `eval_line("42", &mut env)` then `eval_line("%", &mut env)` -> Value::Integer(42)
  12. Test list syntax: `eval_line("[1, 2, 3]", &mut env)` -> Value::List with 3 integers

  **Function count verification test:**
  Add a test that counts the number of distinct function name strings in the dispatch match to assert it equals 79 (or the actual count after accounting for any that map to EvalError::Other). This can be done by extracting function names from the match or maintaining a constant FUNCTION_COUNT.
  </action>
  <verify>
  Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` -- all tests pass.
  Run `cargo test -p qsym-cli -- integration --nocapture` to see integration test output.
  </verify>
  <done>
  - All 20 mock theta functions dispatch and return Value::Series
  - appell_lerch_m, g2, g3 dispatch and return Value::Series
  - bailey_weak_lemma returns Value::Pair, bailey_apply_lemma/chain return Dict/List
  - bailey_discover returns Dict
  - All 15 relation discovery functions from Task 1 are confirmed working
  - All 9 hypergeometric functions from Task 1 are confirmed working
  - q_gosper, q_zeilberger, verify_wz, q_petkovsek dispatch and return Dict/List
  - prove_eta_id dispatches and returns Dict
  - search_identities dispatches and returns List
  - prove_nonterminating returns informative error (requires Python API)
  - Integration tests verify end-to-end: parse -> eval -> format for key scenarios
  - Maple aliases resolve correctly (numbpart -> partition_count)
  - All 79 function names (minus prove_nonterminating) have dispatch arms
  </done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
cargo test -p qsym-cli -- integration --nocapture
cargo test -p qsym-cli -- dispatch --nocapture
```
</verification>

<success_criteria>
- All 79 canonical function names have dispatch arms (prove_nonterminating returns informative error)
- Groups 5-8 dispatch correctly with proper argument extraction and result conversion
- Integration tests pass: aqprod with infinity, partition_count value, variable persistence, series arithmetic, theta/mock theta, Maple aliases, error messages, % reference, list syntax
- Format output matches expected text: series as "1 - q - q^2 + ...", integers as plain numbers
- All phase 25 success criteria met:
  1. aqprod(1,1,1,infinity,20) shows Euler function series
  2. Variable persistence across lines
  3. All 8 function groups work
  4. Series arithmetic (f * g) works
  5. Wrong arg count/type shows descriptive error
</success_criteria>

<output>
After completion, create `.planning/phases/25-evaluator-function-dispatch/25-03-SUMMARY.md`
</output>
