---
phase: 26-repl-shell-session
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/lib.rs
  - crates/qsym-cli/src/main.rs
  - crates/qsym-cli/src/commands.rs
autonomous: true
requirements: [REPL-02, REPL-03]

must_haves:
  truths:
    - "User types 'aq' then Tab and sees 'aqprod(' auto-completed with opening paren"
    - "User defines f := etaq(1,1,20) then types 'f' + Tab and it completes to the variable name"
    - "Tab cycles through multiple candidates zsh-style (not bash list display)"
    - "Completing a function name auto-inserts '(' unless cursor is already before '('"
    - "Only canonical function names appear in completions (no Maple aliases)"
    - "Session commands (help, quit, exit, clear, set) also complete from Tab"
    - "Bare 'help' shows grouped function list in 8 categories with one-line descriptions plus Commands section"
    - "help aqprod shows signature, description, and usage example"
    - "No Maple alias mentions appear in any help text"
  artifacts:
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "ReplHelper with Completer, Validator, variable name sync"
      contains: "impl Completer for ReplHelper"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Grouped help text, per-function help entries for all 81 functions"
      contains: "fn general_help"
  key_links:
    - from: "crates/qsym-cli/src/main.rs"
      to: "crates/qsym-cli/src/repl.rs"
      via: "ReplHelper set on Editor, variable names updated after each eval"
      pattern: "ReplHelper|helper_mut|update_var_names"
    - from: "crates/qsym-cli/src/main.rs"
      to: "crates/qsym-cli/src/help.rs"
      via: "help command dispatch"
      pattern: "general_help|function_help"
    - from: "crates/qsym-cli/src/repl.rs"
      to: "rustyline::completion::Pair"
      via: "Completer returns Pair with display/replacement"
      pattern: "Pair"
---

<objective>
Add tab completion (functions, commands, user variables) and a comprehensive help system (grouped listing + per-function docs) to the REPL. This plan completes the interactive experience by making function discovery frictionless and providing inline documentation.

Purpose: Researchers unfamiliar with q-Kangaroo can discover functions via Tab and learn usage via help -- no need to leave the terminal.

Output: Tab completion cycling through candidates with auto-paren on functions, and a help system covering all 81 dispatched functions organized by 8 categories.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-repl-shell-session/26-CONTEXT.md
@.planning/phases/26-repl-shell-session/26-RESEARCH.md
@.planning/phases/26-repl-shell-session/26-01-SUMMARY.md
@crates/qsym-cli/src/main.rs
@crates/qsym-cli/src/lib.rs
@crates/qsym-cli/src/commands.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/environment.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReplHelper with tab completion and Validator in repl.rs</name>
  <files>
    crates/qsym-cli/src/repl.rs
    crates/qsym-cli/src/lib.rs
  </files>
  <action>
**lib.rs:** Add `pub mod repl;` and `pub mod help;` to the module list.

**repl.rs:** Create the ReplHelper struct implementing rustyline's Helper trait composite.

1. **ReplHelper struct:**
```rust
use rustyline::completion::{Completer, Pair};
use rustyline::highlight::Highlighter;
use rustyline::hint::Hinter;
use rustyline::validate::{ValidationResult, Validator, ValidationContext};
use rustyline::{Context, Helper};

#[derive(Helper, Highlighter, Hinter)]
pub struct ReplHelper {
    /// Canonical function names (static, from ALL_FUNCTION_NAMES in eval.rs)
    function_names: Vec<&'static str>,
    /// Session command names for completion
    command_names: Vec<&'static str>,
    /// User-defined variable names (updated after each eval)
    var_names: Vec<String>,
}
```

Use derive macros for Highlighter and Hinter (no custom behavior needed). Manually implement Completer and Validator.

2. **Constructor:**
```rust
impl ReplHelper {
    pub fn new() -> Self {
        Self {
            function_names: Self::canonical_function_names(),
            command_names: vec!["help", "quit", "exit", "clear", "set"],
            var_names: Vec::new(),
        }
    }

    pub fn update_var_names(&mut self, var_names: Vec<String>) {
        self.var_names = var_names;
    }

    fn canonical_function_names() -> Vec<&'static str> {
        // All 81 canonical function names -- must match eval.rs ALL_FUNCTION_NAMES
        // exactly. NO Maple aliases.
        vec![
            // Group 1: Products (7)
            "aqprod", "qbin", "etaq", "jacprod", "tripleprod", "quinprod", "winquist",
            // Group 2: Partitions (7)
            "partition_count", "partition_gf", "distinct_parts_gf", "odd_parts_gf",
            "bounded_parts_gf", "rank_gf", "crank_gf",
            // Group 3: Theta (3)
            "theta2", "theta3", "theta4",
            // Group 4: Analysis (9)
            "sift", "qdegree", "lqdegree", "qfactor",
            "prodmake", "etamake", "jacprodmake", "mprodmake", "qetamake",
            // Group 5: Relations (12)
            "findlincombo", "findhomcombo", "findnonhomcombo",
            "findlincombomodp", "findhomcombomodp",
            "findhom", "findnonhom", "findhommodp",
            "findmaxind", "findprod", "findcong", "findpoly",
            // Group 6: Hypergeometric (9)
            "phi", "psi", "try_summation",
            "heine1", "heine2", "heine3",
            "sears_transform", "watson_transform", "find_transformation_chain",
            // Group 7: Mock Theta / Appell-Lerch / Bailey (27)
            "mock_theta_f3", "mock_theta_phi3", "mock_theta_psi3",
            "mock_theta_chi3", "mock_theta_omega3", "mock_theta_nu3", "mock_theta_rho3",
            "mock_theta_f0_5", "mock_theta_f1_5",
            "mock_theta_cap_f0_5", "mock_theta_cap_f1_5",
            "mock_theta_phi0_5", "mock_theta_phi1_5",
            "mock_theta_psi0_5", "mock_theta_psi1_5",
            "mock_theta_chi0_5", "mock_theta_chi1_5",
            "mock_theta_cap_f0_7", "mock_theta_cap_f1_7", "mock_theta_cap_f2_7",
            "appell_lerch_m", "universal_mock_theta_g2", "universal_mock_theta_g3",
            "bailey_weak_lemma", "bailey_apply_lemma", "bailey_chain", "bailey_discover",
            // Group 8: Identity Proving (7)
            "prove_eta_id", "search_identities",
            "q_gosper", "q_zeilberger", "verify_wz", "q_petkovsek",
            "prove_nonterminating",
        ]
    }
}
```

The exact count from eval.rs is: 7+7+3+9+12+9+27+7 = 81. Cross-check against eval.rs ALL_FUNCTION_NAMES which has 79 names (it lists "find_transformation_chain" and "prove_nonterminating" at the end making it 81 total -- verify the exact list). Use the same names as ALL_FUNCTION_NAMES in eval.rs.

3. **Completer implementation:**
```rust
impl Completer for ReplHelper {
    type Candidate = Pair;

    fn complete(
        &self,
        line: &str,
        pos: usize,
        _ctx: &Context<'_>,
    ) -> rustyline::Result<(usize, Vec<Pair>)> {
        // Find word start: scan backwards for non-alphanumeric/underscore
        let start = line[..pos]
            .rfind(|c: char| !c.is_alphanumeric() && c != '_')
            .map(|i| i + 1)
            .unwrap_or(0);
        let prefix = &line[start..pos];

        if prefix.is_empty() {
            return Ok((start, vec![]));
        }

        // Check if next char is already '(' (avoid double-paren)
        let has_paren_after = line.get(pos..pos + 1) == Some("(");

        let mut candidates = Vec::new();

        // Complete function names (with auto-paren)
        for &name in &self.function_names {
            if name.starts_with(prefix) {
                let replacement = if has_paren_after {
                    name.to_string()
                } else {
                    format!("{}(", name)
                };
                candidates.push(Pair {
                    display: name.to_string(),
                    replacement,
                });
            }
        }

        // Complete session commands (only at start of line, no paren)
        if start == 0 {
            for &cmd in &self.command_names {
                if cmd.starts_with(prefix) {
                    candidates.push(Pair {
                        display: cmd.to_string(),
                        replacement: cmd.to_string(),
                    });
                }
            }
        }

        // Complete user-defined variable names (no paren)
        for var_name in &self.var_names {
            if var_name.starts_with(prefix) {
                candidates.push(Pair {
                    display: var_name.clone(),
                    replacement: var_name.clone(),
                });
            }
        }

        Ok((start, candidates))
    }
}
```

4. **Validator implementation (paren-counting for multi-line):**
Move the Validator from Plan 01's main.rs helper into repl.rs. Count `(` and `[` depth; if positive, return `Incomplete`; otherwise `Valid(None)`.

5. **Tests for repl.rs:**
- Test that canonical_function_names returns the correct count (cross-check with eval.rs)
- Test completion of "aq" returns "aqprod(" as replacement
- Test completion of "theta" returns 3 candidates (theta2, theta3, theta4)
- Test completion of "q" at start of line includes "quit" command
- Test completion of "q" mid-line (after "(") does NOT include commands, only functions starting with "q" (qbin, q_gosper, etc.)
- Test that after update_var_names(vec!["foo"]), completing "fo" returns "foo"
- Test has_paren_after logic: completing "aqprod" when next char is "(" returns "aqprod" not "aqprod("
- Test Validator: `"f(1, 2)"` => Valid, `"f(1, 2"` => Incomplete, `"f(1) + g(2)"` => Valid, `""` => Valid
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- repl`

All repl.rs tests pass.
  </verify>
  <done>
repl.rs exists with ReplHelper struct implementing Completer (function names with auto-paren, command names at line start, user variable names), Validator (paren counting for multi-line), and Highlighter/Hinter via derive. update_var_names() allows main loop to sync variable names after each eval. All completion tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Help system in help.rs and wiring into commands/main</name>
  <files>
    crates/qsym-cli/src/help.rs
    crates/qsym-cli/src/commands.rs
    crates/qsym-cli/src/main.rs
  </files>
  <action>
**help.rs:** Create the help system with two public functions:

1. **`general_help() -> String`** -- returns the grouped function listing for bare `help` command.

Format (user-locked decisions):
- 8 category groups with headers
- One-line description per function
- Commands section at bottom listing session commands
- No Maple alias mentions anywhere

Output structure:
```
q-Kangaroo Functions
====================

Products:
  aqprod       - q-Pochhammer product (a;q)_n or (a;q)_inf
  qbin         - q-binomial coefficient [n choose k]_q
  etaq         - Dedekind eta quotient q^(b/24) * prod (1-q^(b*k))
  jacprod      - Jacobi triple product J(a,b)
  tripleprod   - triple product (a;q)_inf * (q/a;q)_inf * (q;q)_inf
  quinprod     - quintuple product
  winquist     - Winquist product (6 parameters)

Partitions:
  partition_count    - number of partitions p(n)
  partition_gf       - partition generating function 1/(q;q)_inf
  distinct_parts_gf  - distinct parts generating function (-q;q)_inf
  odd_parts_gf       - odd parts generating function
  bounded_parts_gf   - parts <= max_part generating function
  rank_gf            - rank generating function R(z;q)
  crank_gf           - crank generating function C(z;q)

Theta Functions:
  theta2   - Jacobi theta_2(q)
  theta3   - Jacobi theta_3(q)
  theta4   - Jacobi theta_4(q)

Series Analysis:
  sift           - extract arithmetic subsequence: coeff of q^(mj+r)
  qdegree        - highest power of q with nonzero coefficient
  lqdegree       - lowest power of q with nonzero coefficient
  qfactor        - factor series into (1-q^i) factors
  prodmake       - find infinite product form via log derivative
  etamake        - find eta quotient form
  jacprodmake    - find Jacobi product form
  mprodmake      - find (1+q^n) product form
  qetamake       - combined eta/q-Pochhammer product form

Relations:
  findlincombo       - find linear combination of candidates matching target
  findhomcombo       - find homogeneous polynomial combo matching target
  findnonhomcombo    - find nonhomogeneous polynomial combo matching target
  findlincombomodp   - linear combination mod prime p
  findhomcombomodp   - homogeneous polynomial combo mod prime p
  findhom            - find homogeneous relation among series
  findnonhom         - find nonhomogeneous relation among series
  findhommodp        - homogeneous relation mod prime p
  findmaxind         - find maximally independent subset of series
  findprod           - find product identity among series
  findcong           - find partition congruences
  findpoly           - find polynomial relation between two series

Hypergeometric:
  phi                        - basic hypergeometric r_phi_s series
  psi                        - bilateral hypergeometric r_psi_s series
  try_summation              - attempt closed-form summation
  heine1                     - Heine's first transformation
  heine2                     - Heine's second transformation
  heine3                     - Heine's third transformation
  sears_transform            - Sears' balanced 4_phi_3 transformation
  watson_transform           - Watson's 8_phi_7 to 4_phi_3 reduction
  find_transformation_chain  - BFS search for transformation path

Mock Theta & Bailey:
  mock_theta_f3 .. mock_theta_rho3      - 7 third-order mock theta functions
  mock_theta_f0_5 .. mock_theta_chi1_5  - 10 fifth-order mock theta functions
  mock_theta_cap_f0_7 .. cap_f2_7       - 3 seventh-order mock theta functions
  appell_lerch_m             - Appell-Lerch sum m(a,z,q)
  universal_mock_theta_g2    - universal mock theta g_2(a;q)
  universal_mock_theta_g3    - universal mock theta g_3(a;q)
  bailey_weak_lemma          - apply Bailey's weak lemma to a pair
  bailey_apply_lemma         - apply Bailey's full lemma
  bailey_chain               - iterate Bailey chain to depth d
  bailey_discover            - discover Bailey pair proving an identity

Identity Proving:
  prove_eta_id     - prove eta-quotient identity via valence formula
  search_identities - search for identities of a given type
  q_gosper         - q-Gosper indefinite summation algorithm
  q_zeilberger     - q-Zeilberger creative telescoping
  verify_wz        - verify WZ proof certificate
  q_petkovsek      - q-Petkovsek recurrence solver
  prove_nonterminating - nonterminating identity proof (Python API only)

Commands:
  help [function]   - show this help or help for a specific function
  set precision N   - set default truncation order (currently: 20)
  clear             - reset all variables, %, and precision
  quit / exit       - exit the REPL (also Ctrl-D)
```

Note: For Mock Theta & Bailey, the individual mock theta functions can be grouped with `..` notation to save vertical space, since they all take `(order)`. Show the full name for the first and last in each sub-group.

**Important:** The Commands section mentions `latex` and `save` per the CONTEXT.md locked decision ("Commands section at bottom listing session commands (set, clear, quit, help, latex, save)"). Since those are Phase 27, list them with "(coming in next update)" or similar brief note:
```
  latex [expr]      - show LaTeX for last result or expression (coming soon)
  save filename     - save result to file (coming soon)
```

2. **`function_help(name: &str) -> Option<String>`** -- returns per-function help for `help aqprod`.

Create a static data structure (array of structs or match statement) mapping each of the 81 function names to:
- `signature`: parameter list (reuse from get_signature in eval.rs)
- `description`: 1-3 sentence description
- `example`: a usage example with realistic input
- `example_output`: what the example produces (abbreviated if series)

Format per-function help as:
```
aqprod(coeff_num, coeff_den, power, n_or_infinity, order)

  Compute the q-Pochhammer product (a;q)_n where a = (coeff_num/coeff_den)*q^power.
  When n is 'infinity', computes the infinite product (a;q)_inf.

  Example:
    q> aqprod(1, 1, 1, infinity, 10)
    1 - q - q^2 + q^5 + q^7 + O(q^10)
```

For all 81 functions, provide a one-liner description and example. The descriptions should be mathematically informative but concise. No Maple alias mentions per locked decision.

For functions that are very similar (the 20 mock theta functions), the description can be templated: "Third-order mock theta function f(q)" etc.

If the user asks `help` for an unknown function, return `None` and let the caller print "Unknown function 'xxx'. Type 'help' for a list of available functions."

3. **Update commands.rs:**
Change the `Help` variant handler in `execute_command`:
- `Help(None)` => return `CommandResult::Output(help::general_help())`
- `Help(Some(topic))` => match against `help::function_help(&topic)`:
  - `Some(text)` => return `CommandResult::Output(text)`
  - `None` => return `CommandResult::Output(format!("Unknown function '{}'. Type 'help' for a list of available functions.", topic))`

Add `use crate::help;` import to commands.rs.

4. **Update main.rs:**
- Replace the minimal ReplHelper from Plan 01 with `use qsym_cli::repl::ReplHelper;`
- After each successful eval loop iteration (after processing all stmts), update the helper's variable names:
  ```rust
  // Update variable names in completer
  let var_names: Vec<String> = env.variables.keys().cloned().collect();
  if let Some(helper) = rl.helper_mut() {
      helper.update_var_names(var_names);
  }
  ```
- Remove the inline ReplHelper struct definition from main.rs (it now lives in repl.rs)

5. **Tests for help.rs:**
- Test general_help() contains all 8 category headers
- Test general_help() contains "Commands:" section
- Test general_help() contains "aqprod" and "prove_eta_id" (first and last-ish functions)
- Test general_help() does NOT contain any Maple alias names ("numbpart", "qphihyper", etc.)
- Test function_help("aqprod") returns Some with signature and description
- Test function_help("theta3") returns Some
- Test function_help("nonexistent") returns None
- Test function_help("numbpart") returns None (aliases don't get help entries per no-alias decision)
- Test every function name from canonical list has a help entry (iterate and assert Some for each)
  </action>
  <verify>
Run:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli -- help
cargo test -p qsym-cli -- repl
cargo test -p qsym-cli -- commands
cargo build -p qsym-cli
```

All tests pass. Build succeeds. The help system covers all 81 functions with no gaps. No Maple aliases appear in help text.
  </verify>
  <done>
help.rs provides general_help() returning grouped listing of all 81 functions in 8 categories plus Commands section, and function_help(name) returning per-function signature + description + example for each function. repl.rs ReplHelper has full Completer implementation (functions with auto-paren, commands at line start, user variables). main.rs uses ReplHelper from repl.rs and syncs variable names after each eval. commands.rs dispatches help commands to help.rs. All tests pass, no Maple aliases in help output, cargo build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-cli` succeeds
2. `cargo test -p qsym-cli` -- all tests pass (repl, help, commands, existing)
3. Code inspection confirms:
   - Tab completion returns Pair with auto-paren for functions, no paren for commands/variables
   - Only canonical function names in completion candidates (no aliases)
   - general_help() has 8 categories + Commands section
   - Every function has a help entry with signature, description, example
   - No "numbpart", "qphihyper", etc. in help output
   - Variable names synced after each eval via update_var_names
   - Validator handles paren counting for multi-line
</verification>

<success_criteria>
- repl.rs exists with ReplHelper implementing Completer + Validator
- help.rs exists with general_help() and function_help() covering all 81 functions
- Tab completion includes functions (with auto-paren), commands (at line start), and user variables
- No Maple aliases in completions or help text
- Variable name completion updates dynamically after assignments
- Help system organized by 8 categories with Commands section
- All tests pass, binary builds
</success_criteria>

<output>
After completion, create `.planning/phases/26-repl-shell-session/26-02-SUMMARY.md`
</output>
