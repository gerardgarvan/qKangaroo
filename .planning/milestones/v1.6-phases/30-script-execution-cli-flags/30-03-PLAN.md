---
phase: 30-script-execution-cli-flags
plan: 03
type: execute
wave: 3
depends_on: ["30-02"]
files_modified:
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [CLI-01, CLI-02, CLI-03, CLI-04, CLI-05, CLI-06, EXEC-01, EXEC-02, EXEC-03, EXEC-04, EXEC-05, EXEC-06]

must_haves:
  truths:
    - "Subprocess tests verify --help output contains all flags and exits 0"
    - "Subprocess tests verify -c evaluates and exits 0"
    - "Subprocess tests verify script file execution with comments and multi-line"
    - "Subprocess tests verify piped stdin produces output without banner"
    - "Subprocess tests verify unknown flag exits with code 2"
    - "Subprocess tests verify -- argument separator works"
    - "Subprocess tests verify -q suppresses banner"
    - "Subprocess tests verify -v produces timing on stderr"
    - "Subprocess tests verify read() loads a script file"
  artifacts:
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Comprehensive subprocess-based CLI integration tests"
      min_lines: 200
  key_links:
    - from: "crates/qsym-cli/tests/cli_integration.rs"
      to: "target/debug/q-kangaroo"
      via: "Command::new(env!(\"CARGO_BIN_EXE_q-kangaroo\"))"
      pattern: "CARGO_BIN_EXE"
---

<objective>
Create comprehensive subprocess-based integration tests for all CLI modes and flags.

Purpose: Unit tests verify internal logic, but CLI behavior (exit codes, stdout/stderr content, banner suppression, piped input) can only be fully validated through subprocess testing. These tests run the actual binary and verify the complete user-facing behavior end-to-end for all 12 requirements.

Output: Integration test file covering all 5 success criteria and all 12 requirement IDs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-script-execution-cli-flags/30-RESEARCH.md
@.planning/phases/30-script-execution-cli-flags/30-01-SUMMARY.md
@.planning/phases/30-script-execution-cli-flags/30-02-SUMMARY.md
@crates/qsym-cli/src/main.rs
@crates/qsym-cli/src/script.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subprocess integration test suite</name>
  <files>
    crates/qsym-cli/tests/cli_integration.rs
  </files>
  <action>
Create `crates/qsym-cli/tests/cli_integration.rs` with subprocess tests using `std::process::Command`. Use `env!("CARGO_BIN_EXE_q-kangaroo")` to locate the binary.

Create a helper function at the top:
```rust
use std::process::Command;
use std::io::Write;

/// Run q-kangaroo with given args and return (exit_code, stdout, stderr).
fn run(args: &[&str]) -> (i32, String, String) {
    let output = Command::new(env!("CARGO_BIN_EXE_q-kangaroo"))
        .args(args)
        .output()
        .expect("failed to run q-kangaroo");
    let code = output.status.code().unwrap_or(-1);
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();
    (code, stdout, stderr)
}

/// Run q-kangaroo with piped stdin input.
fn run_piped(input: &str) -> (i32, String, String) {
    let mut child = Command::new(env!("CARGO_BIN_EXE_q-kangaroo"))
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .spawn()
        .expect("failed to spawn q-kangaroo");
    child.stdin.take().unwrap().write_all(input.as_bytes()).unwrap();
    let output = child.wait_with_output().expect("failed to wait");
    let code = output.status.code().unwrap_or(-1);
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();
    (code, stdout, stderr)
}
```

**Requirement CLI-01 (--help/-h):**
```rust
#[test]
fn help_flag_long() {
    let (code, stdout, _) = run(&["--help"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("USAGE:"), "missing USAGE section");
    assert!(stdout.contains("-h, --help"), "missing -h flag");
    assert!(stdout.contains("-V, --version"), "missing -V flag");
    assert!(stdout.contains("-c EXPRESSION"), "missing -c flag");
    assert!(stdout.contains("-q, --quiet"), "missing -q flag");
    assert!(stdout.contains("-v, --verbose"), "missing -v flag");
    assert!(stdout.contains("--"), "missing -- separator");
    assert!(stdout.contains("EXAMPLES:"), "missing EXAMPLES section");
}

#[test]
fn help_flag_short() {
    let (code, stdout, _) = run(&["-h"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("USAGE:"));
}
```

**Requirement CLI-02 (-q/--quiet):**
```rust
#[test]
fn quiet_flag_suppresses_banner() {
    // -q with -c to avoid interactive mode
    // Just verify -q is accepted (no error)
    let (code, _, _) = run(&["-q", "-c", "1+1"]);
    assert_eq!(code, 0);
}
```

**Requirement CLI-03 (-c expression):**
```rust
#[test]
fn c_flag_simple_arithmetic() {
    let (code, stdout, _) = run(&["-c", "1 + 1"]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "2");
}

#[test]
fn c_flag_function_call() {
    let (code, stdout, _) = run(&["-c", "partition_count(5)"]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "7");
}

#[test]
fn c_flag_no_banner() {
    let (code, stdout, _) = run(&["-c", "1 + 1"]);
    assert_eq!(code, 0);
    assert!(!stdout.contains("q-Kangaroo"), "banner should not appear in -c mode");
}

#[test]
fn c_flag_missing_expression() {
    let (code, _, stderr) = run(&["-c"]);
    assert_eq!(code, 2);
    assert!(stderr.contains("requires an argument"));
}

#[test]
fn c_flag_parse_error() {
    let (code, _, stderr) = run(&["-c", "1 + + 2"]);
    assert_ne!(code, 0);
    assert!(!stderr.is_empty(), "parse error should be on stderr");
}

#[test]
fn c_flag_eval_error() {
    let (code, _, stderr) = run(&["-c", "undefined_var"]);
    assert_ne!(code, 0);
    assert!(stderr.contains("undefined variable"));
}
```

**Requirement CLI-04 (-v/--verbose):**
```rust
#[test]
fn verbose_flag_shows_timing() {
    let (code, _, stderr) = run(&["-v", "-c", "1 + 1"]);
    assert_eq!(code, 0);
    assert!(stderr.contains("["), "timing should appear on stderr, got: {}", stderr);
    assert!(stderr.contains("s]"), "timing should show seconds");
}
```

**Requirement CLI-05 (-- separator):**
```rust
#[test]
fn dashdash_separator() {
    // After --, next arg is treated as filename even if it starts with -
    let (code, _, stderr) = run(&["--", "-nonexistent.qk"]);
    assert_ne!(code, 0);
    // Should try to open the file, not treat -nonexistent.qk as a flag
    assert!(stderr.contains("cannot read") || stderr.contains("not found") || stderr.contains("No such file"),
        "should attempt to read file, got stderr: {}", stderr);
}
```

**Requirement CLI-06 (unknown flags):**
```rust
#[test]
fn unknown_flag_exits_2() {
    let (code, _, stderr) = run(&["--badopt"]);
    assert_eq!(code, 2);
    assert!(stderr.contains("unknown option"));
    assert!(stderr.contains("--help"), "should suggest --help");
}

#[test]
fn unknown_short_flag_exits_2() {
    let (code, _, stderr) = run(&["-z"]);
    assert_eq!(code, 2);
    assert!(stderr.contains("unknown option"));
}
```

**Requirement EXEC-01 (script file execution):**
```rust
#[test]
fn script_file_execution() {
    let tmp = std::env::temp_dir().join("qk_test_script.qk");
    std::fs::write(&tmp, "1 + 1").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "2");
    std::fs::remove_file(&tmp).ok();
}

#[test]
fn script_file_no_banner() {
    let tmp = std::env::temp_dir().join("qk_test_banner.qk");
    std::fs::write(&tmp, "1 + 1").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert!(!stdout.contains("q-Kangaroo"), "banner should not appear in script mode");
    std::fs::remove_file(&tmp).ok();
}

#[test]
fn script_file_not_found() {
    let (code, _, stderr) = run(&["/nonexistent/path/script.qk"]);
    assert_ne!(code, 0);
    assert!(stderr.contains("cannot read"));
}

#[test]
fn script_multi_statement() {
    let tmp = std::env::temp_dir().join("qk_test_multi.qk");
    std::fs::write(&tmp, "x := 10:\ny := 20:\nx + y").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "30");
    std::fs::remove_file(&tmp).ok();
}
```

**Requirement EXEC-02 (# comments):**
```rust
#[test]
fn script_with_comments() {
    let tmp = std::env::temp_dir().join("qk_test_comments.qk");
    std::fs::write(&tmp, "# This is a comment\n1 + 2\n# Another comment").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "3");
    std::fs::remove_file(&tmp).ok();
}

#[test]
fn script_inline_comment() {
    let tmp = std::env::temp_dir().join("qk_test_inline.qk");
    std::fs::write(&tmp, "1 + 2 # add numbers").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "3");
    std::fs::remove_file(&tmp).ok();
}
```

**Requirement EXEC-03 (multi-line statements):**
```rust
#[test]
fn script_multiline_expression() {
    let tmp = std::env::temp_dir().join("qk_test_multiline.qk");
    std::fs::write(&tmp, "aqprod(\n  q,q,\n  infinity,20\n)").unwrap();
    let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 0);
    assert!(!stdout.trim().is_empty(), "should produce output");
    std::fs::remove_file(&tmp).ok();
}
```

**Requirement EXEC-04 (piped stdin):**
```rust
#[test]
fn piped_stdin_simple() {
    let (code, stdout, _) = run_piped("1 + 1");
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "2");
}

#[test]
fn piped_stdin_no_banner() {
    let (code, stdout, _) = run_piped("1 + 1");
    assert_eq!(code, 0);
    assert!(!stdout.contains("q-Kangaroo"), "banner should not appear in piped mode");
    assert!(!stdout.contains("q>"), "prompt should not appear in piped mode");
}

#[test]
fn piped_stdin_multi_statement() {
    let (code, stdout, _) = run_piped("x := 5:\nx + 10");
    assert_eq!(code, 0);
    assert_eq!(stdout.trim(), "15");
}
```

**Requirement EXEC-05 (suppress banner in non-interactive modes):**
(Already covered by c_flag_no_banner, script_file_no_banner, piped_stdin_no_banner above)

**Requirement EXEC-06 (read function):**
```rust
#[test]
fn read_function_in_c_flag() {
    let tmp = std::env::temp_dir().join("qk_test_read_target.qk");
    std::fs::write(&tmp, "x := 42:").unwrap();
    let path_str = tmp.to_str().unwrap().replace('\\', "\\\\");
    let expr = format!("read(\"{}\"):\nx", path_str);
    let (code, stdout, stderr) = run(&["-c", &expr]);
    assert_eq!(code, 0, "stderr: {}", stderr);
    assert_eq!(stdout.trim(), "42");
    std::fs::remove_file(&tmp).ok();
}
```

**Version flag:**
```rust
#[test]
fn version_flag() {
    let (code, stdout, _) = run(&["--version"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("q-kangaroo"));
}

#[test]
fn version_flag_short() {
    let (code, stdout, _) = run(&["-V"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("q-kangaroo"));
}
```
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --test cli_integration 2>&1 | tail -20`

All integration tests pass. Then run the full test suite:
`cargo test -p qsym-cli 2>&1 | tail -5`

All unit tests + integration tests pass.
  </verify>
  <done>
Comprehensive integration test suite with 25+ subprocess tests covering all 12 requirements. Tests verify: exit codes (0 for success, 2 for usage error, non-zero for parse/eval errors), stdout content (correct output, no banner in non-interactive modes), stderr content (errors, timing with -v, --help suggestion for unknown flags), piped stdin, script file execution with comments and multi-line, -c flag, read() function, -- separator.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all unit tests + integration tests pass
2. Every success criterion from the roadmap is covered by at least one integration test:
   - SC1 (script.qk): script_file_execution, script_with_comments, script_multiline_expression
   - SC2 (piped): piped_stdin_simple, piped_stdin_no_banner
   - SC3 (-c): c_flag_simple_arithmetic, c_flag_function_call
   - SC4 (--help): help_flag_long, help_flag_short
   - SC5 (read): read_function_in_c_flag
3. Every requirement ID has at least one test asserting its behavior
</verification>

<success_criteria>
- tests/cli_integration.rs exists with 25+ tests
- All tests pass when run via `cargo test -p qsym-cli --test cli_integration`
- Tests cover all 12 requirement IDs (CLI-01..06, EXEC-01..06)
- Tests cover all 5 success criteria from the roadmap
- Tests use subprocess execution (Command::new) for real end-to-end validation
</success_criteria>

<output>
After completion, create `.planning/phases/30-script-execution-cli-flags/30-03-SUMMARY.md`
</output>
