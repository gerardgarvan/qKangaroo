---
phase: 32-pdf-reference-manual
plan: 02
type: execute
wave: 2
depends_on: [32-01]
files_modified:
  - manual/chapters/05-products.typ
  - manual/chapters/06-partitions.typ
  - manual/chapters/07-theta.typ
  - manual/chapters/08-series-analysis.typ
autonomous: true
requirements: [DOC-01]

must_haves:
  truths:
    - "All 7 product functions have complete entries with formal math definitions"
    - "All 7 partition functions have complete entries with generating function definitions"
    - "All 3 theta functions have complete entries with sum/product definitions"
    - "All 9 series analysis functions have complete entries with algorithm descriptions"
    - "Every function entry includes signature, description, parameters, 2-3 REPL examples, edge cases, and related functions"
  artifacts:
    - path: "manual/chapters/05-products.typ"
      provides: "7 function entries: aqprod, qbin, etaq, jacprod, tripleprod, quinprod, winquist"
      contains: "func-entry"
    - path: "manual/chapters/06-partitions.typ"
      provides: "7 function entries: partition_count through crank_gf"
      contains: "func-entry"
    - path: "manual/chapters/07-theta.typ"
      provides: "3 function entries: theta2, theta3, theta4"
      contains: "func-entry"
    - path: "manual/chapters/08-series-analysis.typ"
      provides: "9 function entries: sift through qetamake"
      contains: "func-entry"
  key_links:
    - from: "manual/chapters/05-products.typ"
      to: "manual/template.typ"
      via: "func-entry template calls"
      pattern: "#func-entry"
---

<objective>
Write function reference chapters 5-8 covering Products (7), Partitions (7), Theta Functions (3), and Series Analysis (9) -- 26 functions total.

Purpose: Document the first four function groups with full mathematical definitions, parameter tables, REPL examples, edge cases, and cross-references. These are the foundational q-series functions.

Output: manual/chapters/05-products.typ, 06-partitions.typ, 07-theta.typ, 08-series-analysis.typ
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-pdf-reference-manual/32-RESEARCH.md
@.planning/phases/32-pdf-reference-manual/32-01-SUMMARY.md
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/eval.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Products and Partitions chapters (05-06)</name>
  <files>
    manual/chapters/05-products.typ
    manual/chapters/06-partitions.typ
  </files>
  <action>
**chapters/05-products.typ** -- "Products" chapter (7 functions):

Chapter introduction: Brief overview of infinite products in q-series theory. Mention the q-Pochhammer symbol as the fundamental building block.

For each function, use the `#func-entry()` template from template.typ. Extract signatures from eval.rs `get_signature()` and descriptions/examples from help.rs `FUNC_HELP`.

**aqprod** (q-Pochhammer product):
- Signature: `aqprod(coeff_num, coeff_den, power, n_or_infinity, order)`
- Math definition: $(a;q)_n = product_(k=0)^(n-1) (1 - a q^k)$ where $a = ("coeff_num"/"coeff_den") dot q^"power"$. Infinite case: $(a;q)_oo = product_(k=0)^oo (1 - a q^k)$.
- Parameters: coeff_num (Integer: numerator of coefficient a), coeff_den (Integer: denominator), power (Integer: q-power in a), n_or_infinity (Integer or `infinity`: product length), order (Integer: truncation order)
- Examples: `aqprod(1, 1, 1, infinity, 10)` => `1 - q - q^2 + q^5 + q^7 + O(q^10)` (Euler's function); `aqprod(1, 1, 0, 5, 20)` => `1 - q - q^2 - q^3 - q^4 - q^5 + ...` (finite product)
- Edge cases: coeff_den must be nonzero; n must be non-negative integer or infinity; order must be positive
- Related: etaq, tripleprod, jacprod
- Index entries: "q-Pochhammer symbol", "infinite product", "Euler function"

**qbin** (q-binomial coefficient):
- Math: $binom(n, k)_q = ((q;q)_n) / ((q;q)_k (q;q)_(n-k))$
- Examples: `qbin(4, 2, 20)` => `1 + q + 2*q^2 + q^3 + q^4`; `qbin(5, 0, 20)` => `1`
- Edge cases: k must satisfy 0 <= k <= n; returns polynomial of degree k*(n-k)
- Related: aqprod, partition_gf

**etaq** (Dedekind eta quotient):
- Math: $eta_b^t = q^(b t\/24) product_(k=1)^oo (1-q^(b k))^t$
- Examples: `etaq(1, 1, 10)` showing eta(tau); `etaq(1, -1, 10)` showing 1/eta(tau) = partition_gf
- Edge cases: b must be positive; t can be any integer (positive for products, negative for quotients)
- Related: aqprod, etamake, prove_eta_id

**jacprod** (Jacobi triple product):
- Math: $J(a,b) = product_(k>=1) (1-q^(b k))(1-q^(b k - a))(1-q^(b(k-1)+a))$
- Related: tripleprod, jacprodmake, theta2, theta3, theta4

**tripleprod**:
- Math: $(a;q)_oo (q\/a;q)_oo (q;q)_oo$ where $a = ("cn"/"cd") q^"power"$
- Related: aqprod, jacprod, quinprod

**quinprod** (quintuple product):
- Math: $(a;q)_oo (q\/a;q)_oo (a^2;q^2)_oo (q^2\/a^2;q^2)_oo (q;q)_oo$
- Related: tripleprod, aqprod

**winquist** (Winquist product):
- Math: Product of 10 theta-type factors. Describe the 6 parameters (two (cn, cd, power) triples for a and b).
- Edge cases: Used primarily in partition congruence proofs; 7 parameters
- Related: aqprod, tripleprod, prove_eta_id

---

**chapters/06-partitions.typ** -- "Partitions" chapter (7 functions):

Chapter introduction: Partition generating functions and their role in number theory. Define p(n) as the number of partitions of n.

**partition_count**:
- Math: $p(n) =$ number of partitions of $n$
- Note: returns Integer, not Series. Uses pentagonal number recurrence.
- Examples: `partition_count(5)` => `7`; `partition_count(100)` => `190569292`
- Edge cases: n must be non-negative integer

**partition_gf**:
- Math: $sum_(n>=0) p(n) q^n = 1 / (q;q)_oo = product_(k>=1) 1/(1-q^k)$
- Examples: `partition_gf(10)` showing coefficients 1,1,2,3,5,7,11,15,22,30

**distinct_parts_gf**:
- Math: $(-q;q)_oo = product_(k>=1) (1+q^k)$

**odd_parts_gf**:
- Math: $1/((q;q^2)_oo) = product_(k>=0) 1/(1-q^(2k+1))$
- Note Euler's theorem: equals distinct_parts_gf

**bounded_parts_gf**:
- Math: $product_(k=1)^m 1/(1-q^k)$ where m = max_part

**rank_gf**:
- Math: $R(z;q) = sum_(n>=0) sum_m N(m,n) z^m q^n$ where N(m,n) counts partitions of n with rank m
- Note: At z=1 reduces to partition_gf

**crank_gf**:
- Math: $C(z;q) = product_(n>=1) ((1-q^n)^2) / ((1-z q^n)(1-q^n\/z))$
- Note: At z=1 reduces to partition_gf

For ALL functions: use func-entry template, include 2-3 REPL examples with realistic output matching help.rs, document edge cases, list related functions, add index entries for each function name and key mathematical concepts.
  </action>
  <verify>
Verify files exist and contain all function entries:
- 05-products.typ contains func-entry calls for: aqprod, qbin, etaq, jacprod, tripleprod, quinprod, winquist (7 entries)
- 06-partitions.typ contains func-entry calls for: partition_count, partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf, rank_gf, crank_gf (7 entries)
- All entries have math definitions in Typst $ notation
  </verify>
  <done>
Products chapter (7 functions) and Partitions chapter (7 functions) are complete with formal math definitions, parameter tables, REPL examples, edge cases, and index entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Theta and Series Analysis chapters (07-08)</name>
  <files>
    manual/chapters/07-theta.typ
    manual/chapters/08-series-analysis.typ
  </files>
  <action>
**chapters/07-theta.typ** -- "Theta Functions" chapter (3 functions):

Chapter introduction: Jacobi theta functions and their role in number theory and physics. Brief mention of the classical notation conventions.

**theta2**:
- Math: $theta_2(q) = 2 q^(1\/4) sum_(n>=0) q^(n(n+1))$
- Note: Uses $q^(1\/4)$ convention (fractional powers)
- Examples: `theta2(10)` => `2*q^(1/4) + 2*q^(9/4) + O(q^10)`

**theta3**:
- Math: $theta_3(q) = 1 + 2 sum_(n>=1) q^(n^2) = product_(k>=1) (1-q^(2k))(1+q^(2k-1))^2$
- Both sum and product forms
- Examples: `theta3(10)` => `1 + 2*q + 2*q^4 + 2*q^9 + O(q^10)`
- Index: "sums of squares", "Jacobi theta function"

**theta4**:
- Math: $theta_4(q) = 1 + 2 sum_(n>=1) (-1)^n q^(n^2)$
- Note: Related to theta3 by $q -> -q$
- Examples: `theta4(10)` => `1 - 2*q + 2*q^4 - 2*q^9 + O(q^10)`

Include the classical Jacobi identity $theta_3(q)^4 = theta_2(q)^4 + theta_4(q)^4$ as a highlighted remark (verifiable in q-Kangaroo). All three functions related to each other, plus jacprod.

---

**chapters/08-series-analysis.typ** -- "Series Analysis" chapter (9 functions):

Chapter introduction: Tools for analyzing, dissecting, and reverse-engineering power series. These functions help researchers discover structure in q-series.

**sift** (arithmetic subsequence extraction):
- Description: Extracts coefficients at arithmetic progressions. For series $f(q) = sum a_n q^n$, `sift(f, m, j)` returns $sum a_(m n + j) q^n$.
- Math: informal (utility function per user decision)
- Examples: `sift(partition_gf(50), 5, 4)` to demonstrate Ramanujan's congruence p(5n+4) equiv 0 (mod 5)
- Related: findcong

**qdegree** and **lqdegree**:
- Return highest/lowest q-power with nonzero coefficient
- Utility functions, informal descriptions
- Examples: `qdegree(theta3(10))` => `9`; `lqdegree(theta3(10))` => `0`

**qfactor** (factorization into cyclotomic-like factors):
- Factors a polynomial series into $(1-q^i)$ factors
- Returns a map of {factor: multiplicity}
- Example: factoring a finite q-Pochhammer product

**prodmake** (log derivative method):
- Finds exponents $a_n$ such that $f = product_(n>=1) (1-q^n)^(a_n)$
- Returns a map of {n: exponent}
- Related: etamake, jacprodmake, mprodmake, qetamake

**etamake**:
- Finds eta-quotient representation via Mobius inversion
- Related: etaq, prodmake

**jacprodmake**:
- Finds Jacobi product representation with period search
- Returns period, residue grouping, is_exact flag
- Related: jacprod, prodmake

**mprodmake**:
- Finds $(1+q^n)$ product form
- Related: distinct_parts_gf, prodmake

**qetamake**:
- Combined eta/q-Pochhammer product form
- Related: etamake, prodmake

For ALL functions: use func-entry template, provide realistic REPL examples matching help.rs data, edge cases, related functions, index entries.
  </action>
  <verify>
Verify files exist and contain all function entries:
- 07-theta.typ contains func-entry calls for: theta2, theta3, theta4 (3 entries)
- 08-series-analysis.typ contains func-entry calls for: sift, qdegree, lqdegree, qfactor, prodmake, etamake, jacprodmake, mprodmake, qetamake (9 entries)
- Theta chapter includes Jacobi identity remark
  </verify>
  <done>
Theta Functions chapter (3 functions with formal math) and Series Analysis chapter (9 functions with algorithm descriptions) are complete. All 26 functions across chapters 05-08 are documented.
  </done>
</task>

</tasks>

<verification>
- All 26 functions in Groups 1-4 have func-entry entries
- Mathematical definitions use correct Typst math notation for q-Pochhammer, products, sums
- Signatures match eval.rs get_signature() exactly
- Examples match help.rs FUNC_HELP data
- No Maple equivalents appear in individual entries (per user decision -- migration table only)
- Index entries present for all function names and key math concepts
</verification>

<success_criteria>
- 4 chapter files exist with 26 total function entries
- Each entry has: signature, description, math definition (formal for core, informal for utilities), parameters, 2-3 examples, edge cases, related functions
- Products and Partitions have formal product/sum notation
- Theta has both sum and product forms
- Series Analysis uses prose descriptions for utility functions
</success_criteria>

<output>
After completion, create `.planning/phases/32-pdf-reference-manual/32-02-SUMMARY.md`
</output>
