---
phase: 32-pdf-reference-manual
plan: 04
type: execute
wave: 2
depends_on: [32-01]
files_modified:
  - manual/chapters/11-mock-theta-bailey.typ
  - manual/chapters/12-identity-proving.typ
autonomous: true
requirements: [DOC-01]

must_haves:
  truths:
    - "All 20 mock theta functions have complete entries with sum definitions"
    - "All 3 Appell-Lerch functions have complete entries"
    - "All 4 Bailey chain functions have complete entries"
    - "All 7 identity proving functions have complete entries"
    - "Every function entry includes signature, description, parameters, 2-3 REPL examples, edge cases, and related functions"
  artifacts:
    - path: "manual/chapters/11-mock-theta-bailey.typ"
      provides: "27 function entries: mock theta (20), Appell-Lerch (3), Bailey (4)"
      contains: "func-entry"
    - path: "manual/chapters/12-identity-proving.typ"
      provides: "7 function entries: prove_eta_id through prove_nonterminating"
      contains: "func-entry"
  key_links:
    - from: "manual/chapters/11-mock-theta-bailey.typ"
      to: "manual/template.typ"
      via: "func-entry template calls"
      pattern: "#func-entry"
    - from: "manual/chapters/12-identity-proving.typ"
      to: "manual/template.typ"
      via: "func-entry template calls"
      pattern: "#func-entry"
---

<objective>
Write function reference chapters 11-12 covering Mock Theta/Appell-Lerch/Bailey (27) and Identity Proving (7) -- 34 functions total.

Purpose: Document the most advanced function groups: Ramanujan's mock theta functions (20), Appell-Lerch sums (3), Bailey chain machinery (4), and algorithmic identity proving tools (7).

Output: manual/chapters/11-mock-theta-bailey.typ, 12-identity-proving.typ
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-pdf-reference-manual/32-RESEARCH.md
@.planning/phases/32-pdf-reference-manual/32-01-SUMMARY.md
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/eval.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Mock Theta and Bailey chapter (11)</name>
  <files>manual/chapters/11-mock-theta-bailey.typ</files>
  <action>
**chapters/11-mock-theta-bailey.typ** -- "Mock Theta Functions and Bailey Chains" chapter (27 functions):

Chapter introduction (2 paragraphs): Ramanujan introduced mock theta functions in his last letter to Hardy (1920). They are q-hypergeometric series that behave like modular forms but are not. The theory was later unified by Zwegers (2002) via the Appell-Lerch sum framework. Bailey chains provide a systematic method for generating identities from known Bailey pairs.

**Subsection: Third-Order Mock Theta Functions (7)**

Brief intro: Ramanujan's original 7 third-order mock theta functions from his letter to Hardy. All take a single `order` parameter.

For each of the 7 functions, use func-entry with:
- Formal math definition from help.rs description
- Signature: `(order)`
- One REPL example each
- Related: link to other mock theta functions of same order

**mock_theta_f3**:
- Math: $f(q) = sum_(n>=0) q^(n^2) / (-q;q)_n^2$
- Example: `mock_theta_f3(10)`

**mock_theta_phi3**:
- Math: $phi(q) = sum_(n>=0) q^(n^2) / (-q^2;q^2)_n$

**mock_theta_psi3**:
- Math: $psi(q) = sum_(n>=1) q^(n^2) / (q;q^2)_n$

**mock_theta_chi3**:
- Math: $chi(q) = sum_(n>=0) q^(n^2) (-q;q)_n / product_(k>=1) (1-q^k+q^(2k))$

**mock_theta_omega3**:
- Math: $omega(q) = sum_(n>=0) q^(2n(n+1)) / (q;q^2)_(n+1)^2$

**mock_theta_nu3**:
- Math: $nu(q) = sum_(n>=0) (-1)^n q^(n(n+1)) / (-q;q^2)_(n+1)$

**mock_theta_rho3**:
- Math: $rho(q) = sum_(n>=0) q^(2n(n+1)) / product_(k>=1) (1+q^k+q^(2k))$

**Subsection: Fifth-Order Mock Theta Functions (10)**

Brief intro: Ramanujan's 10 fifth-order mock theta functions. All take a single `order` parameter.

For each function use func-entry. These can be slightly more compact since the pattern is repetitive -- but each MUST still have: signature, math definition, at least 1 example, edge cases, related.

Functions: mock_theta_f0_5, mock_theta_f1_5, mock_theta_cap_f0_5, mock_theta_cap_f1_5, mock_theta_phi0_5, mock_theta_phi1_5, mock_theta_psi0_5, mock_theta_psi1_5, mock_theta_chi0_5, mock_theta_chi1_5.

Extract math definitions from help.rs. Note which use the "q -> -q composition" technique (chi0_5, chi1_5).

**Subsection: Seventh-Order Mock Theta Functions (3)**

Functions: mock_theta_cap_f0_7, mock_theta_cap_f1_7, mock_theta_cap_f2_7. All take `(order)`.

**Subsection: Appell-Lerch Sums (3)**

Brief intro: Zwegers' unifying framework for mock theta functions.

**appell_lerch_m**:
- Math: $m(a,z,q) = 1 / (j(z;q)) sum_(r in ZZ) (-1)^r z^r q^(r(r-1)\/2) / (1 - a q^r z)$ where $a = q^(a_"pow")$, $z = q^(z_"pow")$
- Signature: `appell_lerch_m(a_pow, z_pow, order)`
- Note the j(z;q) Jacobi theta normalization

**universal_mock_theta_g2**:
- Math: $g_2(a;q)$ where $a = q^(a_"pow")$
- Relates to Appell-Lerch sum via algebraic identities

**universal_mock_theta_g3**:
- Math: $g_3(a;q)$ where $a = q^(a_"pow")$

**Subsection: Bailey Chains (4)**

Brief intro (1 paragraph): A Bailey pair relative to $a$ is a pair of sequences $("alpha"_n, "beta"_n)$ satisfying $"beta"_n = sum_(k=0)^n "alpha"_k / ((q;q)_(n-k) (a q;q)_(n+k))$. Bailey's lemma produces new pairs from old. Iterating produces a Bailey chain.

**bailey_weak_lemma**:
- Signature: `bailey_weak_lemma(pair_code, a_num, a_den, a_pow, max_n, order)`
- pair_code: 0=Unit, 1=Rogers-Ramanujan, 2=q-Binomial
- Apply weak form of Bailey's lemma

**bailey_apply_lemma**:
- Full Bailey's lemma with transformation parameters b, c
- 12 parameters (pair_code + a triple + b triple + c triple + max_n + order)

**bailey_chain**:
- Iterate to specified depth
- 13 parameters

**bailey_discover**:
- Search for Bailey pair proving lhs=rhs
- Tries trivial equality, database lookup, weak lemma, chain depth search

Index entries: "mock theta function", "Ramanujan", "Hardy", "Zwegers", "Appell-Lerch sum", "Bailey pair", "Bailey chain", "Bailey's lemma", "Rogers-Ramanujan". Sub-entries under "mock theta function" for each order (third, fifth, seventh).
  </action>
  <verify>
Count func-entry calls in 11-mock-theta-bailey.typ: should be exactly 27 (7 third-order + 10 fifth-order + 3 seventh-order + 3 Appell-Lerch + 4 Bailey).
  </verify>
  <done>
Mock Theta/Bailey chapter complete with 27 function entries across 5 subsections. All mock theta functions have formal sum definitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Identity Proving chapter (12)</name>
  <files>manual/chapters/12-identity-proving.typ</files>
  <action>
**chapters/12-identity-proving.typ** -- "Identity Proving" chapter (7 functions):

Chapter introduction (1-2 paragraphs): Algorithmic methods for proving q-series identities. These functions go beyond empirical verification (checking coefficients agree) to provide rigorous mathematical proofs. The eta-quotient prover uses the valence formula for modular forms. The q-Gosper/q-Zeilberger/WZ machinery provides computer-algebra proofs of summation identities.

**prove_eta_id** (eta-quotient identity prover):
- Signature: `prove_eta_id(terms_list, level)`
- Math: Uses the valence formula for modular forms to verify that a linear combination of eta quotients is identically zero.
- Parameters: terms_list (List of (eta_args, coefficient) pairs where eta_args specifies the eta quotient), level (Integer: modular group level)
- Returns: Boolean (true if identity proven, false if insufficient evidence or disproven)
- Example: Proving a simple eta identity
- Edge cases: level must divide lcm of all eta bases; works for modular forms of weight 0
- Related: etaq, search_identities
- Index: "eta-quotient identity", "valence formula", "modular form"

**search_identities** (identity database search):
- Signature: `search_identities(search_type)`
- Search_type is a string: "theta", "eta", "mock", "bailey", "product"
- Returns list of known identities matching the search
- Example: `search_identities("theta")`
- Related: prove_eta_id

**q_gosper** (q-Gosper indefinite summation):
- Signature: `q_gosper(upper_list, lower_list, z_num, z_den, z_pow, q_num, q_den)`
- Math: Finds a closed form for $sum t_k$ where $t_(k+1)/t_k$ is a q-rational function. The algorithm searches for a q-rational function $y_k$ such that $t_k = y_(k+1) t_(k+1) - y_k t_k$.
- Parameters: upper_list and lower_list specify the q-hypergeometric term ratio $t_(k+1)/t_k$; q_num/q_den specify the base q
- Returns closed-form antidifference or null if no q-hypergeometric solution exists
- Edge cases: Not all q-hypergeometric sums have q-hypergeometric antidifferences (Gosper-summable)
- Related: q_zeilberger, phi
- Index: "q-Gosper algorithm", "indefinite summation", "antidifference"

**q_zeilberger** (creative telescoping):
- Signature: `q_zeilberger(upper_list, lower_list, z_num, z_den, z_pow, n, q_num, q_den, max_order)`
- Math: Produces a recurrence relation $sum_(j=0)^J a_j(q^n) S(n+j) = 0$ for the definite sum $S(n) = sum_k F(n,k)$
- Returns (recurrence_coefficients, WZ_certificate) pair
- Example showing a simple recurrence
- Related: verify_wz, q_gosper
- Index: "q-Zeilberger algorithm", "creative telescoping", "recurrence relation"

**verify_wz** (WZ proof verification):
- Signature: `verify_wz(upper_list, lower_list, z_num, z_den, z_pow, n, q_num, q_den, max_order, max_k)`
- Verifies a WZ proof certificate satisfies the WZ pair equations
- Returns Boolean
- Related: q_zeilberger
- Index: "WZ proof", "Wilf-Zeilberger"

**q_petkovsek** (recurrence solver):
- Signature: `q_petkovsek(coeff_list, q_num, q_den)`
- Finds q-hypergeometric term solutions of a q-holonomic recurrence
- Returns list of solutions
- Related: q_zeilberger
- Index: "q-Petkovsek algorithm", "q-holonomic recurrence"

**prove_nonterminating** (Python API only):
- Signature: `prove_nonterminating(requires Python API)`
- Note prominently: This function requires closure support and is ONLY available through the Python API (`q_kangaroo` package), not the CLI.
- Description: Proves nonterminating hypergeometric identities using symbolic parameter manipulation
- Example: Show error message from CLI: `Error: prove_nonterminating requires the Python API`
- Related: phi, try_summation, q_gosper

For ALL: use func-entry template, include index entries.
  </action>
  <verify>
Verify 12-identity-proving.typ contains func-entry calls for all 7 functions: prove_eta_id, search_identities, q_gosper, q_zeilberger, verify_wz, q_petkovsek, prove_nonterminating.
  </verify>
  <done>
Identity Proving chapter complete with 7 function entries covering eta-quotient proofs, hypergeometric summation algorithms, and WZ certification. prove_nonterminating correctly marked as Python-only.
  </done>
</task>

</tasks>

<verification>
- All 34 functions in Groups 7-8 have func-entry entries
- Mock theta chapter has entries for all 20 mock theta functions (7 third + 10 fifth + 3 seventh)
- Appell-Lerch subsection has 3 entries
- Bailey subsection has 4 entries
- Identity Proving chapter has 7 entries
- prove_nonterminating marked as Python-only
- Signatures match eval.rs get_signature()
- No Maple equivalents in individual entries
- Index entries for all function names and mathematical concepts
</verification>

<success_criteria>
- 2 chapter files with 34 total function entries
- Mock theta functions organized by order (third, fifth, seventh)
- Bailey chain functions include pair_code explanation
- Identity proving chapter covers both verification and algorithmic proving
- All entries complete with func-entry template fields
</success_criteria>

<output>
After completion, create `.planning/phases/32-pdf-reference-manual/32-04-SUMMARY.md`
</output>
