---
phase: 34-product-theta-signatures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true

must_haves:
  truths:
    - "jacprod(1, 5, q, 30) returns JAC(1,5)/JAC(5,15) truncated at O(q^30)"
    - "tripleprod(q^3, q, 20) returns Jacobi triple product with z=q^3"
    - "quinprod(q^2, q, 20) returns quintuple product with z=q^2"
    - "winquist(q, q^2, q, 10) returns Winquist product with a=q, b=q^2"
    - "qbin(q, 4, 2) returns exact q-binomial polynomial [4 choose 2]_q"
    - "qbin(4, 2, q, 10) returns q-binomial with explicit q and T"
    - "etaq(q, [1,2,3], 10) returns product of three individual etaq series"
    - "All legacy signatures continue to work unchanged"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Maple-style dispatch paths for jacprod, tripleprod, quinprod, winquist, qbin, etaq multi-delta"
      contains: "jacprod.*Maple|tripleprod.*Maple|quinprod.*Maple|winquist.*Maple"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch(jacprod)"
      to: "qseries::jacprod + arithmetic::div"
      via: "JAC(a,b)/JAC(b,3b) formula"
      pattern: "arithmetic::div"
    - from: "crates/qsym-cli/src/eval.rs dispatch(etaq multi-delta)"
      to: "qseries::etaq + arithmetic::mul"
      via: "product of individual etaq calls"
      pattern: "arithmetic::mul.*factor"
---

<objective>
Add Maple-style dispatch paths to eval.rs for jacprod, tripleprod, quinprod, winquist, qbin, and etaq multi-delta. Each function gets a new if/else branch above the legacy path, using first-arg type detection and arg count to disambiguate.

Purpose: Researchers can call all product/theta functions with Garvan's exact Maple syntax, while legacy signatures continue to work silently.
Output: Updated eval.rs with 6 new Maple-style dispatch paths, all passing cargo test.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-product-theta-signatures/34-RESEARCH.md
@crates/qsym-cli/src/eval.rs (lines 1140-1340: existing dispatch code for all Group 1 products)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Maple-style dispatch for jacprod, tripleprod, quinprod, winquist</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Modify the dispatch match arms for jacprod, tripleprod, quinprod, and winquist in the `dispatch` function (around lines 1233-1281). For each function, add a Maple-style if/else branch ABOVE the legacy path, following the exact same pattern established by aqprod (lines 1150-1200) in Phase 33.

**jacprod (line ~1233):**
Replace the current 3-arg-only block with:
```rust
"jacprod" => {
    if args.len() == 4 && matches!(&args[2], Value::Symbol(_)) {
        // Maple: jacprod(a, b, q, T) = JAC(a,b) / JAC(b,3b)
        // Per Garvan source: tripleprod(q^a,q^b,T)/tripleprod(q^b,q^(3*b),T)
        let a_val = extract_i64(name, args, 0)?;
        let b_val = extract_i64(name, args, 1)?;
        let sym = extract_symbol_id(name, args, 2, env)?;
        let order = extract_i64(name, args, 3)?;
        let jac_ab = qseries::jacprod(a_val, b_val, sym, order);
        let jac_b3b = qseries::jacprod(b_val, 3 * b_val, sym, order);
        let result = arithmetic::div(&jac_ab, &jac_b3b);
        Ok(Value::Series(result))
    } else {
        // Legacy: jacprod(a, b, order)
        expect_args(name, args, 3)?;
        let a = extract_i64(name, args, 0)?;
        let b = extract_i64(name, args, 1)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::jacprod(a, b, env.sym_q, order);
        Ok(Value::Series(result))
    }
}
```
CRITICAL: Garvan's `jacprod(a,b,q,T) = JAC(a,b)/JAC(b,3b)`, NOT just JAC(a,b). The legacy 3-arg form keeps returning plain JAC(a,b).

**tripleprod (line ~1243):**
Replace the current 4-arg-only block. Disambiguation: 3 args where first is Series/Symbol -> Maple; 4 integer args -> legacy.
```rust
"tripleprod" => {
    if args.len() == 3 && matches!(&args[0], Value::Series(_) | Value::Symbol(_)) {
        // Maple: tripleprod(z, q, T) -- z is monomial, q is variable
        let monomial = extract_monomial_from_arg(name, args, 0)?;
        let sym = extract_symbol_id(name, args, 1, env)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::tripleprod(&monomial, sym, order);
        Ok(Value::Series(result))
    } else {
        // Legacy: tripleprod(cn, cd, power, order)
        expect_args(name, args, 4)?;
        let cn = extract_i64(name, args, 0)?;
        let cd = extract_i64(name, args, 1)?;
        let power = extract_i64(name, args, 2)?;
        let order = extract_i64(name, args, 3)?;
        let monomial = QMonomial::new(QRat::from((cn, cd)), power);
        let result = qseries::tripleprod(&monomial, env.sym_q, order);
        Ok(Value::Series(result))
    }
}
```

**quinprod (line ~1255):**
Same pattern as tripleprod. 3 args with Series/Symbol first -> Maple; 4 integer args -> legacy.
```rust
"quinprod" => {
    if args.len() == 3 && matches!(&args[0], Value::Series(_) | Value::Symbol(_)) {
        // Maple: quinprod(z, q, T)
        let monomial = extract_monomial_from_arg(name, args, 0)?;
        let sym = extract_symbol_id(name, args, 1, env)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::quinprod(&monomial, sym, order);
        Ok(Value::Series(result))
    } else {
        // Legacy: quinprod(cn, cd, power, order)
        expect_args(name, args, 4)?;
        // ... existing code unchanged ...
    }
}
```

**winquist (line ~1267):**
Disambiguation: 4 args where third is Symbol -> Maple; 7 integer args -> legacy.
```rust
"winquist" => {
    if args.len() == 4 && matches!(&args[2], Value::Symbol(_)) {
        // Maple: winquist(a, b, q, T) -- a,b are monomials, q is variable
        let a = extract_monomial_from_arg(name, args, 0)?;
        let b = extract_monomial_from_arg(name, args, 1)?;
        let sym = extract_symbol_id(name, args, 2, env)?;
        let order = extract_i64(name, args, 3)?;
        let result = qseries::winquist(&a, &b, sym, order);
        Ok(Value::Series(result))
    } else {
        // Legacy: winquist(a_cn, a_cd, a_p, b_cn, b_cd, b_p, order)
        expect_args(name, args, 7)?;
        // ... existing code unchanged ...
    }
}
```

Also update `get_signature` (line ~2539) for these 4 functions to show BOTH forms:
- `"jacprod" => "(a, b, q, T) or (a, b, order)"`
- `"tripleprod" => "(z, q, T) or (coeff_num, coeff_den, power, order)"`
- `"quinprod" => "(z, q, T) or (coeff_num, coeff_den, power, order)"`
- `"winquist" => "(a, b, q, T) or (a_cn, a_cd, a_p, b_cn, b_cd, b_p, order)"`

Add unit tests for each new Maple-style dispatch path in the existing test module (near line 3540):
- `dispatch_jacprod_maple_style`: `jacprod(1, 5, Symbol("q"), 30)` -> Value::Series, verify it differs from plain `jacprod(1, 5, 30)` (since Maple = JAC/JAC, legacy = JAC)
- `dispatch_tripleprod_maple_style`: `tripleprod(q^3_series, Symbol("q"), 20)` -> Value::Series
- `dispatch_quinprod_maple_style`: `quinprod(q^2_series, Symbol("q"), 20)` -> Value::Series
- `dispatch_winquist_maple_style`: `winquist(q^1_series, q^2_series, Symbol("q"), 10)` -> Value::Series
- Verify all legacy forms still work (existing tests already cover this, but add explicit assertions).

To create a monomial Series value for test args, use `FormalPowerSeries` with a single coefficient:
```rust
fn make_monomial_series(power: i64) -> Value {
    let sym = SymbolId(0);
    let mut fps = FormalPowerSeries::zero(sym, POLYNOMIAL_ORDER);
    fps.coefficients.insert(power, QRat::one());
    Value::Series(fps)
}
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /cygdrive/c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- dispatch_jacprod dispatch_tripleprod dispatch_quinprod dispatch_winquist` and confirm all new tests pass.

Also run the full CLI test suite: `cargo test -p qsym-cli` to confirm zero regressions.
  </verify>
  <done>
jacprod, tripleprod, quinprod, and winquist each accept both Maple-style and legacy argument forms. All existing tests pass. New unit tests verify Maple-style dispatch returns correct series.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Maple-style dispatch for qbin and etaq multi-delta</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Modify the dispatch match arms for qbin and etaq in eval.rs.

**qbin (line ~1202):**
Replace the current 3-arg-only block with multi-form dispatch. Three forms:
1. Garvan 3-arg: `qbin(q, m, n)` -- first arg is Symbol, produces exact polynomial (POLYNOMIAL_ORDER sentinel)
2. 4-arg with explicit q: `qbin(n, k, q, T)` -- third arg is Symbol
3. Legacy 3-arg: `qbin(n, k, order)` -- all integers

```rust
"qbin" => {
    if args.len() == 3 && matches!(&args[0], Value::Symbol(_)) {
        // Garvan: qbin(q, m, n) -- exact polynomial
        let sym = extract_symbol_id(name, args, 0, env)?;
        let m = extract_i64(name, args, 1)?;
        let n = extract_i64(name, args, 2)?;
        let result = qseries::qbin(n, m, sym, POLYNOMIAL_ORDER);
        Ok(Value::Series(result))
    } else if args.len() == 4 && matches!(&args[2], Value::Symbol(_)) {
        // Extended: qbin(n, k, q, T) -- with explicit variable and truncation
        let n = extract_i64(name, args, 0)?;
        let k = extract_i64(name, args, 1)?;
        let sym = extract_symbol_id(name, args, 2, env)?;
        let order = extract_i64(name, args, 3)?;
        let result = qseries::qbin(n, k, sym, order);
        Ok(Value::Series(result))
    } else {
        // Legacy: qbin(n, k, order)
        expect_args(name, args, 3)?;
        let n = extract_i64(name, args, 0)?;
        let k = extract_i64(name, args, 1)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::qbin(n, k, env.sym_q, order);
        Ok(Value::Series(result))
    }
}
```
NOTE on Garvan arg order: Garvan's `qbin(q, m, n)` has q first, then m (the "choose" parameter), then n (the total). Our Rust `qseries::qbin(n, k, sym, order)` takes n first, k second. So `qbin(q, m, n)` maps to `qseries::qbin(n, m, sym, POLYNOMIAL_ORDER)` -- note the reversal.

**etaq (line ~1212):**
Extend the existing Maple-style branch to also handle multi-delta lists. Currently it only handles `etaq(q, b, T)` when first arg is Symbol. Add a sub-branch for when second arg is `Value::List`:

```rust
"etaq" => {
    if args.len() >= 2 && matches!(&args[0], Value::Symbol(_)) {
        let sym = extract_symbol_id(name, args, 0, env)?;
        if args.len() == 3 && matches!(&args[1], Value::List(_)) {
            // Multi-delta: etaq(q, [d1, d2, ...], T)
            let deltas = extract_i64_list(name, args, 1)?;
            let order = extract_i64(name, args, 2)?;
            if deltas.is_empty() {
                return Err(EvalError::Generic {
                    message: format!("{}: delta list must not be empty", name),
                });
            }
            let mut result = FormalPowerSeries::one(sym, order);
            for d in &deltas {
                if *d <= 0 {
                    return Err(EvalError::Generic {
                        message: format!("{}: each delta must be positive, got {}", name, d),
                    });
                }
                let factor = qseries::etaq(*d, 1, sym, order);
                result = arithmetic::mul(&result, &factor);
            }
            Ok(Value::Series(result))
        } else {
            // Single delta: etaq(q, b, T)
            expect_args(name, args, 3)?;
            let b = extract_i64(name, args, 1)?;
            let order = extract_i64(name, args, 2)?;
            let result = qseries::etaq(b, 1, sym, order);
            Ok(Value::Series(result))
        }
    } else {
        // Legacy: etaq(b, t, order)
        expect_args(name, args, 3)?;
        let b = extract_i64(name, args, 0)?;
        let t = extract_i64(name, args, 1)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::etaq(b, t, env.sym_q, order);
        Ok(Value::Series(result))
    }
}
```
NOTE: `EvalError::Generic` must exist. Check if it does -- if not, use an appropriate variant. In Phase 33's code, errors used `EvalError::WrongArgCount` or `EvalError::ArgType`. If `Generic` doesn't exist, add it to the EvalError enum:
```rust
Generic { message: String },
```
And in the Display impl add:
```rust
EvalError::Generic { message } => write!(f, "{}", message),
```

Also update `get_signature`:
- `"qbin" => "(q, m, n) or (n, k, q, T) or (n, k, order)"`
- `"etaq" => "(q, delta, T) or (q, [deltas], T) or (b, t, order)"`

Add unit tests:
- `dispatch_qbin_garvan_3arg`: `qbin(Symbol("q"), 2, 4)` returns exact polynomial, verify coefficient of q^2 is nonzero
- `dispatch_qbin_4arg`: `qbin(4, 2, Symbol("q"), 10)` returns series
- `dispatch_qbin_legacy`: `qbin(4, 2, 20)` still works (existing test)
- `dispatch_etaq_multi_delta`: `etaq(Symbol("q"), [1, 2], 10)` returns series
- `dispatch_etaq_empty_list_errors`: `etaq(Symbol("q"), [], 10)` returns error
- `dispatch_etaq_negative_delta_errors`: `etaq(Symbol("q"), [-1], 10)` returns error
- `dispatch_etaq_single_delta_legacy`: `etaq(1, 1, 20)` still works (existing test)
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /cygdrive/c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- dispatch_qbin dispatch_etaq` and confirm all new tests pass.

Also run the full CLI test suite: `cargo test -p qsym-cli` to confirm zero regressions.
  </verify>
  <done>
qbin accepts Garvan's `qbin(q, m, n)` 3-arg form, extended `qbin(n, k, q, T)` 4-arg form, and legacy `qbin(n, k, order)`. etaq accepts `etaq(q, [deltas], T)` multi-delta list form, `etaq(q, b, T)` single delta, and legacy `etaq(b, t, order)`. All forms produce correct series. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
Run the full CLI test suite:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /cygdrive/c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
```
All tests pass (existing + new dispatch tests). No regressions.

Spot-check with -c flag:
```bash
./target/release/q-kangaroo -c "jacprod(1, 5, q, 10)"
./target/release/q-kangaroo -c "tripleprod(q^3, q, 10)"
./target/release/q-kangaroo -c "qbin(q, 2, 4)"
./target/release/q-kangaroo -c "etaq(q, [1,2], 10)"
```
All produce valid series output.
</verification>

<success_criteria>
1. jacprod(a, b, q, T) computes JAC(a,b)/JAC(b,3b) per Garvan's formula
2. tripleprod(z, q, T) and quinprod(z, q, T) accept 3-arg Maple form
3. winquist(a, b, q, T) accepts 4-arg Maple form
4. qbin(q, m, n) accepts Garvan's q-first 3-arg form with exact polynomial output
5. qbin(n, k, q, T) accepts 4-arg form with explicit variable and truncation
6. etaq(q, [d1,d2,...], T) computes product of individual etaq series
7. All legacy signatures continue to work unchanged
8. cargo test -p qsym-cli passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-product-theta-signatures/34-01-SUMMARY.md`
</output>
