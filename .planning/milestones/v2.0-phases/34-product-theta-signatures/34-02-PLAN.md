---
phase: 34-product-theta-signatures
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true

must_haves:
  truths:
    - "numbpart(100) returns 190569292"
    - "numbpart(n, m) returns bounded partition count"
    - "partition_count(100) still returns 190569292 (alias)"
    - "help(numbpart) shows Maple-style signature"
    - "help(partition_count) redirects to numbpart"
    - "help(jacprod) shows jacprod(a, b, q, T) as primary signature"
    - "All 7 product function help entries show Maple-style signatures only"
    - "Tab completion includes numbpart, not partition_count"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "numbpart as canonical name, partition_count as alias"
      contains: "\"numbpart\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated help entries for all product/partition functions"
      contains: "numbpart.*numbpart"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "Tab completion with numbpart canonical"
      contains: "\"numbpart\""
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "End-to-end tests for all Maple-style signatures"
      contains: "numbpart|jacprod.*q.*30|tripleprod.*q"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs resolve_alias"
      to: "dispatch numbpart"
      via: "partition_count -> numbpart alias direction"
      pattern: "partition_count.*numbpart"
    - from: "crates/qsym-cli/src/help.rs function_help"
      to: "partition_count redirect"
      via: "manual redirect check"
      pattern: "partition_count.*numbpart"
---

<objective>
Reverse the numbpart/partition_count alias direction (numbpart becomes canonical), add numbpart(n,m) 2-arg form, update all product/partition help text to show Maple-style signatures only, update tab completion, and add integration tests for all Phase 34 changes.

Purpose: Complete the Phase 34 requirements by making naming match Maple conventions and providing comprehensive help text and tests.
Output: Updated eval.rs, help.rs, repl.rs, cli_integration.rs with all alias/help/test changes.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-product-theta-signatures/34-RESEARCH.md
@.planning/phases/34-product-theta-signatures/34-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs (resolve_alias at ~2631, ALL_FUNCTION_NAMES at ~2659, ALL_ALIAS_NAMES at ~2705, get_signature at ~2539, partition_count dispatch at ~1287)
@crates/qsym-cli/src/help.rs (FUNC_HELP array and tests)
@crates/qsym-cli/src/repl.rs (canonical_function_names)
@crates/qsym-cli/tests/cli_integration.rs (test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reverse numbpart alias + add numbpart(n,m) + update eval.rs names</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Five changes in eval.rs:

**1. Rename dispatch match arm (line ~1287):**
Change `"partition_count"` match arm to `"numbpart"`. The code body is identical but add a 2-arg form:
```rust
"numbpart" => {
    if args.len() == 1 {
        // numbpart(n) -- count all partitions of n
        let n = extract_i64(name, args, 0)?;
        let result = qseries::partition_count(n);
        Ok(Value::Integer(QInt(result.0.numer().clone())))
    } else if args.len() == 2 {
        // numbpart(n, m) -- count partitions of n with max part <= m
        let n = extract_i64(name, args, 0)?;
        let m = extract_i64(name, args, 1)?;
        if m <= 0 {
            // 0 parts means only p(0,m)=1 when n=0
            if n == 0 {
                Ok(Value::Integer(QInt::from(1i64)))
            } else {
                Ok(Value::Integer(QInt::from(0i64)))
            }
        } else {
            // Use bounded_parts_gf(m, sym, n+1) and extract coefficient of q^n
            let gf = qseries::bounded_parts_gf(m, env.sym_q, n + 1);
            let coeff = gf.coeff(n);
            Ok(Value::Integer(QInt(coeff.0.numer().clone())))
        }
    } else {
        Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "1 or 2".to_string(),
            got: args.len(),
            signature: get_signature(name),
        })
    }
}
```

**2. Reverse resolve_alias (line ~2631):**
Change:
```rust
"numbpart" => "partition_count".to_string(),
```
To:
```rust
"partition_count" => "numbpart".to_string(),
```
This makes `partition_count` resolve to `numbpart` (the new canonical name).

**3. Update ALL_FUNCTION_NAMES (line ~2659):**
Replace `"partition_count"` with `"numbpart"` in the array (it appears around line 2666 under "Pattern B: No-session").

**4. Update ALL_ALIAS_NAMES (line ~2705):**
Replace `"numbpart"` with `"partition_count"` in the array. numbpart is no longer an alias -- partition_count is now the alias.

**5. Update get_signature (line ~2539):**
Change `"partition_count" => "(n)".to_string()` to:
```rust
"numbpart" => "(n) or (n, m)".to_string(),
```

**6. Update tests in eval.rs:**
- Change `resolve_alias_numbpart` test: assert `resolve_alias("partition_count") == "numbpart"`
- Change `resolve_alias_case_insensitive` test: assert `resolve_alias("PARTITION_COUNT") == "numbpart"` (and keep the QZeil test)
- Change `resolve_alias_all_maple_names` test: update the numbpart assertion to test partition_count -> numbpart direction
- Update any existing `dispatch("partition_count", ...)` test calls to use `"numbpart"` instead (or verify they still work via alias)
- Add `dispatch_numbpart_5` test: `numbpart(5)` returns 7
- Add `dispatch_numbpart_100` test: `numbpart(100)` returns 190569292
- Add `dispatch_numbpart_bounded` test: `numbpart(5, 3)` returns 5 (partitions of 5 with max part 3: 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1)
- Add `dispatch_partition_count_alias` test: `dispatch("partition_count", &[Value::Integer(5)], env)` returns 7 (verifies alias works)
- Update `function_count_verification` test if the count changes (it should remain the same since we renamed, not added)
- Update `general_help_no_maple_aliases` test: remove "numbpart" from the aliases list (it's now canonical), add "partition_count" as an alias that should NOT appear in general help

IMPORTANT: The `general_help_no_maple_aliases` test at help.rs line ~793 checks that "numbpart" does NOT appear in general help. After this change, numbpart SHOULD appear (it's canonical), so this test needs updating -- but that happens in help.rs task below.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /cygdrive/c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- dispatch_numbpart resolve_alias` and confirm new tests pass.
  </verify>
  <done>
numbpart is the canonical dispatch name. partition_count resolves to numbpart via alias. numbpart(n) and numbpart(n,m) both work. All existing tests updated and passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update help text, tab completion, and add integration tests</name>
  <files>crates/qsym-cli/src/help.rs, crates/qsym-cli/src/repl.rs, crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
Three files to update:

**help.rs -- Update FUNC_HELP entries and general_help:**

1. In `general_help()` function (line ~13), update the Partitions section:
   Change `partition_count    - number of partitions p(n)` to `numbpart        - number of partitions p(n) or p(n,m)`

2. In `FUNC_HELP` array, update ALL product function entries (per locked decision: help shows Maple-style signatures ONLY):

```rust
FuncHelp {
    name: "aqprod",
    signature: "aqprod(a, q, n)",
    description: "Compute the q-Pochhammer product (a;q)_n where a is a q-monomial, q is the variable, and n is a non-negative integer.\n  When n is 'infinity', use aqprod(a, q, infinity, T) with explicit truncation T.",
    example: "q> aqprod(q^2, q, 5)",
    example_output: "1 - q^2 - q^3 + q^5 + q^8 - q^12 - q^14",
},
FuncHelp {
    name: "qbin",
    signature: "qbin(q, m, n)",
    description: "Compute the q-binomial coefficient (Gaussian binomial) [n choose m]_q.\n  Returns an exact polynomial in q of degree m*(n-m).",
    example: "q> qbin(q, 2, 4)",
    example_output: "1 + q + 2*q^2 + q^3 + q^4",
},
FuncHelp {
    name: "etaq",
    signature: "etaq(q, delta, T)",
    description: "Compute the Dedekind eta quotient (q^delta; q^delta)_inf truncated to O(q^T).\n  Also accepts a list of deltas: etaq(q, [d1, d2, ...], T) computes the product of individual eta quotients.",
    example: "q> etaq(q, 1, 10)",
    example_output: "1 - q - q^2 + q^5 + q^7 + O(q^10)",
},
FuncHelp {
    name: "jacprod",
    signature: "jacprod(a, b, q, T)",
    description: "Compute the Jacobi product JAC(a,b)/JAC(b,3b) truncated to O(q^T).\n  Parameters: a, b are positive integers, q is the variable, T is truncation order.",
    example: "q> jacprod(1, 5, q, 20)",
    example_output: "1 + q + q^2 + q^3 + q^4 - q^7 - q^8 + ... + O(q^20)",
},
FuncHelp {
    name: "tripleprod",
    signature: "tripleprod(z, q, T)",
    description: "Compute the Jacobi triple product (z;q)_inf * (q/z;q)_inf * (q;q)_inf truncated to O(q^T).\n  The first argument z is a q-monomial (like q^3 or -q^2).",
    example: "q> tripleprod(q, q, 20)",
    example_output: "1 - 2*q + 2*q^4 - 2*q^9 + 2*q^16 + O(q^20)",
},
FuncHelp {
    name: "quinprod",
    signature: "quinprod(z, q, T)",
    description: "Compute the quintuple product expansion truncated to O(q^T).\n  The first argument z is a q-monomial.",
    example: "q> quinprod(q, q, 20)",
    example_output: "1 - q - q^2 + q^5 + q^7 + O(q^20)",
},
FuncHelp {
    name: "winquist",
    signature: "winquist(a, b, q, T)",
    description: "Compute the Winquist product with q-monomial parameters a, b truncated to O(q^T).\n  A product of 10 theta-type factors used in partition congruence proofs.",
    example: "q> winquist(q, q^2, q, 10)",
    example_output: "(series in q truncated to order 10)",
},
```

3. Replace the `partition_count` entry with `numbpart`:
```rust
FuncHelp {
    name: "numbpart",
    signature: "numbpart(n) or numbpart(n, m)",
    description: "Compute the number of partitions p(n). With two arguments, compute the number of partitions of n with largest part at most m.",
    example: "q> numbpart(100)",
    example_output: "190569292",
},
```

4. Add a redirect in `function_help()` for partition_count:
After the existing `FUNC_HELP.iter().find(...)` line, add:
```rust
pub fn function_help(name: &str) -> Option<String> {
    // Redirect partition_count to numbpart
    let lookup = if name == "partition_count" { "numbpart" } else { name };
    FUNC_HELP.iter().find(|h| h.name == lookup).map(|h| {
        format!(
            "{}\n\n  {}\n\n  Example:\n    {}\n    {}",
            h.signature, h.description, h.example, h.example_output
        )
    })
}
```

5. Update help.rs tests:
- `general_help_no_maple_aliases`: Remove "numbpart" from the aliases list (it's now canonical). Add "partition_count" to the list if it shouldn't appear in general help.
- `function_help_maple_alias_returns_none`: Remove the `numbpart` assertion (it now has help). The test should still assert `qphihyper` and `qgosper` return None.
- `every_canonical_function_has_help_entry`: Replace `"partition_count"` with `"numbpart"` in the canonical list.
- `func_help_count_matches_canonical`: Count stays at 81 (renamed, not added).
- Add new test `function_help_partition_count_redirects_to_numbpart`: assert `function_help("partition_count").is_some()` and the result contains "numbpart".

**repl.rs -- Update tab completion:**

1. In `canonical_function_names()` (line ~54), replace `"partition_count"` with `"numbpart"` in Group 2.

2. Update tests:
- `canonical_function_count`: Count stays at 83 (renamed, not added).
- `complete_no_maple_aliases`: Change the assertion from checking "numbpart" to checking "partition_count":
  ```rust
  let (_, pairs) = h.complete_inner("part", 4);
  let displays: Vec<&str> = pairs.iter().map(|p| p.0.as_str()).collect();
  assert!(!displays.contains(&"partition_count"), "alias partition_count should not appear");
  ```
  And add a positive test that "numb" completes to "numbpart".

**cli_integration.rs -- Add end-to-end integration tests:**

Add tests in a new section at the end of the file:

```rust
// ===========================================================================
// Phase 34: Product & Theta Signatures -- Maple-style dispatch
// ===========================================================================

#[test]
fn maple_jacprod_4arg() {
    let (code, stdout, _) = run(&["-c", "jacprod(1, 5, q, 20)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("q"), "jacprod(1,5,q,20) should produce series in q");
    assert!(stdout.contains("O(q^20)"), "should have truncation");
}

#[test]
fn maple_tripleprod_3arg() {
    let (code, stdout, _) = run(&["-c", "tripleprod(q, q, 10)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^10)"), "should have truncation at 10");
}

#[test]
fn maple_quinprod_3arg() {
    let (code, stdout, _) = run(&["-c", "quinprod(q, q, 10)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^10)"), "should have truncation");
}

#[test]
fn maple_winquist_4arg() {
    let (code, stdout, _) = run(&["-c", "winquist(q, q^2, q, 10)"]);
    assert_eq!(code, 0);
    // winquist should produce a series
}

#[test]
fn maple_qbin_garvan_3arg() {
    let (code, stdout, _) = run(&["-c", "qbin(q, 2, 4)"]);
    assert_eq!(code, 0);
    // qbin(q,2,4) = [4 choose 2]_q = 1 + q + 2*q^2 + q^3 + q^4
    assert!(stdout.contains("1 + q + 2*q^2 + q^3 + q^4"), "exact polynomial expected");
    assert!(!stdout.contains("O(q^"), "exact polynomial should not have O() truncation");
}

#[test]
fn maple_qbin_4arg_with_truncation() {
    let (code, stdout, _) = run(&["-c", "qbin(4, 2, q, 10)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("q"), "should contain series terms");
}

#[test]
fn maple_etaq_multi_delta() {
    let (code, stdout, _) = run(&["-c", "etaq(q, [1, 2], 10)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^10)"), "should have truncation");
}

#[test]
fn maple_etaq_single_delta() {
    let (code, stdout, _) = run(&["-c", "etaq(q, 3, 10)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^10)"), "should have truncation");
}

#[test]
fn numbpart_primary_name() {
    let (code, stdout, _) = run(&["-c", "numbpart(100)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("190569292"), "numbpart(100) = 190569292");
}

#[test]
fn numbpart_small() {
    let (code, stdout, _) = run(&["-c", "numbpart(5)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("7"), "numbpart(5) = 7");
}

#[test]
fn numbpart_bounded() {
    let (code, stdout, _) = run(&["-c", "numbpart(5, 3)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("5"), "numbpart(5, 3) = 5");
}

#[test]
fn partition_count_alias_still_works() {
    let (code, stdout, _) = run(&["-c", "partition_count(100)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("190569292"), "partition_count alias should still work");
}

#[test]
fn legacy_jacprod_3arg_still_works() {
    let (code, stdout, _) = run(&["-c", "jacprod(1, 5, 20)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^20)"), "legacy jacprod should still work");
}

#[test]
fn legacy_tripleprod_4arg_still_works() {
    let (code, stdout, _) = run(&["-c", "tripleprod(1, 1, 1, 20)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^20)"), "legacy tripleprod should still work");
}

#[test]
fn legacy_qbin_3arg_still_works() {
    let (code, stdout, _) = run(&["-c", "qbin(4, 2, 20)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("q"), "legacy qbin should still work");
}

#[test]
fn legacy_etaq_3arg_still_works() {
    let (code, stdout, _) = run(&["-c", "etaq(1, 1, 20)"]);
    assert_eq!(code, 0);
    assert!(stdout.contains("O(q^20)"), "legacy etaq should still work");
}
```

Also add a piped-mode help test:
```rust
#[test]
fn help_numbpart_shows_maple_signature() {
    let (code, stdout, _) = run_piped("help(numbpart)\n");
    assert_eq!(code, 0);
    assert!(stdout.contains("numbpart"), "help should show numbpart");
    assert!(stdout.contains("partitions"), "help should describe partitions");
}

#[test]
fn help_partition_count_redirects() {
    let (code, stdout, _) = run_piped("help(partition_count)\n");
    assert_eq!(code, 0);
    assert!(stdout.contains("numbpart"), "help(partition_count) should redirect to numbpart");
}
```
  </action>
  <verify>
Run the full test suite across all modified crates:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /cygdrive/c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
```
All tests pass including new integration tests. Zero regressions.

Specifically verify:
- `cargo test -p qsym-cli -- maple_` passes all Maple-style integration tests
- `cargo test -p qsym-cli -- numbpart` passes all numbpart tests
- `cargo test -p qsym-cli -- legacy_` passes all legacy backward-compat tests
- `cargo test -p qsym-cli -- help` passes all help tests
  </verify>
  <done>
numbpart is the primary name with partition_count as alias. help(numbpart) shows Maple signatures. help(partition_count) redirects to numbpart. All 7 product function help entries show Maple-style signatures only. Tab completion includes numbpart. All integration tests verify Maple-style and legacy forms work end-to-end.
  </done>
</task>

</tasks>

<verification>
Run the complete test suite:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /cygdrive/c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli
```

Verify all Phase 34 success criteria:
1. `./target/release/q-kangaroo -c "aqprod(q^2, q, 5)"` -- correct polynomial
2. `./target/release/q-kangaroo -c "etaq(q, 3, 20)"` -- correct eta series
3. `./target/release/q-kangaroo -c "jacprod(1, 5, q, 30)"` -- JAC(1,5)/JAC(5,15)
4. `./target/release/q-kangaroo -c "qbin(q, 2, 4)"` -- exact polynomial [4 choose 2]_q
5. `./target/release/q-kangaroo -c "numbpart(100)"` -- 190569292
6. `./target/release/q-kangaroo -c "tripleprod(q^3, q, 20)"` -- triple product
7. `./target/release/q-kangaroo -c "quinprod(q^2, q, 20)"` -- quintuple product
8. `./target/release/q-kangaroo -c "winquist(q, q^2, q, 10)"` -- Winquist product
</verification>

<success_criteria>
1. numbpart(100) returns 190569292
2. numbpart(5, 3) returns 5 (bounded partitions)
3. partition_count(n) still works as alias
4. help(numbpart) shows Maple-style signature
5. help(partition_count) redirects to numbpart
6. All 7 product function help entries show Maple signatures only
7. Tab completion includes "numbpart" (not "partition_count")
8. All integration tests pass: Maple-style forms, legacy forms, numbpart, help
9. cargo test -p qsym-cli passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-product-theta-signatures/34-02-SUMMARY.md`
</output>
