---
phase: 36-relation-discovery-signatures
plan: 03
type: execute
wave: 3
depends_on: ["36-02"]
files_modified:
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements:
  - SIG-15
  - SIG-16
  - SIG-17
  - SIG-18
  - SIG-19
  - SIG-20
  - SIG-21
  - SIG-22
  - SIG-23
  - SIG-24
  - SIG-25
  - OUT-01
  - OUT-02

must_haves:
  truths:
    - "help(findlincombo) shows the new 5-arg Garvan signature with SL parameter"
    - "help(findcong) shows the new (QS, T, [LM], [XSET]) signature"
    - "All 12 help entries match Garvan's actual calling conventions"
    - "Integration tests verify end-to-end behavior through the actual binary"
    - "Old-signature error tests confirm clean error messages for wrong arg counts"
  artifacts:
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated help entries for all 12 relation discovery functions"
      contains: "findlincombo(f, L, SL, q, topshift)"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Integration tests for Maple-compatible relation discovery dispatch"
      contains: "findlincombo"
  key_links:
    - from: "crates/qsym-cli/src/help.rs"
      to: "crates/qsym-cli/src/eval.rs"
      via: "signature strings must match dispatch expectations"
      pattern: "findlincombo"
    - from: "crates/qsym-cli/tests/cli_integration.rs"
      to: "target/debug/q-kangaroo or release binary"
      via: "subprocess execution with -c flag"
      pattern: "run\\("
---

<objective>
Update help text for all relation discovery functions to reflect Garvan's actual signatures, and add CLI integration tests verifying end-to-end behavior.

Purpose: Researchers using help(function_name) see the correct Maple-compatible calling conventions. Integration tests catch regressions in the full pipeline from parsing through evaluation to output formatting.

Output: Updated help.rs with 12 corrected help entries; new integration tests in cli_integration.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-relation-discovery-signatures/36-RESEARCH.md
@.planning/phases/36-relation-discovery-signatures/36-02-SUMMARY.md
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/tests/cli_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update help text for all 12 relation discovery functions</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
Update each help entry in the HELP_ENTRIES array. Follow the two-line example format established in Phase 35 (assign then call). Use Garvan's actual verified signatures from 36-RESEARCH.md.

Also update the category listing (~lines 54-65) to reflect new signatures.

1. **findlincombo** (was: `(target, [candidates], topshift)`)
   ```
   name: "findlincombo",
   signature: "findlincombo(f, L, SL, q, topshift)",
   description: "Find f as a linear combination of basis series L, printing result using symbolic labels SL",
   example: "q> f := partition_gf(30)\nq> findlincombo(f, [distinct_parts_gf(30), odd_parts_gf(30)], [D, O], q, 0)",
   ```

2. **findhomcombo** (was: `(target, [candidates], degree, topshift)`)
   ```
   name: "findhomcombo",
   signature: "findhomcombo(f, L, q, n, topshift)",
   description: "Express f as a degree-n homogeneous polynomial in basis series L (uses X[i] labels)",
   example: "q> f := partition_gf(30)\nq> findhomcombo(f, [etaq(1, 1, 30), etaq(2, 1, 30)], q, 2, 0)",
   ```

3. **findnonhomcombo** (was: `(target, [candidates], degree, topshift)`)
   ```
   name: "findnonhomcombo",
   signature: "findnonhomcombo(f, L, q, n, topshift)",
   description: "Express f as a degree-<=n polynomial in basis series L (uses X[i] labels)",
   example: "q> f := partition_gf(30)\nq> findnonhomcombo(f, [etaq(1, 1, 30), etaq(2, 1, 30)], q, 2, 0)",
   ```

4. **findlincombomodp** (was: `(target, [candidates], p, topshift)`)
   ```
   name: "findlincombomodp",
   signature: "findlincombomodp(f, L, SL, p, q, topshift)",
   description: "Find f as a linear combination of L mod prime p, using symbolic labels SL. Note: p before q",
   example: "q> f := partition_gf(30)\nq> findlincombomodp(f, [distinct_parts_gf(30)], [D], 7, q, 0)",
   ```

5. **findhomcombomodp** (was: `(target, [candidates], p, degree, topshift)`)
   ```
   name: "findhomcombomodp",
   signature: "findhomcombomodp(f, L, p, q, n, topshift)",
   description: "Express f as degree-n homogeneous polynomial in L, mod prime p (uses X[i] labels). Note: p before q",
   example: "q> f := partition_gf(30)\nq> findhomcombomodp(f, [etaq(1, 1, 30)], 5, q, 2, 0)",
   ```

6. **findhom** (was: `([series], degree, topshift)`)
   ```
   name: "findhom",
   signature: "findhom(L, q, n, topshift)",
   description: "Find all degree-n homogeneous polynomial relations among series in L (uses X[i] labels)",
   example: "q> e1 := etaq(1, 1, 50)\nq> findhom([theta3(50)^2, theta2(50)^2, theta4(50)^2], q, 1, 0)",
   ```

7. **findnonhom** (was: `([series], degree, topshift)`)
   ```
   name: "findnonhom",
   signature: "findnonhom(L, q, n, topshift)",
   description: "Find all degree-<=n polynomial relations among series in L (uses X[i] labels)",
   example: "q> findnonhom([theta3(50)^2, theta2(50)^2, theta4(50)^2], q, 2, 0)",
   ```

8. **findhommodp** (was: `([series], p, degree, topshift)`)
   ```
   name: "findhommodp",
   signature: "findhommodp(L, p, q, n, topshift)",
   description: "Find degree-n homogeneous relations mod prime p (uses X[i] labels). Note: p before q",
   example: "q> findhommodp([etaq(1, 1, 30), etaq(2, 1, 30)], 7, q, 2, 0)",
   ```

9. **findmaxind** (was: `([series], topshift)`)
   ```
   name: "findmaxind",
   signature: "findmaxind(L, T)",
   description: "Find maximally linearly independent subset of series L, using T extra rows",
   example: "q> findmaxind([etaq(1, 1, 20), etaq(2, 1, 20), etaq(1, 1, 20)], 0)",
   ```

10. **findcong** (was: `(series, [moduli])`)
    ```
    name: "findcong",
    signature: "findcong(QS, T) or findcong(QS, T, LM) or findcong(QS, T, LM, XSET)",
    description: "Auto-discover congruences in series QS up to T terms. Scans moduli 2..LM (default floor(sqrt(T))). Output: [B, A, R] triples",
    example: "q> p := partition_gf(200)\nq> findcong(p, 200)",
    ```

11. **findpoly** (was: `(x, y, deg_x, deg_y, topshift)`)
    ```
    name: "findpoly",
    signature: "findpoly(x, y, q, dx, dy) or findpoly(x, y, q, dx, dy, check)",
    description: "Find polynomial P(X,Y)=0 with deg(X)<=dx, deg(Y)<=dy. Optional check: verify to O(q^check)",
    example: "q> x := theta3(50)^4\nq> findpoly(x, theta2(50)^4, q, 2, 2)",
    ```

12. **findprod** -- keep UNCHANGED (not part of Phase 36 scope, but verify it still shows correctly).

Ensure the category listing (around lines 54-65) is updated to match the new signatures in the brief summary.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib -- help 2>&1 | tail -10`
All help-related tests pass.
  </verify>
  <done>
All 11 help entries updated to show Garvan's actual calling conventions. findlincombo and findlincombomodp show SL parameter. Modp functions show p before q. findcong shows the auto-scan overloaded forms. findmaxind shows 2-arg (L, T). findpoly shows optional check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI integration tests for relation discovery functions</name>
  <files>crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
Add integration tests at the end of cli_integration.rs using the established `run` and `write_temp_script` helpers. Each test runs the actual q-kangaroo binary with `-c` flag or via temp script.

Tests to add (target ~12 tests):

1. **test_findlincombo_maple_style**: Write a script that assigns two series and calls findlincombo with SL labels.
   ```
   f := partition_gf(30)
   g := distinct_parts_gf(30)
   findlincombo(f, [f, g], [F1, F2], q, 0)
   ```
   Assert exit code 0, stdout contains "F1" (since f = 1*f + 0*g, output should contain "F1" or "1*F1").

2. **test_findlincombo_not_found**: Test a case where no linear combo exists.
   ```
   f := partition_gf(20)
   g := etaq(1, 1, 20)
   h := etaq(2, 1, 20)
   findlincombo(g, [h], [H], q, 0)
   ```
   Assert exit code 0, stdout contains "NOT A LINEAR COMBO".

3. **test_findlincombo_duplicate_sl_error**: Call with duplicate labels [F, F].
   Assert exit code non-zero (EX_DATAERR=65), stderr contains "duplicate label".

4. **test_findlincombomodp_maple_style**: Test findlincombomodp with SL, p before q.
   ```
   f := partition_gf(30)
   findlincombomodp(f, [f], [F], 7, q, 0)
   ```
   Assert exit code 0, stdout contains "F".

5. **test_findlincombomodp_non_prime_error**: Call with p=4. Assert exit code non-zero, stderr contains "not prime".

6. **test_findhom_maple_style**: Test findhom with q parameter.
   ```
   e1 := etaq(1, 1, 50)
   findhom([theta3(50)^2, theta2(50)^2, theta4(50)^2], q, 1, 0)
   ```
   Assert exit code 0, stdout contains "X[" (polynomial expression with X[i] labels).

7. **test_findhommodp_p_before_q**: Test findhommodp with p before q.
   ```
   e1 := etaq(1, 1, 30)
   e2 := etaq(2, 1, 30)
   findhommodp([e1, e2], 7, q, 2, 0)
   ```
   Assert exit code 0.

8. **test_findmaxind_two_args**: Test findmaxind(L, T) with 2 args.
   ```
   e1 := etaq(1, 1, 20)
   e2 := etaq(2, 1, 20)
   findmaxind([e1, e2], 0)
   ```
   Assert exit code 0, stdout contains result (should be [1, 2] or similar).

9. **test_findpoly_maple_style**: Test findpoly with q parameter.
   ```
   x := theta3(50)^4
   y := theta2(50)^4
   findpoly(x, y, q, 2, 2)
   ```
   Assert exit code 0. May find or not find a relation depending on series -- just verify no crash.

10. **test_findcong_garvan_auto_scan**: Test findcong with 2-arg Garvan form.
    ```
    p := partition_gf(200)
    findcong(p, 200)
    ```
    Assert exit code 0, stdout contains "[4, 5, 5]" (Ramanujan's p(5n+4) = 0 mod 5).

11. **test_findcong_with_lm**: Test findcong with 3-arg (QS, T, LM).
    ```
    p := partition_gf(200)
    findcong(p, 200, 5)
    ```
    Assert exit code 0, stdout contains "[4, 5, 5]" but does NOT contain modulus 7 results (since LM=5 limits scan).

12. **test_findcong_old_signature_error**: Test that old (series, [moduli]) signature fails.
    ```
    p := partition_gf(50)
    findcong(p, [5, 7])
    ```
    Assert exit code non-zero (list is not integer for arg 2), stderr contains error.

13. **test_findlincombo_old_signature_error**: Test old 3-arg signature fails.
    ```
    f := partition_gf(20)
    findlincombo(f, [f], 0)
    ```
    Assert exit code non-zero, stderr contains "expects 5 arguments" or similar.

Use `write_temp_script` for multi-line scripts, `run(&["-c", "..."])` for single expressions.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --test cli_integration 2>&1 | tail -30`
All new integration tests pass. All existing integration tests still pass.
  </verify>
  <done>
~13 new integration tests pass covering:
- findlincombo with SL labels (success + not found + duplicate label error)
- findlincombomodp with p before q (success + non-prime error)
- findhom with q parameter
- findhommodp with p before q
- findmaxind with 2 args
- findpoly with q parameter
- findcong auto-scan (2-arg and 3-arg)
- Old-signature error tests for findlincombo and findcong
All existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p qsym-cli` passes all tests (unit + integration)
- help(findlincombo) shows "(f, L, SL, q, topshift)" signature
- help(findcong) shows "(QS, T) or (QS, T, LM) or (QS, T, LM, XSET)" signature
- Integration tests verify actual binary behavior end-to-end
- Old signatures produce clean error messages
</verification>

<success_criteria>
- All 11 help entries reflect Garvan's actual calling conventions
- ~13 integration tests pass covering all function groups
- Old-signature error tests confirm clean WrongArgCount messages
- findcong integration test finds Ramanujan's p(5n+4) = 0 mod 5
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/36-relation-discovery-signatures/36-03-SUMMARY.md`
</output>
