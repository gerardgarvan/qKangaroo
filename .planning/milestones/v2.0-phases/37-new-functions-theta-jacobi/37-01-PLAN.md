---
phase: 37-new-functions-theta-jacobi
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
requirements: [NEW-01, NEW-02, NEW-03]
autonomous: true
must_haves:
  truths:
    - "JAC(1,5) returns a JacobiProduct value representing (q;q^5)_inf"
    - "JAC(1,5) * JAC(2,5) returns a combined JacobiProduct with two factors"
    - "JAC(1,5) / JAC(2,5) returns a JacobiProduct with positive and negative exponents"
    - "JAC(1,5)^3 returns a JacobiProduct with exponent 3"
    - "JAC(1,5) + JAC(2,5) returns a TypeError telling user to use jac2series()"
    - "x := JAC(1,5) stores a JacobiProduct and x retrieves it"
    - "JAC(0,5) is allowed at symbolic level (degenerate, jac2series will give zero)"
    - "JAC(1,-1) errors: b must be a positive integer"
    - "Printing JAC(1,5)*JAC(2,5)^(-1) displays that exact notation"
    - "theta(1, q, 10) returns a series with sum(1^i * q^(i^2)) = sum(q^(i^2))"
    - "theta(q^2, q, 5) returns a univariate q-series via monomial substitution"
    - "theta(z, q, 10) where z is undefined prints a warning and returns NONE"
    - "jac2prod(JAC(1,5), q, 20) prints product notation and returns an FPS"
    - "jac2series(JAC(1,5)*JAC(4,5), q, 20) prints a series and returns an FPS"
    - "jac2prod(etaq(q,1,20), q, 20) errors: expected Jacobi product expression"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::JacobiProduct variant, normalize_jacobi_product, JAC dispatch, JP arithmetic in eval_mul/div/pow, JP TypeError in eval_add/sub, theta dispatch, jac2prod dispatch, jac2series dispatch, jacobi_product_to_fps helper"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_value and format_latex match arms for JacobiProduct"
  key_links:
    - from: "eval.rs JAC dispatch"
      to: "Value::JacobiProduct"
      via: "returns JacobiProduct(vec![(a, b, 1)])"
      pattern: "JacobiProduct\\(vec"
    - from: "eval.rs eval_mul"
      to: "normalize_jacobi_product"
      via: "JP*JP combines and normalizes factors"
      pattern: "normalize_jacobi_product"
    - from: "eval.rs jac2prod/jac2series"
      to: "qseries::etaq"
      via: "jacobi_product_to_fps expands each factor via etaq(a, b, sym, order)"
      pattern: "etaq\\("
    - from: "eval.rs theta"
      to: "FormalPowerSeries::zero + set_coeff"
      via: "direct summation loop building FPS term by term"
      pattern: "set_coeff"
    - from: "format.rs format_value"
      to: "Value::JacobiProduct"
      via: "new match arm for display"
      pattern: "JacobiProduct"
---

<objective>
Add the Value::JacobiProduct type with full arithmetic support, the JAC(a,b) constructor, JacobiProduct formatting, and implement theta/jac2prod/jac2series dispatch functions.

Purpose: Establishes the JacobiProduct first-class value type and the three functions that create or consume it (theta is independent but groups naturally). This is the foundation for qs2jaccombo in Plan 02.

Output: JacobiProduct values can be created, combined, displayed, and converted to series. theta() produces theta series.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-new-functions-theta-jacobi/37-CONTEXT.md
@.planning/phases/37-new-functions-theta-jacobi/37-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: JacobiProduct value type, JAC constructor, arithmetic, and formatting</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/src/format.rs</files>
  <action>
Add Value::JacobiProduct variant and all supporting infrastructure:

**1. Value::JacobiProduct variant (eval.rs)**

Add to the Value enum after Symbol:
```rust
/// Jacobi product expression: product of (q^a;q^b)_inf^exp factors.
/// Each triple is (a, b, exponent). Maintained in canonical form.
JacobiProduct(Vec<(i64, i64, i64)>),
```

Add to type_name(): `Value::JacobiProduct(_) => "jacobi_product"`

**2. normalize_jacobi_product helper (eval.rs)**

Add a free function (near the series_pow helper, around line 1365):
```rust
fn normalize_jacobi_product(mut factors: Vec<(i64, i64, i64)>) -> Vec<(i64, i64, i64)> {
    factors.sort_by_key(|&(a, b, _)| (b, a));
    let mut merged: Vec<(i64, i64, i64)> = Vec::new();
    for (a, b, exp) in factors {
        if let Some(last) = merged.last_mut() {
            if last.0 == a && last.1 == b {
                last.2 += exp;
                continue;
            }
        }
        merged.push((a, b, exp));
    }
    merged.retain(|&(_, _, exp)| exp != 0);
    merged
}
```

**3. JAC(a,b) constructor dispatch (eval.rs)**

Add in the dispatch() function, in a new Group section (after Group 10 Variable Management, before the `_` fallthrough):
```
// =================================================================
// Group 11: Jacobi Product Constructor (NEW-01/02/03)
// =================================================================

"jac" | "JAC" => {
    expect_args(name, args, 2)?;
    let a = extract_i64(name, args, 0)?;
    let b = extract_i64(name, args, 1)?;
    if b <= 0 {
        return Err(EvalError::Other(format!(
            "JAC: second argument (b) must be a positive integer, got {}", b
        )));
    }
    Ok(Value::JacobiProduct(vec![(a, b, 1)]))
}
```

**4. JacobiProduct arithmetic in eval_mul, eval_div, eval_pow (eval.rs)**

In eval_mul, add BEFORE the `_ => Err(TypeError)` catchall:
```rust
// JacobiProduct * JacobiProduct
(Value::JacobiProduct(a), Value::JacobiProduct(b)) => {
    let mut combined = a.clone();
    combined.extend_from_slice(b);
    Ok(Value::JacobiProduct(normalize_jacobi_product(combined)))
}
```

In eval_div, add BEFORE the `_ => Err(TypeError)` catchall:
```rust
// JacobiProduct / JacobiProduct
(Value::JacobiProduct(a), Value::JacobiProduct(b)) => {
    let mut combined = a.clone();
    for &(av, bv, exp) in b {
        combined.push((av, bv, -exp));
    }
    Ok(Value::JacobiProduct(normalize_jacobi_product(combined)))
}
```

In eval_pow, add BEFORE the `_ => Err(TypeError)` catchall:
```rust
// JacobiProduct ^ Integer
(Value::JacobiProduct(factors), Value::Integer(n)) => {
    let exp = n.0.to_i64().ok_or_else(|| EvalError::Other(
        "exponent too large".to_string(),
    ))?;
    let scaled: Vec<_> = factors.iter().map(|&(a, b, e)| (a, b, e * exp)).collect();
    Ok(Value::JacobiProduct(normalize_jacobi_product(scaled)))
}
```

In eval_add and eval_sub, add BEFORE the `_ => Err(TypeError)` catchall:
```rust
// JacobiProduct in add/sub -> TypeError with helpful message
(Value::JacobiProduct(_), _) | (_, Value::JacobiProduct(_)) => {
    Err(EvalError::TypeError {
        operation: "+".to_string(),  // or "-" for eval_sub
        left: left.type_name().to_string(),
        right: right.type_name().to_string(),
    })
}
```
(Note: the existing TypeError message already shows "cannot + jacobi_product and ..." from the format in EvalError display. If the display uses a different format, just use the standard pattern -- the type names will appear. For a more helpful message, alternatively use EvalError::Other with "cannot add jacobi_product and series -- use jac2series() to expand first". Use the EvalError::Other approach for better UX.)

**5. format_value and format_latex for JacobiProduct (format.rs)**

In format_value, add before the closing brace of the match, after Value::Symbol:
```rust
Value::JacobiProduct(factors) => format_jacobi_product(factors),
```

In format_latex, add similarly:
```rust
Value::JacobiProduct(factors) => format_jacobi_product_latex(factors),
```

Add helper functions in format.rs:
```rust
/// Format a JacobiProduct value as human-readable string.
/// Examples: "JAC(1,5)", "JAC(1,5)*JAC(2,5)", "JAC(1,5)^(-1)", "1" (empty product)
fn format_jacobi_product(factors: &[(i64, i64, i64)]) -> String {
    if factors.is_empty() {
        return "1".to_string();
    }
    let parts: Vec<String> = factors.iter().map(|&(a, b, exp)| {
        if exp == 1 {
            format!("JAC({},{})", a, b)
        } else {
            format!("JAC({},{})^({})", a, b, exp)
        }
    }).collect();
    parts.join("*")
}

/// Format a JacobiProduct value as LaTeX.
/// Uses (q^a;q^b)_\infty notation.
fn format_jacobi_product_latex(factors: &[(i64, i64, i64)]) -> String {
    if factors.is_empty() {
        return "1".to_string();
    }
    let parts: Vec<String> = factors.iter().map(|&(a, b, exp)| {
        let base = format!("(q^{{{}}};q^{{{}}})_{{\\infty}}", a, b);
        if exp == 1 {
            base
        } else {
            format!("{}^{{{}}}", base, exp)
        }
    }).collect();
    parts.join(" \\cdot ")
}
```

**6. get_signature entry (eval.rs)**

Add to get_signature:
```rust
"jac" | "JAC" => "(a, b) -- Jacobi product factor (q^a;q^b)_inf".to_string(),
```

**7. ALL_FUNCTION_NAMES entry (eval.rs)**

Add "JAC" to ALL_FUNCTION_NAMES array in the appropriate location (create a new comment section "// Pattern O: Jacobi Products" or add to existing).

**8. Unit tests (eval.rs)**

Add tests at the end of the test module:
- `dispatch_jac_returns_jacobi_product`: `JAC(1,5)` returns `JacobiProduct([(1,5,1)])`
- `dispatch_jac_negative_b_errors`: `JAC(1,-3)` returns error about positive b
- `dispatch_jac_zero_b_errors`: `JAC(1,0)` returns error
- `eval_mul_jacobi_products`: `JAC(1,5) * JAC(2,5)` gives 2-factor product
- `eval_div_jacobi_products`: `JAC(1,5) / JAC(2,5)` gives factor with exp -1
- `eval_pow_jacobi_product`: `JAC(1,5)^3` gives exp 3
- `eval_pow_jacobi_product_negative`: `JAC(1,5)^(-2)` gives exp -2
- `eval_add_jacobi_product_errors`: `JAC(1,5) + JAC(2,5)` returns error
- `normalize_merges_same_factors`: `JAC(1,5) * JAC(1,5)` gives single factor with exp 2
- `normalize_removes_zero_exp`: `JAC(1,5) / JAC(1,5)` gives empty product

**9. Format tests (format.rs)**

Add tests:
- `format_jacobi_product_single`: `[(1,5,1)]` -> "JAC(1,5)"
- `format_jacobi_product_multiple`: `[(1,5,1),(2,5,1)]` -> "JAC(1,5)*JAC(2,5)"
- `format_jacobi_product_negative_exp`: `[(1,5,-1)]` -> "JAC(1,5)^(-1)"
- `format_jacobi_product_empty`: `[]` -> "1"
- `format_jacobi_product_latex_single`: uses (q^a;q^b)_infty notation
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all existing + new tests pass.

Specifically verify:
- `cargo test -p qsym-cli dispatch_jac` passes
- `cargo test -p qsym-cli eval_mul_jacobi` passes
- `cargo test -p qsym-cli format_jacobi` passes
  </verify>
  <done>
Value::JacobiProduct is a first-class CLI value: JAC(a,b) creates it, *, /, ^ combine them, +/- give helpful error, display shows JAC notation, LaTeX shows (q^a;q^b)_inf notation. All existing tests still pass (no regressions from adding the new variant to match arms).
  </done>
</task>

<task type="auto">
  <name>Task 2: theta, jac2prod, jac2series dispatch functions</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add three new function dispatches and their helper. All go in eval.rs dispatch() function in a new Group section:

**1. jacobi_product_to_fps helper (eval.rs)**

Add a helper function (near series_pow and normalize_jacobi_product):
```rust
/// Expand a JacobiProduct to a FormalPowerSeries by computing each factor
/// via etaq(a, b, sym, order) and combining with mul/invert.
fn jacobi_product_to_fps(
    factors: &[(i64, i64, i64)],
    sym: SymbolId,
    order: i64,
) -> FormalPowerSeries {
    let mut result = FormalPowerSeries::one(sym, order);
    for &(a, b, exp) in factors {
        let factor_fps = qseries::etaq(a, b, sym, order);
        if exp > 0 {
            for _ in 0..exp {
                result = arithmetic::mul(&result, &factor_fps);
            }
        } else if exp < 0 {
            let inv = arithmetic::invert(&factor_fps);
            for _ in 0..(-exp) {
                result = arithmetic::mul(&result, &inv);
            }
        }
        // exp == 0: skip (should not happen after normalization)
    }
    result
}
```

**2. jac2prod dispatch (eval.rs)**

Requires 3 args: JacobiProduct, symbol, truncation. Prints explicit product notation `(1-q)(1-q^2)...`, returns FPS.

```rust
"jac2prod" => {
    expect_args(name, args, 3)?;
    let factors = match &args[0] {
        Value::JacobiProduct(f) => f.clone(),
        _ => return Err(EvalError::Other(
            "expected Jacobi product expression (use JAC(a,b))".to_string()
        )),
    };
    let sym = extract_symbol_id(name, args, 1, env)?;
    let order = extract_i64(name, args, 2)?;
    let sym_name = env.symbols.resolve(sym).unwrap_or("q");

    // Print product notation
    let notation = format_product_notation(&factors, sym_name, order);
    println!("{}", notation);

    // Compute and return FPS
    let fps = jacobi_product_to_fps(&factors, sym, order);
    Ok(Value::Series(fps))
}
```

Add helper `format_product_notation`:
```rust
/// Format a JacobiProduct as explicit finite product notation.
/// E.g., "(1-q)(1-q^6)(1-q^11)..." for JAC(1,5) up to order.
fn format_product_notation(factors: &[(i64, i64, i64)], sym_name: &str, order: i64) -> String {
    if factors.is_empty() {
        return "1".to_string();
    }
    let mut numer_parts = Vec::new();
    let mut denom_parts = Vec::new();
    for &(a, b, exp) in factors {
        let abs_exp = exp.unsigned_abs() as i64;
        // Build the factor string: (1-q^a)(1-q^{a+b})(1-q^{a+2b})...
        let mut factor_strs = Vec::new();
        let mut k = a;
        while k > 0 && k < order {
            if k == 1 {
                factor_strs.push(format!("(1-{})", sym_name));
            } else {
                factor_strs.push(format!("(1-{}^{})", sym_name, k));
            }
            k += b;
        }
        let factor_block = factor_strs.join("");
        // Repeat for |exp| times
        for _ in 0..abs_exp {
            if exp > 0 {
                numer_parts.push(factor_block.clone());
            } else {
                denom_parts.push(factor_block.clone());
            }
        }
    }
    let numer = if numer_parts.is_empty() { "1".to_string() } else { numer_parts.join("") };
    if denom_parts.is_empty() {
        numer
    } else {
        format!("{}/{}", numer, denom_parts.join(""))
    }
}
```

**3. jac2series dispatch (eval.rs)**

Same as jac2prod but prints standard series format:
```rust
"jac2series" => {
    expect_args(name, args, 3)?;
    let factors = match &args[0] {
        Value::JacobiProduct(f) => f.clone(),
        _ => return Err(EvalError::Other(
            "expected Jacobi product expression (use JAC(a,b))".to_string()
        )),
    };
    let sym = extract_symbol_id(name, args, 1, env)?;
    let order = extract_i64(name, args, 2)?;
    let fps = jacobi_product_to_fps(&factors, sym, order);
    // Print using standard series format
    let formatted = crate::format::format_value(&Value::Series(fps.clone()), &env.symbols);
    println!("{}", formatted);
    Ok(Value::Series(fps))
}
```

**4. theta(z, q, T) dispatch (eval.rs)**

Three cases based on z argument type:
```rust
"theta" => {
    expect_args(name, args, 3)?;
    let sym = extract_symbol_id(name, args, 1, env)?;
    let t_range = extract_i64(name, args, 2)?;

    match &args[0] {
        // Case 1: z is numeric (Integer or Rational)
        Value::Integer(_) | Value::Rational(_) => {
            let z_val = extract_qrat(name, args, 0)?;
            let mut fps = FormalPowerSeries::zero(sym, t_range);
            for i in -t_range..=t_range {
                let q_exp = i * i;
                if q_exp >= t_range { continue; }
                let z_pow_i = qrat_pow(&z_val, i);
                let old = fps.coeff(q_exp);
                fps.set_coeff(q_exp, old + z_pow_i);
            }
            Ok(Value::Series(fps))
        }
        // Case 2: z is a q-monomial (Series)
        Value::Series(_) => {
            let mono = extract_monomial_from_arg(name, args, 0)?;
            let mono_power = mono.power;
            let mono_coeff = QRat::from((mono.coeff_num, mono.coeff_den));
            let mut fps = FormalPowerSeries::zero(sym, t_range);
            for i in -t_range..=t_range {
                let q_exp = mono_power * i + i * i;
                if q_exp < 0 || q_exp >= t_range { continue; }
                let coeff_i = qrat_pow(&mono_coeff, i);
                let old = fps.coeff(q_exp);
                fps.set_coeff(q_exp, old + coeff_i);
            }
            Ok(Value::Series(fps))
        }
        // Case 3: z is a bare Symbol -> warn, don't error
        Value::Symbol(sym_name) => {
            println!("Warning: theta(z, q, T) requires z to be numeric or a q-monomial; '{}' is an unassigned symbol", sym_name);
            Ok(Value::None)
        }
        _ => Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 0,
            expected: "numeric value, q-monomial, or symbol",
            got: args[0].type_name().to_string(),
        })
    }
}
```

Add helper `qrat_pow`:
```rust
/// Compute r^n for integer n (positive, negative, or zero).
fn qrat_pow(r: &QRat, n: i64) -> QRat {
    if n == 0 {
        return QRat::one();
    }
    let (base, abs_n) = if n < 0 {
        (QRat::one() / r.clone(), n.unsigned_abs())
    } else {
        (r.clone(), n as u64)
    };
    let mut result = QRat::one();
    for _ in 0..abs_n {
        result = result * base.clone();
    }
    result
}
```

Note: `extract_monomial_from_arg` returns a `QMonomial` with fields `coeff_num`, `coeff_den`, `power`. Check the actual struct fields by reading the extract_monomial_from_arg function and QMonomial definition. The research references `.coefficient` and `.power` but the actual struct may differ -- use the real field names.

**5. get_signature entries (eval.rs)**

Add to get_signature:
```rust
"theta" => "(z, q, T) -- general theta series sum(z^i * q^(i^2), i=-T..T)".to_string(),
"jac2prod" => "(JP, q, T) -- convert Jacobi product to explicit product form".to_string(),
"jac2series" => "(JP, q, T) -- convert Jacobi product to q-series".to_string(),
```

**6. ALL_FUNCTION_NAMES entries (eval.rs)**

Add "theta", "jac2prod", "jac2series" to ALL_FUNCTION_NAMES.

**7. Unit tests (eval.rs)**

Add tests:
- `dispatch_theta_numeric_z`: `theta(1, q, 10)` returns series with coefficient at q^0 = 2*10+1 = 21 terms (i=-10..10, all q^(i^2) where i^2 < 10, so i in {-3..3} give q^{0,1,4,9}). Check specific coefficients.
- `dispatch_theta_monomial_z`: `theta(q^2, q, 10)` returns correct series.
- `dispatch_theta_symbol_z_warns`: `theta(z, q, 10)` where z is Symbol returns None.
- `dispatch_jac2prod_returns_series`: `jac2prod(JAC(1,5), q, 20)` returns a series.
- `dispatch_jac2prod_wrong_type_errors`: `jac2prod(42, q, 20)` errors.
- `dispatch_jac2series_returns_series`: `jac2series(JAC(1,5), q, 20)` returns a series.
- `dispatch_jac2series_matches_etaq`: `jac2series(JAC(1,5), q, 20)` should equal `etaq(1, 5, q, 20)`.
- `dispatch_jac2series_product`: `jac2series(JAC(1,5)*JAC(4,5), q, 20)` should equal `etaq(1,5,q,20) * etaq(4,5,q,20)`.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass.

Specifically verify:
- `cargo test -p qsym-cli dispatch_theta` passes
- `cargo test -p qsym-cli dispatch_jac2prod` passes
- `cargo test -p qsym-cli dispatch_jac2series` passes
- `cargo test -p qsym-cli -- --ignored 2>&1 | grep "0 passed"` -- no accidentally ignored tests
  </verify>
  <done>
theta(z, q, T) handles all three z types (numeric, monomial, symbol warning). jac2prod prints product notation and returns FPS. jac2series prints series and returns FPS. All conversion functions validate JacobiProduct input type. Unit tests confirm correctness including cross-validation with etaq.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (existing + new)
2. `cargo test -p qsym-core` -- no regressions in core
3. `cargo build -p qsym-cli` -- clean compile, no warnings
4. Verify JAC(1,5) * JAC(2,5) round-trips: create, display, convert via jac2series
5. Verify theta(1, q, 5) produces expected coefficients: q^0 has coeff 2*5+1=11? No -- i from -5 to 5, q^(i^2): i^2 values are 0,1,4,9,16,25. Only i^2 < 5 are kept: i in {-2,-1,0,1,2} give q^{0,1,4,1,4} -> coeff at q^0 = 1 (i=0), q^1 = 2 (i=+-1), q^4 = 2 (i=+-2). Check these.
</verification>

<success_criteria>
- Value::JacobiProduct is a fully functional value type with arithmetic
- JAC(a,b) constructor validates inputs and creates normalized JacobiProducts
- theta(z, q, T) handles numeric, monomial, and symbol z arguments
- jac2prod prints product notation, returns FPS
- jac2series prints series, returns FPS
- Both jac2prod/jac2series reject non-JacobiProduct inputs with clear error
- All existing tests pass (no regressions)
- 15+ new unit tests covering all new functionality
</success_criteria>

<output>
After completion, create `.planning/phases/37-new-functions-theta-jacobi/37-01-SUMMARY.md`
</output>
