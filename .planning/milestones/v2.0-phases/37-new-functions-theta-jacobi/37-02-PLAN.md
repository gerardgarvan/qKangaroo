---
phase: 37-new-functions-theta-jacobi
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/tests/integration.rs
requirements: [NEW-04]
autonomous: true
must_haves:
  truths:
    - "qs2jaccombo(f, q, 30) decomposes a q-series into a linear combination of Jacobi products"
    - "qs2jaccombo prints a formula like '2*JAC(1,5)*JAC(2,5) + 3*JAC(3,5)' when decomposition is found"
    - "qs2jaccombo returns the input series unchanged and prints a message when no decomposition found"
    - "help(JAC) shows JAC(a,b) signature and description"
    - "help(theta) shows theta(z, q, T) signature with description"
    - "help(jac2prod) shows jac2prod(JP, q, T) signature"
    - "help(jac2series) shows jac2series(JP, q, T) signature"
    - "help(qs2jaccombo) shows qs2jaccombo(f, q, T) signature"
    - "Tab completion includes JAC, theta, jac2prod, jac2series, qs2jaccombo"
    - "General help lists the new functions under appropriate categories"
    - "CLI integration tests verify JAC creation, theta computation, and jac2series output"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "qs2jaccombo dispatch function"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entries for JAC, theta, jac2prod, jac2series, qs2jaccombo; updated general_help categories"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "5 new function names in canonical_function_names list"
    - path: "crates/qsym-cli/tests/integration.rs"
      provides: "CLI integration tests for JAC, theta, jac2series, qs2jaccombo"
  key_links:
    - from: "eval.rs qs2jaccombo"
      to: "qseries::jacprodmake"
      via: "first attempts single-product decomposition"
      pattern: "jacprodmake"
    - from: "eval.rs qs2jaccombo"
      to: "qseries::findlincombo"
      via: "finds linear combination over JAC basis"
      pattern: "findlincombo"
    - from: "eval.rs qs2jaccombo"
      to: "qseries::etaq"
      via: "expands candidate JAC products to FPS for basis"
      pattern: "etaq"
    - from: "help.rs FUNC_HELP"
      to: "eval.rs dispatch names"
      via: "help entries match dispatch function names"
      pattern: "jac2prod|jac2series|qs2jaccombo|theta|JAC"
    - from: "repl.rs canonical_function_names"
      to: "eval.rs ALL_FUNCTION_NAMES"
      via: "must stay in sync for tab completion"
      pattern: "JAC.*theta.*jac2prod"
---

<objective>
Implement qs2jaccombo (the most complex new function), add help text for all 5 new functions, update tab completion, and write CLI integration tests.

Purpose: Completes Phase 37 by adding the final conversion function and ensuring all new functions are discoverable (help, tab completion) and verified (integration tests).

Output: All four phase requirements (NEW-01 through NEW-04) fully satisfied with help and integration tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-new-functions-theta-jacobi/37-CONTEXT.md
@.planning/phases/37-new-functions-theta-jacobi/37-RESEARCH.md
@.planning/phases/37-new-functions-theta-jacobi/37-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/repl.rs
@crates/qsym-cli/tests/integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: qs2jaccombo dispatch function</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Implement the qs2jaccombo(f, q, T) function in eval.rs dispatch. This is the most algorithmically complex new function.

**Algorithm (two-phase approach per research):**

Phase A -- Try single Jacobi product decomposition:
1. Extract series f, symbol q, and truncation order T from args
2. Call `qseries::jacprodmake(&f, T)` to attempt single-product decomposition
3. If `is_exact` is true, format the result as JAC notation and return

Phase B -- Find linear combination of JAC products:
1. From the jacprodmake result, extract the periods (b values) that appeared
2. Generate candidate JAC(a,b) products for each period: for each b, try a=1..b-1
3. For each candidate, expand to FPS via `qseries::etaq(a, b, sym, T)`
4. Call `qseries::findlincombo(&f, &candidate_fps_refs, topshift)` where topshift = 0
5. If found, format and print the result, return `Value::String(formula)`
6. If not found, print "No Jacobi product decomposition found", return the input series unchanged

```rust
"qs2jaccombo" => {
    expect_args(name, args, 3)?;
    let f = extract_series(name, args, 0)?;
    let sym = extract_symbol_id(name, args, 1, env)?;
    let order = extract_i64(name, args, 2)?;

    // Phase A: Try single JAC product via jacprodmake
    let jpform = qseries::jacprodmake(&f, order);
    if jpform.is_exact && jpform.scalar == QRat::one() {
        // Single product decomposition found
        let factors: Vec<(i64,i64,i64)> = jpform.factors.iter()
            .map(|(&(a,b), &exp)| (a, b, exp))
            .collect();
        let jp_str = format_jacobi_product_value(&factors);
        println!("{}", jp_str);
        return Ok(Value::String(jp_str));
    }

    // Phase B: Generate candidate JAC basis from identified periods
    // Collect unique b values from jacprodmake result
    let mut periods: Vec<i64> = jpform.factors.keys().map(|&(_, b)| b).collect();
    periods.sort();
    periods.dedup();

    // If no periods found, try small periods 2..min(order, 20)
    if periods.is_empty() {
        periods = (2..=std::cmp::min(order, 20)).collect();
    }

    // Generate candidate (a,b) pairs and expand each to FPS
    let mut candidate_labels: Vec<String> = Vec::new();
    let mut candidate_fps: Vec<FormalPowerSeries> = Vec::new();

    for &b in &periods {
        for a in 1..b {
            let fps = qseries::etaq(a, b, sym, order);
            candidate_labels.push(format!("JAC({},{})", a, b));
            candidate_fps.push(fps);
        }
    }

    if candidate_fps.is_empty() {
        println!("No Jacobi product decomposition found");
        return Ok(Value::Series(f));
    }

    // Build references for findlincombo
    let refs: Vec<&FormalPowerSeries> = candidate_fps.iter().collect();
    match qseries::findlincombo(&f, &refs, 0) {
        Some(coeffs) => {
            let formula = format_linear_combo(&coeffs, &candidate_labels);
            println!("{}", formula);
            Ok(Value::String(formula))
        }
        None => {
            println!("No Jacobi product decomposition found");
            Ok(Value::Series(f))
        }
    }
}
```

Add helper for formatting a JacobiProduct factors vec as a display string (reuse the format_jacobi_product function from format.rs, or add a small wrapper):
```rust
/// Format JacobiProduct factors as display string for qs2jaccombo output.
/// This is the same logic as format.rs format_jacobi_product but accessible from eval.rs.
fn format_jacobi_product_value(factors: &[(i64, i64, i64)]) -> String {
    if factors.is_empty() {
        return "1".to_string();
    }
    let parts: Vec<String> = factors.iter().map(|&(a, b, exp)| {
        if exp == 1 {
            format!("JAC({},{})", a, b)
        } else {
            format!("JAC({},{})^({})", a, b, exp)
        }
    }).collect();
    parts.join("*")
}
```

Note: If the jacprodmake result has `is_exact=true` but a non-unit scalar, format as `scalar * product`. Handle the scalar case:
```rust
if jpform.is_exact {
    let factors: Vec<(i64,i64,i64)> = jpform.factors.iter()
        .map(|(&(a,b), &exp)| (a, b, exp))
        .collect();
    let jp_str = format_jacobi_product_value(&factors);
    let result_str = if jpform.scalar == QRat::one() {
        jp_str
    } else {
        format!("{}*{}", jpform.scalar, jp_str)
    };
    println!("{}", result_str);
    return Ok(Value::String(result_str));
}
```

**get_signature entry:**
```rust
"qs2jaccombo" => "(f, q, T) -- decompose q-series into sum of Jacobi products".to_string(),
```

**ALL_FUNCTION_NAMES:** Add "qs2jaccombo" to the array.

**Unit tests:**
- `dispatch_qs2jaccombo_single_product`: Create etaq(1,5,q,30) and pass to qs2jaccombo -- should find JAC(1,5)
- `dispatch_qs2jaccombo_no_decomposition`: Pass a series that has no JAC decomposition (e.g., just q+1) -- should return input series unchanged
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli dispatch_qs2jaccombo 2>&1` -- new tests pass.

Then `cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass.
  </verify>
  <done>
qs2jaccombo(f, q, T) decomposes a q-series into a linear combination of JAC products using jacprodmake + findlincombo. Prints human-readable formula when found, prints failure message when not found. Returns Value::String on success, Value::Series (input unchanged) on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Help text, tab completion, and CLI integration tests</name>
  <files>crates/qsym-cli/src/help.rs, crates/qsym-cli/src/repl.rs, crates/qsym-cli/tests/integration.rs</files>
  <action>
**1. Help entries (help.rs)**

Add 5 new FuncHelp entries to the FUNC_HELP array. Place them in a new section after the existing Groups:

```rust
// -----------------------------------------------------------------------
// Group 11: Jacobi Products & Conversions (5)
// -----------------------------------------------------------------------
FuncHelp {
    name: "JAC",
    signature: "JAC(a, b)",
    description: "Create a Jacobi product factor (q^a;q^b)_inf. JacobiProduct values support *, /, and ^ operations.\n  Use jac2series() or jac2prod() to expand to a q-series.",
    example: "q> jp := JAC(1,5) * JAC(4,5)",
    example_output: "JAC(1,5)*JAC(4,5)",
},
FuncHelp {
    name: "theta",
    signature: "theta(z, q, T)",
    description: "Compute the general theta series sum(z^i * q^(i^2), i=-T..T).\n  z can be numeric (integer/rational) or a q-monomial like q^2.\n  If z is an unassigned symbol, prints a warning.",
    example: "q> theta(q^2, q, 10)",
    example_output: "1 + 2*q^3 + 2*q^8 + ... + O(q^10)",
},
FuncHelp {
    name: "jac2prod",
    signature: "jac2prod(JP, q, T)",
    description: "Convert a Jacobi product expression to explicit product notation.\n  JP must be a JacobiProduct value (created with JAC(a,b)).\n  Prints product notation like (1-q)(1-q^6)... and returns the expanded q-series.",
    example: "q> jp := JAC(1,5)\nq> jac2prod(jp, q, 20)",
    example_output: "(1-q)(1-q^6)(1-q^11)(1-q^16)",
},
FuncHelp {
    name: "jac2series",
    signature: "jac2series(JP, q, T)",
    description: "Convert a Jacobi product expression to a truncated q-series.\n  JP must be a JacobiProduct value (created with JAC(a,b)).\n  Prints and returns the series expansion.",
    example: "q> jp := JAC(1,5) * JAC(4,5)\nq> jac2series(jp, q, 20)",
    example_output: "1 - q - q^4 + q^7 + ... + O(q^20)",
},
FuncHelp {
    name: "qs2jaccombo",
    signature: "qs2jaccombo(f, q, T)",
    description: "Decompose a q-series into a linear combination of Jacobi products.\n  First tries single-product decomposition via jacprodmake, then tries linear combination.\n  Prints the JAC formula if found, or 'No Jacobi product decomposition found' otherwise.",
    example: "q> f := etaq(q, 1, 30)\nq> qs2jaccombo(f, q, 30)",
    example_output: "JAC(1,1)",
},
```

Note: Adjust example_output to be accurate -- the examples above are illustrative. For theta(q^2, q, 10): i=-3..3 gives q^{9+6=15}, q^{4+4=8}, q^{1+2=3}, q^0=0, q^{1+2=3}, q^{4+4=8}, q^{9+6=15}. Only q^0, q^3, q^8 are < 10. So output is "1 + 2*q^3 + 2*q^8 + O(q^10)". Adjust examples to be correct.

**2. Update general_help (help.rs)**

In the general_help() function, add a new category section. Add after "Theta Functions:" and before "Series Analysis:":

```
Jacobi Products:
  JAC          - Jacobi product factor (q^a;q^b)_inf
  jac2prod     - convert Jacobi product to explicit product form
  jac2series   - convert Jacobi product to q-series
  qs2jaccombo  - decompose q-series into sum of Jacobi products
```

Also update the "Theta Functions:" section to include `theta`:
```
Theta Functions:
  theta    - general theta series sum(z^i*q^(i^2), i=-T..T)
  theta2   - Jacobi theta_2(q)
  theta3   - Jacobi theta_3(q)
  theta4   - Jacobi theta_4(q)
```

**3. Update help entry count**

The FUNC_HELP array currently has 81 entries. Adding 5 brings it to 86. Update the test `help_has_expected_entry_count` to expect 86.

**4. Tab completion (repl.rs)**

Add 5 new function names to the `canonical_function_names()` list. Add a new group:
```rust
// Group 10: Jacobi Products (5)
"JAC", "theta", "jac2prod", "jac2series", "qs2jaccombo",
```

Update the count comment from "83" to "88" and update the test `canonical_function_count_matches` to expect 88.

Note: There's a discrepancy -- current code says "83 canonical function names" but actually has 83 entries. After adding 5, it becomes 88. Also add "read" if it's in the list already. Check the actual count and keep consistent.

**5. ALL_FUNCTION_NAMES update (eval.rs)**

The eval.rs ALL_FUNCTION_NAMES array also needs the 5 new entries. Add:
```rust
// Pattern O: Jacobi Products
"JAC", "theta", "jac2prod", "jac2series", "qs2jaccombo",
```

Update the comment "79 functions" to the new count.

**6. CLI integration tests (integration.rs)**

Add integration tests that run the CLI binary with `-c` flag:

```rust
#[test]
fn jac_creates_jacobi_product() {
    // JAC(1,5) should display as JAC(1,5)
    let output = run_cli("-c", "JAC(1,5);");
    assert!(output.contains("JAC(1,5)"), "expected JAC(1,5) in output: {}", output);
}

#[test]
fn jac_multiply_combines_factors() {
    let output = run_cli("-c", "JAC(1,5) * JAC(2,5);");
    assert!(output.contains("JAC(1,5)*JAC(2,5)"), "expected combined product: {}", output);
}

#[test]
fn jac_invalid_b_errors() {
    let output = run_cli("-c", "JAC(1, -3);");
    assert!(output.contains("positive integer"), "expected validation error: {}", output);
}

#[test]
fn theta_numeric_z() {
    // theta(1, q, 5) = sum(q^(i^2), i=-5..5) for i^2 < 5: i in {-2,-1,0,1,2}
    // q^0: 1 (i=0), q^1: 2 (i=+-1), q^4: 2 (i=+-2)
    let output = run_cli("-c", "theta(1, q, 5);");
    assert!(output.contains("1 + 2*q + 2*q^4"), "expected theta coefficients: {}", output);
}

#[test]
fn theta_monomial_z() {
    // theta(q^2, q, 10) = sum(q^(2i+i^2), i=-T..T) for valid terms
    let output = run_cli("-c", "theta(q^2, q, 10);");
    // Should contain terms and O(q^10)
    assert!(output.contains("O(q^10)") || output.contains("q^"), "expected series output: {}", output);
}

#[test]
fn jac2series_single_factor() {
    // jac2series(JAC(1,1), q, 10) should equal etaq(q, 1, 10) = (q;q)_inf
    // which is 1 - q - q^2 + q^5 + q^7 + O(q^10)
    let output = run_cli("-c", "jac2series(JAC(1,1), q, 10);");
    assert!(output.contains("1 - q"), "expected (q;q)_inf series: {}", output);
}

#[test]
fn jac2series_wrong_type_errors() {
    let output = run_cli("-c", "jac2series(42, q, 10);");
    assert!(output.contains("expected Jacobi product"), "expected type error: {}", output);
}

#[test]
fn jac2prod_shows_product_notation() {
    let output = run_cli("-c", "jac2prod(JAC(1,5), q, 20);");
    assert!(output.contains("(1-q)"), "expected product notation: {}", output);
}

#[test]
fn qs2jaccombo_finds_single_product() {
    // etaq(1,1,q,30) = (q;q)_inf = JAC(1,1)
    let output = run_cli("-c", "f := etaq(q, 1, 30): qs2jaccombo(f, q, 30);");
    assert!(output.contains("JAC(1,1)") || output.contains("JAC"), "expected JAC decomposition: {}", output);
}

#[test]
fn help_jac_shows_entry() {
    let output = run_cli("-c", "help(JAC);");
    assert!(output.contains("JAC(a, b)"), "expected JAC help: {}", output);
}

#[test]
fn help_theta_shows_entry() {
    let output = run_cli("-c", "help(theta);");
    assert!(output.contains("theta(z, q, T)"), "expected theta help: {}", output);
}
```

Adapt these to the actual test harness pattern used in the existing integration.rs file. Read integration.rs first to understand the helper function (likely `run_cli` or similar using `Command::new`).
  </action>
  <verify>
Run these commands in sequence:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-cli 2>&1 | tail -10     # unit tests
cargo test -p qsym-cli --test integration 2>&1 | tail -10  # integration tests
```

Specifically:
- `cargo test -p qsym-cli canonical_function_count` passes (88 functions)
- `cargo test -p qsym-cli help_has_expected_entry_count` passes (86 entries)
- `cargo test -p qsym-cli --test integration jac` passes
- `cargo test -p qsym-cli --test integration theta` passes
- `cargo test -p qsym-cli --test integration qs2jaccombo` passes
  </verify>
  <done>
qs2jaccombo decomposes q-series into JAC linear combinations. All 5 new functions have help(name) entries. Tab completion includes JAC, theta, jac2prod, jac2series, qs2jaccombo. General help lists new categories. CLI integration tests verify end-to-end behavior. All requirement IDs (NEW-01 through NEW-04) are satisfied.
  </done>
</task>

</tasks>

<verification>
Full phase verification:
1. `cargo test -p qsym-cli` -- all unit tests pass (existing + ~20 new)
2. `cargo test -p qsym-cli --test integration` -- all integration tests pass
3. `cargo test -p qsym-core` -- no regressions in core
4. `cargo build -p qsym-cli --release` -- clean release build
5. Verify success criteria from ROADMAP:
   - theta(z, q, 20) works with numeric and monomial z
   - jac2prod(JP, q, 30) converts JacobiProduct to product notation
   - jac2series(JP, q, 30) converts JacobiProduct to series
   - qs2jaccombo(f, q, 30) decomposes series into JAC formula
</verification>

<success_criteria>
- NEW-01: theta(z, q, T) returns correct theta series for numeric/monomial z, warns for symbols
- NEW-02: jac2prod(JP, q, T) prints product notation and returns FPS
- NEW-03: jac2series(JP, q, T) prints series and returns FPS
- NEW-04: qs2jaccombo(f, q, T) decomposes to JAC linear combination
- All 5 new functions appear in help and tab completion
- CLI integration tests verify end-to-end correctness
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/37-new-functions-theta-jacobi/37-02-SUMMARY.md`
</output>
