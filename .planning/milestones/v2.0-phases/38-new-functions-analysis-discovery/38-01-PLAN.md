---
phase: 38-new-functions-analysis-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements: [NEW-05, NEW-06, NEW-07, NEW-09]

must_haves:
  truths:
    - "lqdegree0(f) returns the minimum key in an FPS BTreeMap (lowest q-degree)"
    - "checkmult(f, T) prints MULTIPLICATIVE or NOT MULTIPLICATIVE with first failing (m,n) and returns 1 or 0"
    - "checkmult(f, T, 'yes') prints ALL failing (m,n) pairs and returns 1 or 0"
    - "checkprod(f, M, Q) silently returns [a, 1] for nice products, [a, max_exp] otherwise, or [[a, c0], -1] for non-integer leading coeff"
    - "findprod(FL, T, M, Q) silently returns list of [valuation, coeff_vector] pairs for primitive coefficient vectors yielding nice products"
    - "Old 3-arg findprod dispatch is replaced by new 4-arg Garvan version"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "All 4 function dispatch arms + gcd helper + checkprod_impl helper + get_signature + ALL_FUNCTION_NAMES"
      contains: "lqdegree0|checkmult|checkprod|findprod"
  key_links:
    - from: "eval.rs checkprod dispatch"
      to: "checkprod_impl helper"
      via: "direct function call"
      pattern: "checkprod_impl"
    - from: "eval.rs findprod dispatch"
      to: "checkprod_impl helper"
      via: "called in inner loop for each coefficient vector"
      pattern: "checkprod_impl"
    - from: "eval.rs findprod dispatch"
      to: "qseries::compute_linear_combination or inline equivalent"
      via: "forms linear combination from coefficient vector"
      pattern: "scalar_mul|add"
---

<objective>
Implement all four Phase 38 analysis/discovery functions as CLI dispatch arms in eval.rs: lqdegree0, checkmult, checkprod (with shared helper), and findprod (replacing old 3-arg version).

Purpose: Completes the univariate Garvan function inventory for analysis and product discovery.
Output: Four working dispatch arms, gcd helper, checkprod_impl shared helper, updated get_signature and ALL_FUNCTION_NAMES, unit tests for all four.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-new-functions-analysis-discovery/38-RESEARCH.md
@.planning/phases/38-new-functions-analysis-discovery/38-CONTEXT.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-core/src/qseries/relations.rs
@crates/qsym-core/src/qseries/prodmake.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lqdegree0, checkmult, checkprod_impl, checkprod, and gcd helper</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add a private `gcd` helper function in eval.rs (Euclidean algorithm on i64, handles negative inputs via abs):

```rust
fn gcd(a: i64, b: i64) -> i64 {
    let (mut x, mut y) = (a.abs(), b.abs());
    while y != 0 {
        let tmp = y;
        y = x % y;
        x = tmp;
    }
    x
}
```

Add a private `checkprod_impl` helper function in eval.rs. This is the shared logic called by both the `checkprod` dispatch and the `findprod` dispatch. Algorithm:
1. Get valuation `a = fps.min_order().unwrap_or(0)`.
2. Get leading coefficient `c0 = fps.coeff(a)`.
3. If `c0.denom() != &rug::Integer::from(1)`, return `Value::List(vec![Value::List(vec![Value::Integer(a), Value::Rational(c0)]), Value::Integer(-1)])`.
4. Call `qseries::prodmake(&fps, q_order)` to get the InfiniteProductForm.
5. Find `max_exp = max(|numer| for each exponent value)`. Use `rat.numer().to_i64().unwrap_or(i64::MAX).abs()`. If exponents is empty, max_exp = 0.
6. If `max_exp < m_threshold`, return `Value::List(vec![Value::Integer(a), Value::Integer(1)])` (nice product).
7. Otherwise return `Value::List(vec![Value::Integer(a), Value::Integer(max_exp)])`.

Signature: `fn checkprod_impl(fps: &FormalPowerSeries, m_threshold: i64, q_order: i64) -> Value`

Add dispatch arm for `"lqdegree0"` — place it immediately after the existing `"lqdegree"` arm (around line 1955). Nearly identical to lqdegree:
```rust
"lqdegree0" => {
    // Garvan: lqdegree0(qexp) -- lowest q-degree (alias of lqdegree for FPS)
    expect_args(name, args, 1)?;
    let fps = extract_series(name, args, 0)?;
    match fps.min_order() {
        Some(d) => Ok(Value::Integer(QInt::from(d))),
        None => Ok(Value::None),
    }
}
```

Add dispatch arm for `"checkmult"` — place near other analysis functions. Uses `expect_args_range(name, args, 2, 3)`:
```rust
"checkmult" => {
    // Garvan: checkmult(QS, T) or checkmult(QS, T, 'yes')
    expect_args_range(name, args, 2, 3)?;
    let fps = extract_series(name, args, 0)?;
    let t = extract_i64(name, args, 1)?;
    let print_all = args.len() == 3 && matches!(&args[2], Value::String(s) if s == "yes");

    let mut failures: Vec<(i64, i64)> = Vec::new();
    let half_t = t / 2;
    'outer: for m in 2..=half_t {
        for n in m..=half_t {
            if m * n > t { break; }
            if gcd(m, n) != 1 { continue; }
            let fm = fps.coeff(m);
            let fn_ = fps.coeff(n);
            let fmn = fps.coeff(m * n);
            if fm.clone() * fn_.clone() != fmn {
                failures.push((m, n));
                if !print_all { break 'outer; }
            }
        }
    }

    if failures.is_empty() {
        println!("MULTIPLICATIVE");
        Ok(Value::Integer(QInt::from(1i64)))
    } else {
        for (m, n) in &failures {
            println!("NOT MULTIPLICATIVE at ({}, {})", m, n);
        }
        Ok(Value::Integer(QInt::from(0i64)))
    }
}
```

Add dispatch arm for `"checkprod"`:
```rust
"checkprod" => {
    // Garvan: checkprod(f, M, Q) -- check if series is nice product
    expect_args(name, args, 3)?;
    let fps = extract_series(name, args, 0)?;
    let m_threshold = extract_i64(name, args, 1)?;
    let q_order = extract_i64(name, args, 2)?;
    Ok(checkprod_impl(&fps, m_threshold, q_order))
}
```

**REPLACE** the existing `"findprod"` dispatch arm at line 2303 (old 3-arg) with the new 4-arg Garvan version. The new arm:
1. `expect_args(name, args, 4)`.
2. Extract series_list (arg 0), max_coeff T (arg 1), m_threshold M (arg 2), q_order Q (arg 3).
3. Iterate coefficient vectors from `[-T, ..., -T]` to `[T, ..., T]` using odometer increment.
4. Skip zero vector. Skip non-primitive vectors (gcd of abs values > 1).
5. Compute linear combination using `arithmetic::scalar_mul` + `arithmetic::add` (same pattern as `compute_linear_combination` in relations.rs).
6. If combo is not zero, call `checkprod_impl(&combo, m_threshold, q_order)`.
7. Check if result is "nice" (second element is Integer(1)). If so, extract valuation `a` from first element.
8. Build result row: `[a, c1, c2, ..., ck]` and push to results.
9. Return `Value::List(results)`.

For the linear combination computation, either call `qseries::relations::compute_linear_combination` (if it's public) or inline the same logic using `arithmetic::scalar_mul` and `arithmetic::add`. The function is currently private in relations.rs, so inline it:
```rust
let trunc = q_order.min(series_list.iter().map(|s| s.truncation_order()).min().unwrap());
let var = series_list[0].variable();
let mut combo = FormalPowerSeries::zero(var, trunc);
for (s, &c) in series_list.iter().zip(coeffs.iter()) {
    if c == 0 { continue; }
    let scaled = arithmetic::scalar_mul(&QRat::from((c, 1i64)), s);
    combo = arithmetic::add(&combo, &scaled);
}
```

For checking if a checkprod result is "nice" (second element is 1):
```rust
fn is_nice_checkprod_result(result: &Value) -> Option<i64> {
    if let Value::List(items) = result {
        if items.len() == 2 {
            if let (Value::Integer(a), Value::Integer(code)) = (&items[0], &items[1]) {
                if *code == QInt::from(1i64) {
                    return a.to_i64();
                }
            }
        }
    }
    None
}
```

Update `get_signature()` to add entries for the 4 new functions:
- `"lqdegree0" => "(f)".to_string()`
- `"checkmult" => "(QS, T) or (QS, T, 'yes')".to_string()`
- `"checkprod" => "(f, M, Q)".to_string()`
- `"findprod" => "(FL, T, M, Q)".to_string()` (REPLACE the old entry)

Update `ALL_FUNCTION_NAMES` array:
- Add `"lqdegree0"` to Pattern C (after `"lqdegree"`)
- Add `"checkmult"` and `"checkprod"` to a new comment line "Pattern P: Analysis" or add to Pattern C
- The existing `"findprod"` entry in Pattern E stays (signature changes but name is same)

Update `function_count_verification` test: change `count >= 75` to `count >= 78` (3 new names: lqdegree0, checkmult, checkprod; findprod already exists).

Import notes: Ensure `use crate::qsym_core::arithmetic` is available. Also ensure `qseries::prodmake` is accessible. Use `use qsym_core::series::FormalPowerSeries` and `use qsym_core::qseries` as already imported.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- --test-threads=1 dispatch_lqdegree 2>&1 | tail -5`

Verify existing tests still pass: `cargo test -p qsym-cli -- --test-threads=1 function_count 2>&1 | tail -5`
  </verify>
  <done>lqdegree0, checkmult, checkprod, and findprod dispatch arms compile and existing tests pass. get_signature and ALL_FUNCTION_NAMES updated.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for all four functions</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add unit tests in the `#[cfg(test)] mod tests` section of eval.rs. Follow the established dispatch test pattern (create env, call dispatch(), assert on returned Value).

**lqdegree0 test:**
```rust
#[test]
fn dispatch_lqdegree0_returns_min_order() {
    let mut env = test_env();
    // Create a series with known min order (partition_gf starts at q^0)
    let eta = dispatch("etaq", &[
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(20i64)),
    ], &mut env).unwrap();
    let val = dispatch("lqdegree0", &[eta], &mut env).unwrap();
    if let Value::Integer(n) = val {
        assert_eq!(n, QInt::from(0i64));
    } else {
        panic!("expected Integer, got {:?}", val);
    }
}
```

**checkmult tests (2 arg and 3 arg):**
```rust
#[test]
fn dispatch_checkmult_partition_not_multiplicative() {
    let mut env = test_env();
    let pgf = dispatch("partition_gf", &[Value::Integer(QInt::from(50i64))], &mut env).unwrap();
    let val = dispatch("checkmult", &[pgf, Value::Integer(QInt::from(30i64))], &mut env).unwrap();
    // partition function is NOT multiplicative
    assert_eq!(val, Value::Integer(QInt::from(0i64)));
}

#[test]
fn dispatch_checkmult_with_yes_prints_all() {
    let mut env = test_env();
    let pgf = dispatch("partition_gf", &[Value::Integer(QInt::from(50i64))], &mut env).unwrap();
    let val = dispatch("checkmult", &[
        pgf,
        Value::Integer(QInt::from(30i64)),
        Value::String("yes".to_string()),
    ], &mut env).unwrap();
    // Still returns 0 (not multiplicative), but prints all failures
    assert_eq!(val, Value::Integer(QInt::from(0i64)));
}
```

**checkprod test:**
```rust
#[test]
fn dispatch_checkprod_eta_nice_product() {
    let mut env = test_env();
    // etaq(1,1,30) = prod (1-q^n)^1 which is a nice product
    let eta = dispatch("etaq", &[
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(30i64)),
    ], &mut env).unwrap();
    let val = dispatch("checkprod", &[
        eta,
        Value::Integer(QInt::from(10i64)),  // M threshold
        Value::Integer(QInt::from(30i64)),  // Q order
    ], &mut env).unwrap();
    // Should be [a, 1] for a nice product
    if let Value::List(items) = &val {
        assert_eq!(items.len(), 2);
        // Second element should be 1 (nice)
        assert_eq!(items[1], Value::Integer(QInt::from(1i64)));
    } else {
        panic!("expected List, got {:?}", val);
    }
}
```

**findprod test:**
```rust
#[test]
fn dispatch_findprod_garvan_4arg() {
    let mut env = test_env();
    // Create two eta quotients as a simple test
    let e1 = dispatch("etaq", &[
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(30i64)),
    ], &mut env).unwrap();
    let e2 = dispatch("etaq", &[
        Value::Integer(QInt::from(2i64)),
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(30i64)),
    ], &mut env).unwrap();
    let val = dispatch("findprod", &[
        Value::List(vec![e1, e2]),
        Value::Integer(QInt::from(2i64)),   // T: max |coeff|
        Value::Integer(QInt::from(10i64)),  // M: max exponent threshold
        Value::Integer(QInt::from(30i64)),  // Q: truncation order
    ], &mut env).unwrap();
    // Should return a list (possibly empty, possibly with results)
    if let Value::List(results) = &val {
        // Each result should be [valuation, c1, c2, ...]
        for row in results {
            if let Value::List(items) = row {
                assert!(items.len() >= 3, "each result should have valuation + k coefficients");
            } else {
                panic!("expected List row, got {:?}", row);
            }
        }
    } else {
        panic!("expected List, got {:?}", val);
    }
}
```

Also add a test verifying the old 3-arg findprod now errors:
```rust
#[test]
fn dispatch_findprod_old_3arg_errors() {
    let mut env = test_env();
    let e1 = dispatch("etaq", &[
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(1i64)),
        Value::Integer(QInt::from(20i64)),
    ], &mut env).unwrap();
    let result = dispatch("findprod", &[
        Value::List(vec![e1]),
        Value::Integer(QInt::from(2i64)),
        Value::Integer(QInt::from(5i64)),
    ], &mut env);
    assert!(result.is_err(), "old 3-arg findprod should now error (expects 4 args)");
}
```
  </action>
  <verify>
Run all new tests: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- --test-threads=1 dispatch_lqdegree0 dispatch_checkmult dispatch_checkprod dispatch_findprod function_count 2>&1 | tail -20`

Run full CLI test suite to check for regressions: `cargo test -p qsym-cli -- --test-threads=1 2>&1 | tail -5`
  </verify>
  <done>All 6 new unit tests pass. Full CLI test suite passes with zero regressions. Old 3-arg findprod correctly errors.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli -- --test-threads=1` passes all tests including new ones
2. `cargo test -p qsym-core` passes (no core changes needed)
3. New functions appear in get_signature() output
4. New function names appear in ALL_FUNCTION_NAMES
5. function_count_verification test passes with updated count
</verification>

<success_criteria>
- lqdegree0 dispatch returns min order for FPS inputs
- checkmult correctly identifies multiplicative/non-multiplicative series with proper printing
- checkprod silently returns [a, code] list values
- findprod (4-arg) replaces old 3-arg version and returns [valuation, coeff_vector] pairs
- checkprod_impl is a shared private helper used by both checkprod and findprod
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/38-new-functions-analysis-discovery/38-01-SUMMARY.md`
</output>
