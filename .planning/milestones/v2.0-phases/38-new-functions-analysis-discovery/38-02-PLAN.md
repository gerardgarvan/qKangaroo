---
phase: 38-new-functions-analysis-discovery
plan: 02
type: execute
wave: 2
depends_on: [38-01]
files_modified:
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [NEW-05, NEW-06, NEW-07, NEW-09]

must_haves:
  truths:
    - "help(checkmult) shows signature, description, and example with 2-arg and 3-arg forms"
    - "help(checkprod) shows signature with (f, M, Q) and describes silent [a, code] return"
    - "help(lqdegree0) shows signature with (f) and describes FPS-only behavior"
    - "help(findprod) shows updated 4-arg (FL, T, M, Q) signature, not old 3-arg"
    - "General help listing includes checkmult, checkprod, lqdegree0 in appropriate categories"
    - "Integration tests verify all 4 functions work end-to-end via CLI -c flag"
  artifacts:
    - path: "crates/qsym-cli/src/help.rs"
      provides: "FuncHelp entries for checkmult, checkprod, lqdegree0; updated findprod entry; general_help listing updates"
      contains: "checkmult|checkprod|lqdegree0"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Integration tests for all 4 Phase 38 functions"
      contains: "checkmult|checkprod|lqdegree0|findprod"
  key_links:
    - from: "help.rs FUNC_HELP array"
      to: "help.rs canonical test list"
      via: "every_canonical_function_has_help_entry test"
      pattern: "checkmult.*checkprod.*lqdegree0"
    - from: "cli_integration.rs"
      to: "qsym-cli binary"
      via: "Command::new(cargo_bin) with -c flag"
      pattern: "checkmult|checkprod|lqdegree0|findprod"
---

<objective>
Add help text entries for all four Phase 38 functions and integration tests verifying end-to-end CLI behavior.

Purpose: Users can discover and learn the new functions via `help(name)`, and all functions are verified to work through the CLI binary.
Output: Updated help.rs with 3 new + 1 updated FuncHelp entries, updated general_help listing, integration tests in cli_integration.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-new-functions-analysis-discovery/38-RESEARCH.md
@.planning/phases/38-new-functions-analysis-discovery/38-CONTEXT.md
@.planning/phases/38-new-functions-analysis-discovery/38-01-SUMMARY.md
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/tests/cli_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add help text entries and update general help listing</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
Add 3 new FuncHelp entries to the FUNC_HELP array and update the existing findprod entry. Place them in the appropriate section (Series Analysis / Relations).

**New entry for lqdegree0** (place after the lqdegree entry):
```rust
FuncHelp {
    name: "lqdegree0",
    signature: "lqdegree0(f)",
    description: "Return the lowest power of q with a nonzero coefficient.\n  Equivalent to lqdegree for FPS inputs. Added for Garvan Maple compatibility.",
    example: "q> f := partition_gf(20)\nq> lqdegree0(f)",
    example_output: "0",
},
```

**New entry for checkmult** (place after checkprod or in Series Analysis section):
```rust
FuncHelp {
    name: "checkmult",
    signature: "checkmult(QS, T) or checkmult(QS, T, 'yes')",
    description: "Test if q-series coefficients are multiplicative: f(mn) = f(m)*f(n) for gcd(m,n)=1.\n  Checks all coprime pairs m,n with 2<=m,n<=T/2 and m*n<=T.\n  Prints MULTIPLICATIVE or NOT MULTIPLICATIVE at (m,n). Returns 1 or 0.\n  Optional 'yes' arg prints ALL failing pairs instead of stopping at first.",
    example: "q> f := partition_gf(50)\nq> checkmult(f, 30)",
    example_output: "NOT MULTIPLICATIVE at (2, 3)\n0",
},
```

**New entry for checkprod** (place near prodmake/analysis functions):
```rust
FuncHelp {
    name: "checkprod",
    signature: "checkprod(f, M, Q)",
    description: "Check if series f is a nice formal product.\n  M is max absolute exponent threshold, Q is truncation order.\n  Returns [a, 1] for nice product, [a, max_exp] if not nice,\n  or [[a, c0], -1] if leading coefficient is non-integer.",
    example: "q> f := etaq(1, 1, 30)\nq> checkprod(f, 10, 30)",
    example_output: "[0, 1]",
},
```

**Update existing findprod entry** (replace the old 3-arg description):
```rust
FuncHelp {
    name: "findprod",
    signature: "findprod(FL, T, M, Q)",
    description: "Search for linear combinations of series FL that yield nice products.\n  T is max |coefficient|, M is max product exponent threshold, Q is truncation order.\n  Tests all primitive coefficient vectors with entries in [-T,T].\n  Returns list of [valuation, c1, c2, ...] pairs silently.",
    example: "q> e1 := etaq(1, 1, 30); e2 := etaq(2, 1, 30)\nq> findprod([e1, e2], 2, 10, 30)",
    example_output: "[[0, 1, 0], [0, 0, 1], ...] (coefficient vectors yielding nice products)",
},
```

**Update the general_help() listing:**
- In the "Series Analysis:" section, add `lqdegree0`, `checkmult`, and `checkprod`:
  ```
  lqdegree0      - lowest q-degree (Garvan compat alias)
  checkmult      - test if coefficients are multiplicative
  checkprod      - test if series is a nice formal product
  ```
- The existing `findprod` line in the "Relations:" section stays (description may be updated to match new semantics):
  ```
  findprod           - search for product identities in series list
  ```

**Update the `every_canonical_function_has_help_entry` test:**
- Add `"lqdegree0"`, `"checkmult"`, `"checkprod"` to the canonical list.
- Update the `assert_eq!(canonical.len(), 86, ...)` to `assert_eq!(canonical.len(), 89, ...)` (3 new entries).

**Update the `func_help_count_matches_canonical` test:**
- Change `assert_eq!(FUNC_HELP.len(), 86, ...)` to `assert_eq!(FUNC_HELP.len(), 89, ...)`.
  </action>
  <verify>
Run help tests: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- --test-threads=1 help 2>&1 | tail -10`

Verify all canonical function tests pass: `cargo test -p qsym-cli -- --test-threads=1 every_canonical func_help_count 2>&1 | tail -10`
  </verify>
  <done>3 new FuncHelp entries added, findprod entry updated, general_help listing updated, canonical count tests updated to 89. All help tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI integration tests for all four functions</name>
  <files>crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
Add integration tests that invoke the qsym-cli binary with `-c` flag to test all four Phase 38 functions end-to-end. Follow the established pattern in cli_integration.rs (use `Command::new(cargo_bin("qsym-cli"))` with `.arg("-c")` and `.arg("expression")`).

**Test lqdegree0:**
```rust
#[test]
fn cli_lqdegree0_partition_gf() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("f := partition_gf(20); lqdegree0(f)")
        .output()
        .expect("failed to execute");
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("0"), "lqdegree0 of partition_gf should be 0, got: {}", stdout);
}
```

**Test checkmult (2-arg, not multiplicative):**
```rust
#[test]
fn cli_checkmult_not_multiplicative() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("f := partition_gf(50); checkmult(f, 30)")
        .output()
        .expect("failed to execute");
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("NOT MULTIPLICATIVE"), "partition function should not be multiplicative, got: {}", stdout);
    assert!(stdout.contains("0"), "should return 0, got: {}", stdout);
}
```

**Test checkmult (3-arg with 'yes'):**
```rust
#[test]
fn cli_checkmult_with_yes() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("f := partition_gf(50); checkmult(f, 30, 'yes')")
        .output()
        .expect("failed to execute");
    let stdout = String::from_utf8_lossy(&output.stdout);
    // Should print multiple NOT MULTIPLICATIVE lines
    let not_mult_count = stdout.matches("NOT MULTIPLICATIVE").count();
    assert!(not_mult_count >= 2, "with 'yes' should print multiple failures, got {} lines", not_mult_count);
}
```

**Test checkprod (nice product - eta function):**
```rust
#[test]
fn cli_checkprod_eta_nice() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("f := etaq(1, 1, 30); checkprod(f, 10, 30)")
        .output()
        .expect("failed to execute");
    let stdout = String::from_utf8_lossy(&output.stdout);
    // eta is a nice product, should contain [_, 1]
    assert!(stdout.contains("1]"), "eta should be a nice product, got: {}", stdout);
}
```

**Test findprod (4-arg Garvan version):**
```rust
#[test]
fn cli_findprod_garvan_4arg() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("e1 := etaq(1, 1, 30); e2 := etaq(2, 1, 30); findprod([e1, e2], 1, 10, 30)")
        .output()
        .expect("failed to execute");
    let stdout = String::from_utf8_lossy(&output.stdout);
    // Should return a list (possibly with results)
    assert!(stdout.contains("["), "findprod should return a list, got: {}", stdout);
    assert!(output.status.success(), "findprod should succeed");
}
```

**Test findprod old 3-arg errors:**
```rust
#[test]
fn cli_findprod_old_3arg_errors() {
    let output = Command::new(cargo_bin("qsym-cli"))
        .arg("-c")
        .arg("e1 := etaq(1, 1, 20); findprod([e1], 2, 5)")
        .output()
        .expect("failed to execute");
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("expects 4 arguments") || stderr.contains("expected 4"),
        "old 3-arg findprod should error, got stderr: {}", stderr);
}
```

Use colon terminators for multi-statement separation in `-c` arg expressions (as established in Phase 36-03 decisions).
  </action>
  <verify>
Build CLI binary and run integration tests: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --test cli_integration -- --test-threads=1 cli_lqdegree0 cli_checkmult cli_checkprod cli_findprod 2>&1 | tail -20`

Run full integration test suite: `cargo test -p qsym-cli --test cli_integration -- --test-threads=1 2>&1 | tail -5`
  </verify>
  <done>6 new integration tests pass. Full integration test suite passes with zero regressions. All 4 Phase 38 functions verified end-to-end via CLI binary.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli -- --test-threads=1` passes all unit tests
2. `cargo test -p qsym-cli --test cli_integration -- --test-threads=1` passes all integration tests
3. `help(checkmult)`, `help(checkprod)`, `help(lqdegree0)`, `help(findprod)` all return proper help text
4. General help listing shows all 4 functions in appropriate categories
5. Canonical function count test passes at 89
</verification>

<success_criteria>
- All 4 functions have complete FuncHelp entries with signature, description, example, and example_output
- findprod help entry reflects new 4-arg Garvan signature (not old 3-arg)
- General help listing includes lqdegree0, checkmult, checkprod in Series Analysis section
- 6 integration tests verify end-to-end CLI behavior for all functions
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/38-new-functions-analysis-discovery/38-02-SUMMARY.md`
</output>
