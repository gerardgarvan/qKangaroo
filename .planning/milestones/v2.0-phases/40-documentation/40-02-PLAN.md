---
phase: 40-documentation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - manual/chapters/08-series-analysis.typ
  - manual/chapters/09-relations.typ
autonomous: true
requirements: [DOC-01]

must_haves:
  truths:
    - "Chapter 08 shows Garvan-canonical signatures for all 9 existing analysis functions plus 3 new entries (lqdegree0, checkmult, checkprod)"
    - "Chapter 09 shows Garvan-canonical signatures for all 12 relation discovery functions including findprod and findcong updated forms"
    - "All signatures match help.rs exactly -- no legacy forms remain"
  artifacts:
    - path: "manual/chapters/08-series-analysis.typ"
      provides: "Series analysis reference with 12 entries total and Garvan signatures"
      contains: "sift(s, q, n, k, T)"
    - path: "manual/chapters/09-relations.typ"
      provides: "Relation discovery reference with 12 entries and Garvan signatures"
      contains: "findcong(QS, T)"
  key_links:
    - from: "manual/chapters/08-series-analysis.typ"
      to: "crates/qsym-cli/src/help.rs"
      via: "signature consistency"
      pattern: "sift\\(s, q, n, k, T\\)"
    - from: "manual/chapters/09-relations.typ"
      to: "crates/qsym-cli/src/help.rs"
      via: "signature consistency"
      pattern: "findcong\\(QS, T\\)"
---

<objective>
Update manual chapters 08 (Series Analysis) and 09 (Relations) to reflect v2.0 Maple-compatible signatures, add 3 new function entries in chapter 08, and update all 12 relation functions in chapter 09.

Purpose: These two chapters contain the "detective tools" and "discovery tools" of q-series research. Every signature changed in v2.0 phases 35-38, and 3 new functions (lqdegree0, checkmult, checkprod) need complete entries. Per user decision, legacy signatures are replaced entirely with Garvan-canonical forms.

Output: Two updated .typ files with Garvan-canonical signatures for all 24 functions, new func-entry blocks for lqdegree0/checkmult/checkprod, and textbook-quality formal math definitions.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-documentation/40-CONTEXT.md
@.planning/phases/40-documentation/40-RESEARCH.md
@manual/chapters/08-series-analysis.typ
@manual/chapters/09-relations.typ
@manual/template.typ
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update chapter 08 (Series Analysis) signatures + add 3 new functions</name>
  <files>manual/chapters/08-series-analysis.typ</files>
  <action>
Replace ALL existing function signatures with Garvan-canonical forms. The help.rs entries are the authoritative source. For each function, update: signature line, description text, params table, examples, edge-cases.

Specific signature replacements:
- sift: `sift(s, q, n, k, T)` (was `sift(series, m, j)`). Params: s (Series, input), q (Variable), n (Integer, modulus), k (Integer, residue), T (Integer, truncation). Description: extracts coefficients at positions n*i+k from the input, using terms up to q^T. Example: `f := partition_gf(50): sift(f, q, 5, 4, 50)`.
- qdegree: stays `qdegree(series)` -- no change needed.
- lqdegree: stays `lqdegree(series)` -- no change needed.
- qfactor: `qfactor(f, q)` or `qfactor(f, q, T)` (was `qfactor(series)`). Now takes explicit q arg. Example: `f := aqprod(q, q, 5): qfactor(f, q)`.
- prodmake: `prodmake(f, q, T)` (was `prodmake(series, max_n)`). Example: `f := partition_gf(50): prodmake(f, q, 20)`.
- etamake: `etamake(f, q, T)` (was `etamake(series, max_n)`). Example: `f := partition_gf(50): etamake(f, q, 10)`.
- jacprodmake: `jacprodmake(f, q, T)` or `jacprodmake(f, q, T, P)` (was `jacprodmake(series, max_n)`). P is optional period filter. Example: `f := jacprod(1, 5, q, 30): jacprodmake(f, q, 10)`.
- mprodmake: `mprodmake(f, q, T)` (was `mprodmake(series, max_n)`). Example: `f := distinct_parts_gf(50): mprodmake(f, q, 10)`.
- qetamake: `qetamake(f, q, T)` (was `qetamake(series, max_n)`). Example: `f := partition_gf(50): qetamake(f, q, 10)`.

For ALL updated functions: describe that q is now passed explicitly as an argument (Garvan convention), and T is the truncation/search bound.

ADD 3 new func-entry blocks after qetamake (before the chapter ends):
1. lqdegree0(f): Garvan compatibility alias for lqdegree. Returns lowest q-degree of an FPS value. Math-def: min{n : a_n != 0} where f(q) = sum a_n q^n. Example: `f := partition_gf(20): lqdegree0(f)` -> 0. Note: equivalent to lqdegree for FPS inputs. Related: lqdegree, qdegree.

2. checkmult(QS, T) or checkmult(QS, T, 'yes'): Test if q-series coefficients are multiplicative. Math-def: A sequence {a_n} is multiplicative if a_1=1 and a_{mn} = a_m * a_n whenever gcd(m,n)=1. The function checks all coprime pairs (m,n) with 2 <= m,n <= T/2 and m*n <= T. Prints MULTIPLICATIVE or NOT MULTIPLICATIVE at first failing (m,n). Returns 1 or 0. Optional 'yes' argument prints ALL failing pairs. Params: QS (Series), T (Integer, upper bound), 'yes' (String, optional). Example: `f := partition_gf(50): checkmult(f, 30)` -> NOT MULTIPLICATIVE at (2,3), 0. Edge cases: only checks coprime pairs; does not constitute a proof for all n. Related: checkprod, sift, findcong.

3. checkprod(f, M, Q): Check if series f is a "nice" formal product. Math-def: Uses prodmake to decompose f into prod(1-q^n)^{a_n}, then checks if all |a_n| <= M. Returns [valuation, 1] if nice, [valuation, max_exp] otherwise, or [[valuation, c0], -1] if leading coefficient is non-integer. Params: f (Series), M (Integer, max absolute exponent threshold), Q (Integer, truncation order). Example: `f := etaq(q, 1, 30): checkprod(f, 10, 30)` -> [0, 1]. Related: checkmult, prodmake, findprod.

Update chapter intro to reflect new function count: was "9 series analysis functions", now 12.
  </action>
  <verify>Read the file and verify: (1) all 9 original functions show Garvan signatures, (2) 3 new entries exist for lqdegree0/checkmult/checkprod, (3) no legacy signatures remain, (4) all signatures match help.rs.</verify>
  <done>Chapter 08 has 12 func-entry blocks with Garvan-canonical signatures. New functions checkmult, checkprod, lqdegree0 have complete entries with formal math definitions, parameters, examples, and edge cases.</done>
</task>

<task type="auto">
  <name>Task 2: Update chapter 09 (Relations) with Garvan-canonical signatures</name>
  <files>manual/chapters/09-relations.typ</files>
  <action>
Replace ALL 12 relation function signatures with Garvan-canonical forms. The help.rs entries are the authoritative source.

Specific signature replacements -- these are the most complex signature changes in v2.0:

**Linear Combinations section:**
- findlincombo: `findlincombo(f, L, SL, q, topshift)` (was `findlincombo(target, [candidates], topshift)`). Now takes symbolic labels SL as separate list, explicit q. Description: find f as linear combination of basis series L, printing result using symbolic labels SL. Example: `f := partition_gf(30): findlincombo(f, [distinct_parts_gf(30), odd_parts_gf(30)], [D, O], q, 0)`. Note the SL labels D, O are bare symbols.
- findhomcombo: `findhomcombo(f, L, q, n, topshift)` (was `findhomcombo(target, [candidates], degree, topshift)`). Auto-generated X[i] labels. Example: `findhomcombo(f, [etaq(1,1,30), etaq(2,1,30)], q, 2, 0)`.
- findnonhomcombo: `findnonhomcombo(f, L, q, n, topshift)` (was `findnonhomcombo(target, [candidates], degree, topshift)`). Auto X[i] labels.
- findlincombomodp: `findlincombomodp(f, L, SL, p, q, topshift)` (was `findlincombomodp(target, [candidates], p, topshift)`). Note p comes before q.
- findhomcombomodp: `findhomcombomodp(f, L, p, q, n, topshift)` (was `findhomcombomodp(target, [candidates], p, degree, topshift)`). Note p before q.

**Relation Finding section:**
- findhom: `findhom(L, q, n, topshift)` (was `findhom([series], degree, topshift)`). Explicit q. Example: `findhom([theta3(50)^2, theta2(50)^2, theta4(50)^2], q, 1, 0)`.
- findnonhom: `findnonhom(L, q, n, topshift)` (was `findnonhom([series], degree, topshift)`).
- findhommodp: `findhommodp(L, p, q, n, topshift)` (was `findhommodp([series], p, degree, topshift)`). Note p before q.
- findmaxind: `findmaxind(L, T)` (was `findmaxind([series], topshift)`). Parameter renamed to T. Returns 1-based indices (per Garvan convention). Update example to show 1-based: `findmaxind([etaq(1,1,20), etaq(2,1,20), etaq(1,1,20)], 0)` -> [1, 2].

**Specialized Searches section:**
- findprod: `findprod(FL, T, M, Q)` (was `findprod([series], max_coeff, max_exp)`). Completely different semantics: searches for linear combinations of series FL that yield nice products. T is max |coefficient|, M is max product exponent, Q is truncation. Returns list of [valuation, c1, c2, ...] pairs silently. Example: `e1 := etaq(1,1,30); e2 := etaq(2,1,30): findprod([e1, e2], 2, 10, 30)`.
- findcong: `findcong(QS, T)` or `findcong(QS, T, LM)` or `findcong(QS, T, LM, XSET)` (was `findcong(series, [moduli])`). Auto-discovers congruences. QS is series, T is number of terms to scan, LM is max modulus (default sqrt(T)), XSET is exclusion list. Output: [B, A, R] triples meaning p(A*n+B) = 0 mod R. Example: `p := partition_gf(200): findcong(p, 200)` -> discovers Ramanujan congruences.
- findpoly: `findpoly(x, y, q, dx, dy)` or `findpoly(x, y, q, dx, dy, check)` (was `findpoly(x, y, deg_x, deg_y, topshift)`). Now takes explicit q. Optional check arg for verification. Example: `findpoly(theta3(50)^4, theta2(50)^4 + theta4(50)^4, q, 1, 1)`.

For ALL functions: update description text to explain the new calling convention, update params tables with new parameter names and types, provide Garvan-style examples. Mention that all functions now print results using symbolic labels where applicable (SL for findlincombo/findlincombomodp, auto X[i] for others).

Update chapter intro text to reflect that the relation functions now accept Garvan's exact calling conventions with explicit q parameters and symbolic labels.
  </action>
  <verify>Read the file and verify: (1) all 12 relation functions show Garvan signatures, (2) no legacy signatures remain, (3) findcong shows the 3 overloaded forms, (4) findprod shows new FL/T/M/Q semantics, (5) all signatures match help.rs.</verify>
  <done>Chapter 09 has 12 func-entry blocks with Garvan-canonical signatures. findcong and findprod show completely rewritten entries reflecting their new Garvan semantics. All functions document explicit q parameters and symbolic label conventions.</done>
</task>

</tasks>

<verification>
- All signatures in chapters 08 and 09 match help.rs canonical forms exactly
- No legacy signatures remain (no `sift(series, m, j)`, no `findcong(series, [moduli])`, etc.)
- 3 new functions (lqdegree0, checkmult, checkprod) have complete func-entry blocks
- findprod and findcong entries accurately describe their completely new v2.0 semantics
- Formal math definitions present for all new entries
</verification>

<success_criteria>
- Chapter 08 contains 12 func-entry blocks (9 updated + 3 new)
- Chapter 09 contains 12 func-entry blocks (all updated)
- Every signature matches the corresponding help.rs entry
- checkmult/checkprod have textbook-quality multiplicativity and product-checking definitions
- findcong shows all 3 overloaded forms with [B, A, R] output format
</success_criteria>

<output>
After completion, create `.planning/phases/40-documentation/40-02-SUMMARY.md`
</output>
