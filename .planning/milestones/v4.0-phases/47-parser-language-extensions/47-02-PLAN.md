---
phase: 47-parser-language-extensions
plan: 02
type: execute
wave: 2
depends_on: [47-01, 47-03]
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
autonomous: true
requirements: [LANG-02]

must_haves:
  truths:
    - "User defines F := q -> theta3(q,500)/theta3(q^5,100) and calls F(q) to get a series"
    - "Lambda q -> expr is stored as Value::Procedure and callable via existing call_procedure"
    - "F := q -> q^2 + 1; F(3) returns 10"
    - "Arrow operator binds correctly: F := q -> expr assigns the lambda to F"
    - "Error reported if LHS of -> is not a variable name"
  artifacts:
    - path: "crates/qsym-cli/src/token.rs"
      provides: "Token::Arrow variant"
      contains: "Arrow"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Arrow lexing for -> sequence"
      contains: "Token::Arrow"
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode::Lambda variant"
      contains: "Lambda"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Arrow LED handler with correct precedence"
      contains: "Token::Arrow"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Lambda evaluation creating Value::Procedure"
      contains: "AstNode::Lambda"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "Lambda display (same as proc display)"
      contains: "no additional match arm needed -- Lambda evals to Value::Procedure"
  key_links:
    - from: "crates/qsym-cli/src/parser.rs"
      to: "AstNode::Lambda"
      via: "LED handler for Token::Arrow"
      pattern: "AstNode::Lambda"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "Value::Procedure"
      via: "Lambda eval creates Procedure with single param"
      pattern: "AstNode::Lambda.*Procedure"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "call_procedure"
      via: "FuncCall dispatches to user procedure"
      pattern: "call_procedure"
---

<objective>
Add arrow operator (`->`) for defining lambda functions: `F := q -> expr` creates a callable single-parameter procedure.

Purpose: Concise function definition syntax matching Maple's arrow operator.
Output: Modified token.rs, lexer.rs, ast.rs, parser.rs, eval.rs with tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-parser-language-extensions/47-RESEARCH.md
@.planning/phases/47-parser-language-extensions/47-01-SUMMARY.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Token::Arrow, lexer, AstNode::Lambda, and parser LED</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/ast.rs
    crates/qsym-cli/src/parser.rs
  </files>
  <action>
1. **token.rs**: Add `Arrow` variant to `Token` enum. Doc comment: `/// '->` arrow operator for lambda definitions.`

2. **lexer.rs**: In the `-` handling section -- currently `-` is matched as `Token::Minus` in the single-character tokens match. Modify this: remove `b'-'` from the single-character match. Instead, add a new block before or after the single-char block (similar to the `:` / `:=` disambiguation). When `b == b'-'`, check if the next byte is `b'>'`. If so, emit `Token::Arrow` with span `(pos, pos+2)`, advance pos by 2. Otherwise, emit `Token::Minus` with span `(pos, pos+1)`, advance pos by 1. Continue in both cases.

3. **ast.rs**: Add `Lambda` variant to `AstNode` enum:
   ```rust
   /// Lambda function: `param -> body`.
   Lambda {
       param: String,
       body: Box<AstNode>,
   },
   ```

4. **parser.rs**:
   a. In `token_name`, add: `Token::Arrow => "'->'".to_string(),`

   b. In the LED loop of `expr_bp`, add an arrow handler AFTER the assignment handler (`:=` check) but BEFORE the `infix_bp` check. The arrow has l_bp = 2 (same level as assignment) so it gets captured as the RHS of `:=`. Implementation:
   ```rust
   // Arrow operator: q -> expr (lambda)
   if *self.peek() == Token::Arrow {
       if 2 < min_bp {
           break;
       }
       if let AstNode::Variable(param) = lhs {
           self.advance(); // consume ->
           let body = self.expr_bp(0)?; // capture full RHS expression
           lhs = AstNode::Lambda {
               param,
               body: Box::new(body),
           };
           continue;
       } else {
           let span = self.peek_span();
           return Err(ParseError::new(
               "left side of '->' must be a parameter name".to_string(),
               span,
           ));
       }
   }
   ```
   The key precedence behavior: `F := q -> theta3(q,500)/theta3(q^5,100)` parses as `F := (q -> (theta3(q,500)/theta3(q^5,100)))`. This works because:
   - `:=` has l_bp=2, r_bp=1. It calls expr_bp(1) for its RHS.
   - Arrow's l_bp=2 > min_bp=1, so arrow is captured as part of the RHS.
   - Arrow calls expr_bp(0) for its body, capturing the full expression.

5. Add tests:
   - **Lexer**: `test_lex_arrow`: `tokens("q -> expr")` -> `[Ident("q"), Arrow, Ident("expr"), Eof]`
   - **Lexer**: `test_lex_minus_still_works`: `tokens("a - b")` -> `[Ident("a"), Minus, Ident("b"), Eof]`
   - **Lexer**: `test_lex_arrow_no_spaces`: `tokens("q->expr")` -> `[Ident("q"), Arrow, Ident("expr"), Eof]`
   - **Parser**: `test_lambda_simple`: `parse_expr("q -> q^2")` produces `AstNode::Lambda { param: "q", body: BinOp(Pow, Variable("q"), Integer(2)) }`
   - **Parser**: `test_lambda_assign`: `parse_expr("F := q -> q + 1")` produces `Assign { name: "F", value: Lambda { param: "q", body: BinOp(Add, Variable("q"), Integer(1)) } }`
   - **Parser**: `test_lambda_complex_body`: `parse_expr("F := q -> theta3(q,500)/theta3(q^5,100)")` produces `Assign { name: "F", value: Lambda { param: "q", body: BinOp(Div, FuncCall("theta3", ...), FuncCall("theta3", ...)) } }`
   - **Parser**: `test_lambda_error_non_variable_lhs`: `parse("3 -> x")` should error with "left side of '->' must be a parameter name"
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli lexer::tests::test_lex_arrow -- --nocapture 2>&1 | tail -5` and `cargo test -p qsym-cli lexer::tests::test_lex_minus -- --nocapture 2>&1 | tail -5` and `cargo test -p qsym-cli parser::tests::test_lambda -- --nocapture 2>&1 | tail -10` -- all pass. Then `cargo test -p qsym-cli 2>&1 | tail -5` to confirm no regressions.
  </verify>
  <done>Token::Arrow exists. `->` lexes as Arrow, `-` still lexes as Minus. AstNode::Lambda variant exists. Parser handles arrow in LED loop with correct precedence. Lambda assigned via `:=` works. 7+ new tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Lambda evaluation and integration tests</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
1. In `eval_expr` in eval.rs, add a match arm for `AstNode::Lambda` (right before or after the `AstNode::ProcDef` arm):
   ```rust
   AstNode::Lambda { param, body } => {
       Ok(Value::Procedure(Procedure {
           name: String::new(),
           params: vec![param.clone()],
           locals: vec![],
           remember: false,
           body: vec![Stmt {
               node: body.as_ref().clone(),
               terminator: Terminator::Implicit,
           }],
           memo: Rc::new(RefCell::new(HashMap::new())),
       }))
   }
   ```
   This converts the lambda into a `Value::Procedure` with one parameter and an implicit-return body. The existing `call_procedure` infrastructure handles calling, arity checking, variable save/restore, and memoization.

   The existing `AstNode::Assign` handler already sets `proc_val.name = name.clone()` for Procedure values, so `F := q -> expr` will have `F.name == "F"`.

   No changes needed to format.rs -- `Value::Procedure` already displays as `proc(q) ... end proc`.

2. Add evaluator tests (in the `#[cfg(test)] mod tests` block of eval.rs):
   - `test_eval_lambda_simple`: Parse and eval `"F := q -> q + 1; F(5)"`. The second statement should return `Value::Integer(6)`.
   - `test_eval_lambda_with_series`: Parse and eval `"F := q -> q^2; F(q)"`. Result should be a `Value::Series` with a monomial at exponent 2.
   - `test_eval_lambda_arity_error`: Parse and eval `"F := q -> q; F(1, 2)"`. Should return an arity error.
   - `test_eval_lambda_procedure_display`: Parse and eval `"q -> q^2"`. Result should be `Value::Procedure` with params=["q"].

   Use the existing test pattern with `make_env()` and `eval_expr`. For multi-statement tests, parse with `parse()`, then eval each statement in sequence using `eval_expr`, storing `env.last_result` after each.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli eval::tests::test_eval_lambda -- --nocapture 2>&1 | tail -15` -- all lambda tests pass. Then `cargo test -p qsym-cli 2>&1 | tail -5` -- full suite passes.
  </verify>
  <done>Lambda `q -> expr` evaluates to Value::Procedure. Lambda callable via `F(q)`. Arity checking works. 4+ new evaluator tests pass. Full test suite green.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass
2. `F := q -> q^2 + 1; F(3)` evaluates to 10 (via proc calling infrastructure)
3. `F := q -> theta3(q,500)/theta3(q^5,100)` assigns a callable lambda
4. Arrow precedence correct: `:=` captures the entire lambda as its RHS
5. Error on non-variable LHS: `3 -> x` produces descriptive error
6. Minus operator unaffected: `a - b` still works
</verification>

<success_criteria>
- `cargo test -p qsym-cli` passes with zero failures
- Token::Arrow lexed from `->`, Minus still lexed from `-`
- AstNode::Lambda parsed with correct precedence relative to `:=`
- Lambda evaluates to Value::Procedure, callable via existing infrastructure
- `F := q -> expr; F(q)` works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/47-parser-language-extensions/47-02-SUMMARY.md`
</output>
