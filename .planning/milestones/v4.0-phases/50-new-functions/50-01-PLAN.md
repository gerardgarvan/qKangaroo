---
phase: 50-new-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [FUNC-01, FUNC-03]

must_haves:
  truths:
    - "jac2series(JAC(0,1), 50) returns the q-series expansion of (q;q)_inf to O(q^50)"
    - "jac2series(JAC(1,5), q, 20) still works (3-arg backward compatibility)"
    - "jac2series(JAC(1,5)*JAC(4,5), 20) returns the Jacobi triple product expansion"
    - "quinprod(z,q,prodid) displays the quintuple product identity in product form as a string"
    - "quinprod(z,q,seriesid) displays the quintuple product identity in series form as a string"
    - "quinprod(z,q,10) still computes numerical result (existing behavior unchanged)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "jacobi_product_to_fps_garvan function, 2-arg jac2series dispatch, quinprod identity branches"
      contains: "jacobi_product_to_fps_garvan"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Integration tests for jac2series 2-arg and quinprod identity modes"
  key_links:
    - from: "jac2series 2-arg dispatch"
      to: "jacobi_product_to_fps_garvan"
      via: "function call for Garvan convention"
      pattern: "jacobi_product_to_fps_garvan"
    - from: "quinprod dispatch"
      to: "Value::Symbol matching"
      via: "symbol string match on prodid/seriesid"
      pattern: "prodid.*seriesid"
---

<objective>
Overhaul jac2series to support Garvan's 2-arg signature and fix JAC(0,b) expansion, plus add quinprod prodid/seriesid identity display modes.

Purpose: FUNC-01 enables jac2series(jacexpr, T) matching Garvan's qseries 1.3 signature. FUNC-03 enables quinprod identity display for mathematical reference.
Output: Working jac2series 2-arg form with correct JAC(0,b) handling, quinprod prodid/seriesid string display.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-new-functions/50-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: jac2series 2-arg Garvan form with JAC(0,b) fix</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
1. Add a new function `jacobi_product_to_fps_garvan(factors, sym, order)` near the existing `jacobi_product_to_fps` (around line 2411). This uses Garvan's JAC convention:
   - JAC(0, b) = (q^b; q^b)_inf = `etaq(b, b, sym, order)` (NOT etaq(0, b) which returns zero)
   - JAC(a, b) for 0 < a < b = triple product = `jacprod(a, b, sym, order)` (the existing qseries::jacprod does (q^a;q^b)(q^{b-a};q^b)(q^b;q^b))
   - JAC(a, b) for a < 0: reduce via ((a % b) + b) % b then use the appropriate case
   - JAC(a, b) for a >= b: reduce via a % b, if result is 0 use etaq(b,b), else use jacprod
   - Exponent handling: positive exp multiplies, negative exp inverts (same pattern as existing jacobi_product_to_fps)
   - Keep existing `jacobi_product_to_fps` UNCHANGED -- it is used by series(), qs2jaccombo, and other code

2. Modify the `"jac2series"` dispatch (line ~4650) to accept BOTH 2-arg and 3-arg forms:
   - Replace `expect_args(name, args, 3)?;` with an if/else on `args.len()`
   - 2-arg path: `jac2series(jacexpr, T)` -- extract JacobiProduct from args[0], extract order from args[1], call `jacobi_product_to_fps_garvan(&factors, env.sym_q, order)`, print formatted result, return Value::Series
   - 3-arg path: keep existing code exactly (backward compatibility) -- extract JacobiProduct, extract_symbol_id, extract_i64, call `jacobi_product_to_fps` (NOT garvan)
   - If args.len() is neither 2 nor 3, return WrongArgCount error with expected "2 or 3"

3. Update `get_signature` for "jac2series" (line ~5662) from `"(JP, q, T)"` to `"(jacexpr, T) or (JP, q, T)"`.

4. Add unit tests in the `#[cfg(test)]` module:
   - `dispatch_jac2series_2arg_basic`: jac2series(JAC(1,5), 20) 2-arg form returns same etaq-based expansion as the triple product jacprod(1,5)
   - `dispatch_jac2series_2arg_jac0b`: jac2series(JAC(0,1), 20) 2-arg form returns same result as etaq(1, 1, q, 20) -- the (q;q)_inf Euler function
   - `dispatch_jac2series_3arg_unchanged`: jac2series(JAC(1,5), q, 20) 3-arg form still works (existing test pattern, just verify it still passes)
   - `dispatch_jac2series_2arg_product`: jac2series(JAC(1,5)*JAC(4,5), 20) returns the combined product expansion

IMPORTANT: The 2-arg Garvan jac2series(JAC(a,b), T) expands JAC(a,b) as the TRIPLE product (q^a;q^b)(q^{b-a};q^b)(q^b;q^b), which is DIFFERENT from the 3-arg legacy path that uses single Pochhammer etaq(a,b). The function `jacobi_product_to_fps_garvan` calls `qseries::jacprod(a, b, sym, order)` which already computes the triple product correctly. Do NOT use etaq(a, b) for the 2-arg path when 0 < a < b.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test --package qsym-cli dispatch_jac2series 2>&1 | tail -20`
All jac2series tests pass (existing 3-arg tests unchanged, new 2-arg tests green).
  </verify>
  <done>
jac2series accepts 2-arg (Garvan) and 3-arg (legacy) forms. JAC(0,b) expands correctly via etaq(b,b). All existing jac2series tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: quinprod prodid/seriesid identity modes and integration tests</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
1. In the `"quinprod"` dispatch (line ~3272), add identity mode detection BEFORE the existing numeric/bivariate dispatch. The logic should be:
   - Inside the `if args.len() == 3` block, BEFORE the `is_symbolic_outer` check, add:
   ```
   if let Value::Symbol(mode) = &args[2] {
       let mode_str = mode.as_str();
       if mode_str == "prodid" || mode_str == "seriesid" {
           let z_str = match &args[0] {
               Value::Symbol(s) => s.clone(),
               _ => "z".to_string(),
           };
           let q_str = match &args[1] {
               Value::Symbol(s) => s.clone(),
               _ => "q".to_string(),
           };
           let identity = if mode_str == "prodid" {
               format_quinprod_prodid(&z_str, &q_str)
           } else {
               format_quinprod_seriesid(&z_str, &q_str)
           };
           println!("{}", identity);
           return Ok(Value::String(identity));
       }
   }
   ```
   - Note: This must be BEFORE the `is_symbolic_outer` check because `prodid` and `seriesid` are symbols but should not be treated as q-variable symbols.

2. Add two helper functions near the quinprod dispatch (or in a helper section):
   - `format_quinprod_prodid(z: &str, q: &str) -> String`: Returns the quintuple product identity in product form. Format:
     `"({z},{q})_inf * ({q}/{z},{q})_inf * ({z}^2,{q}^2)_inf * ({q}^2/{z}^2,{q}^2)_inf * ({q},{q})_inf"`
   - `format_quinprod_seriesid(z: &str, q: &str) -> String`: Returns the product side PLUS equals series side. Format:
     Same product string, then newline, then `"  = sum(m=-inf..inf, ({z}^(3*m) - {z}^(-3*m-1)) * {q}^(m*(3*m+1)/2))"`

3. Update `get_signature` for "quinprod" to include the identity modes: `"(z, q, T) or (z, q, prodid) or (z, q, seriesid)"`.

4. Add unit tests:
   - `dispatch_quinprod_prodid`: quinprod(z_sym, q_sym, prodid_sym) returns Value::String containing "(z,q)_inf" and "(q,q)_inf"
   - `dispatch_quinprod_seriesid`: quinprod(z_sym, q_sym, seriesid_sym) returns Value::String containing "sum" and "3*m"
   - `dispatch_quinprod_numeric_unchanged`: quinprod(z_sym, q_sym, Integer(10)) still returns a BivariateSeries (existing behavior)

5. Add integration tests in `cli_integration.rs`:
   - `jac2series_2arg_garvan`: run `jac2series(JAC(1,5), 20)` and check output contains series terms (e.g., "1 - q")
   - `jac2series_2arg_jac0`: run `jac2series(JAC(0,1), 10)` and check output contains Euler function terms (the partition function reciprocal: 1 - q - q^2 + q^5 + q^7 ...)
   - `quinprod_prodid`: run `quinprod(z,q,prodid)` and check output contains "(z,q)_inf"
   - `quinprod_seriesid`: run `quinprod(z,q,seriesid)` and check output contains "sum"
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test --package qsym-cli quinprod 2>&1 | tail -20`
and: `cargo test --package qsym-cli jac2series 2>&1 | tail -20`
All quinprod and jac2series tests pass. Existing tests unchanged.
  </verify>
  <done>
quinprod(z,q,prodid) and quinprod(z,q,seriesid) display identity strings. Existing quinprod numeric behavior unchanged. jac2series and quinprod integration tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --package qsym-cli dispatch_jac2series` -- all jac2series dispatch tests pass
2. `cargo test --package qsym-cli quinprod` -- all quinprod tests pass (identity + numeric)
3. `cargo test --package qsym-cli --test cli_integration jac2series` -- integration tests pass
4. `cargo test --package qsym-cli --test cli_integration quinprod` -- integration tests pass
5. Existing test suite: `cargo test --package qsym-cli` -- no regressions
</verification>

<success_criteria>
- jac2series(JAC(0,1), 50) returns the Euler function expansion to O(q^50)
- jac2series(JAC(1,5), 20) returns the Jacobi triple product J(1,5)
- jac2series(JAC(1,5), q, 20) still works (backward compat)
- quinprod(z,q,prodid) returns product-form identity string
- quinprod(z,q,seriesid) returns series-form identity string
- quinprod(z,q,10) still returns BivariateSeries (unchanged)
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/50-new-functions/50-01-SUMMARY.md`
</output>
