---
phase: 50-new-functions
plan: 02
type: execute
wave: 2
depends_on: [50-01]
files_modified:
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [FUNC-02, FUNC-04]

must_haves:
  truths:
    - "X[1] parses as a valid variable name in expressions and assignments"
    - "subs(X[1]=q, X[2]=q^2, expr) performs multiple indexed-variable substitutions"
    - "subs(q=1, expr) still works (backward compatibility for single substitution)"
    - "theta3(q^5, 20) computes the theta3 series evaluated at q^5, with correct truncation"
    - "radsimp(theta3(q,100)/theta3(q^5,20)) returns a simplified series"
    - "radsimp(series) returns the series unchanged (identity for already-evaluated)"
  artifacts:
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Subscript parsing: X[i] becomes Variable('X[i]')"
      contains: "LBracket"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Multi-arg subs, theta monomial support, radsimp dispatch"
      contains: "radsimp"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Integration tests for subs multi-arg, subscript vars, radsimp"
  key_links:
    - from: "parser.rs subscript parsing"
      to: "AstNode::Variable with bracket name"
      via: "X[1] -> Variable('X[1]')"
      pattern: "Variable.*\\[.*\\]"
    - from: "subs AST interception"
      to: "perform_substitution"
      via: "loop over substitution pairs"
      pattern: "args\\.len\\(\\) - 1"
    - from: "theta3 2-arg monomial path"
      to: "qseries::theta3"
      via: "exponent scaling for q^k argument"
      pattern: "extract_monomial.*theta"
    - from: "radsimp dispatch"
      to: "args[0].clone()"
      via: "identity function returning evaluated argument"
      pattern: "radsimp"
---

<objective>
Add parser subscript syntax for indexed variables (X[1]), extend subs to multi-substitution, enhance theta functions to accept monomial arguments (q^k), and add radsimp as a series simplification function.

Purpose: FUNC-04 enables the findnonhom workflow with indexed variable substitution. FUNC-02 enables radsimp for series quotient simplification, which requires theta functions to handle monomial args like q^5.
Output: Working subscript parsing, multi-arg subs, theta monomial support, and radsimp function.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-new-functions/50-RESEARCH.md
@.planning/phases/50-new-functions/50-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser subscript syntax and multi-arg subs</name>
  <files>crates/qsym-cli/src/parser.rs, crates/qsym-cli/src/eval.rs</files>
  <action>
1. **Parser subscript syntax** in `parser.rs`. In the LED loop of `expr_bp()` (around line 316), add subscript handling BEFORE the infix_bp check (line 382) but AFTER the Arrow handler (line 379). Insert this block:

   ```rust
   // Subscript: X[i] -- index into a variable
   if *self.peek() == Token::LBracket {
       if 19 < min_bp { break; } // same precedence as function call
       if let AstNode::Variable(ref name) = lhs {
           let saved_name = name.clone();
           self.advance(); // consume [
           let index = self.expr_bp(0)?;
           self.expect(&Token::RBracket, "']' to close subscript")?;
           if let AstNode::Integer(i) = &index {
               lhs = AstNode::Variable(format!("{}[{}]", saved_name, i));
               continue;
           }
           // Non-integer subscript
           return Err(ParseError::new(
               "subscript index must be an integer".to_string(),
               self.peek_span(),
           ));
       }
       break; // Not a variable on the left, don't subscript
   }
   ```

   This makes `X[1]` parse as `AstNode::Variable("X[1]")`, which works seamlessly with the existing variable assignment and lookup machinery. The `[1]` part is consumed as subscript syntax, NOT as a list literal.

   IMPORTANT: The binding power check `19 < min_bp` must use the same value as function call (19) so subscripts bind at the same level. The `break` at the end (non-variable case) prevents `5[1]` from parsing as a subscript.

2. **Multi-arg subs** in `eval.rs`. Modify the subs AST interception (line ~1089):
   - Change `if args.len() != 2` to `if args.len() < 2`
   - Update the error message: expected "at least 2", signature "subs(var=val, ..., expr)"
   - Replace the single-substitution block with a loop:
     ```rust
     // Evaluate target (last argument)
     let mut target = eval_expr(&args[args.len() - 1], env)?;
     // Process each substitution pair (all args except the last)
     for i in 0..(args.len() - 1) {
         match &args[i] {
             AstNode::Compare { op: CompOp::Eq, lhs, rhs } => {
                 let var_name = match lhs.as_ref() {
                     AstNode::Variable(vname) => vname.clone(),
                     _ => return Err(EvalError::Other(
                         "subs: left side of = must be a variable name".into()
                     )),
                 };
                 let sub_value = eval_expr(rhs, env)?;
                 target = perform_substitution(&var_name, sub_value, target, env)?;
             }
             _ => return Err(EvalError::Other(
                 "subs: each substitution must be var=value".into()
             )),
         }
     }
     return Ok(target);
     ```
   - Note: `perform_substitution` already handles the case where var_name doesn't match the series variable (returns target unchanged), so multi-sub with different variable names works correctly by iterating.

3. Update `get_signature` for "subs" from `"(var=val, expr)"` to `"(var=val, ..., expr)"`.

4. Add parser unit tests (in parser.rs `#[cfg(test)]` module):
   - `parse_subscript_variable`: "X[1]" parses as Variable("X[1]")
   - `parse_subscript_in_assignment`: "X[1] := 5" parses as Assign { name: "X[1]", ... }
   - `parse_subscript_in_expression`: "X[1] + X[2]" parses as BinOp(Add, Variable("X[1]"), Variable("X[2]"))

5. Add eval unit tests:
   - `subs_multi_substitution`: Create a series with variable q, test subs(q=1, ...) still works with single pair
   - `subs_indexed_variable`: Test subs with indexed variable names (X[1]=value) -- this works because X[1] is just a variable name string, and perform_substitution matches by name
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test --package qsym-cli parse_subscript 2>&1 | tail -20`
and: `cargo test --package qsym-cli subs 2>&1 | tail -20`
All parser subscript tests and subs tests pass.
  </verify>
  <done>
X[1] parses as Variable("X[1]"). subs accepts multiple var=val pairs. subs(q=1, expr) backward compatibility maintained.
  </done>
</task>

<task type="auto">
  <name>Task 2: Theta monomial support, radsimp, and integration tests</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
1. **Enhance theta2, theta3, theta4 to accept monomial arguments** in the 2-arg path. For each theta function's 2-arg branch (theta3 is at line ~3505), modify the dispatch to handle Value::Series (monomial) as the first argument:

   For theta3 (modify the `else if args.len() == 2` branch):
   ```rust
   } else if args.len() == 2 {
       match &args[0] {
           Value::Symbol(s) => {
               // Existing: theta3(q, T)
               let sym = env.symbols.intern(s);
               let order = extract_i64(name, args, 1)?;
               Ok(Value::Series(qseries::theta3(sym, order)))
           }
           Value::Series(mono) => {
               // New: theta3(q^k, T) -- compute theta3 at monomial argument
               let terms: Vec<_> = mono.iter().collect();
               if terms.len() == 1 {
                   let (&exp, coeff) = terms[0];
                   if *coeff == QRat::one() && exp > 0 {
                       let order = extract_i64(name, args, 1)?;
                       let sym = mono.variable();
                       // Compute theta3(q, order*exp) then extract terms divisible by exp
                       let full = qseries::theta3(sym, order * exp);
                       let mut new_coeffs = std::collections::BTreeMap::new();
                       for (&e, c) in full.iter() {
                           if e % exp == 0 {
                               new_coeffs.insert(e / exp, c.clone());
                           }
                       }
                       let result = FormalPowerSeries::from_coeffs(sym, new_coeffs, order);
                       return Ok(Value::Series(result));
                   }
               }
               Err(EvalError::Other(format!(
                   "{}: first argument must be a variable or q^k monomial", name
               )))
           }
           _ => {
               let sym = extract_symbol_id(name, args, 0, env)?;
               let order = extract_i64(name, args, 1)?;
               Ok(Value::Series(qseries::theta3(sym, order)))
           }
       }
   }
   ```

   Apply the same pattern to theta2 and theta4. For theta2, note that theta2 involves half-integer exponents (q^(1/4) factor), so the monomial support for theta2 may produce fractional power series. If theta2(q^k) is complex, it's acceptable to skip the monomial path for theta2 and only implement it for theta3 and theta4 (the success criteria only mention theta3). Add a clear error message for theta2 if monomial arg is given: "theta2: monomial argument q^k not supported, use subs(q=q^k, theta2(q,T)) instead".

   CRITICAL: When extracting terms from theta3(q, order*exp), the result exponents must be DIVIDED by exp (not kept as-is). This maps q^(k*n) back to q^n in the output. The truncation order of the result is `order` (the user-provided T), not `order*exp`. Use `FormalPowerSeries::from_coeffs(sym, new_coeffs, order)` with the original order.

2. **Add radsimp function** to the dispatch table. Add it near the end of the dispatch (before the unknown function handler, line ~4944):
   ```rust
   "radsimp" => {
       expect_args(name, args, 1)?;
       // radsimp simplifies rational series expressions.
       // Since series division is already computed during evaluation,
       // radsimp acts as an identity function -- the simplification
       // already happened when the argument was evaluated.
       // For Series: return as-is (already simplified)
       // For other types: return as-is
       let result = args[0].clone();
       // Print the result for display
       let formatted = crate::format::format_value(&result, &env.symbols);
       println!("{}", formatted);
       Ok(result)
   }
   ```

3. Add "radsimp" to `ALL_FUNCTION_NAMES` (line ~5716, in Pattern S or a new pattern).

4. Add `get_signature` entry for "radsimp": `"(expr) -- simplify rational series expression"`.

5. Add unit tests:
   - `dispatch_theta3_monomial`: theta3(q^5, 10) returns a Series -- verify it has the right number of terms and correct coefficients (theta3(q^5,10) should have terms at q^0, q^5, q^20, q^45... but mapped back, so coefficients at exponents 0, 1, 4, 9 which are the squares)
   - Wait -- actually theta3(q) = sum q^(n^2). So theta3(q^5, T) should equal the series obtained by substituting q -> q^5 in theta3. The exponents in the output should be the n^2 values (0, 1, 4, 9, 16, 25...) since we divide by exp=5 after computing theta3(q, 5*T). Actually let me reconsider:
     theta3(q, N) = 1 + 2q + 2q^4 + 2q^9 + ... up to O(q^N)
     theta3(q^5, T) should give: 1 + 2q^5 + 2q^20 + 2q^45 + ... up to O(q^(5T))
     After the computation: compute theta3(q, 5T), then keep only terms where exponent % 5 == 0, and DON'T divide exponents by 5. The result should have exponents that are multiples of 5.

     CORRECTION to the code above: Do NOT divide exponents by exp. The output should keep the original exponents (multiples of k). The truncation order should be order * exp. So:
     ```rust
     let mut new_coeffs = std::collections::BTreeMap::new();
     for (&e, c) in full.iter() {
         if e % exp == 0 {
             new_coeffs.insert(e, c.clone()); // Keep original exponent, not e/exp
         }
     }
     let result = FormalPowerSeries::from_coeffs(sym, new_coeffs, order * exp);
     ```
     This way theta3(q^5, 20) returns 1 + 2q^5 + 2q^20 + 2q^45 + ... + O(q^100), and dividing by theta3(q^5, 20) works correctly because both series use the same variable and truncation.

   - `dispatch_radsimp_identity`: radsimp(series_value) returns the same series unchanged
   - `dispatch_radsimp_integer`: radsimp(Integer(5)) returns Integer(5)

6. Add integration tests in `cli_integration.rs`:
   - `subscript_variable_assignment`: run `X[1] := 5; X[1]` and check output is "5"
   - `subs_multi_indexed`: run `subs(q=0, 1 + q + q^2)` (single sub) and verify "1"
   - `theta3_monomial`: run `theta3(q^2, 10)` and check output contains series terms with even exponents
   - `radsimp_series`: run `radsimp(theta3(q,20))` and check output matches theta3(q,20)
   - `radsimp_quotient`: run `radsimp(theta3(q,50)/theta3(q^5,10))` and check output is a non-trivial series
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test --package qsym-cli radsimp 2>&1 | tail -20`
and: `cargo test --package qsym-cli theta3_monomial 2>&1 | tail -20`
and: `cargo test --package qsym-cli --test cli_integration subscript 2>&1 | tail -20`
and: `cargo test --package qsym-cli 2>&1 | tail -5` (full suite, no regressions)
  </verify>
  <done>
theta3(q^k, T) computes correctly with monomial argument. radsimp(expr) returns simplified series. Subscript variables work in assignments and expressions. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --package qsym-cli parse_subscript` -- parser subscript tests pass
2. `cargo test --package qsym-cli subs` -- subs multi-arg tests pass
3. `cargo test --package qsym-cli theta3_monomial` -- theta monomial support works
4. `cargo test --package qsym-cli radsimp` -- radsimp function works
5. `cargo test --package qsym-cli --test cli_integration subscript` -- integration tests pass
6. `cargo test --package qsym-cli --test cli_integration radsimp` -- integration tests pass
7. Full suite: `cargo test --package qsym-cli` -- no regressions
</verification>

<success_criteria>
- X[1] := theta3(q, 200) works (subscript variable assignment)
- subs(X[1]=q, X[2]=q^2, expr) performs multi-substitution
- subs(q=1, expr) still works (backward compat)
- theta3(q^5, 20) returns correct series with terms at multiples of 5
- radsimp(theta3(q,100)/theta3(q^5,20)) returns a series
- radsimp(5) returns 5 (identity for non-series)
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/50-new-functions/50-02-SUMMARY.md`
</output>
