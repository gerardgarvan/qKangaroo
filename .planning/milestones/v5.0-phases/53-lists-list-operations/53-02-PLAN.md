---
phase: 53-lists-list-operations
plan: 02
type: execute
wave: 2
depends_on: [53-01]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements: [LIST-01, LIST-02, LIST-03, LIST-04]

must_haves:
  truths:
    - "nops([a, b, c]) returns 3"
    - "nops works on series (counts nonzero terms) and integers (returns 1)"
    - "op(2, [a, b, c]) returns b (1-indexed)"
    - "op works on series (returns i-th nonzero term as [exponent, coefficient] list)"
    - "map(f, [1,2,3]) applies builtin f to each element returning a list"
    - "map works with user-defined procedures (lambda and proc)"
    - "sort([3,1,2]) returns [1,2,3]"
    - "sort handles mixed numeric types (Integer and Rational)"
    - "All 4 new functions have help entries and tab completion"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "nops, op, map, sort dispatch entries in dispatch()"
      contains: "\"nops\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entries for nops, op, map, sort in FUNC_HELP and general_help"
      contains: "nops"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "Tab completion entries for nops, op, map, sort"
      contains: "\"nops\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "dispatch()"
      via: "nops/op/map/sort match arms in dispatch function"
      pattern: "\"nops\"|\"op\"|\"map\"|\"sort\""
    - from: "crates/qsym-cli/src/eval.rs"
      to: "ALL_FUNCTION_NAMES"
      via: "New function names added to ALL_FUNCTION_NAMES array"
      pattern: "\"nops\", \"op\", \"map\", \"sort\""
    - from: "crates/qsym-cli/src/eval.rs"
      to: "call_procedure"
      via: "map implementation calls call_procedure for Value::Procedure callbacks"
      pattern: "call_procedure"
---

<objective>
Add nops, op, map, and sort as dispatch functions in eval.rs, with help entries in help.rs and tab completion in repl.rs. Update function count constants in tests.

Purpose: Complete the list manipulation requirements (LIST-01 through LIST-04) so researchers can inspect, transform, and sort lists using familiar Maple syntax.

Output: Four working list functions with help text and tab completion, function counts updated from 101 to 105.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-lists-list-operations/53-RESEARCH.md
@.planning/phases/53-lists-list-operations/53-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/repl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nops, op, map, sort dispatch entries and ALL_FUNCTION_NAMES</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
**Add four new dispatch arms** in the `dispatch()` function. Place them after the existing Pattern T (radsimp) section, in a new section:

```rust
// Pattern U: List operations
"nops" => { ... }
"op" => { ... }
"map" => { ... }
"sort" => { ... }
```

**nops implementation (LIST-01):**
```rust
"nops" => {
    expect_args(name, args, 1)?;
    match &args[0] {
        Value::List(items) => Ok(Value::Integer(QInt::from(items.len() as i64))),
        Value::Series(fps) => {
            // Count nonzero terms
            let count = fps.iter().filter(|(_, c)| !c.is_zero()).count();
            Ok(Value::Integer(QInt::from(count as i64)))
        }
        Value::Integer(_) | Value::Rational(_) => Ok(Value::Integer(QInt::from(1i64))),
        Value::Symbol(_) => Ok(Value::Integer(QInt::from(1i64))),
        Value::BivariateSeries(bvs) => {
            // Count nonzero z-coefficients
            let count = bvs.iter().filter(|(_, fps)| !fps.is_zero()).count();
            Ok(Value::Integer(QInt::from(count as i64)))
        }
        other => Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 0,
            expected: "list, series, integer, rational, or symbol",
            got: other.type_name().to_string(),
        }),
    }
}
```

Note: `fps.is_zero()` may not exist -- use `fps.iter().all(|(_, c)| c.is_zero())` or check if the BTreeMap is empty after filtering zeros. Check existing code patterns for how zero-checking is done on FPS.

**op implementation (LIST-02):**
```rust
"op" => {
    expect_args(name, args, 2)?;
    let i = match &args[0] {
        Value::Integer(n) => n.0.to_i64().ok_or_else(|| EvalError::Other(
            "op: index too large".to_string()
        ))?,
        _ => return Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 0,
            expected: "integer",
            got: args[0].type_name().to_string(),
        }),
    };
    match &args[1] {
        Value::List(items) => {
            if i < 1 || i as usize > items.len() {
                return Err(EvalError::Other(format!(
                    "op: index {} out of range (expression has {} operands)",
                    i, items.len()
                )));
            }
            Ok(items[(i - 1) as usize].clone())
        }
        Value::Series(fps) => {
            // Return i-th nonzero term as [exponent, coefficient]
            let nonzero: Vec<_> = fps.iter()
                .filter(|(_, c)| !c.is_zero())
                .collect();
            if i < 1 || i as usize > nonzero.len() {
                return Err(EvalError::Other(format!(
                    "op: index {} out of range (series has {} nonzero terms)",
                    i, nonzero.len()
                )));
            }
            let (exp, coeff) = nonzero[(i - 1) as usize];
            Ok(Value::List(vec![
                Value::Integer(QInt::from(*exp)),
                if coeff.is_integer() {
                    Value::Integer(QInt(coeff.numer().clone()))
                } else {
                    Value::Rational(coeff.clone())
                },
            ]))
        }
        Value::Integer(_) | Value::Rational(_) | Value::Symbol(_) => {
            if i == 1 {
                Ok(args[1].clone())
            } else {
                Err(EvalError::Other(format!(
                    "op: index {} out of range (expression has 1 operand)", i
                )))
            }
        }
        other => Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 1,
            expected: "list, series, integer, rational, or symbol",
            got: other.type_name().to_string(),
        }),
    }
}
```

**map implementation (LIST-03):**
```rust
"map" => {
    expect_args(name, args, 2)?;
    let func = args[0].clone();
    let list = match &args[1] {
        Value::List(items) => items.clone(),
        other => return Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 1,
            expected: "list",
            got: other.type_name().to_string(),
        }),
    };
    let mut result = Vec::with_capacity(list.len());
    for elem in &list {
        let val = match &func {
            Value::Procedure(proc) => call_procedure(proc, &[elem.clone()], env)?,
            Value::Symbol(fname) => dispatch(fname, &[elem.clone()], env)?,
            other => return Err(EvalError::ArgType {
                function: name.to_string(),
                arg_index: 0,
                expected: "procedure or function name",
                got: other.type_name().to_string(),
            }),
        };
        result.push(val);
    }
    Ok(Value::List(result))
}
```

**sort implementation (LIST-04):**

First, add a helper function `compare_values_for_sort` outside dispatch:

```rust
/// Compare two Values for sorting purposes.
/// Numeric types are compared by value (Integer and Rational unified via QRat).
/// Symbols and strings are compared lexicographically.
/// Returns None if types are incomparable.
fn compare_values_for_sort(a: &Value, b: &Value) -> Option<std::cmp::Ordering> {
    match (a, b) {
        (Value::Integer(x), Value::Integer(y)) => Some(x.0.cmp(&y.0)),
        (Value::Rational(x), Value::Rational(y)) => Some(x.cmp(y)),
        (Value::Integer(x), Value::Rational(y)) => {
            let xr = QRat::from(x.0.clone());
            Some(xr.cmp(y))
        }
        (Value::Rational(x), Value::Integer(y)) => {
            let yr = QRat::from(y.0.clone());
            Some(x.cmp(&yr))
        }
        (Value::Symbol(x), Value::Symbol(y)) => Some(x.cmp(y)),
        (Value::String(x), Value::String(y)) => Some(x.cmp(y)),
        _ => None,
    }
}
```

Then the dispatch entry:
```rust
"sort" => {
    expect_args(name, args, 1)?;
    let list = match &args[0] {
        Value::List(items) => items.clone(),
        other => return Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 0,
            expected: "list",
            got: other.type_name().to_string(),
        }),
    };
    let mut sorted = list;
    let mut sort_error: Option<String> = None;
    sorted.sort_by(|a, b| {
        match compare_values_for_sort(a, b) {
            Some(ord) => ord,
            None => {
                if sort_error.is_none() {
                    sort_error = Some(format!(
                        "sort: cannot compare {} with {}",
                        a.type_name(), b.type_name()
                    ));
                }
                std::cmp::Ordering::Equal
            }
        }
    });
    if let Some(err) = sort_error {
        return Err(EvalError::Other(err));
    }
    Ok(Value::List(sorted))
}
```

**Update ALL_FUNCTION_NAMES** (around line 5988): Add a new comment block after Pattern T:
```rust
// Pattern U: List operations
"nops", "op", "map", "sort",
```

**Update the `function_count_verification` test** (around line 8310): Change the assertion from `count >= 78` to `count >= 82` (or equivalent to match the new total). The exact count after adding 4 entries should be the old count + 4.

**Add dispatch tests:**

1. `dispatch_nops_list`: `nops([1, 2, 3])` returns `Integer(3)`
2. `dispatch_nops_integer`: `nops(42)` returns `Integer(1)`
3. `dispatch_nops_series`: Create a simple series with known nonzero terms, verify count
4. `dispatch_op_list`: `op(2, [10, 20, 30])` returns `Integer(20)`
5. `dispatch_op_out_of_range`: `op(4, [1, 2, 3])` returns error
6. `dispatch_op_series`: `op(1, series)` returns `[exponent, coefficient]` list
7. `dispatch_map_builtin`: `map(numbpart, [1, 2, 3, 4, 5])` returns `[1, 2, 3, 5, 7]`
8. `dispatch_map_symbol`: Verify map with a symbol that names a builtin function
9. `dispatch_sort_integers`: `sort([3, 1, 2])` returns `[1, 2, 3]`
10. `dispatch_sort_rationals`: `sort([3/2, 1/2, 5/2])` returns `[1/2, 3/2, 5/2]`
11. `dispatch_sort_mixed_numeric`: `sort([3, 1/2, 2])` returns `[1/2, 2, 3]`
12. `dispatch_sort_symbols`: `sort([c, a, b])` returns `[a, b, c]` (where a, b, c are Value::Symbol)

**Integration tests using parse+eval:**
13. `eval_nops_list_expr`: Parse and eval `nops([1,2,3])` returns 3
14. `eval_op_list_expr`: Parse and eval `op(2, [10, 20, 30])` returns 20
15. `eval_map_with_lambda`: Parse and eval `map(x -> x*x, [1,2,3,4])` returns `[1, 4, 9, 16]` -- NOTE: lambdas evaluate to Value::Procedure, so map should handle them
16. `eval_sort_expr`: Parse and eval `sort([3, 1, 2])` returns `[1, 2, 3]`
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli dispatch_nops dispatch_op dispatch_map dispatch_sort eval_nops eval_op eval_map eval_sort -- --nocapture 2>&1 | tail -40` to verify all new dispatch and integration tests pass.
  </verify>
  <done>
`nops([a,b,c])` returns 3. `op(2, [a,b,c])` returns the second element. `map(f, [1,2,3])` applies f to each element. `sort([3,1,2])` returns `[1,2,3]`. All functions work with series and other Value types where appropriate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Help entries, tab completion, function count updates</name>
  <files>crates/qsym-cli/src/help.rs, crates/qsym-cli/src/repl.rs</files>
  <action>
**help.rs changes:**

1. Add a new category in `general_help()` text, after the "Simplification:" section and before "Number Theory:":

```
List Operations:
  nops    - number of operands/elements: nops([a,b,c]) = 3
  op      - extract i-th operand: op(2, [a,b,c]) = b
  map     - apply function to each element: map(f, [1,2,3])
  sort    - sort list elements: sort([3,1,2]) = [1,2,3]
```

2. Add four `FuncHelp` entries to the `FUNC_HELP` array. Place them in a new "Group U: List Operations" section:

```rust
// -----------------------------------------------------------------------
// Group U: List operations (4)
// -----------------------------------------------------------------------
FuncHelp {
    name: "nops",
    signature: "nops(expr)",
    description: "Return the number of operands of expr.  For a list, returns the\n  number of elements.  For a series, returns the number of nonzero terms.\n  For an integer, rational, or symbol, returns 1.",
    example: "nops([a, b, c])",
    example_output: "3",
},
FuncHelp {
    name: "op",
    signature: "op(i, expr)",
    description: "Extract the i-th operand of expr (1-indexed).  For a list, returns\n  the i-th element.  For a series, returns the i-th nonzero term as\n  [exponent, coefficient].",
    example: "op(2, [10, 20, 30])",
    example_output: "20",
},
FuncHelp {
    name: "map",
    signature: "map(f, list)",
    description: "Apply function f to each element of list, returning a new list.\n  f can be a built-in function name (symbol) or a user-defined procedure/lambda.",
    example: "map(x -> x^2, [1, 2, 3, 4])",
    example_output: "[1, 4, 9, 16]",
},
FuncHelp {
    name: "sort",
    signature: "sort(list)",
    description: "Sort the elements of list in ascending order.  Numeric values\n  (integers and rationals) are sorted by value.  Symbols and strings\n  are sorted lexicographically.",
    example: "sort([3, 1, 2])",
    example_output: "[1, 2, 3]",
},
```

3. Update the FUNC_HELP count test `func_help_count_matches_canonical` (around line 1183): Change from `99` to `103` (99 + 4 new entries).

4. Update the general_help doc comment: change "99 functions" to "103 functions".

**repl.rs changes:**

5. Add the 4 new function names to `canonical_function_names()`. Add a new group after Group M:
```rust
// Group U: List Operations (4)
"nops", "op", "map", "sort",
```

6. Update the `canonical_function_count` test (line 312): Change from `101` to `105`.

**Add help tests:**

7. `function_help_nops_returns_some`: Verify `function_help("nops")` returns Some with "nops" and "operands" in text.
8. `function_help_op_returns_some`: Verify `function_help("op")` returns Some.
9. `function_help_map_returns_some`: Verify `function_help("map")` returns Some with "Apply" in text.
10. `function_help_sort_returns_some`: Verify `function_help("sort")` returns Some with "Sort" in text.
11. `general_help_lists_section`: Verify `general_help()` contains "List Operations:" and "nops".
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -30` to verify ALL tests pass including function count assertions (105 in repl.rs, 103 in help.rs).
  </verify>
  <done>
`?nops`, `?op`, `?map`, `?sort` all show help text. Tab completion includes all 4 new names. Function count tests pass at 105 (repl.rs) and 103 (help.rs). General help shows "List Operations:" category.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (0 failures)
2. Manual check: `echo "nops([1,2,3]);" | cargo run -p qsym-cli --` outputs `3`
3. Manual check: `echo "op(2, [10, 20, 30]);" | cargo run -p qsym-cli --` outputs `20`
4. Manual check: `echo "map(x -> x^2, [1,2,3,4]);" | cargo run -p qsym-cli --` outputs `[1, 4, 9, 16]`
5. Manual check: `echo "sort([3, 1, 2]);" | cargo run -p qsym-cli --` outputs `[1, 2, 3]`
6. Manual check: `echo "map(numbpart, [1,2,3,4,5]);" | cargo run -p qsym-cli --` outputs `[1, 2, 3, 5, 7]`
</verification>

<success_criteria>
- nops([a,b,c]) returns 3, nops(series) returns nonzero term count, nops(integer) returns 1
- op(2, [a,b,c]) returns b, op(i, series) returns [exponent, coefficient]
- map(f, [1,2,3]) works with builtins (Symbol), procedures, and lambdas
- sort([3,1,2]) returns [1,2,3], sort handles mixed Integer/Rational
- All 4 functions have ?help entries and tab completion
- Function count: 105 in repl.rs, 103 in help.rs, >=82 in eval.rs
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/53-lists-list-operations/53-02-SUMMARY.md`
</output>
