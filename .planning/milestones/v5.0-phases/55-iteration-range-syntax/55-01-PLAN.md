---
phase: 55-iteration-range-syntax
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements:
  - ITER-01
  - ITER-02
  - ITER-03

must_haves:
  truths:
    - "add(i^2, i=1..5) returns 55"
    - "add(q^i/aqprod(q,q,i), i=0..5) computes a series sum"
    - "mul(1-q^i, i=1..5) returns the product polynomial matching aqprod(q,q,5)"
    - "seq(i^2, i=1..5) returns the list [1, 4, 9, 16, 25]"
    - "Range variable i is locally scoped -- outer i is not modified"
    - "Empty ranges return identity values (0 for add, 1 for mul, [] for seq)"
    - "Range expressions outside add/mul/seq produce a clear error"
  artifacts:
    - path: "crates/qsym-cli/src/token.rs"
      provides: "Token::DotDot variant"
      contains: "DotDot"
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode::Range { lo, hi } variant"
      contains: "Range"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Lexing of '..' as Token::DotDot"
      contains: "DotDot"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Infix parsing of DotDot into AstNode::Range"
      contains: "DotDot"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "eval_iteration_func for add/mul/seq special-case"
      contains: "eval_iteration_func"
  key_links:
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "infix handler constructs AstNode::Range from Token::DotDot"
      pattern: "AstNode::Range"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "FuncCall handler matches AstNode::Compare containing AstNode::Range"
      pattern: "AstNode::Range.*lo.*hi"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/eval.rs"
      via: "eval_iteration_func calls eval_add/eval_mul for accumulation"
      pattern: "eval_add|eval_mul"
---

<objective>
Implement Maple-style `add(expr, i=a..b)`, `mul(expr, i=a..b)`, and `seq(expr, i=a..b)` with range syntax.

Purpose: Researchers need concise iteration syntax for summation, products, and sequence generation -- the most common Maple patterns for q-series exploration.
Output: Working add/mul/seq with `..` range operator, complete with help entries and tab completion.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-iteration-range-syntax/55-RESEARCH.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/repl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Token::DotDot, AstNode::Range, and parser support for `..` operator</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/ast.rs
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/parser.rs
  </files>
  <action>
**token.rs:** Add `DotDot` variant to the `Token` enum, placed after the comparison operators section (before `Eof`). Doc comment: `/// \`..` range operator.`

**ast.rs:** Add `Range { lo: Box<AstNode>, hi: Box<AstNode> }` variant to `AstNode` enum, placed after `Lambda`. Doc comment: `/// Range expression: \`lo..hi\` (used in add/mul/seq iteration).`

**lexer.rs:** Add `b'.'` match arm BEFORE the "Unknown character" block (before line 299). Pattern:
```rust
if b == b'.' {
    if pos + 1 < bytes.len() && bytes[pos + 1] == b'.' {
        tokens.push(SpannedToken {
            token: Token::DotDot,
            span: Span::new(pos, pos + 2),
        });
        pos += 2;
    } else {
        return Err(ParseError::new(
            "unexpected character '.'".to_string(),
            Span::new(pos, pos + 1),
        ));
    }
    continue;
}
```

**parser.rs -- 4 changes:**

1. **`infix_bp()`** (line 600): Add `Token::DotDot => Some((10, 10)),` after the comparison operators line and BEFORE the `+`/`-` line. Binding power (10,10) makes `..` tighter than `=` (9,10) but looser than `+` (11,12), so `i=1+2..3+4` parses as `i = ((1+2)..(3+4))`.

2. **`expr_bp()` infix match block** (line 437-502): Add a new match arm for `Token::DotDot` BEFORE the `_ => unreachable!()` at line 502. This is CRITICAL -- without it, the parser panics. Insert:
```rust
Token::DotDot => {
    lhs = AstNode::Range {
        lo: Box::new(lhs),
        hi: Box::new(rhs),
    };
}
```
Place this arm between the `Token::And | Token::Or` arm (line 490) and the `_ => unreachable!()` (line 502).

3. **`token_name()`** (line 614): Add `Token::DotDot => "'..'".to_string(),` to the match block.

4. **Parser tests:** Add unit tests for:
   - `1..5` parses to `AstNode::Range { lo: Integer(1), hi: Integer(5) }`
   - `i=1..5` parses to `Compare(Eq, Variable("i"), Range(Integer(1), Integer(5)))` -- confirms `=` correctly binds looser than `..`
   - `1+2..3+4` parses to `Range(BinOp(Add,1,2), BinOp(Add,3,4))` -- confirms arithmetic binds tighter than `..`

**Lexer tests:** Add tests for:
   - `tokenize("1..5")` produces `[Integer(1), DotDot, Integer(5), Eof]`
   - `tokenize("i=1..5")` produces `[Ident("i"), Equal, Integer(1), DotDot, Integer(5), Eof]`
   - `tokenize(".")` produces an error containing "unexpected character '.'"
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib -- token:: lexer:: parser::` and confirm all existing + new tests pass. Zero panics on `..` input.
  </verify>
  <done>
Token::DotDot lexes correctly, AstNode::Range parses with correct precedence (looser than arithmetic, tighter than comparison), token_name handles DotDot, and all parser/lexer tests pass including the new ones.
  </done>
</task>

<task type="auto">
  <name>Task 2: Evaluator special-case for add/mul/seq, Range error handler, and registration</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/help.rs
    crates/qsym-cli/src/repl.rs
  </files>
  <action>
**eval.rs -- 4 changes:**

1. **`eval_expr` AstNode::Range handler:** Add a match arm for `AstNode::Range { .. }` in the main `eval_expr` function's match block. It should return an error: `"range expressions (a..b) are only valid inside add(), mul(), or seq()"`. This prevents confusion if someone writes `1..5` at top level.

2. **Add/mul/seq special-case in FuncCall handler:** In `eval_expr`, inside the `AstNode::FuncCall { name, args }` match arm, add a special-case block AFTER the `subs` special-case (line 1191) and AFTER the `print` special-case (line 1210), but BEFORE the user-defined procedure check (line 1212). This ensures the body expression is NOT eagerly evaluated. The block:

```rust
if name == "add" || name == "mul" || name == "seq" {
    return eval_iteration_func(name, args, env);
}
```

3. **`eval_iteration_func` function:** Create a new function (place near `eval_for_loop` around line 1565):

```rust
fn eval_iteration_func(
    name: &str,
    args: &[AstNode],
    env: &mut Environment,
) -> Result<Value, EvalError> {
    if args.len() != 2 {
        return Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "2".to_string(),
            got: args.len(),
            signature: format!("{}(expr, var=a..b)", name),
        });
    }
    // Extract iteration variable and range from args[1]
    let (var_name, lo, hi) = match &args[1] {
        AstNode::Compare { op: CompOp::Eq, lhs, rhs } => {
            let var = match lhs.as_ref() {
                AstNode::Variable(v) => v.clone(),
                _ => return Err(EvalError::Other(
                    format!("{}: expected variable on left of =", name)
                )),
            };
            let (lo_node, hi_node) = match rhs.as_ref() {
                AstNode::Range { lo, hi } => (lo.as_ref(), hi.as_ref()),
                _ => return Err(EvalError::Other(
                    format!("{}: expected range (a..b) on right of =", name)
                )),
            };
            let lo_val = eval_expr(lo_node, env)?;
            let hi_val = eval_expr(hi_node, env)?;
            let lo_i = value_to_i64(&lo_val, &format!("{} range start", name))?;
            let hi_i = value_to_i64(&hi_val, &format!("{} range end", name))?;
            (var, lo_i, hi_i)
        }
        _ => return Err(EvalError::Other(
            format!("{}: second argument must be var=a..b", name)
        )),
    };

    // Save and restore iteration variable (same pattern as eval_for_loop)
    let saved = env.variables.remove(&var_name);

    let result = (|| -> Result<Value, EvalError> {
        match name {
            "add" => {
                let mut acc = Value::Integer(QInt::from(0i64));
                for i in lo..=hi {
                    env.set_var(&var_name, Value::Integer(QInt::from(i)));
                    let val = eval_expr(&args[0], env)?;
                    acc = eval_add(acc, val, env)?;
                }
                Ok(acc)
            }
            "mul" => {
                let mut acc = Value::Integer(QInt::from(1i64));
                for i in lo..=hi {
                    env.set_var(&var_name, Value::Integer(QInt::from(i)));
                    let val = eval_expr(&args[0], env)?;
                    acc = eval_mul(acc, val, env)?;
                }
                Ok(acc)
            }
            "seq" => {
                let mut items = Vec::new();
                for i in lo..=hi {
                    env.set_var(&var_name, Value::Integer(QInt::from(i)));
                    let val = eval_expr(&args[0], env)?;
                    items.push(val);
                }
                Ok(Value::List(items))
            }
            _ => unreachable!(),
        }
    })();

    // Restore variable (even on error)
    match saved {
        Some(old_val) => env.set_var(&var_name, old_val),
        None => { env.variables.remove(&var_name); }
    }

    result
}
```

4. **Registration in eval.rs:**
   - **`ALL_FUNCTION_NAMES`** (~line 6431): Add `"add", "mul", "seq"` as a new comment group `// Pattern W: Iteration` at the end, before the closing `];`.
   - **`get_signature()`** (~line 6272): Add entries: `"add" => "(expr, i=a..b)".to_string()`, `"mul" => "(expr, i=a..b)".to_string()`, `"seq" => "(expr, i=a..b)".to_string()`.
   - **Update `function_count_verification` test** (~line 8757): The count check should increase by 3 (from the current value). Currently asserts `count >= 82`, update to `count >= 85`. Also check if there's an exact-count assertion and update it.

**help.rs -- 2 changes:**

1. **`general_help()`** (~line 16): Add a new "Iteration:" category after "Series Coefficients & Utility:" and before "Series Analysis:". Content:
```
Iteration:
  add    - sum expression over range: add(i^2, i=1..5)
  mul    - product over range: mul(1-q^i, i=1..5)
  seq    - generate list over range: seq(i^2, i=1..5)
```

2. **`FUNC_HELP`** (~line 185): Add 3 new `FuncHelp` entries in a new `// Group W: Iteration (3)` section:
   - `add`: signature `"add(expr, var=a..b)"`, description explains it sums expr as var ranges from a to b, var is locally scoped, empty range returns 0. Example: `"q> add(i^2, i=1..5)"` / `"55"`.
   - `mul`: signature `"mul(expr, var=a..b)"`, description explains it multiplies expr as var ranges from a to b, var is locally scoped, empty range returns 1. Example: `"q> mul(1-q^i, i=1..5)"` / the aqprod(q,q,5) polynomial.
   - `seq`: signature `"seq(expr, var=a..b)"`, description explains it collects expr into a list as var ranges from a to b. Example: `"q> seq(i^2, i=1..5)"` / `"[1, 4, 9, 16, 25]"`.
   - **Update FUNC_HELP count test** (`func_help_count_matches_canonical`): Change from 112 to 115.

**repl.rs -- 1 change:**

1. **`canonical_function_names()`** (~line 66): Add `"add", "mul", "seq"` in a new `// Group W: Iteration (3)` comment section. Update the `canonical_function_count` test from 114 to 117.

**eval.rs integration tests:** Add tests at the bottom of the test module:
- `add(i^2, i=1..5)` returns `Value::Integer(55)`
- `add(i, i=1..0)` returns `Value::Integer(0)` (empty range)
- `mul(i, i=1..5)` returns `Value::Integer(120)` (5! = 120)
- `mul(i, i=1..0)` returns `Value::Integer(1)` (empty range)
- `seq(i^2, i=1..5)` returns `Value::List([1, 4, 9, 16, 25])`
- `seq(i, i=1..0)` returns empty `Value::List([])`
- Variable scoping: `i:=99: add(i, i=1..3): i;` returns 99 (i restored)
- Negative bounds: `add(i, i=-2..2)` returns 0
- Range outside add/mul/seq: `1..5;` produces an error about range expressions

Also add a CLI integration test file or add to existing integration tests:
- `add(q^i/aqprod(q,q,i), i=0..5)` computes a series (verifies series accumulation works)
- `mul(1-q^i, i=1..5)` matches `aqprod(q,q,5)` (verifies product accumulation)
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli` and confirm ALL tests pass (existing + new). Then run the integration test suite: `cargo test -p qsym-cli --test integration` (or however integration tests are structured). Verify the function count tests pass with updated numbers.
  </verify>
  <done>
`add(i^2, i=1..5)` returns 55. `mul(1-q^i, i=1..5)` returns the aqprod(q,q,5) polynomial. `seq(i^2, i=1..5)` returns `[1, 4, 9, 16, 25]`. Variable scoping works (outer `i` is preserved). Empty ranges return identity values. `help add`, `help mul`, `help seq` show help text. Tab completion includes add, mul, seq. All existing tests still pass with 0 regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all unit tests pass including new ones for lexer, parser, eval
2. `cargo test -p qsym-cli --test integration` -- all integration tests pass
3. Manual REPL verification (optional):
   - `add(i^2, i=1..5)` prints `55`
   - `mul(1-q^i, i=1..5)` prints the aqprod polynomial
   - `seq(i^2, i=1..5)` prints `[1, 4, 9, 16, 25]`
   - `i:=42: add(i, i=1..3): i;` prints `42` (scoping)
   - `1..5;` prints a clear error message
   - `?add` shows help
</verification>

<success_criteria>
- All 4 roadmap success criteria are met (add returns 55, mul matches aqprod, seq returns list, variable scoping works)
- 3 new functions registered in all 5 locations (ALL_FUNCTION_NAMES, canonical_function_names, general_help, FUNC_HELP, get_signature)
- Token::DotDot + AstNode::Range integrate cleanly with existing lexer/parser
- All existing tests pass with 0 regressions
- Function count tests updated and passing (117 canonical, 115 FUNC_HELP, >=85 ALL_FUNCTION_NAMES)
</success_criteria>

<output>
After completion, create `.planning/phases/55-iteration-range-syntax/55-01-SUMMARY.md`
</output>
