---
phase: 01-expression-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/qsym-core/Cargo.toml
  - crates/qsym-core/src/lib.rs
  - crates/qsym-core/src/number.rs
  - crates/qsym-core/src/symbol.rs
  - crates/qsym-core/src/expr.rs
  - crates/qsym-core/src/arena.rs
  - crates/qsym-core/src/canonical.rs
  - crates/qsym-core/tests/arena_tests.rs
autonomous: true

must_haves:
  truths:
    - "Expressions with q-Pochhammer, theta, eta, and hypergeometric nodes can be constructed and stored in the arena"
    - "Structurally identical expressions always resolve to the same ExprRef (hash-consing deduplication)"
    - "O(1) structural equality via ExprRef u32 comparison"
    - "N-ary Add/Mul with canonical child ordering ensures a+b == b+a at ExprRef level"
  artifacts:
    - path: "Cargo.toml"
      provides: "Workspace root with crates/qsym-core member"
      contains: "workspace"
    - path: "crates/qsym-core/Cargo.toml"
      provides: "Crate manifest with rug, smallvec, rustc-hash, serde dependencies"
      contains: "rug"
    - path: "crates/qsym-core/src/expr.rs"
      provides: "Expr enum with ~12-14 variants (atoms, arithmetic, q-specific nodes) and ExprRef newtype"
      exports: ["Expr", "ExprRef"]
    - path: "crates/qsym-core/src/arena.rs"
      provides: "ExprArena with Vec<Expr> storage and FxHashMap<Expr, ExprRef> dedup table"
      exports: ["ExprArena"]
    - path: "crates/qsym-core/src/number.rs"
      provides: "QInt and QRat wrapper types around rug::Integer and rug::Rational with Hash/Eq"
      exports: ["QInt", "QRat"]
    - path: "crates/qsym-core/src/symbol.rs"
      provides: "SymbolId newtype and SymbolRegistry for string interning"
      exports: ["SymbolId", "SymbolRegistry"]
    - path: "crates/qsym-core/src/canonical.rs"
      provides: "make_add and make_mul functions that sort children before interning"
      exports: ["make_add", "make_mul"]
  key_links:
    - from: "crates/qsym-core/src/expr.rs"
      to: "crates/qsym-core/src/number.rs"
      via: "Expr::Integer(QInt) and Expr::Rational(QRat) variants"
      pattern: "QInt|QRat"
    - from: "crates/qsym-core/src/arena.rs"
      to: "crates/qsym-core/src/expr.rs"
      via: "ExprArena stores Vec<Expr> and dedup FxHashMap<Expr, ExprRef>"
      pattern: "Vec<Expr>|FxHashMap<Expr"
    - from: "crates/qsym-core/src/canonical.rs"
      to: "crates/qsym-core/src/arena.rs"
      via: "make_add/make_mul call arena.intern() after sorting children"
      pattern: "arena\\.intern"
    - from: "crates/qsym-core/src/arena.rs"
      to: "crates/qsym-core/src/symbol.rs"
      via: "ExprArena contains SymbolRegistry, provides intern_symbol helper"
      pattern: "SymbolRegistry|intern_symbol"
---

<objective>
Build the complete expression foundation: Cargo workspace, Expr enum with all Phase 1 node types, ExprArena with hash-consing, number wrappers for GMP types, symbol interning, and canonical ordering for commutative operations.

Purpose: This is the absolute foundation of Q-Symbolic. Every subsequent phase depends on being able to construct, store, and deduplicate expressions. Getting hash-consing right here means O(1) equality everywhere downstream.

Output: A compiling Rust workspace with crates/qsym-core containing the expression IR, arena, and passing hash-consing invariant tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace scaffold and all type definitions</name>
  <files>
    Cargo.toml
    crates/qsym-core/Cargo.toml
    crates/qsym-core/src/lib.rs
    crates/qsym-core/src/number.rs
    crates/qsym-core/src/symbol.rs
    crates/qsym-core/src/expr.rs
  </files>
  <action>
Create the Cargo workspace and all foundational type definitions. This task gets everything compiling.

1. **Workspace root Cargo.toml:**
   - Create `Cargo.toml` at project root as a workspace with member `crates/qsym-core`.
   - Set resolver = "2".

2. **crates/qsym-core/Cargo.toml:**
   - Package: name = "qsym-core", version = "0.1.0", edition = "2024", rust-version = "1.85".
   - Dependencies: rug = { version = "1.28", features = ["rational", "serde"] }, smallvec = { version = "1", features = ["const_generics", "serde"] }, serde = { version = "1.0", features = ["derive"] }, rustc-hash = "2".
   - Dev-dependencies: proptest = "1", serde_json = "1".

3. **number.rs -- QInt and QRat wrappers:**
   - `QInt(pub rug::Integer)` -- newtype wrapper. Derive Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize.
   - Implement `std::hash::Hash` for QInt: first try `#[derive(Hash)]`. If rug::Integer does not implement Hash (compiler will tell you), implement manually by hashing `self.0.to_digits::<u8>(rug::integer::Order::Msf)` and the sign via `self.0.cmp0()`.
   - `QRat(pub rug::Rational)` -- same pattern. rug::Rational is confirmed to implement Hash, so derive should work. If not, hash numerator and denominator separately.
   - Implement `From<i64>`, `From<i32>`, `From<(i64, i64)>` for convenience construction.
   - Implement basic arithmetic ops (Add, Sub, Mul) by delegating to rug, returning new QInt/QRat. These are needed so the TDD plan can test arithmetic without touching rug directly.
   - IMPORTANT: Verify the Hash invariant immediately -- `a == b` implies `hash(a) == hash(b)` -- by writing a quick compile-check. If rug types do not implement Hash, the manual implementation must be consistent.

4. **symbol.rs -- SymbolId and SymbolRegistry:**
   - `SymbolId(u32)` -- derive Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug, Serialize, Deserialize.
   - `SymbolRegistry` with `names: Vec<String>` and `lookup: FxHashMap<String, SymbolId>`.
   - Methods: `new()`, `intern(&mut self, name: &str) -> SymbolId`, `name(&self, id: SymbolId) -> &str`.
   - Append-only: symbols are never removed.

5. **expr.rs -- Expr enum and ExprRef:**
   - `ExprRef(u32)` -- derive Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug, Serialize, Deserialize.
   - `Expr` enum with these variants (derive Clone, Debug, Hash, Eq, PartialEq):
     - Atoms: `Integer(QInt)`, `Rational(QRat)`, `Symbol(SymbolId)`, `Infinity`, `Undefined`
     - Arithmetic: `Add(Vec<ExprRef>)`, `Mul(Vec<ExprRef>)`, `Neg(ExprRef)`, `Pow(ExprRef, ExprRef)`
     - q-Specific: `QPochhammer { base: ExprRef, nome: ExprRef, order: ExprRef }`, `JacobiTheta { index: u8, nome: ExprRef }`, `DedekindEta(ExprRef)`, `BasicHypergeometric { upper: SmallVec<[ExprRef; 4]>, lower: SmallVec<[ExprRef; 4]>, nome: ExprRef, argument: ExprRef }`
   - Do NOT derive Serialize/Deserialize on Expr yet (SmallVec serde can be tricky) -- add later if needed.
   - Keep Neg as a separate variant (not Mul([-1, x])) per research recommendation for Phase 1.

6. **lib.rs:**
   - Declare pub modules: `pub mod number;`, `pub mod symbol;`, `pub mod expr;`, `pub mod arena;`, `pub mod canonical;`, `pub mod render;`.
   - Re-export key types: `pub use expr::{Expr, ExprRef};`, `pub use arena::ExprArena;`, `pub use number::{QInt, QRat};`, `pub use symbol::{SymbolId, SymbolRegistry};`.
   - Create empty `render/mod.rs` as placeholder (will be populated in Plan 03).

Run `cargo build` in the workspace root. Fix any compilation errors. The goal is a clean build with zero warnings.
  </action>
  <verify>
Run `cargo build` from the workspace root. Must compile with zero errors. Run `cargo test` to confirm test harness works (no tests yet, but compilation of test targets must succeed).
  </verify>
  <done>
Workspace compiles cleanly. All type definitions exist with correct derives. QInt and QRat have working Hash implementations. SymbolRegistry interns and retrieves names. Expr enum has all ~14 variants. ExprRef is a Copy u32 newtype.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ExprArena with hash-consing and canonical ordering</name>
  <files>
    crates/qsym-core/src/arena.rs
    crates/qsym-core/src/canonical.rs
    crates/qsym-core/tests/arena_tests.rs
  </files>
  <action>
Implement the core hash-consing arena and canonical ordering, then prove correctness with tests.

1. **arena.rs -- ExprArena:**
   - Fields: `nodes: Vec<Expr>`, `dedup: FxHashMap<Expr, ExprRef>`, `symbols: SymbolRegistry`.
   - `ExprArena::new() -> Self` -- empty arena.
   - `intern(&mut self, expr: Expr) -> ExprRef` -- the core operation. Check dedup map first; if found, return existing ref. Otherwise push to nodes vec, insert in dedup, return new ref.
   - `get(&self, r: ExprRef) -> &Expr` -- O(1) lookup by index.
   - `len(&self) -> usize` -- number of interned expressions.
   - `intern_symbol(&mut self, name: &str) -> ExprRef` -- convenience: interns the name in SymbolRegistry, then interns Expr::Symbol(id) in the arena.
   - `intern_int(&mut self, val: impl Into<rug::Integer>) -> ExprRef` -- convenience for integers.
   - `intern_rat(&mut self, num: impl Into<rug::Integer>, den: impl Into<rug::Integer>) -> ExprRef` -- convenience for rationals.
   - `symbols(&self) -> &SymbolRegistry` -- accessor for rendering.
   - Do NOT implement removal or garbage collection. Arena is append-only.

2. **canonical.rs -- Canonical construction helpers:**
   - `make_add(arena: &mut ExprArena, mut children: Vec<ExprRef>) -> ExprRef`:
     - Sort children by ExprRef (u32 numeric order).
     - Dedup consecutive identical refs.
     - If 0 children: return arena.intern(Expr::Integer(QInt::from(0))).
     - If 1 child: return that child directly (no wrapping).
     - Otherwise: return arena.intern(Expr::Add(children)).
   - `make_mul(arena: &mut ExprArena, mut children: Vec<ExprRef>) -> ExprRef`:
     - Same pattern as make_add but for multiplication.
     - If 0 children: return arena.intern(Expr::Integer(QInt::from(1))) (multiplicative identity).
     - If 1 child: return that child directly.
     - Otherwise: return arena.intern(Expr::Mul(children)).
   - `make_neg(arena: &mut ExprArena, child: ExprRef) -> ExprRef`:
     - Returns arena.intern(Expr::Neg(child)).
   - `make_pow(arena: &mut ExprArena, base: ExprRef, exp: ExprRef) -> ExprRef`:
     - Returns arena.intern(Expr::Pow(base, exp)).
   - All q-specific constructors: `make_qpochhammer`, `make_jacobi_theta`, `make_dedekind_eta`, `make_basic_hypergeometric` -- thin wrappers around arena.intern() for the respective Expr variants.

3. **tests/arena_tests.rs -- Hash-consing invariant tests:**
   - Test: interning the same integer twice returns the same ExprRef. `assert_eq!(arena.intern_int(42), arena.intern_int(42))`.
   - Test: interning the same symbol twice returns the same ExprRef. `assert_eq!(arena.intern_symbol("q"), arena.intern_symbol("q"))`.
   - Test: interning the same QPochhammer (same base, nome, order refs) returns the same ExprRef.
   - Test: `make_add(arena, vec![a, b]) == make_add(arena, vec![b, a])` -- commutativity via canonical sorting.
   - Test: `make_mul(arena, vec![a, b]) == make_mul(arena, vec![b, a])` -- same for multiplication.
   - Test: `make_add` with 0 children returns integer zero.
   - Test: `make_add` with 1 child returns that child (unwrapping).
   - Test: `make_mul` with 0 children returns integer one.
   - Test: different expressions get different ExprRefs. `arena.intern_int(1) != arena.intern_int(2)`.
   - Test: arena.len() grows correctly (no spurious duplicates, no missed dedup).
   - Test: complex nested expression -- construct `(a;q)_inf + (a;q)_5` and verify both QPochhammer sub-expressions are interned only once.
   - Test: construct a JacobiTheta, DedekindEta, and BasicHypergeometric and verify round-trip through arena.get().
   - Use proptest for: generate random permutations of children for Add/Mul, verify they always produce the same ExprRef.

Run `cargo test` -- all tests must pass.
  </action>
  <verify>
Run `cargo test` from workspace root. All arena_tests must pass. Specifically verify:
- `cargo test arena_tests` shows all tests passing.
- No test should be `#[ignore]`.
- proptest tests run at least 256 cases without failure.
  </verify>
  <done>
ExprArena correctly interns and deduplicates all Expr variants. Canonical ordering ensures Add/Mul commutativity. All hash-consing invariants verified by tests. Arena convenience methods (intern_symbol, intern_int, intern_rat) work correctly. proptest confirms invariants hold for random inputs.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero errors and zero warnings in the workspace.
2. `cargo test` passes all tests in arena_tests.rs.
3. All Expr variants can be constructed and interned.
4. Hash-consing deduplication is verifiable: same structure -> same ExprRef.
5. Commutative operations (Add, Mul) are canonicalized: different child orderings produce the same ExprRef.
</verification>

<success_criteria>
- Workspace compiles: `cargo build` clean
- All ~12+ tests pass: `cargo test` green
- ExprRef equality works: structurally identical expressions get identical ExprRefs
- Canonical ordering works: shuffled Add/Mul children produce same result
- Arena grows correctly: no spurious duplicates, no missed dedup
- All 14 Expr variants are constructable and round-trip through arena.get()
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-foundation/01-01-SUMMARY.md`
</output>
