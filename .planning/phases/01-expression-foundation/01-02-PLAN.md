---
phase: 01-expression-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/qsym-core/src/number.rs
  - crates/qsym-core/tests/number_tests.rs
autonomous: true

must_haves:
  truths:
    - "BigInt arithmetic produces exact results for zero, negative, and large values"
    - "BigRat arithmetic produces exact results with auto-reduction to lowest terms"
    - "Edge cases (division by zero, 0^0, overflow from machine word) are handled correctly"
    - "QInt and QRat hash consistently: equal values always produce equal hashes"
  artifacts:
    - path: "crates/qsym-core/tests/number_tests.rs"
      provides: "Comprehensive edge-case test suite for QInt and QRat arithmetic"
      min_lines: 100
    - path: "crates/qsym-core/src/number.rs"
      provides: "QInt and QRat with arithmetic ops, Display, and From conversions"
      exports: ["QInt", "QRat"]
  key_links:
    - from: "crates/qsym-core/tests/number_tests.rs"
      to: "crates/qsym-core/src/number.rs"
      via: "Tests import QInt/QRat and exercise all arithmetic operations"
      pattern: "use qsym_core::.*(QInt|QRat)"
    - from: "crates/qsym-core/src/number.rs"
      to: "rug"
      via: "QInt wraps rug::Integer, QRat wraps rug::Rational"
      pattern: "rug::(Integer|Rational)"
---

<objective>
Verify arbitrary precision arithmetic correctness for QInt (BigInt) and QRat (BigRat) using TDD. Write failing tests first for all edge cases from the research, then ensure the number.rs implementation passes them all.

Purpose: Success criterion 2 requires "exact results matching GMP reference output for edge cases (zero, negative, large values)." This plan proves that QInt and QRat arithmetic is correct by testing every documented edge case from the research.

Output: Comprehensive test suite proving arithmetic correctness, plus any fixes to number.rs needed to pass.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-foundation/01-RESEARCH.md
@.planning/phases/01-expression-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Arbitrary Precision Arithmetic Correctness</name>
  <files>crates/qsym-core/src/number.rs, crates/qsym-core/tests/number_tests.rs</files>
  <behavior>
QInt (wrapping rug::Integer) and QRat (wrapping rug::Rational) must produce exact arithmetic results.

**Integer edge cases (from research):**
- 0 + 0 = 0 (zero identity)
- i64::MAX + 1 = correct big value (overflow from machine word)
- -1 * x = -x (sign handling)
- 0 * anything = 0 (zero annihilation)
- 0^0 = 1 (mathematical convention)
- (-2)^3 = -8 (negative base, odd exponent)
- 2^64 = 18446744073709551616 (exceeds u64)
- -0 == 0 (GMP normalizes -0)

**Rational edge cases (from research):**
- (6, 4) auto-reduces to 3/2
- (-3, -5) normalizes to 3/5 (double negative)
- (0, n) = 0 (zero numerator)
- (n, 0) = error/panic (zero denominator)
- 1/3 + 1/6 = 1/2 (common denominator + reduction)
- 1/2 - 1/2 = 0 (exact cancellation)
- (1/3) * (3/1) = 1 (multiplicative inverse)
- Large values: no precision loss on large numerator/denominator

**Hash invariant:**
- For all a, b: if a == b then hash(a) == hash(b)
- Specifically: QInt(0) and QInt(-0) must hash the same (GMP normalizes both to 0)
- QRat(2,4) and QRat(1,2) must hash the same (auto-reduction means they are ==)

**Display:**
- QInt displays as decimal string
- QRat displays as "num/den" for non-integers, as integer for integer-valued rationals
  </behavior>
  <implementation>
RED phase: Create tests/number_tests.rs with all the above test cases. Tests should import QInt and QRat from qsym_core. Run `cargo test number_tests` -- tests should compile but some may fail if number.rs is incomplete.

GREEN phase: Update number.rs to ensure all tests pass:
- Ensure From<i64>, From<i32>, From<(i64, i64)> conversions work
- Ensure Add, Sub, Mul, Div ops are implemented (delegating to rug)
- Ensure Neg is implemented for QInt
- Ensure Display formats correctly
- Ensure pow operation exists (at least as a method, e.g., `qi.pow(exp)`)
- Handle division by zero for QRat: either panic with clear message or return a Result

REFACTOR phase: Clean up if needed -- ensure ops take references where appropriate to avoid unnecessary cloning of GMP values.
  </implementation>
</feature>

<verification>
1. `cargo test number_tests` passes all tests (20+ test cases).
2. No `#[ignore]` tests remain.
3. Hash invariant holds for all tested values.
4. Zero denominator construction panics or returns error (not undefined behavior).
5. Large number arithmetic (2^64, 2^128) produces exact results.
</verification>

<success_criteria>
- All integer edge cases pass: zero identity, overflow, sign handling, zero annihilation, 0^0, negative base powers, large exponents, -0 normalization
- All rational edge cases pass: auto-reduction, double negative, zero numerator, zero denominator handling, common denominator arithmetic, exact cancellation, multiplicative inverse, large values
- Hash invariant verified: equal values always hash equally
- Display formatting correct for both types
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-foundation/01-02-SUMMARY.md`
</output>
