---
phase: 01-expression-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/qsym-core/src/render/mod.rs
  - crates/qsym-core/src/render/latex.rs
  - crates/qsym-core/src/render/unicode.rs
  - crates/qsym-core/tests/render_tests.rs
autonomous: true

must_haves:
  truths:
    - "Every Expr variant renders to valid LaTeX without compilation errors"
    - "Every Expr variant renders to readable Unicode for terminal display"
    - "LaTeX follows DLMF 17.2 notation for q-Pochhammer and basic hypergeometric"
    - "Unicode uses Greek letters, digit subscripts/superscripts with ASCII fallback"
    - "Nested expressions render with correct parenthesization and precedence"
  artifacts:
    - path: "crates/qsym-core/src/render/mod.rs"
      provides: "to_latex and DisplayExpr public API for rendering"
      exports: ["to_latex", "DisplayExpr"]
    - path: "crates/qsym-core/src/render/latex.rs"
      provides: "LaTeX rendering for all 14 Expr variants"
      min_lines: 80
    - path: "crates/qsym-core/src/render/unicode.rs"
      provides: "Unicode terminal rendering with fmt::Display for all Expr variants"
      min_lines: 80
    - path: "crates/qsym-core/tests/render_tests.rs"
      provides: "Snapshot tests for LaTeX and Unicode output of all Expr variants"
      min_lines: 100
  key_links:
    - from: "crates/qsym-core/src/render/latex.rs"
      to: "crates/qsym-core/src/arena.rs"
      via: "to_latex takes &ExprArena and ExprRef, traverses arena.get() recursively"
      pattern: "arena\\.get\\(|ExprArena"
    - from: "crates/qsym-core/src/render/unicode.rs"
      to: "crates/qsym-core/src/arena.rs"
      via: "DisplayExpr holds &ExprArena and ExprRef, implements fmt::Display"
      pattern: "arena\\.get\\(|ExprArena"
    - from: "crates/qsym-core/src/render/latex.rs"
      to: "crates/qsym-core/src/symbol.rs"
      via: "Renders Symbol(id) by looking up name in arena.symbols()"
      pattern: "symbols\\(\\)\\.name|SymbolRegistry"
    - from: "crates/qsym-core/src/render/unicode.rs"
      to: "crates/qsym-core/src/symbol.rs"
      via: "Same symbol name lookup for Unicode rendering"
      pattern: "symbols\\(\\)\\.name|SymbolRegistry"
---

<objective>
Implement LaTeX and Unicode rendering for all Expr variants, with comprehensive snapshot tests proving every expression type renders correctly.

Purpose: Success criteria 3 and 4 require that every expression type renders to valid LaTeX and readable Unicode. This is the user-facing output of the expression system -- researchers will see these renderings in terminals and papers.

Output: Complete render/ module with LaTeX and Unicode backends, plus snapshot tests for all Expr variants.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-foundation/01-RESEARCH.md
@.planning/phases/01-expression-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LaTeX and Unicode rendering for all Expr variants</name>
  <files>
    crates/qsym-core/src/render/mod.rs
    crates/qsym-core/src/render/latex.rs
    crates/qsym-core/src/render/unicode.rs
  </files>
  <action>
Implement both rendering backends. Reference the research for exact output formats.

1. **render/mod.rs -- Public API:**
   - `pub mod latex;`
   - `pub mod unicode;`
   - Re-export: `pub use latex::to_latex;`
   - Re-export: `pub use unicode::DisplayExpr;`

2. **render/latex.rs -- LaTeX rendering:**
   - Public function: `pub fn to_latex(arena: &ExprArena, expr: ExprRef) -> String`
   - Internal recursive function that pattern-matches on arena.get(expr) and builds a String.
   - Use an always-brace policy for subscripts and superscripts (e.g., `q^{2}` not `q^2`) to avoid edge-case bugs.
   - Rendering rules for each variant (from research):
     - `Integer(n)` where n >= 0: decimal string. Where n < 0: decimal string (the minus sign is part of the number).
     - `Rational(p/q)`: `\frac{p}{q}`. Always use \frac, never inline p/q.
     - `Symbol(id)`: Look up name. If it is a recognized Greek letter (alpha, beta, gamma, delta, epsilon, zeta, eta, theta, iota, kappa, lambda, mu, nu, xi, pi, rho, sigma, tau, upsilon, phi, chi, psi, omega -- and uppercase variants), emit `\alpha`, `\beta`, etc. Otherwise emit the name directly. Handle subscripted names like "x_1" -> `x_{1}`.
     - `Infinity`: `\infty`
     - `Undefined`: `\text{undefined}`
     - `Add(terms)`: Join with ` + `. Detect Neg children: if a child is Neg(x), render as ` - {x}` instead of ` + (-x)`.
     - `Mul(factors)`: Context-dependent. For numeric * symbolic: `2 q` (space, no cdot for simple cases). For general: join with ` \cdot `. Parenthesize Add children.
     - `Neg(x)`: If x is an atom, render `-x`. If x is compound, render `-(expr)` with \left( \right).
     - `Pow(base, exp)`: `{base}^{exp}`. Parenthesize base if it is Add, Mul, or Neg. Always brace exponent.
     - `QPochhammer { base, nome, order }`: `(base ; nome)_{order}` -- use `\left(` and `\right)` for the outer parens. Use ` ; ` with spaces. Subscript the order.
     - `JacobiTheta { index, nome }`: `\theta_{index}(nome)` -- use `\left(` `\right)` for the argument parens.
     - `DedekindEta(tau)`: `\eta\!\left(tau\right)` -- thin space before parens.
     - `BasicHypergeometric { upper, lower, nome, argument }`: Full matrix notation per DLMF 17.2: `{}_{r}\phi_{s}\!\left(\begin{matrix} a_1, \ldots, a_r \\ b_1, \ldots, b_s \end{matrix} ; q, z\right)` where r = upper.len(), s = lower.len(). Use `\left(` `\right)`.
   - Helper: `fn needs_parens(arena: &ExprArena, expr: ExprRef, context: ParenContext) -> bool` -- determines if an expression needs parentheses based on context (e.g., base of Pow, factor in Mul).
   - Helper: `fn greek_letter(name: &str) -> Option<&str>` -- maps "alpha" -> "\\alpha", etc. Include both lowercase and uppercase (Gamma -> "\\Gamma").

3. **render/unicode.rs -- Unicode terminal rendering:**
   - `pub struct DisplayExpr<'a> { pub arena: &'a ExprArena, pub expr: ExprRef }`
   - Implement `fmt::Display` for `DisplayExpr`.
   - Convenience method on ExprArena: `pub fn display(&self, expr: ExprRef) -> DisplayExpr` -- returns DisplayExpr { arena: self, expr }.
   - Rendering rules for each variant (from research):
     - `Integer(n)`: decimal string.
     - `Rational(p/q)`: "p/q" inline notation.
     - `Symbol(id)`: Look up name. Map Greek letter names to Unicode characters: "alpha" -> '\u{03b1}', "theta" -> '\u{03b8}', "eta" -> '\u{03b7}', "tau" -> '\u{03c4}', "phi" -> '\u{03c6}', "pi" -> '\u{03c0}', "psi" -> '\u{03c8}', etc. Non-Greek names render as-is.
     - `Infinity`: '\u{221e}' (infinity symbol).
     - `Undefined`: "undefined".
     - `Add(terms)`: Join with " + ". Detect Neg children for minus rendering.
     - `Mul(factors)`: Join with "*". Parenthesize Add children.
     - `Neg(x)`: "-x" for atoms, "-(expr)" for compound.
     - `Pow(base, exp)`: Try Unicode superscript for numeric exponents (digits 0-9 map to superscript characters: 0->\u{2070}, 1->\u{00b9}, 2->\u{00b2}, 3->\u{00b3}, 4->\u{2074}..9->\u{2079}). Handle negative exponents with superscript minus '\u{207b}'. For non-numeric exponents, fall back to "base^exp" or "base^(expr)".
     - `QPochhammer { base, nome, order }`: "(base;nome)" followed by subscript of order. Use Unicode digit subscripts (\u{2080}-\u{2089}) for numeric orders. For Infinity order, use '\u{221e}'. For symbolic orders, fall back to "_order".
     - `JacobiTheta { index, nome }`: "\u{03b8}" + subscript digit + "(nome)".
     - `DedekindEta(tau)`: "\u{03b7}(tau)".
     - `BasicHypergeometric`: "_{r}\u{03c6}_{s}(a1,...,ar; b1,...,bs; q, z)" with subscript digits for r and s.
   - Helper: `fn unicode_superscript(n: i64) -> Option<String>` -- converts a small integer to Unicode superscript characters. Returns None for numbers that cannot be fully represented.
   - Helper: `fn unicode_subscript(n: u64) -> String` -- converts a non-negative integer to Unicode subscript digit characters.
   - Helper: `fn greek_to_unicode(name: &str) -> Option<char>` -- maps "alpha" -> '\u{03b1}', etc.
  </action>
  <verify>
Run `cargo build` -- all render modules must compile. Manually inspect a few rendered expressions by adding a quick `#[test]` or `println!` in a test to confirm the output looks right.
  </verify>
  <done>
Both render backends compile and produce output for all 14 Expr variants. LaTeX uses always-brace policy and DLMF notation. Unicode uses Greek characters and subscript/superscript digits with ASCII fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive rendering snapshot tests</name>
  <files>
    crates/qsym-core/tests/render_tests.rs
  </files>
  <action>
Write snapshot tests that verify the exact LaTeX and Unicode output for every Expr variant, including nested expressions and edge cases.

Create `tests/render_tests.rs` with the following test structure:

1. **Helper function:** Create a shared `setup_arena()` that builds an ExprArena pre-populated with common sub-expressions: symbol "q", symbol "a", symbol "tau", symbol "alpha", integer 0, integer 1, integer 2, integer 5, integer -7, rational 3/4, Infinity.

2. **LaTeX tests -- one per Expr variant:**
   - `test_latex_integer_positive`: Integer(42) -> "42"
   - `test_latex_integer_negative`: Integer(-7) -> "-7"
   - `test_latex_integer_zero`: Integer(0) -> "0"
   - `test_latex_rational`: Rational(3/4) -> "\\frac{3}{4}"
   - `test_latex_rational_negative`: Rational(-1/3) -> "-\\frac{1}{3}" or "\\frac{-1}{3}"
   - `test_latex_symbol_simple`: Symbol("q") -> "q"
   - `test_latex_symbol_greek`: Symbol("alpha") -> "\\alpha"
   - `test_latex_infinity`: Infinity -> "\\infty"
   - `test_latex_undefined`: Undefined -> "\\text{undefined}"
   - `test_latex_add`: Add([a, b]) -> "a + b" (with actual symbol names)
   - `test_latex_add_with_neg`: Add([a, Neg(b)]) -> "a - b"
   - `test_latex_mul`: Mul([a, b]) -> "a \\cdot b"
   - `test_latex_neg_atom`: Neg(q) -> "-q"
   - `test_latex_neg_compound`: Neg(Add([a, b])) -> "-(a + b)" with proper LaTeX parens
   - `test_latex_pow`: Pow(q, 2) -> "q^{2}"
   - `test_latex_pow_compound_base`: Pow(Add([a, b]), 2) -> "(a + b)^{2}" with proper LaTeX parens
   - `test_latex_qpochhammer_finite`: QPochhammer(a, q, 5) -> "\\left(a ; q\\right)_{5}"
   - `test_latex_qpochhammer_infinite`: QPochhammer(a, q, Infinity) -> "\\left(a ; q\\right)_{\\infty}"
   - `test_latex_jacobi_theta`: JacobiTheta(2, q) -> "\\theta_{2}\\!\\left(q\\right)" or similar
   - `test_latex_dedekind_eta`: DedekindEta(tau) -> "\\eta\\!\\left(\\tau\\right)"
   - `test_latex_basic_hypergeometric`: BasicHypergeometric with upper=[a,b], lower=[c], nome=q, arg=z -> full DLMF matrix notation

3. **Unicode tests -- one per Expr variant:**
   - `test_unicode_integer`: Integer(42) -> "42"
   - `test_unicode_rational`: Rational(3/4) -> "3/4"
   - `test_unicode_symbol_greek`: Symbol("theta") -> "\u{03b8}"
   - `test_unicode_infinity`: Infinity -> "\u{221e}"
   - `test_unicode_add`: Add([a, b]) -> "a + b"
   - `test_unicode_mul`: Mul([a, b]) -> "a*b"
   - `test_unicode_pow_numeric`: Pow(q, 2) -> "q\u{00b2}"
   - `test_unicode_pow_symbolic`: Pow(q, n) -> "q^n"
   - `test_unicode_qpochhammer_numeric`: QPochhammer(a, q, 5) -> "(a;q)\u{2085}"
   - `test_unicode_qpochhammer_infinite`: QPochhammer(a, q, inf) -> "(a;q)\u{221e}" or "(a;q)_\u{221e}"
   - `test_unicode_jacobi_theta`: JacobiTheta(2, q) -> "\u{03b8}\u{2082}(q)"
   - `test_unicode_dedekind_eta`: DedekindEta(tau) -> "\u{03b7}(\u{03c4})"
   - `test_unicode_basic_hypergeometric`: Renders with subscript digits for r/s

4. **Edge case tests (both backends):**
   - `test_latex_nested_pow`: Pow(Pow(q, 2), 3) -- verify no ambiguity
   - `test_latex_deeply_nested_qpoch`: QPochhammer where order is itself an Add expression
   - `test_latex_product_of_qpoch`: Mul of two QPochhammer symbols
   - `test_unicode_large_exponent`: Pow(q, 12) -- multi-digit superscript
   - `test_unicode_negative_exponent`: Pow(q, -1) -- superscript minus

Each test follows the pattern:
```rust
#[test]
fn test_latex_integer_positive() {
    let mut arena = ExprArena::new();
    let e = arena.intern_int(42);
    assert_eq!(to_latex(&arena, e), "42");
}
```

Run all tests. If any LaTeX output looks wrong, fix the rendering code.
  </action>
  <verify>
Run `cargo test render_tests` -- all tests must pass. Count the tests: should have at least 30 test functions covering all variants for both backends plus edge cases.
  </verify>
  <done>
Every Expr variant has at least one LaTeX test and one Unicode test. Edge cases for nesting, compound bases/exponents, and multi-digit subscripts are covered. All 30+ tests pass. The exact expected output strings are documented in the test assertions -- serving as living documentation of the rendering format.
  </done>
</task>

</tasks>

<verification>
1. `cargo test render_tests` passes all 30+ tests.
2. LaTeX output for all 14 Expr variants is verified by assertions.
3. Unicode output for all 14 Expr variants is verified by assertions.
4. Nested expressions (Pow of Pow, Mul of QPochhammer, etc.) render without ambiguity.
5. Greek letter symbols render correctly in both backends (LaTeX commands vs Unicode characters).
6. Parenthesization is correct: compound bases in Pow get parens, Add terms in Mul get parens.
</verification>

<success_criteria>
- All Expr variants render to LaTeX: 14 variants, each with at least one test
- All Expr variants render to Unicode: 14 variants, each with at least one test
- LaTeX uses always-brace policy for sub/superscripts
- LaTeX follows DLMF 17.2 for q-Pochhammer and basic hypergeometric
- Unicode uses real Greek/subscript/superscript characters where available
- Unicode falls back to ASCII notation for unsupported characters
- Edge cases tested: negative numbers, nested expressions, compound bases/exponents
- Zero test failures: `cargo test render_tests` all green
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-foundation/01-03-SUMMARY.md`
</output>
