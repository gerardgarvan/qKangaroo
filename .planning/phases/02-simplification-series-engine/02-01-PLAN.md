---
phase: 02-simplification-series-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/series/mod.rs
  - crates/qsym-core/src/series/arithmetic.rs
  - crates/qsym-core/src/series/display.rs
  - crates/qsym-core/src/lib.rs
  - crates/qsym-core/tests/series_tests.rs
autonomous: true

must_haves:
  truths:
    - "FPS with BTreeMap<i64, QRat> stores only nonzero coefficients and reports correct sparsity"
    - "Truncation order is explicitly tracked and propagated correctly through all operations"
    - "Series addition of O(q^N) + O(q^M) yields O(q^min(N,M)) with correct coefficients"
    - "Series multiplication truncates DURING computation, never creating O(q^2N) intermediates"
    - "(1-q) * (1+q) = 1 - q^2 and (1-q)^2 = 1 - 2q + q^2 are verified"
    - "Series inversion via recurrence produces correct coefficients for 1/(1-q)"
    - "Coefficient extraction panics for exponents at or above truncation order"
  artifacts:
    - path: "crates/qsym-core/src/series/mod.rs"
      provides: "FormalPowerSeries struct with BTreeMap<i64, QRat>, truncation_order, SymbolId variable"
      exports: ["FormalPowerSeries"]
    - path: "crates/qsym-core/src/series/arithmetic.rs"
      provides: "add, mul, negate, scalar_mul, sub, invert, shift operations"
      exports: ["add", "mul", "negate", "scalar_mul", "sub", "invert"]
    - path: "crates/qsym-core/src/series/display.rs"
      provides: "Display impl for FPS showing '1 + q + q^2 + O(q^3)' format"
    - path: "crates/qsym-core/tests/series_tests.rs"
      provides: "Comprehensive TDD tests for FPS construction and arithmetic"
  key_links:
    - from: "crates/qsym-core/src/series/arithmetic.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "operates on FormalPowerSeries fields"
      pattern: "FormalPowerSeries"
    - from: "crates/qsym-core/src/series/mod.rs"
      to: "crates/qsym-core/src/number.rs"
      via: "QRat coefficients"
      pattern: "QRat"
    - from: "crates/qsym-core/src/series/mod.rs"
      to: "crates/qsym-core/src/symbol.rs"
      via: "SymbolId for variable identity"
      pattern: "SymbolId"
---

<objective>
Build the FormalPowerSeries data structure and all series arithmetic operations using TDD.

Purpose: CORE-05 (sparse FPS) and CORE-07 (series arithmetic) are the foundation for all q-series computation. Every subsequent phase depends on correct truncated series arithmetic. TDD ensures mathematical correctness from the start.

Output: `series/` module with FormalPowerSeries, add/mul/sub/negate/scalar_mul/invert/shift, Display, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-simplification-series-engine/02-RESEARCH.md
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/symbol.rs
@crates/qsym-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - FormalPowerSeries struct and comprehensive failing tests</name>
  <files>
    crates/qsym-core/src/series/mod.rs
    crates/qsym-core/src/series/arithmetic.rs
    crates/qsym-core/src/series/display.rs
    crates/qsym-core/src/lib.rs
    crates/qsym-core/tests/series_tests.rs
  </files>
  <action>
Create `crates/qsym-core/src/series/` directory with three files.

**series/mod.rs** -- The FormalPowerSeries struct:
```rust
use std::collections::BTreeMap;
use crate::number::QRat;
use crate::symbol::SymbolId;
```

Struct fields:
- `coefficients: BTreeMap<i64, QRat>` (sparse, only nonzero entries)
- `variable: SymbolId` (which variable, usually "q")
- `truncation_order: i64` (coefficients exact below this, unknown at/above)

Public API on FormalPowerSeries:
- `zero(variable, truncation_order)` -- the zero series O(q^N)
- `one(variable, truncation_order)` -- constant 1 + O(q^N)
- `monomial(variable, coeff, power, truncation_order)` -- c*q^k + O(q^N)
- `from_coeffs(variable, coeffs: BTreeMap<i64, QRat>, truncation_order)` -- direct construction, strips zeros
- `coeff(&self, k) -> QRat` -- returns zero for missing, panics if k >= truncation_order
- `set_coeff(&mut self, k, value)` -- removes if zero, ignores if k >= truncation_order
- `num_nonzero(&self) -> usize`
- `min_order(&self) -> Option<i64>`
- `truncation_order(&self) -> i64`
- `is_zero(&self) -> bool` -- true if all coefficients are zero
- `variable(&self) -> SymbolId`
- `iter(&self) -> impl Iterator<Item = (&i64, &QRat)>` -- iterate nonzero coefficients in order

Derive Clone, Debug. Implement PartialEq manually: two FPS are equal iff they have same variable, same truncation_order, and identical coefficient maps (after zero removal).

**series/arithmetic.rs** -- Stub all functions with `todo!()`:
- `pub fn add(a: &FormalPowerSeries, b: &FormalPowerSeries) -> FormalPowerSeries`
- `pub fn sub(a: &FormalPowerSeries, b: &FormalPowerSeries) -> FormalPowerSeries`
- `pub fn negate(a: &FormalPowerSeries) -> FormalPowerSeries`
- `pub fn scalar_mul(s: &QRat, a: &FormalPowerSeries) -> FormalPowerSeries`
- `pub fn mul(a: &FormalPowerSeries, b: &FormalPowerSeries) -> FormalPowerSeries`
- `pub fn invert(a: &FormalPowerSeries) -> FormalPowerSeries` (requires a.coeff(0) != 0)
- `pub fn shift(a: &FormalPowerSeries, k: i64) -> FormalPowerSeries` (multiply by q^k)

All binary operations must assert `a.variable == b.variable`.

**series/display.rs** -- Stub Display with `todo!()`. Target format: `"1 - q + 2*q^3 + O(q^10)"`. Use `q` as variable name. Terms in ascending exponent order. Coefficient of 1 or -1 omitted (just `q^k` or `-q^k`). Exponent of 0 shows just the constant. Exponent of 1 shows just `q`. Zero series shows `O(q^N)`.

**lib.rs** -- Add `pub mod series;` to module declarations.

**tests/series_tests.rs** -- Write ALL failing tests first (RED phase). Categories:

1. **Construction tests** (5+):
   - `zero_series_is_zero`: zero(q, 10) has no nonzero coefficients, is_zero() == true
   - `one_series_constant`: one(q, 10) has coeff(0) == 1, all others zero
   - `monomial_construction`: monomial(q, QRat(3), 5, 10) has coeff(5) == 3
   - `from_coeffs_strips_zeros`: from_coeffs with {0: 1, 1: 0, 2: 3} drops the zero entry
   - `coeff_panics_above_truncation`: coeff(10) panics on O(q^10) series

2. **Addition tests** (4+):
   - `add_zero_identity`: f + 0 = f
   - `add_disjoint_support`: {0: 1} + {1: 1} = {0: 1, 1: 1}
   - `add_overlapping_cancellation`: {0: 1, 1: 1} + {0: -1} = {1: 1}
   - `add_truncation_min`: O(q^10) + O(q^5) produces O(q^5)

3. **Subtraction/negation tests** (3+):
   - `negate_flips_signs`: -(1 - q) = -1 + q
   - `sub_equals_add_negate`: a - b = a + (-b)
   - `sub_self_is_zero`: f - f = 0

4. **Scalar multiplication tests** (3+):
   - `scalar_mul_by_zero`: 0 * f = 0
   - `scalar_mul_by_one`: 1 * f = f
   - `scalar_mul_distributes`: s*(a+b) = s*a + s*b (use concrete values)

5. **Multiplication tests** (5+):
   - `mul_by_one_identity`: 1 * f = f
   - `mul_by_zero_annihilator`: 0 * f = 0
   - `mul_1_minus_q_times_1_plus_q`: (1-q)(1+q) = 1 - q^2
   - `mul_1_minus_q_squared`: (1-q)^2 = 1 - 2q + q^2
   - `mul_truncation_enforced`: multiply O(q^5) series, result has no terms at q^5 or above

6. **Inversion tests** (3+):
   - `invert_one_is_one`: 1/1 = 1
   - `invert_1_minus_q`: 1/(1-q) = 1 + q + q^2 + ... + q^(N-1) + O(q^N)
   - `invert_panics_on_zero_constant_term`: invert series with coeff(0) == 0 should panic

7. **Shift tests** (2+):
   - `shift_by_zero_identity`: shift(f, 0) = f
   - `shift_monomial`: shift(1+O(q^5), 3) = q^3 + O(q^5)

8. **Display tests** (3+):
   - `display_zero_series`: "O(q^10)"
   - `display_constant`: "1 + O(q^10)"
   - `display_polynomial`: "1 - q + 2*q^3 + O(q^10)"

Use a helper function to create SymbolId for "q":
```rust
fn q_var() -> SymbolId {
    let mut arena = ExprArena::new();
    let q_ref = arena.intern_symbol("q");
    // Extract SymbolId from the Symbol variant
    match arena.get(q_ref) {
        Expr::Symbol(id) => *id,
        _ => unreachable!(),
    }
}
```

Actually, SymbolRegistry is inside ExprArena. For tests, either expose a way to get SymbolId directly or use ExprArena just for symbol interning. Check how SymbolRegistry::intern works -- it returns SymbolId. Since ExprArena has `symbols_mut()`, tests can do:
```rust
let mut arena = ExprArena::new();
let q = arena.symbols_mut().intern("q");
```

All tests should compile but fail (todo!() panics or assertion failures). Run `cargo test --test series_tests` to confirm RED state.

Commit: `test(02-01): add failing tests for FPS construction and arithmetic`
  </action>
  <verify>
`cargo test --test series_tests 2>&1 | grep -E "(FAILED|test result)"` shows all tests failing. `cargo build` succeeds (no compile errors).
  </verify>
  <done>
series/ module exists with FormalPowerSeries struct fully implemented, arithmetic functions stubbed with todo!(), Display stubbed, 28+ tests written and all failing.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement all FPS arithmetic, pass all tests</name>
  <files>
    crates/qsym-core/src/series/arithmetic.rs
    crates/qsym-core/src/series/display.rs
  </files>
  <action>
Implement all stubbed functions to make tests pass.

**arithmetic.rs -- add:**
- Result truncation = min(a.truncation_order, b.truncation_order)
- Merge both coefficient maps, only keeping keys < trunc
- After adding overlapping keys, remove any that became zero
- Time O(|a| + |b|), Space O(|a| + |b|)

**arithmetic.rs -- sub:**
- Implement as add(a, &negate(b))

**arithmetic.rs -- negate:**
- Clone coefficients, negate each value
- Preserve truncation_order

**arithmetic.rs -- scalar_mul:**
- If scalar is zero, return zero series
- Multiply each coefficient, skip if result is zero
- Preserve truncation_order

**arithmetic.rs -- mul (CRITICAL):**
- Result truncation = min(a.truncation_order, b.truncation_order)
- Nested loop over both coefficient maps
- CRITICAL: check `ka + kb < trunc` BEFORE computing product
- CRITICAL: since BTreeMap iterates in ascending order, once `ka + kb >= trunc`, break inner loop
- After accumulation, retain only nonzero entries
- Time O(|a| * |b|), Space O(N) where N = truncation order

```rust
pub fn mul(a: &FormalPowerSeries, b: &FormalPowerSeries) -> FormalPowerSeries {
    assert_eq!(a.variable, b.variable, "Cannot multiply series in different variables");
    let trunc = a.truncation_order.min(b.truncation_order);
    let mut result = FormalPowerSeries::zero(a.variable, trunc);

    for (&ka, ca) in a.coefficients.iter() {
        if ka >= trunc { break; }  // a is sorted, all remaining ka >= trunc
        for (&kb, cb) in b.coefficients.iter() {
            let k = ka + kb;
            if k >= trunc { break; }  // b is sorted, all remaining kb even larger
            let product = ca.clone() * cb.clone();
            // Accumulate into result
            let entry = result.coefficients.entry(k).or_insert_with(QRat::zero);
            *entry = &*entry + &product;
        }
    }
    // Clean up zeros from cancellation
    result.coefficients.retain(|_, v| !v.is_zero());
    result
}
```

Note on QRat arithmetic: use owned `ca.clone() * cb.clone()` or reference ops `ca * cb` depending on what's implemented. Check number.rs -- we have `Mul for QRat` (owned) and `Mul<&QRat> for &QRat` (ref). For accumulation: `&*entry + &product` uses the ref variant.

**arithmetic.rs -- invert:**
- Assert coeff(0) is not zero
- Use recurrence: c[n] = (-1/a0) * sum_{k=1}^{n} a[k] * c[n-k] for n >= 1, c[0] = 1/a0
- Where a0 = a.coeff(0), a[k] = a.coeff(k)
- Build result coefficients iteratively from n=0 to truncation_order-1
- Only store nonzero c[n] values

```rust
pub fn invert(a: &FormalPowerSeries) -> FormalPowerSeries {
    let a0 = a.coeff(0);
    assert!(!a0.is_zero(), "Cannot invert series with zero constant term");
    let trunc = a.truncation_order;
    let inv_a0 = QRat::one() / a0;

    let mut result = FormalPowerSeries::zero(a.variable, trunc);
    result.set_coeff(0, inv_a0.clone());

    let neg_inv_a0 = -inv_a0;

    for n in 1..trunc {
        let mut sum = QRat::zero();
        // sum_{k=1}^{n} a[k] * c[n-k]
        for k in 1..=n {
            let ak = a.coeff(k);
            if ak.is_zero() { continue; }
            let cn_k = result.coeff(n - k);
            if cn_k.is_zero() { continue; }
            sum = sum + ak * cn_k;
        }
        let cn = &neg_inv_a0 * &sum;
        result.set_coeff(n, cn);
    }
    result
}
```

**arithmetic.rs -- shift:**
- Shift all exponents by k: coefficient at power p moves to power p+k
- New truncation_order = old + k (if shifting forward) -- actually truncation stays the same since we only know coefficients in the original range. More precisely: if original is exact below T, then shifted is exact below T (the shifted series q^k * f(q) still has truncation order T because coefficients below T-k map to below T). Wait -- re-think: shift(f, k) = q^k * f(q). If f is known to O(q^T), then q^k * f is known to O(q^T) as well (we know each coefficient c_n for n < T, so we know q^k * c_n * q^n = c_n * q^{n+k} for n < T, meaning we know coefficients at positions k, k+1, ..., k+T-1, which is O(q^{k+T})). Actually the truncation of q^k * f should be T + k. But we should only keep terms below a reasonable bound. Let's keep truncation_order = a.truncation_order + k. Filter out any terms that fall below 0 if k is negative (though negative shifts are unusual).
- Actually simpler: truncation stays at a.truncation_order. We just shift the exponents. Terms that shift to >= truncation_order are dropped. This is simpler and safer.
- Wait, no. If f = 1 + q + O(q^5) and we shift by 3, we get q^3 + q^4 + O(q^8). The truncation order SHOULD increase by k. Let me reconsider: the semantics of "shift by k" is "multiply by q^k". The result's truncation should be a.truncation_order + k because f has exact coefficients for exponents < a.truncation_order, and multiplying by q^k shifts them to < a.truncation_order + k.
- Implementation: new BTreeMap with each key increased by k. New truncation_order = a.truncation_order + k.

**display.rs -- Display for FormalPowerSeries:**
- Iterate coefficients in ascending exponent order
- For each (k, c):
  - k==0: just show c (e.g., "1", "-3", "1/2")
  - k==1: show c*q (e.g., "q", "-q", "2*q", "-3/2*q")
  - k>1: show c*q^k (e.g., "q^2", "-q^5", "3*q^7")
  - Coefficient of 1: omit "1*" (just "q^k")
  - Coefficient of -1: show "-q^k"
  - Other coefficients: show "c*q^k"
- Between terms: " + " for positive, " - " for negative (absorb the sign)
- End with " + O(q^N)" where N is truncation_order
- Empty (zero) series: just "O(q^N)"
- Use the variable name from SymbolRegistry if available, otherwise "q" -- actually we don't have access to SymbolRegistry in Display. For now, hardcode "q" as the variable name. Phase 3+ can add a display_with_arena method.

Run `cargo test --test series_tests` -- all tests must pass.
Run `cargo test` -- all 166 prior tests plus new tests must pass.

Commit: `feat(02-01): implement FPS data structure and series arithmetic`
  </action>
  <verify>
`cargo test` passes all tests (166 existing + 28+ new series tests). `cargo test --test series_tests` shows all green.
  </verify>
  <done>
FormalPowerSeries with BTreeMap sparse storage is complete. All arithmetic operations (add, sub, mul, negate, scalar_mul, invert, shift) work correctly with proper truncation tracking. Display shows human-readable polynomial format. All tests pass including: (1-q)(1+q) = 1-q^2, (1-q)^2 = 1-2q+q^2, 1/(1-q) geometric series, truncation enforcement.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --test series_tests` -- all FPS tests pass
2. `cargo test` -- all tests pass (existing 166 + new series tests)
3. `cargo build` -- zero warnings
4. Verify truncation: create two O(q^5) series, multiply, confirm no coefficients at exponent >= 5
5. Verify sparsity: monomial series with coeff at q^100 only has 1 entry in BTreeMap
6. Verify inversion: 1/(1-q) to O(q^20) has all coefficients equal to 1
</verification>

<success_criteria>
- FormalPowerSeries struct exists with BTreeMap<i64, QRat> sparse storage
- Truncation order explicitly tracked and propagated through all operations
- add, sub, mul, negate, scalar_mul, invert, shift all implemented and tested
- Multiplication truncates during computation (no O(q^2N) intermediates)
- Display shows readable polynomial format with O(q^N) truncation
- All tests pass with zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-simplification-series-engine/02-01-SUMMARY.md`
</output>
