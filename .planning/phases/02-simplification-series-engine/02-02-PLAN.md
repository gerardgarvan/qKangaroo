---
phase: 02-simplification-series-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/simplify/mod.rs
  - crates/qsym-core/src/simplify/rules.rs
  - crates/qsym-core/src/simplify/traverse.rs
  - crates/qsym-core/src/lib.rs
  - crates/qsym-core/tests/simplify_tests.rs
autonomous: true

must_haves:
  truths:
    - "SimplificationEngine applies rules in phased order (normalize, cancel, collect, simplify) and returns a fixpoint"
    - "Simplification terminates on all inputs including adversarial expressions (Neg(Neg(Neg(...))), deeply nested Add/Mul)"
    - "Hash-consing provides O(1) change detection: if no rules fired, the ExprRef is unchanged"
    - "Flatten nested Add/Mul: Add([a, Add([b, c])]) becomes Add([a, b, c])"
    - "Combine numeric constants: Add([3, 5, x]) becomes Add([8, x])"
    - "Cancel identity elements: x + 0 = x, x * 1 = x, x * 0 = 0"
    - "Double negation: Neg(Neg(x)) = x"
    - "Neg of integer constant: Neg(Integer(3)) = Integer(-3)"
  artifacts:
    - path: "crates/qsym-core/src/simplify/mod.rs"
      provides: "SimplificationEngine with phased rule application and fixpoint detection"
      exports: ["SimplificationEngine", "simplify"]
    - path: "crates/qsym-core/src/simplify/rules.rs"
      provides: "Rewrite rules as Rust match functions for each phase"
      exports: ["normalize", "cancel", "collect", "simplify_arith"]
    - path: "crates/qsym-core/src/simplify/traverse.rs"
      provides: "Bottom-up traversal of ExprArena DAG with recursive child simplification"
      exports: ["bottom_up_apply"]
    - path: "crates/qsym-core/tests/simplify_tests.rs"
      provides: "Tests for all simplification phases and fixpoint termination"
  key_links:
    - from: "crates/qsym-core/src/simplify/mod.rs"
      to: "crates/qsym-core/src/arena.rs"
      via: "ExprArena is mutated to intern simplified expressions"
      pattern: "arena\\.intern|arena\\.get"
    - from: "crates/qsym-core/src/simplify/traverse.rs"
      to: "crates/qsym-core/src/expr.rs"
      via: "Pattern matching on Expr variants to traverse children"
      pattern: "Expr::Add|Expr::Mul|Expr::Neg|Expr::Pow"
    - from: "crates/qsym-core/src/simplify/rules.rs"
      to: "crates/qsym-core/src/canonical.rs"
      via: "Uses make_add/make_mul/make_neg for canonical reconstruction"
      pattern: "make_add|make_mul|make_neg"
---

<objective>
Build the phased simplification engine that applies rewrite rules in priority order with guaranteed termination.

Purpose: CORE-04 provides algebraic simplification needed by all downstream phases. The simplification engine normalizes expressions (flatten, combine constants, cancel identities, eliminate double negation) so that later phases (q-series evaluation, series-to-product conversion) work on canonical forms. Guaranteed termination prevents infinite loops on adversarial input.

Output: `simplify/` module with SimplificationEngine, 4 rule phases (normalize, cancel, collect, simplify_arith), bottom-up traversal, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-simplification-series-engine/02-RESEARCH.md
@crates/qsym-core/src/expr.rs
@crates/qsym-core/src/arena.rs
@crates/qsym-core/src/canonical.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SimplificationEngine with bottom-up traversal and 4 rule phases</name>
  <files>
    crates/qsym-core/src/simplify/mod.rs
    crates/qsym-core/src/simplify/rules.rs
    crates/qsym-core/src/simplify/traverse.rs
    crates/qsym-core/src/lib.rs
  </files>
  <action>
Create `crates/qsym-core/src/simplify/` directory with three files.

**simplify/mod.rs** -- The SimplificationEngine:

```rust
pub mod rules;
pub mod traverse;

use crate::arena::ExprArena;
use crate::expr::ExprRef;
```

The engine applies 4 rule phases in order. If any phase changes the expression (detected via ExprRef != comparison, which is O(1) thanks to hash-consing), restart from phase 1. Cap total restarts at `max_iterations` (default: 100).

```rust
pub struct SimplificationEngine {
    max_iterations: usize,
}
```

Public API:
- `SimplificationEngine::new() -> Self` -- default max_iterations = 100
- `SimplificationEngine::with_max_iterations(n: usize) -> Self`
- `SimplificationEngine::simplify(&self, expr: ExprRef, arena: &mut ExprArena) -> ExprRef`

The `simplify` method:
1. Set `current = expr`, `iterations = 0`
2. Loop while iterations < max_iterations:
   a. Apply phase 1 (normalize) bottom-up. If result != current, set current = result, increment iterations, restart loop.
   b. Apply phase 2 (cancel) bottom-up. If changed, restart.
   c. Apply phase 3 (collect) bottom-up. If changed, restart.
   d. Apply phase 4 (simplify_arith) bottom-up. If changed, restart.
   e. If no phase changed anything, break (fixpoint reached).
3. Return current.

Also provide a convenience free function:
```rust
pub fn simplify(expr: ExprRef, arena: &mut ExprArena) -> ExprRef {
    SimplificationEngine::new().simplify(expr, arena)
}
```

**simplify/traverse.rs** -- Bottom-up traversal:

```rust
pub fn bottom_up_apply(
    expr: ExprRef,
    arena: &mut ExprArena,
    rule_fn: &dyn Fn(ExprRef, &mut ExprArena) -> ExprRef,
) -> ExprRef
```

This function:
1. Gets the Expr for `expr` from the arena (clone it to avoid borrow issues).
2. Recursively simplifies children based on variant:
   - `Add(children)`: map each child through bottom_up_apply, reconstruct via `make_add` if any changed
   - `Mul(children)`: same, via `make_mul`
   - `Neg(child)`: simplify child, reconstruct via `make_neg` if changed
   - `Pow(base, exp)`: simplify both, reconstruct via `make_pow` if either changed
   - `QPochhammer{base, nome, order}`: simplify all three fields, reconstruct if any changed
   - `JacobiTheta{index, nome}`: simplify nome, reconstruct if changed
   - `DedekindEta(tau)`: simplify tau, reconstruct if changed
   - `BasicHypergeometric{upper, lower, nome, argument}`: simplify all fields, reconstruct if any changed
   - Atoms (Integer, Rational, Symbol, Infinity, Undefined): return unchanged
3. After simplifying children, apply `rule_fn` to the result.
4. Return the final ExprRef.

Key: compare ExprRefs before and after to detect changes. If children didn't change, don't reconstruct (avoids unnecessary interning). Clone the Expr from arena before recursing to avoid immutable/mutable borrow conflict.

**simplify/rules.rs** -- Four rule phase functions, each with signature:
```rust
pub fn phase_name(expr: ExprRef, arena: &mut ExprArena) -> ExprRef
```

Per the research, implement rules as direct Rust match arms on the Expr enum (NOT through a generic pattern matching engine). This handles n-ary operators correctly.

**Phase 1: normalize(expr, arena)**
Rules (applied to the current node after children are simplified):
1. **Flatten nested Add**: If Expr::Add(children) and any child is also Add, collect all grandchildren into a flat list, re-canonicalize via make_add.
2. **Flatten nested Mul**: Same for Mul.
3. **Combine numeric constants in Add**: If Add has multiple Integer/Rational atoms, sum them into one. If the sum is zero, remove it. Rebuild via make_add.
4. **Combine numeric constants in Mul**: If Mul has multiple Integer/Rational atoms, multiply them into one. If the product is one, remove it. Rebuild via make_mul.
5. **Singleton unwrap**: If after modifications Add/Mul has only 1 child, return that child. If 0 children, return identity (0 for Add, 1 for Mul). (make_add/make_mul already handle this.)

Implementation approach: match on arena.get(expr).clone(), check the variant, iterate children to detect any that need processing, rebuild if needed.

For combining numeric constants: iterate children of Add, partition into numeric (Integer/Rational) and non-numeric. Sum all numerics (promote Integer to Rational if mixed). If sum is nonzero, prepend to non-numeric list. Rebuild via make_add.

For Mul: same but multiply, and identity is 1 not 0.

Type conversion: when adding Integer(a) + Rational(b), promote a to QRat via `QRat::from(a.clone())`, add, return as Rational. When multiplying Integer(a) * Integer(b), result is Integer. When Integer * Rational, promote and return Rational.

**Phase 2: cancel(expr, arena)**
Rules:
1. **Add zero elimination**: If Add(children) contains Integer(0), remove all zeros. Rebuild. (Also check for Rational(0/1) though QRat auto-reduces.)
2. **Mul one elimination**: If Mul(children) contains Integer(1), remove all ones. Rebuild.
3. **Mul zero annihilation**: If Mul(children) contains Integer(0), return Integer(0).
4. **Pow(x, 0) -> 1**: Return Integer(1). (For any x; we follow convention that 0^0 = 1.)
5. **Pow(x, 1) -> x**: Return x.
6. **Pow(1, n) -> 1**: If base is Integer(1), return Integer(1).
7. **Neg(Integer(0)) -> Integer(0)**: Negation of zero is zero.

**Phase 3: collect(expr, arena)**
Rules for Phase 2 scope (keep simple -- full like-term collection is complex):
1. **Duplicate detection in Add**: If Add(children) has duplicate ExprRefs (same child appears N times), replace with Mul([Integer(N), child]). This works because children are sorted, so duplicates are adjacent. Iterate and count runs. Note: make_add already dedups via children.dedup(). So actually duplicates in Add should not exist after canonical construction. HOWEVER, simplification may produce them: e.g., if we have Add([Mul([2,x]), Mul([3,x])]) we want to collect to Mul([5,x]). This is like-term collection, which is more complex.

For Phase 2 scope, implement a simple version:
- In Add(children), group terms by their "base" (strip numeric coefficient). For each child, determine if it's Mul([Integer(n), rest...]) -- then base is Mul(rest) (or rest if only one non-numeric), coefficient is n. If it's just an atom/compound, coefficient is 1. Group by base, sum coefficients. Rebuild.
- This handles: `x + x -> 2*x`, `2*x + 3*x -> 5*x`, `x + x + x -> 3*x`.

2. **Duplicate detection in Mul**: If Mul(children) has the same ExprRef appearing N times, replace with Pow(child, Integer(N)). Iterate sorted children, count runs. Rebuild.
- This handles: `x * x -> x^2`, `x * x * x -> x^3`.

**Phase 4: simplify_arith(expr, arena)**
Rules:
1. **Double negation**: Neg(Neg(x)) -> x
2. **Neg of integer**: Neg(Integer(n)) -> Integer(-n)
3. **Neg of rational**: Neg(Rational(r)) -> Rational(-r)
4. **Pow(Pow(x, a), b) -> Pow(x, a*b)** when a and b are both Integer: compute a*b, return Pow(x, Integer(a*b)). Only when both exponents are Integer to avoid algebraic issues with fractional/symbolic exponents.

Do NOT implement these (deferred per research):
- Expand phase (distribute Mul over Add) -- off by default in Phase 2
- Neg bubbling from Mul (complex interaction with n-ary Mul) -- save for later
- Verify phase is implicit in the fixpoint check of the outer loop

**lib.rs** -- Add `pub mod simplify;` to module declarations.

Commit: `feat(02-02): implement phased simplification engine with 4 rule phases`
  </action>
  <verify>
`cargo build` succeeds with zero warnings. `cargo test` passes all 166 existing tests (simplification module compiles but has no tests yet).
  </verify>
  <done>
simplify/ module exists with SimplificationEngine, bottom-up traversal, and 4 rule phases (normalize, cancel, collect, simplify_arith). Code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive simplification tests including termination</name>
  <files>
    crates/qsym-core/tests/simplify_tests.rs
  </files>
  <action>
Create comprehensive test file covering all simplification rules and termination guarantees.

Use ExprArena and canonical constructors to build test expressions, then call `simplify::simplify(expr, &mut arena)` and verify the result.

Helper pattern for all tests:
```rust
use qsym_core::{ExprArena, Expr, ExprRef};
use qsym_core::canonical::*;
use qsym_core::simplify::simplify;
use qsym_core::number::{QInt, QRat};
```

**Normalization tests (5+):**
1. `flatten_nested_add`: Add([a, Add([b, c])]) simplifies to Add([a, b, c]) (children sorted by ExprRef)
2. `flatten_nested_mul`: Mul([a, Mul([b, c])]) simplifies to Mul([a, b, c])
3. `combine_integer_add`: Add([Integer(3), x, Integer(5)]) -> Add([Integer(8), x]) or Add([x, Integer(8)]) depending on sort order
4. `combine_integer_mul`: Mul([Integer(3), x, Integer(5)]) -> Mul([Integer(15), x])
5. `combine_mixed_numeric_add`: Add([Integer(1), Rational(1/2), x]) -> Add([Rational(3/2), x])

**Cancellation tests (7+):**
6. `add_zero_left`: Add([Integer(0), x]) -> x
7. `add_zero_right`: Add([x, Integer(0)]) -> x
8. `mul_one`: Mul([Integer(1), x]) -> x
9. `mul_zero`: Mul([Integer(0), x]) -> Integer(0)
10. `pow_zero_exp`: Pow(x, Integer(0)) -> Integer(1)
11. `pow_one_exp`: Pow(x, Integer(1)) -> x
12. `pow_one_base`: Pow(Integer(1), x) -> Integer(1)

**Collection tests (4+):**
13. `collect_duplicate_add`: Build Add with same ExprRef twice by manually constructing Expr::Add(vec![x, x]) (bypass make_add dedup). After simplification, should get Mul([Integer(2), x]).
   Note: Since make_add dedups, we need to construct the expr directly: `arena.intern(Expr::Add(vec![x_ref, x_ref]))`. This bypasses canonical form. Simplification should handle it.
14. `collect_like_terms_add`: Add([Mul([Integer(2), x]), Mul([Integer(3), x])]) -> Mul([Integer(5), x])
15. `collect_duplicate_mul`: Mul with same ExprRef twice -> Pow(x, Integer(2))
16. `collect_triple_mul`: x * x * x -> Pow(x, Integer(3))

**Arithmetic simplification tests (4+):**
17. `double_negation`: Neg(Neg(x)) -> x
18. `triple_negation`: Neg(Neg(Neg(x))) -> Neg(x)
19. `neg_integer`: Neg(Integer(5)) -> Integer(-5)
20. `neg_rational`: Neg(Rational(3/4)) -> Rational(-3/4)

**Compound/integration tests (5+):**
21. `nested_flatten_and_cancel`: Add([Add([Integer(0), x]), y]) -> Add([x, y])
22. `deep_negation_chain`: Neg(Neg(Neg(Neg(x)))) -> x (4 levels = even = identity)
23. `complex_simplify`: Mul([Integer(1), Add([Integer(3), Integer(5), Neg(Integer(0))])]) -> Integer(8)
   Steps: Neg(0)->0, Add([3,5,0])->Add([3,5])->Add([8])=8, Mul([1,8])->8
24. `pow_pow_integer_exp`: Pow(Pow(x, Integer(2)), Integer(3)) -> Pow(x, Integer(6))
25. `atoms_unchanged`: Symbol, Integer, Rational, Infinity, Undefined pass through simplify unchanged.

**Termination tests (3+):**
26. `termination_identity`: simplify(x) == x (fixpoint on atoms)
27. `termination_deep_nesting`: Build Neg(Neg(Neg(...Neg(x)...))) 50 levels deep. Verify simplification terminates and returns x (even depth) or Neg(x) (odd depth). Use `SimplificationEngine::with_max_iterations(200)`.
28. `termination_wide_expression`: Build Add of 100 distinct symbols. Verify simplification terminates quickly (no exponential blowup).

**Idempotency test (1+):**
29. `simplify_is_idempotent`: For several expressions, verify that `simplify(simplify(expr)) == simplify(expr)`.

Run `cargo test --test simplify_tests` -- all pass.
Run `cargo test` -- all tests pass.

Commit: `test(02-02): comprehensive simplification tests with termination verification`
  </action>
  <verify>
`cargo test --test simplify_tests` passes all tests. `cargo test` passes all tests (166 existing + series tests from 02-01 + 29+ simplification tests). No test takes more than 1 second (termination guarantee).
  </verify>
  <done>
Simplification engine passes 29+ tests covering all 4 rule phases: normalization (flatten, combine constants), cancellation (zero/one/identity elimination), collection (like terms, duplicate factors), arithmetic simplification (double negation, neg of constants, pow of pow). Termination verified on adversarial inputs. Idempotency verified.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --test simplify_tests` -- all simplification tests pass
2. `cargo test` -- all tests pass (existing + new)
3. `cargo build` -- zero warnings
4. Termination: deeply nested Neg(Neg(...)) 50 levels simplifies in < 1 second
5. Idempotency: simplify(simplify(e)) == simplify(e) for all test expressions
6. Change detection: simplify(atom) returns same ExprRef (O(1), no new interning)
</verification>

<success_criteria>
- SimplificationEngine with 4 phased rule sets (normalize, cancel, collect, simplify_arith)
- Bottom-up traversal correctly recurses into all Expr variant children
- Fixpoint detection via ExprRef equality (O(1) hash-consing comparison)
- Guaranteed termination via max_iterations cap
- All rewrite rules implemented as direct Rust match arms (no generic pattern matcher)
- 29+ tests pass covering all rules, compound cases, termination, and idempotency
</success_criteria>

<output>
After completion, create `.planning/phases/02-simplification-series-engine/02-02-SUMMARY.md`
</output>
