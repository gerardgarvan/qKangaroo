---
phase: 02-simplification-series-engine
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/qsym-core/src/series/generator.rs
  - crates/qsym-core/src/series/mod.rs
  - crates/qsym-core/tests/generator_tests.rs
autonomous: true

must_haves:
  truths:
    - "Lazy generator for (q;q)_inf produces correct Euler function coefficients matching OEIS A010815 to O(q^60)"
    - "Generator only multiplies as many factors as needed for the requested truncation order"
    - "Euler function coefficients are nonzero only at generalized pentagonal numbers k(3k-1)/2"
    - "Series inversion of Euler function produces partition function p(n) matching OEIS A000041 for n=0..20"
    - "Jacobi triple product special case (z=1) produces theta_3 coefficients: sum_{n=-inf}^{inf} q^{n^2}"
    - "General infinite product generator accepts custom factor functions"
    - "Requesting higher truncation order after lower order reuses previous partial product"
  artifacts:
    - path: "crates/qsym-core/src/series/generator.rs"
      provides: "InfiniteProductGenerator struct and euler_function_generator factory"
      exports: ["InfiniteProductGenerator", "euler_function_generator"]
    - path: "crates/qsym-core/tests/generator_tests.rs"
      provides: "Tests for Euler function, partition function, Jacobi triple product, generator reuse"
  key_links:
    - from: "crates/qsym-core/src/series/generator.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "Uses mul() for multiplying each factor into partial product"
      pattern: "arithmetic::mul"
    - from: "crates/qsym-core/src/series/generator.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "Constructs and stores FormalPowerSeries as partial product"
      pattern: "FormalPowerSeries"
    - from: "crates/qsym-core/tests/generator_tests.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "Uses invert() to compute partition function from Euler function"
      pattern: "arithmetic::invert"
---

<objective>
Build lazy generators for infinite product expansion and verify mathematical correctness against known q-series identities.

Purpose: CORE-06 (lazy generators) enables computing infinite products like (q;q)_inf = prod_{k=1}^{inf}(1-q^k) to any requested truncation order. This is the bridge between symbolic q-Pochhammer expressions and their series expansions. Verification against the pentagonal number theorem, partition function values, and the Jacobi triple product proves end-to-end correctness of the entire series engine (FPS + arithmetic + generators).

Output: `series/generator.rs` with InfiniteProductGenerator, euler_function_generator, and tests verifying Euler function, partition function, and Jacobi triple product.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-simplification-series-engine/02-RESEARCH.md
@.planning/phases/02-simplification-series-engine/02-01-SUMMARY.md
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/symbol.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: InfiniteProductGenerator and euler_function_generator</name>
  <files>
    crates/qsym-core/src/series/generator.rs
    crates/qsym-core/src/series/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/series/generator.rs` and add `pub mod generator;` to `series/mod.rs`.

**InfiniteProductGenerator struct:**

```rust
use crate::number::QRat;
use crate::symbol::SymbolId;
use super::{FormalPowerSeries, arithmetic};
```

```rust
pub struct InfiniteProductGenerator {
    /// Current partial product (truncated series)
    partial_product: FormalPowerSeries,
    /// How many factors have been multiplied in (0-indexed: factors_included means
    /// factors 0..factors_included have been applied)
    factors_included: i64,
    /// Starting factor index (e.g., 1 for (q;q)_inf which starts at k=1)
    start_index: i64,
    /// Function that generates the k-th factor as a FormalPowerSeries
    /// Arguments: (k: factor index, variable: SymbolId, truncation_order: i64)
    factor_fn: Box<dyn FnMut(i64, SymbolId, i64) -> FormalPowerSeries>,
}
```

Public API:
- `InfiniteProductGenerator::new(initial: FormalPowerSeries, start_index: i64, factor_fn: Box<dyn FnMut(i64, SymbolId, i64) -> FormalPowerSeries>) -> Self`
  - Sets partial_product = initial, factors_included = start_index (no factors applied yet)

- `ensure_order(&mut self, target_order: i64)`:
  - While factors_included < target_order, compute next factor via factor_fn, multiply into partial_product using arithmetic::mul.
  - Key optimization: for products like (1 - q^k), factor k only affects terms at q^k and above. Once k >= target_order, the factor is 1 + O(q^target_order), which doesn't change the partial product below target_order. So we only need target_order factors.
  - After multiplying each factor, factors_included increments.

- `series(&self) -> &FormalPowerSeries` -- returns reference to current partial product.

- `into_series(self) -> FormalPowerSeries` -- consumes generator, returns owned series.

**euler_function_generator factory:**

```rust
pub fn euler_function_generator(
    variable: SymbolId,
    truncation_order: i64,
) -> InfiniteProductGenerator
```

Creates a generator for (q;q)_inf = prod_{k=1}^{inf} (1 - q^k).

- Initial partial product: 1 + O(q^truncation_order) (the empty product)
- Start index: 1 (first factor is 1 - q^1)
- Factor function: for index k, returns the series (1 - q^k) = {0: 1, k: -1} + O(q^truncation_order)

Implementation:
```rust
pub fn euler_function_generator(
    variable: SymbolId,
    truncation_order: i64,
) -> InfiniteProductGenerator {
    let initial = FormalPowerSeries::one(variable, truncation_order);

    InfiniteProductGenerator::new(
        initial,
        1, // start at k=1 for (q;q)_inf
        Box::new(move |k, var, trunc| {
            // Factor = (1 - q^k)
            let mut factor = FormalPowerSeries::one(var, trunc);
            factor.set_coeff(k, -QRat::one());
            factor
        }),
    )
}
```

Also create a more general factory:

```rust
/// Generator for (a*q^offset; q)_inf = prod_{k=0}^{inf} (1 - a * q^{offset + k})
/// where a is a QRat constant.
pub fn qpochhammer_inf_generator(
    a: QRat,
    offset: i64,
    variable: SymbolId,
    truncation_order: i64,
) -> InfiniteProductGenerator
```

- For a=1, offset=1, this gives (q;q)_inf (same as euler_function_generator).
- Factor k: (1 - a * q^{offset+k}). As a series: {0: 1, offset+k: -a} + O(q^trunc).
- Start index: 0 (first factor at q^{offset+0} = q^offset).

Commit: `feat(02-03): implement InfiniteProductGenerator and Euler function generator`
  </action>
  <verify>
`cargo build` succeeds with zero warnings. `cargo test` passes all existing tests (generator module compiles but not yet tested separately).
  </verify>
  <done>
InfiniteProductGenerator struct exists with ensure_order(), series(), into_series(). euler_function_generator and qpochhammer_inf_generator factory functions produce lazy generators. Module integrated into series/mod.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Euler function, partition function, Jacobi triple product, and identity verification tests</name>
  <files>
    crates/qsym-core/tests/generator_tests.rs
  </files>
  <action>
Create comprehensive integration tests that verify mathematical correctness against known values.

```rust
use qsym_core::ExprArena;
use qsym_core::number::QRat;
use qsym_core::series::{FormalPowerSeries, arithmetic, generator};
```

Helper to get a SymbolId for "q":
```rust
fn q_sym() -> qsym_core::symbol::SymbolId {
    let mut arena = ExprArena::new();
    let sym = arena.symbols_mut().intern("q");
    sym
}
```

**Euler function tests (pentagonal number theorem) -- OEIS A010815:**

1. `euler_function_coefficients_to_30`: Create euler_function_generator with truncation_order=30. Call ensure_order(30). Verify all 30 coefficients against known values:
   ```
   q^0: +1, q^1: -1, q^2: -1, q^3: 0, q^4: 0,
   q^5: +1, q^6: 0, q^7: +1, q^8: 0, q^9: 0,
   q^10: 0, q^11: 0, q^12: -1, q^13: 0, q^14: 0,
   q^15: -1, q^16: 0, q^17: 0, q^18: 0, q^19: 0,
   q^20: 0, q^21: 0, q^22: +1, q^23: 0, q^24: 0,
   q^25: 0, q^26: +1, q^27: 0, q^28: 0, q^29: 0
   ```
   Nonzero only at generalized pentagonal numbers: 0, 1, 2, 5, 7, 12, 15, 22, 26.

2. `euler_function_to_60`: Extend to truncation_order=60 to verify additional pentagonal numbers:
   q^35: -1, q^40: -1, q^51: +1, q^57: +1. All others in range are 0.

3. `euler_function_sparsity`: After ensure_order(60), verify num_nonzero() is exactly the count of generalized pentagonal numbers below 60. The pentagonal numbers below 60 are: 0,1,2,5,7,12,15,22,26,35,40,51,57 = 13 values. So num_nonzero() == 13.

**Partition function tests -- OEIS A000041:**

4. `partition_function_via_inversion`: Compute 1/(q;q)_inf by inverting the Euler function. Use truncation_order = 25. Verify:
   ```
   p(0)=1, p(1)=1, p(2)=2, p(3)=3, p(4)=5, p(5)=7,
   p(6)=11, p(7)=15, p(8)=22, p(9)=30, p(10)=42,
   p(11)=56, p(12)=77, p(13)=101, p(14)=135, p(15)=176,
   p(16)=231, p(17)=297, p(18)=385, p(19)=490, p(20)=627
   ```
   Verify each coefficient of the inverted series matches.

5. `partition_function_extended`: Use truncation_order = 50. Verify p(0)..p(20) and check that the series has the expected number of nonzero terms -- all p(n) for n>=0 are positive, so there should be exactly truncation_order nonzero coefficients for 1/(q;q)_inf.

**Jacobi triple product tests (ROADMAP success criterion 5):**

The Jacobi triple product identity states:
  prod_{n=1}^{inf} (1 - q^{2n})(1 + z*q^{2n-1})(1 + z^{-1}*q^{2n-1}) = sum_{n=-inf}^{inf} z^n * q^{n^2}

The univariate special case z=1 gives:
  prod_{n=1}^{inf} (1 - q^{2n})(1 + q^{2n-1})^2 = sum_{n=-inf}^{inf} q^{n^2} = theta_3(q)

This is the Jacobi theta function theta_3(q) = 1 + 2*q + 2*q^4 + 2*q^9 + 2*q^16 + 2*q^25 + ...

6. `jacobi_triple_product_z1_theta3`: Verify the z=1 special case to O(q^50).
   **Product side:** Compute three infinite products and multiply them:
   - P1 = prod_{n=1}^{inf} (1 - q^{2n}): Use qpochhammer_inf_generator with a=1, offset=2, but stepping by 2. Actually, since our generator steps by 1, we need a custom factor_fn. Build an InfiniteProductGenerator where factor k (starting k=1) produces (1 - q^{2k}). This is:
     ```rust
     let p1 = InfiniteProductGenerator::new(
         FormalPowerSeries::one(q, trunc),
         1,
         Box::new(move |k, var, tr| {
             let mut f = FormalPowerSeries::one(var, tr);
             f.set_coeff(2 * k, -QRat::one()); // (1 - q^{2k})
             f
         }),
     );
     ```
   - P2 = prod_{n=1}^{inf} (1 + q^{2n-1}): Factor k produces (1 + q^{2k-1}):
     ```rust
     let p2 = InfiniteProductGenerator::new(
         FormalPowerSeries::one(q, trunc),
         1,
         Box::new(move |k, var, tr| {
             let mut f = FormalPowerSeries::one(var, tr);
             f.set_coeff(2 * k - 1, QRat::one()); // (1 + q^{2k-1})
             f
         }),
     );
     ```
   - P3 = P2 (same product, since z=1 means z^{-1}=1). So square P2's result.

   Multiply: result = P1 * P2 * P2 (or P1 * P2^2).

   **Sum side:** Construct the series sum_{n=-inf}^{inf} q^{n^2} directly:
   - Coefficients: coeff(0) = 1, coeff(n^2) += 1 for each n in {-N..N} where n^2 < trunc.
   - Since n and -n give the same n^2: coeff(0) = 1, coeff(k) = 2 for each k that is a perfect square (1, 4, 9, 16, 25, 36, 49).

   **Verify:** The product-side series and sum-side series have identical coefficients to O(q^50).

   Expected nonzero coefficients of theta_3 below q^50:
   q^0: 1, q^1: 2, q^4: 2, q^9: 2, q^16: 2, q^25: 2, q^36: 2, q^49: 2.
   All other coefficients are 0.

7. `jacobi_triple_product_z1_spot_check`: A simpler/faster version -- compute the product side to O(q^20) and spot-check:
   - coeff(0) == 1
   - coeff(1) == 2
   - coeff(2) == 0
   - coeff(3) == 0
   - coeff(4) == 2
   - coeff(9) == 2
   - coeff(16) == 2
   - All non-square exponents below 20 are 0.

**Generator reuse tests:**

8. `generator_incremental_order`: Create generator with truncation_order=10. ensure_order(5) first, check coefficients to O(q^5). Then ensure_order(10), check more coefficients. The generator should reuse the partial product from the first call.

9. `generator_already_complete`: After ensure_order(N), calling ensure_order(N) again is a no-op (factors_included >= target_order).

**Simple series identity tests (end-to-end):**

10. `identity_1_minus_q_times_1_plus_q_via_generator`: Rather than using generator, use raw FPS arithmetic: (1-q)(1+q) = 1 - q^2. Verify this matches the manually constructed series. (Sanity check that 02-01 arithmetic works in this test file too.)

11. `identity_euler_squared_times_partition_squared`: (q;q)_inf * 1/(q;q)_inf should be 1 + O(q^N). Compute Euler function, invert it, multiply the two. All coefficients should be 0 except coeff(0) = 1.

12. `qpochhammer_general_generator`: Use qpochhammer_inf_generator with a = QRat::one(), offset = 1 to verify it gives the same Euler function as euler_function_generator. Compare coefficient-by-coefficient to O(q^30).

**Performance sanity check:**

13. `euler_function_order_100`: Generate Euler function to O(q^100). Should complete in well under 1 second. Verify q^70 = -1 (from k=7: 7*(3*7-1)/2 = 70, sign (-1)^7 = -1) and q^77 = -1 (from k=-7: 7*(3*7+1)/2 = 77, sign (-1)^{-7} = -1).

Run all tests:
```
cargo test --test generator_tests
cargo test
```

Commit: `test(02-03): verify Euler function, partition values, and Jacobi triple product against known identities`
  </action>
  <verify>
`cargo test --test generator_tests` passes all 13+ tests. `cargo test` passes all tests across entire crate. Euler function coefficients match OEIS A010815. Partition function values match OEIS A000041. Jacobi triple product (z=1) matches theta_3 series.
  </verify>
  <done>
Euler function generator verified against pentagonal number theorem (OEIS A010815) to O(q^60+). Partition function via series inversion matches OEIS A000041 for p(0)..p(20). Jacobi triple product identity verified: product side prod(1-q^{2n})(1+q^{2n-1})^2 equals sum side sum q^{n^2} (theta_3) to O(q^50). Generator reuse confirmed. End-to-end identity (q;q)_inf * 1/(q;q)_inf = 1 verified. All mathematical correctness tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --test generator_tests` -- all generator/identity tests pass
2. `cargo test` -- full suite passes (all Phase 1 + Phase 2 tests)
3. `cargo build` -- zero warnings
4. Euler function: nonzero coefficients only at generalized pentagonal numbers, with correct signs
5. Partition function: p(n) values match OEIS A000041 for n=0..20
6. Jacobi triple product (z=1): product side equals theta_3 = 1 + 2q + 2q^4 + 2q^9 + ... to O(q^50)
7. Identity: (q;q)_inf * 1/(q;q)_inf = 1 + O(q^N) with all non-constant coefficients zero
8. Performance: O(q^100) Euler function computes in < 1 second
</verification>

<success_criteria>
- InfiniteProductGenerator lazily multiplies factors on demand via ensure_order()
- euler_function_generator produces (q;q)_inf with correct pentagonal number theorem coefficients
- qpochhammer_inf_generator handles general (a;q)_inf products
- Series inversion of Euler function produces partition function p(n)
- Jacobi triple product special case (z=1) verified: prod(1-q^{2n})(1+q^{2n-1})^2 = sum q^{n^2}
- Mathematical identity (q;q)_inf * 1/(q;q)_inf = 1 verified to O(q^N)
- All 13+ tests pass verifying end-to-end correctness of the series engine
</success_criteria>

<output>
After completion, create `.planning/phases/02-simplification-series-engine/02-03-SUMMARY.md`
</output>
