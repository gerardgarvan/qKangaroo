---
phase: 03-core-qseries-partitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/src/qseries/pochhammer.rs
  - crates/qsym-core/src/qseries/qbinomial.rs
  - crates/qsym-core/src/lib.rs
  - crates/qsym-core/tests/qseries_pochhammer_tests.rs
autonomous: true

must_haves:
  truths:
    - "aqprod(a, q, 0) returns 1 for any a"
    - "aqprod(1*q^0, q, n) returns 0 for any n >= 1 (since first factor is 1-1=0)"
    - "aqprod(1*q^1, q, 2) = (1-q)(1-q^2) = 1 - q - q^2 + q^3"
    - "aqprod(1*q^1, q, Infinite) matches euler_function_generator output"
    - "aqprod(a, q, -1) = 1/(1 - a/q) as an inverted FPS"
    - "qbin(4, 2, q) = 1 + q + 2q^2 + q^3 + q^4"
    - "qbin(5, 2, q) = 1 + q + 2q^2 + 2q^3 + 2q^4 + q^5 + q^6"
  artifacts:
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "Module declaration, QMonomial struct, PochhammerOrder enum, re-exports"
      contains: "pub struct QMonomial"
    - path: "crates/qsym-core/src/qseries/pochhammer.rs"
      provides: "aqprod function handling finite positive, finite negative, zero, and infinite cases"
      exports: ["aqprod"]
    - path: "crates/qsym-core/src/qseries/qbinomial.rs"
      provides: "q-binomial coefficient computation"
      exports: ["qbin"]
    - path: "crates/qsym-core/tests/qseries_pochhammer_tests.rs"
      provides: "Tests for aqprod and qbin"
      min_lines: 100
  key_links:
    - from: "crates/qsym-core/src/qseries/pochhammer.rs"
      to: "crates/qsym-core/src/series/generator.rs"
      via: "qpochhammer_inf_generator for infinite case"
      pattern: "qpochhammer_inf_generator"
    - from: "crates/qsym-core/src/qseries/pochhammer.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "mul, invert for finite product and negative order"
      pattern: "arithmetic::mul|arithmetic::invert"
    - from: "crates/qsym-core/src/qseries/qbinomial.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "Uses aqprod for ratio of q-Pochhammer symbols"
      pattern: "aqprod"
---

<objective>
Create the qseries module with QMonomial, PochhammerOrder, the general q-Pochhammer symbol aqprod(a, q, n), and the q-binomial coefficient qbin(n, k, q).

Purpose: These are the foundational types and functions that ALL other Phase 3 functions build upon. Every named product, theta function, and partition function ultimately composes from aqprod.

Output: `crates/qsym-core/src/qseries/` module with pochhammer.rs and qbinomial.rs, plus comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-qseries-partitions/03-RESEARCH.md

Key existing infrastructure:
@crates/qsym-core/src/series/mod.rs -- FormalPowerSeries struct
@crates/qsym-core/src/series/arithmetic.rs -- add, sub, mul, invert, shift, scalar_mul, negate
@crates/qsym-core/src/series/generator.rs -- InfiniteProductGenerator, euler_function_generator, qpochhammer_inf_generator
@crates/qsym-core/src/number.rs -- QRat, QInt with full arithmetic
@crates/qsym-core/src/lib.rs -- module declarations
@crates/qsym-core/tests/generator_tests.rs -- test patterns to follow
</context>

<tasks>

<task type="auto">
  <name>Task 1: QMonomial, PochhammerOrder, and aqprod function</name>
  <files>
    crates/qsym-core/src/qseries/mod.rs
    crates/qsym-core/src/qseries/pochhammer.rs
    crates/qsym-core/src/lib.rs
  </files>
  <action>
Create the `crates/qsym-core/src/qseries/` directory and module tree.

**In `qseries/mod.rs`:**
- Declare submodules: `pub mod pochhammer; pub mod qbinomial;`
- Define `QMonomial` struct with `coeff: QRat` and `power: i64` fields (both pub). This represents `c * q^m` used as the `a` parameter in aqprod. Add convenience constructors:
  - `QMonomial::new(coeff, power)`
  - `QMonomial::q_power(m)` -- shorthand for `1 * q^m`
  - `QMonomial::constant(c)` -- shorthand for `c * q^0`
- Derive Clone, Debug, PartialEq, Eq on QMonomial
- Define `PochhammerOrder` enum: `Finite(i64)` and `Infinite`. Derive Clone, Debug, PartialEq, Eq.
- Re-export key types: `pub use pochhammer::aqprod; pub use qbinomial::qbin;`

**In `qseries/pochhammer.rs`:**
- Implement `pub fn aqprod(a: &QMonomial, variable: SymbolId, n: PochhammerOrder, truncation_order: i64) -> FormalPowerSeries`
- Match on n:
  - `Finite(0)`: return `FormalPowerSeries::one(variable, truncation_order)`
  - `Finite(k) if k > 0`: call `aqprod_finite_positive`
  - `Finite(k)` (k < 0): call `aqprod_finite_negative`
  - `Infinite`: call `aqprod_infinite`

- `aqprod_finite_positive(a, variable, n, truncation_order)`:
  - CRITICAL: if `a.coeff == QRat::one() && a.power == 0`, first factor is (1-1)=0, return zero series immediately
  - More generally, check if ANY factor `(1 - a.coeff * q^{a.power + k})` for k in 0..n is the zero polynomial. This happens when `a.coeff == QRat::one()` and `a.power + k == 0` for some k. Simpler: if `a.coeff` is 1 and `0 <= -a.power < n`, one factor vanishes.
  - Otherwise: build each factor as `1 - a.coeff * q^{a.power + k}` and multiply sequentially using `arithmetic::mul`
  - Each factor: start with `FormalPowerSeries::one(var, trunc)`, set_coeff at exponent `a.power + k` to `-a.coeff`

- `aqprod_finite_negative(a, variable, n, truncation_order)` where n < 0:
  - `(a;q)_{-|n|} = 1 / (a*q^{-|n|}; q)_{|n|}`
  - Compute `(a*q^{n}; q)_{|n|}` as a finite product (using aqprod_finite_positive with shifted a)
  - The shifted QMonomial has coeff = a.coeff, power = a.power + n (since n is negative, this shifts down)
  - Then invert using `arithmetic::invert`
  - NOTE: the denominator product may have non-unit constant term. If `a.power + n < 0`, there will be negative exponents. Handle by computing the product with the BTreeMap's i64 key support.

- `aqprod_infinite(a, variable, truncation_order)`:
  - Use `qpochhammer_inf_generator(a.coeff.clone(), a.power, variable, truncation_order)` from the existing generator module
  - Call `ensure_order(truncation_order)` on it
  - Return `into_series()`
  - Special case: if `a.coeff == QRat::one() && a.power == 0`, the first factor is (1-1)=0, return zero series (the product diverges to 0)

**In `lib.rs`:** Add `pub mod qseries;` to the module list.

IMPORTANT: Use `crate::series::FormalPowerSeries`, `crate::series::arithmetic`, `crate::series::generator::qpochhammer_inf_generator`, `crate::number::QRat`, `crate::symbol::SymbolId`. Follow existing patterns from the series module.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /cygdrive/c/cygwin64/home/Owner/Kangaroo && cargo build 2>&1` -- must compile with no errors.
  </verify>
  <done>QMonomial, PochhammerOrder, and aqprod compile. The aqprod function handles Finite(0), Finite(positive), Finite(negative), and Infinite cases.</done>
</task>

<task type="auto">
  <name>Task 2: q-binomial coefficient and comprehensive tests</name>
  <files>
    crates/qsym-core/src/qseries/qbinomial.rs
    crates/qsym-core/tests/qseries_pochhammer_tests.rs
  </files>
  <action>
**In `qseries/qbinomial.rs`:**
- Implement `pub fn qbin(n: i64, k: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`
- Edge cases: if k < 0 or k > n, return zero series. If k == 0 or k == n, return one series.
- Use the iterative product formula: `[n choose k]_q = prod_{i=1}^{k} (1 - q^{n-k+i}) / (1 - q^i)`
- Implementation: compute numerator product `prod_{i=1}^{k} (1 - q^{n-k+i})` by building each factor as an FPS and multiplying. Then compute denominator product `prod_{i=1}^{k} (1 - q^i)` similarly. Then use `arithmetic::mul(&numerator, &arithmetic::invert(&denominator))`.
- Alternatively, compute the ratio incrementally: start with 1, for each i from 1 to k: multiply by `(1 - q^{n-k+i})` and divide by `(1 - q^i)`. The "divide by (1-q^i)" is `multiply by 1/(1-q^i)` which is a geometric series `1 + q^i + q^{2i} + ...`.
  - For efficiency, the incremental approach with geometric series inversion avoids computing a potentially large denominator product. But for Phase 3, just compute numerator product and denominator product separately, then multiply by inverted denominator. This is cleaner and uses existing arithmetic.
- The result is always a polynomial (no infinite series), degree = k*(n-k). The truncation_order should be at least k*(n-k)+1 to capture all terms.

**In `qseries_pochhammer_tests.rs`:**
Create comprehensive tests following the pattern in generator_tests.rs. Include helpers:
- `fn q_var() -> SymbolId` (same pattern as generator_tests.rs)
- `fn qrat(n: i64) -> QRat` (same)

**aqprod tests:**
1. `aqprod_order_zero` -- aqprod(any, q, Finite(0)) = 1
2. `aqprod_a_is_one_finite` -- aqprod(1*q^0, q, Finite(5)) = 0 (a=1, first factor vanishes)
3. `aqprod_q_order_2` -- aqprod(1*q^1, q, Finite(2)) = (1-q)(1-q^2) = 1 - q - q^2 + q^3
4. `aqprod_q_squared_order_3` -- aqprod(1*q^2, q, Finite(3)) = (1-q^2)(1-q^3)(1-q^4). Verify specific coefficients.
5. `aqprod_zero_coeff` -- aqprod(0*q^0, q, Finite(5)) = 1 (all factors are (1-0)=1). QMonomial with coeff=0.
6. `aqprod_negative_order_minus_1` -- aqprod(1*q^2, q, Finite(-1)) = 1/(1-q) as inverted FPS. Check: coeff(0)=1, coeff(1)=1, coeff(2)=1, ... (geometric series for 1/(1-q)).
   Wait: (a;q)_{-1} = 1/(a*q^{-1};q)_1 = 1/(1 - a/q). For a=q^2: 1/(1 - q^2/q) = 1/(1-q). Yes.
7. `aqprod_negative_order_minus_2` -- aqprod(1*q^2, q, Finite(-2)) = 1/[(q^0;q)_2] = 1/[(1-1)(1-q)] ... wait, (a*q^n;q)_{|n|} with a=q^2, n=-2: shifted a has power = 2+(-2) = 0, so product is (q^0;q)_2 = (1;q)_2 = (1-1)(1-q) = 0. Cannot invert. Choose a different test: aqprod(1*q^3, q, Finite(-2)) = 1/(q^1;q)_2 = 1/[(1-q)(1-q^2)] = 1/[1-q-q^2+q^3]. Verify low coefficients: 1/(1-q-q^2+q^3) starts as 1 + q + 2q^2 + 2q^3 + 3q^4 + ...
   Actually let me think more carefully. (q^3;q)_{-2} = 1/(q^3 * q^{-2};q)_2 = 1/(q;q)_2 = 1/[(1-q)(1-q^2)]. So 1/(1-q-q^2+q^3). Coefficients: invert 1 - q - q^2 + q^3. c[0]=1, c[1]=1, c[2]=1+1=2, c[3]=2+1-1=2... Let me compute properly:
   f = 1 - q - q^2 + q^3. 1/f: c[0]=1. c[1] = -(-1)*1 = 1. c[2] = -((-1)*1 + (-1)*1) = 2. c[3] = -((-1)*2 + (-1)*1 + 1*1) = -(−2−1+1) = 2. c[4] = -((-1)*2 + (-1)*2 + 1*1) = 3. OK good.
8. `aqprod_infinite_matches_euler` -- aqprod(QMonomial::q_power(1), q, Infinite, 30) should match euler_function_generator. Compare coefficient-by-coefficient to O(q^30).
9. `aqprod_infinite_minus_q` -- aqprod(QMonomial::new(-QRat::one(), 1), q, Infinite, 30). This is (-q;q)_inf = prod(1+q^k). Coefficients: 1/(q;q)_inf for distinct parts? No, (-q;q)_inf = prod_{k>=0}(1-(-q)*q^k) = prod_{k>=0}(1+q^{k+1}). First factor k=0: (1+q). k=1: (1+q^2). So (-q;q)_inf = prod_{k>=1}(1+q^k) which is the distinct parts GF. Verify first coefficients: Q(0)=1, Q(1)=1, Q(2)=1, Q(3)=2, Q(4)=2, Q(5)=3 (OEIS A000009).
   Wait: qpochhammer_inf_generator with a=-1, offset=1 gives prod_{k>=0}(1-(-1)*q^{1+k}) = prod_{k>=0}(1+q^{1+k}) = prod_{n>=1}(1+q^n). That IS the distinct parts GF. Good. But aqprod would call it with QMonomial(-1, 1), meaning a.coeff=-1, a.power=1. The generator would be qpochhammer_inf_generator(-1, 1, ...) which produces prod(1-(-1)*q^{1+k}) = prod(1+q^{1+k}) for k>=0 = prod(1+q^n) for n>=1. Correct.

**qbin tests:**
10. `qbin_4_2` -- [4 choose 2]_q = 1 + q + 2q^2 + q^3 + q^4
11. `qbin_5_2` -- [5 choose 2]_q = 1 + q + 2q^2 + 2q^3 + 2q^4 + q^5 + q^6
12. `qbin_n_0` -- [5 choose 0]_q = 1
13. `qbin_n_n` -- [5 choose 5]_q = 1
14. `qbin_symmetry` -- [6 choose 2]_q == [6 choose 4]_q
15. `qbin_n_1` -- [5 choose 1]_q = 1 + q + q^2 + q^3 + q^4

All tests follow the pattern: create q_var(), compute the function, check specific coefficients using `assert_eq!(fps.coeff(k), qrat(expected))`.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /cygdrive/c/cygwin64/home/Owner/Kangaroo && cargo test 2>&1` -- all tests pass including new ones, zero regressions on existing 253 tests.
  </verify>
  <done>aqprod handles all cases correctly: Finite(0) returns 1, Finite(positive) computes product, a=1 at q^0 returns zero, Finite(negative) inverts, Infinite delegates to generator. qbin produces correct Gaussian polynomials. All tests pass.</done>
</task>

</tasks>

<verification>
- `cargo build` compiles without errors
- `cargo test` passes all tests (existing 253 + new ~15)
- aqprod(1*q^1, q, Infinite, 30) matches euler_function_generator coefficient-by-coefficient
- qbin(4,2) = 1 + q + 2q^2 + q^3 + q^4 matches hand computation
</verification>

<success_criteria>
- QMonomial and PochhammerOrder types exist and are usable
- aqprod handles all 4 order cases (0, positive, negative, infinite) with correct output
- qbin produces correct Gaussian polynomials
- All Phase 3 functions can import and use these types
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-qseries-partitions/03-01-SUMMARY.md`
</output>
