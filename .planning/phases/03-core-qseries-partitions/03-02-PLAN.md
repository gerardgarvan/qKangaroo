---
phase: 03-core-qseries-partitions
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/qsym-core/src/qseries/products.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_products_tests.rs
autonomous: true

must_haves:
  truths:
    - "etaq(1, 1, q, 50) matches euler_function_generator output (since etaq(1,1) = (q;q)_inf)"
    - "jacprod(1, 5, q, 50) expands to a correct series (Jacobi product with a=1, b=5)"
    - "tripleprod with z=1 matches theta3 coefficients (1 + 2q + 2q^4 + 2q^9 + ...)"
    - "quinprod produces correct series verified against quintuple product identity"
    - "winquist(a, b, q, 30) produces a series with correct leading terms"
  artifacts:
    - path: "crates/qsym-core/src/qseries/products.rs"
      provides: "etaq, jacprod, tripleprod, quinprod, winquist functions"
      exports: ["etaq", "jacprod", "tripleprod", "quinprod", "winquist"]
    - path: "crates/qsym-core/tests/qseries_products_tests.rs"
      provides: "Tests for all 5 named products"
      min_lines: 100
  key_links:
    - from: "crates/qsym-core/src/qseries/products.rs"
      to: "crates/qsym-core/src/series/generator.rs"
      via: "InfiniteProductGenerator for each product factor"
      pattern: "InfiniteProductGenerator::new"
    - from: "crates/qsym-core/src/qseries/products.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "mul to compose product factors"
      pattern: "arithmetic::mul"
---

<objective>
Implement the five named infinite product functions: etaq, jacprod, tripleprod, quinprod, and winquist.

Purpose: These are the building blocks for Garvan's q-series package. Each is defined as a product of q-Pochhammer symbols and is computed by composing InfiniteProductGenerator instances.

Output: `products.rs` with all 5 functions and comprehensive tests verifying against known identities.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-qseries-partitions/03-RESEARCH.md
@.planning/phases/03-core-qseries-partitions/03-01-SUMMARY.md

Key files:
@crates/qsym-core/src/series/generator.rs -- InfiniteProductGenerator
@crates/qsym-core/src/series/arithmetic.rs -- mul, invert, scalar_mul
@crates/qsym-core/src/qseries/mod.rs -- QMonomial, PochhammerOrder (from Plan 01)
@crates/qsym-core/src/qseries/pochhammer.rs -- aqprod (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: etaq and jacprod functions</name>
  <files>
    crates/qsym-core/src/qseries/products.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
**In `qseries/products.rs`:**

Implement `etaq(b: i64, t: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Computes `(q^b; q^t)_inf = prod_{n=0}^{inf} (1 - q^{b + t*n})`
- Cannot directly use `qpochhammer_inf_generator` because that assumes step q^1. etaq uses step q^t.
- Build a custom InfiniteProductGenerator:
  - Factor n: `(1 - q^{b + t*n})`
  - Start index: 0
  - factor_fn: `|n, var, trunc| { let exp = b + t * n; let mut f = FPS::one(var, trunc); if exp < trunc && exp >= 0 { f.set_coeff(exp, -QRat::one()); } f }`
  - The generator naturally terminates when `b + t*n >= truncation_order`
  - Call `ensure_order(truncation_order)` -- this is correct because the loop in ensure_order runs while `factors_included < target_order`, and factor n only contributes at exponent `b + t*n`. We actually need factors_included to go up to approximately `(truncation_order - b) / t`. But ensure_order uses the factor index, not the exponent. Since factor n has minimum exponent `b + t*n`, once `b + t*n >= trunc`, the factor is `1 + O(q^trunc)` and doesn't affect the result. So we need ensure_order to run until the factor index n satisfies `b + t*n >= trunc`, i.e., `n >= (trunc - b) / t`. Call `ensure_order((truncation_order - b + t - 1) / t + 1)` or more simply `ensure_order(truncation_order)` which is safe (it just multiplies by identity factors for large n, which is wasteful but correct). Actually, looking at the generator code, it multiplies factor k for k from start_index up to target_order. If we pass truncation_order as target, we get way too many factors. Instead, compute the needed count: `let max_factors = ((truncation_order - b) / t) + 1;` and call `ensure_order(max_factors.max(0))`.
  - Return `into_series()`
- Special case: if b <= 0 and t > 0, the first factor has exponent b which may be <= 0. For b=0: factor is (1 - q^0) = (1-1) = 0, so the entire product is 0. Return zero series.
- Assert t > 0 (step must be positive).

Implement `jacprod(a: i64, b: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Computes `JAC(a, b) = (q^a; q^b)_inf * (q^{b-a}; q^b)_inf * (q^b; q^b)_inf`
- Precondition: 0 < a < b. Assert this.
- Three calls to etaq, multiplied together:
  ```
  let p1 = etaq(a, b, variable, truncation_order);
  let p2 = etaq(b - a, b, variable, truncation_order);
  let p3 = etaq(b, b, variable, truncation_order);
  let temp = arithmetic::mul(&p1, &p2);
  arithmetic::mul(&temp, &p3)
  ```

**In `qseries/mod.rs`:** Add `pub mod products;` and re-export: `pub use products::{etaq, jacprod, tripleprod, quinprod, winquist};`
  </action>
  <verify>
Run `cargo build` -- must compile.
  </verify>
  <done>etaq correctly computes (q^b; q^t)_inf with arbitrary step. jacprod computes the Jacobi triple product as three etaq factors.</done>
</task>

<task type="auto">
  <name>Task 2: tripleprod, quinprod, winquist, and tests for all products</name>
  <files>
    crates/qsym-core/src/qseries/products.rs
    crates/qsym-core/tests/qseries_products_tests.rs
  </files>
  <action>
**Add to `products.rs`:**

Implement `tripleprod(z: &QMonomial, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Jacobi triple product: `prod_{n>=1}(1-q^n) * prod_{n>=0}(1 - z*q^n) * prod_{n>=1}(1 - q^n/z)`
- Where z is a QMonomial `c * q^m`.
- Factor 1: `(q;q)_inf` = euler function. Use `euler_function_generator(variable, truncation_order)`.
- Factor 2: `prod_{n>=0}(1 - c*q^{m+n})`. This is `(c*q^m; q)_inf`. Use `qpochhammer_inf_generator(c, m, variable, truncation_order)`. But careful: if c==1 and m==0, the first factor (1-1)=0 and the product is 0. Handle this edge case.
- Factor 3: `prod_{n>=1}(1 - (1/c)*q^{-m+n})`. This is `((1/c)*q^{-m+1}; q)_inf` starting from n=1, which is `(q^{1-m}/c; q)_inf`. Actually: the n-th factor (n>=1) is `(1 - q^n/z) = (1 - (1/c)*q^{n-m})`. So it is `prod_{n>=1}(1 - (1/c)*q^{n-m})`. Use `qpochhammer_inf_generator(QRat::one()/c, 1-m, variable, truncation_order)` -- wait, that generator does `prod_{k>=0}(1 - a*q^{offset+k})`. For our needs, offset = 1-m, a = 1/c. Factor k has exponent `1-m+k`. For k=0: exponent `1-m`. For k=1: `2-m`. This matches n=1 giving exponent `1-m`, n=2 giving `2-m`, etc. But if c != 0, ensure 1/c is valid. Assert c != 0.
  - If 1/c results in issues (c might be rational), just compute `QRat::one() / z.coeff.clone()`.
- Multiply all three factors: `euler * factor2 * factor3`
- Ensure all three generators are ensured to the same truncation_order before extracting series.

Implement `quinprod(z: &QMonomial, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Quintuple product: `prod_{n>=1}(1-q^n)(1-z*q^n)(1-z^{-1}*q^{n-1})(1-z^2*q^{2n-1})(1-z^{-2}*q^{2n-1})`
- Where z = c*q^m.
- Factor 1: `(q;q)_inf` (start at n=1) -- euler function
- Factor 2: `prod_{n>=1}(1 - c*q^{m+n})` -- qpochhammer_inf_generator(c, m+1, var, trunc) -- start at exponent m+1
- Factor 3: `prod_{n>=1}(1 - (1/c)*q^{-m+n-1})` = `prod_{n>=1}(1 - (1/c)*q^{n-m-1})` -- qpochhammer_inf_generator(1/c, -m, var, trunc) -- start at exponent -m (when n=1, exp = 1-m-1 = -m)
  Wait: n>=1, exponent = n-1-m. For n=1: -m. For n=2: 1-m. Offset = -m, step = 1. generator does k from 0: offset+k = -m, -m+1, ... which gives n=1,2,... Good.
  Use qpochhammer_inf_generator(1/c, -m, var, trunc). But if -m is negative, the generator will produce factors with negative exponents early on, which the FPS supports.
- Factor 4: `prod_{n>=1}(1 - c^2*q^{2m+2n-1})` -- custom generator with factor n = (1 - c^2*q^{2m+2n-1}). Exponent = 2m+2n-1. For n=1: 2m+1. Step = 2. Use InfiniteProductGenerator with a = c^2, starting exponent = 2m+1, step = 2.
- Factor 5: `prod_{n>=1}(1 - (1/c^2)*q^{-2m+2n-1})` -- similar, exponent = 2n-1-2m. For n=1: 1-2m. Step = 2. a = 1/c^2.
- Multiply all 5 factors.
- For factors 4 and 5, build custom InfiniteProductGenerators similar to etaq pattern with step 2.

Implement `winquist(a: &QMonomial, b: &QMonomial, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Winquist's identity product:
  `prod_{n>=1}(1-q^n)^2 * prod_{n>=0}(1-a_c*q^{a_p+n})(1-a_c^{-1}*q^{1-a_p+n})(1-b_c*q^{b_p+n})(1-b_c^{-1}*q^{1-b_p+n})(1-a_c*b_c*q^{a_p+b_p+n})(1-a_c^{-1}*b_c^{-1}*q^{2-a_p-b_p+n})(1-a_c*b_c^{-1}*q^{a_p-b_p+n})(1-a_c^{-1}*b_c*q^{1-a_p+b_p+n})`
  where a = a_c * q^{a_p}, b = b_c * q^{b_p}.
- This is 10 product factors: (q;q)_inf^2 times 8 q-Pochhammer infinite products.
- Build each using qpochhammer_inf_generator with appropriate (coefficient, offset).
- The (q;q)_inf^2 factor: compute euler function, square it.
- Then multiply in the 8 remaining factors one at a time.
- Use the same truncation_order for all.

**In `qseries_products_tests.rs`:**

1. `etaq_1_1_is_euler` -- etaq(1, 1, q, 30) matches euler_function_generator to O(q^30)
2. `etaq_2_2_is_q2_q2_inf` -- etaq(2, 2, q, 30) = (q^2;q^2)_inf = prod(1-q^{2n}) for n>=1. Verify: at even pentagonal-like exponents, nonzero; at odd exponents, always zero.
3. `jacprod_1_2` -- jacprod(1, 2, q, 30) = (q;q^2)_inf * (q;q^2)_inf * (q^2;q^2)_inf. This equals (q;q)_inf by Jacobi triple product (since (q;q)_inf = (q;q^2)_inf * (q^2;q^2)_inf and ... actually this needs careful verification). Better test: jacprod(1, 5, q, 50) and check known coefficients.
   Actually simplest: jacprod(1, 2, q, 30) = etaq(1,2)*etaq(1,2)*etaq(2,2) = (q;q^2)_inf^2 * (q^2;q^2)_inf. And (q;q^2)_inf * (q^2;q^2)_inf = (q;q)_inf. So jacprod(1,2) = (q;q^2)_inf * (q;q)_inf. Hmm, not a clean identity. Let me use a different verification approach.
   Use: theta4(q) = jacprod(1, 2, q, T) because theta4 = (q^2;q^2)_inf * (q;q^2)_inf^2 which is exactly JAC(1,2). Verify theta4 coefficients: 1 - 2q + 2q^4 - 2q^9 + 2q^16 - ...
4. `tripleprod_z1_is_theta3` -- tripleprod with z = QMonomial::q_power(0) (i.e., z=1)... Wait, z=1 means c=1, m=0. Then factor 2 is prod_{n>=0}(1-q^n): first factor is (1-1)=0, entire product is 0! That's wrong. The issue is that the standard Jacobi triple product formula has `prod_{n>=0}(1-z*q^n)` which for z=1 gives 0. The correct z=1 formula for theta3 uses a DIFFERENT form.
   Actually, the research says tripleprod at z=1 gives theta3 but the indexing is: `prod_{n>=1}(1-q^{2n})(1+q^{2n-1})^2`. This is the PRODUCT representation of theta3, NOT the Jacobi triple product with z=1. The Jacobi triple product `sum (-1)^n z^n q^{n(n-1)/2}` at z=1 gives `sum (-1)^n q^{n(n-1)/2}` which is the Euler function, not theta3.
   So tripleprod as defined in the research (Garvan's convention) is `prod_{n>=1}(1-q^n) * prod_{n>=0}(1-z*q^n) * prod_{n>=1}(1-q^n/z)`. At z=q: factor2 starts with (1-q*q^0)=(1-q), then (1-q*q)=(1-q^2)... so prod_{n>=0}(1-q^{n+1}) = (q;q)_inf. Factor3: prod_{n>=1}(1-q^{n-1}) = (1-1)*... = 0. So z=q also gives 0.
   Better test for tripleprod: use z = QMonomial::new(-QRat::one(), 0) (z = -1). Then: factor2 = prod_{n>=0}(1-(-1)*q^n) = prod(1+q^n). factor3 = prod_{n>=1}(1-(-1)*q^n) = prod_{n>=1}(1+q^n). Wait factor3 is prod_{n>=1}(1 - q^n/(-1)) = prod_{n>=1}(1 + q^n). So: tripleprod(-1) = (q;q)_inf * prod_{n>=0}(1+q^n) * prod_{n>=1}(1+q^n). The first product factor (n=0) of factor2 is (1+1)=2. So factor2 = 2 * prod_{n>=1}(1+q^n). Thus tripleprod(-1) = 2 * (q;q)_inf * [prod_{n>=1}(1+q^n)]^2.
   This gets complicated. Let me just test with z = QMonomial::new(QRat::one(), 1) (z = q). Factor 2: prod_{n>=0}(1-q^{1+n}) = prod_{n>=1}(1-q^n) = (q;q)_inf. Factor 3: prod_{n>=1}(1 - q^{n-1}) -- first factor (1-q^0)=(1-1)=0 so entire product is 0. Result: 0. Test that tripleprod(q, q, T) = 0.
   For a non-trivial test: the Jacobi triple product identity says tripleprod equals a specific bilateral sum. Let's build the sum side independently and compare. For z=QMonomial::new(QRat::one(), 2) (z=q^2):
   tripleprod(q^2, q, T) = prod_{n>=1}(1-q^n) * prod_{n>=0}(1-q^{2+n}) * prod_{n>=1}(1-q^{n-2}).
   Factor 3 first factor is (1-q^{-1}) which has a negative exponent term. This is messy.
   Better approach: verify tripleprod against the bilateral series sum directly. For generic z = c*q^m, the bilateral sum is sum_{n=-inf}^{inf} (-1)^n * c^n * q^{m*n + n*(n-1)/2}. Build this sum as an FPS and compare.
5. `quinprod_basic` -- At z = QMonomial::q_power(1) (z=q), verify quinprod against the series representation.
6. `winquist_basic` -- At a = QMonomial::q_power(1), b = QMonomial::q_power(1), verify first few nonzero coefficients.
7. `etaq_builds_eta` -- etaq(1, 1, q, 50) gives (q;q)_inf. The Dedekind eta is q^{1/24} * etaq(1,1). Verify that etaq(1,1) * etaq(1,1) (i.e., (q;q)_inf^2) has the right coefficients for testing Winquist.

For tripleprod verification, the most robust approach: compute tripleprod for z = QMonomial::new(-QRat::one(), 1) (z = -q) and compare against the bilateral series: sum_{n=-inf}^{inf} (-1)^n * (-1)^n * q^{n + n(n-1)/2} = sum q^{n(n+1)/2} (since (-1)^n * (-1)^n = 1). Build that sum as FPS and compare with the product. The sum has terms at triangular numbers: 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 with coefficient 1 each (for n>=0) plus terms for n<0 at the same positions (triangular numbers are symmetric: n(n+1)/2 for n and |n|-1 give same values for negative n). Actually for n<0: let n = -k, k>0: exponent = -k*(-k-1)/2 = k(k+1)/2, sign = (-1)^{-k}*(-q)^{-k} = ... this gets complicated. Let me just build both sides numerically to O(q^30) and compare.

Actually, the most practical test approach: verify that `jacprod(a, b)` equals `etaq(a,b) * etaq(b-a,b) * etaq(b,b)` by computing both sides. This tests the composition but not absolute correctness. For absolute correctness, use the theta4 identity: `theta4(q) = (q^2;q^2)_inf * (q;q^2)_inf^2 = jacprod(1,2,q,T)`. Verify theta4 coefficients are 1, -2, 0, 0, 2, 0, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 2, ...
  </action>
  <verify>
Run `cargo test` -- all tests pass with zero regressions.
  </verify>
  <done>All 5 named products (etaq, jacprod, tripleprod, quinprod, winquist) produce correct series expansions. Tests verify against known identities and coefficient values.</done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests
- etaq(1,1) matches euler function
- jacprod(1,2) produces theta4 coefficients
- Product functions compose correctly from InfiniteProductGenerator
</verification>

<success_criteria>
- etaq(b, t, q, T) correctly computes (q^b; q^t)_inf for arbitrary step t
- jacprod, tripleprod, quinprod, winquist all produce correct series
- All named products match known mathematical identities in tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-qseries-partitions/03-02-SUMMARY.md`
</output>
