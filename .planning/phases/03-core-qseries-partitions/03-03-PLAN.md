---
phase: 03-core-qseries-partitions
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/qsym-core/src/qseries/theta.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_theta_tests.rs
autonomous: true

must_haves:
  truths:
    - "theta3(q, 50) has nonzero coefficients only at perfect squares, with coeff(0)=1 and coeff(n^2)=2 for n>=1"
    - "theta4(q, 50) has nonzero coefficients only at perfect squares, with coeff(0)=1 and coeff(n^2)=2*(-1)^n for n>=1"
    - "theta2(q, 50) returns series in q^{1/4} variable with coeff at exponent 4k^2+4k+1 = (2k+1)^2"
    - "theta3(q)^2 coefficients match r_2(n) values (sum of two squares representation counts)"
  artifacts:
    - path: "crates/qsym-core/src/qseries/theta.rs"
      provides: "theta2, theta3, theta4 functions"
      exports: ["theta2", "theta3", "theta4"]
    - path: "crates/qsym-core/tests/qseries_theta_tests.rs"
      provides: "Theta function tests including identity verification"
      min_lines: 80
  key_links:
    - from: "crates/qsym-core/src/qseries/theta.rs"
      to: "crates/qsym-core/src/series/generator.rs"
      via: "InfiniteProductGenerator for product representations"
      pattern: "InfiniteProductGenerator::new"
    - from: "crates/qsym-core/src/qseries/theta.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "mul and scalar_mul for combining factors"
      pattern: "arithmetic::mul|arithmetic::scalar_mul"
---

<objective>
Implement the three Jacobi theta functions: theta2(q), theta3(q), theta4(q), using their product representations.

Purpose: Theta functions are central to q-series research. theta3 and theta4 are straightforward products in q. theta2 involves a q^{1/4} prefactor requiring special handling via a rescaled variable.

Output: `theta.rs` with all 3 theta functions and tests verifying against known coefficients and identities (theta3^2 gives sum-of-two-squares counts).
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-qseries-partitions/03-RESEARCH.md
@.planning/phases/03-core-qseries-partitions/03-01-SUMMARY.md

Key files:
@crates/qsym-core/src/series/generator.rs -- InfiniteProductGenerator
@crates/qsym-core/src/series/arithmetic.rs -- mul, scalar_mul
@crates/qsym-core/src/series/mod.rs -- FormalPowerSeries
@crates/qsym-core/tests/generator_tests.rs -- existing theta3 test pattern (jacobi_triple_product_z1_theta3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: theta3 and theta4 functions</name>
  <files>
    crates/qsym-core/src/qseries/theta.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
**In `qseries/theta.rs`:**

Implement `pub fn theta3(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Product form: `theta3(q) = (q^2; q^2)_inf * (-q; q^2)_inf^2`
- Equivalently: `prod_{n>=1}(1-q^{2n}) * [prod_{n>=0}(1+q^{2n+1})]^2`
- Factor 1: `(q^2; q^2)_inf` -- InfiniteProductGenerator starting at n=1, factor n = (1 - q^{2n}). Need `(truncation_order + 1) / 2` factors (since exponent 2n, we need 2n < trunc, so n < trunc/2).
  ```
  InfiniteProductGenerator::new(
      FPS::one(variable, truncation_order),
      1, // start at n=1
      |n, var, trunc| { factor with -1 at exponent 2*n }
  )
  ```
  Call ensure_order with `(truncation_order + 1) / 2` to avoid unnecessary factor evaluations.
- Factor 2: `(-q; q^2)_inf = prod_{n>=0}(1 + q^{2n+1})` -- InfiniteProductGenerator starting at n=0, factor n = (1 + q^{2n+1}). Note the +1 (not -1) because this is prod(1-(-q)*q^{2n}) = prod(1+q^{2n+1}).
  Call ensure_order with `(truncation_order + 1) / 2`.
- Compute: `factor1 * factor2 * factor2` (square factor2 by multiplying its series by itself, then multiply by factor1).

Implement `pub fn theta4(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Product form: `theta4(q) = (q^2; q^2)_inf * (q; q^2)_inf^2`
- Equivalently: `prod_{n>=1}(1-q^{2n}) * [prod_{n>=0}(1-q^{2n+1})]^2`
- Factor 1: Same as theta3's factor 1: `(q^2; q^2)_inf`
- Factor 2: `(q; q^2)_inf = prod_{n>=0}(1-q^{2n+1})` -- InfiniteProductGenerator starting at n=0, factor n = (1 - q^{2n+1}). Note the -1 here (unlike theta3's +1).
- Compute: `factor1 * factor2^2`

Note: theta3 and theta4 share the same factor1. For code clarity, extract a helper `q2_q2_inf(variable, truncation_order) -> FormalPowerSeries` that computes `(q^2; q^2)_inf`.

**In `qseries/mod.rs`:** Add `pub mod theta;` and re-export: `pub use theta::{theta2, theta3, theta4};`
  </action>
  <verify>
Run `cargo build` -- must compile. Quick smoke test: `cargo test theta` should find the test file (even if empty initially).
  </verify>
  <done>theta3 and theta4 compile and use product representations via InfiniteProductGenerator.</done>
</task>

<task type="auto">
  <name>Task 2: theta2 function and comprehensive theta tests</name>
  <files>
    crates/qsym-core/src/qseries/theta.rs
    crates/qsym-core/tests/qseries_theta_tests.rs
  </files>
  <action>
**Add theta2 to `qseries/theta.rs`:**

Implement `pub fn theta2(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- theta2(q) = 2*q^{1/4} * prod_{n>=1}(1-q^{2n})(1+q^{2n})^2
- Since our FPS uses integer exponents, theta2 is returned as a series in X = q^{1/4}. The `variable` parameter conceptually represents q^{1/4} for this function. Document this clearly in the docstring.
- After the substitution q = X^4, theta2 becomes:
  `2*X * prod_{n>=1}(1 - X^{8n})(1 + X^{8n})^2`
- The returned FPS has integer exponents representing powers of X = q^{1/4}:
  - Exponent 1: coefficient 2 (from the 2*X prefactor)
  - Exponent 9: coefficient 2 (from 2*X^9 = 2*(q^{1/4})^9 = 2*q^{9/4})
  - Exponent 25: coefficient 2
  - Generally: nonzero at odd perfect squares (2k+1)^2 with coefficient 2
- Factor 1: `prod_{n>=1}(1 - X^{8n})` -- generator with factor n = (1 - X^{8n}).
  Call ensure_order with `(truncation_order + 7) / 8 + 1`.
- Factor 2: `prod_{n>=1}(1 + X^{8n})` -- generator with factor n = (1 + X^{8n}).
- Compute: `factor1 * factor2^2`, then multiply by the monomial `2*X` using `arithmetic::mul` with `FPS::monomial(variable, QRat::from((2,1)), 1, truncation_order)`.

Alternatively, the series representation of theta2 in X=q^{1/4} has nonzero terms only at (2k+1)^2 for k=0,1,2,... with coefficient 2. So: exponents 1, 9, 25, 49, 81, 121, ... This is the sum `2 * sum_{k=0}^{inf} X^{(2k+1)^2}`.

Both approaches should agree. The product representation is more general and can be cross-checked against the sum.

**In `qseries_theta_tests.rs`:**

Create test file with helpers (q_var, qrat as in other test files).

**theta3 tests:**
1. `theta3_coefficients_to_50` -- theta3 nonzero only at perfect squares 0,1,4,9,16,25,36,49. coeff(0)=1, coeff(n^2)=2 for n=1..7. All non-square exponents are 0.
2. `theta3_matches_phase2_jacobi_test` -- theta3 output matches the product-side computation from generator_tests.rs::jacobi_triple_product_z1_theta3. Compute both and compare coefficient by coefficient to O(q^50).
3. `theta3_squared_sum_of_two_squares` -- theta3(q)^2 coefficients match r_2(n) from OEIS A004018: r_2(0)=1, r_2(1)=4, r_2(2)=4, r_2(3)=0, r_2(4)=4, r_2(5)=8, r_2(6)=0, r_2(7)=0, r_2(8)=4, r_2(9)=4, r_2(10)=8. This is a strong correctness check.

**theta4 tests:**
4. `theta4_coefficients_to_50` -- theta4 nonzero only at perfect squares with alternating signs: coeff(0)=1, coeff(1)=-2, coeff(4)=2, coeff(9)=-2, coeff(16)=2, coeff(25)=-2, coeff(36)=2, coeff(49)=-2.
5. `theta4_times_theta4_check` -- theta4(q)^2 has known coefficients. Specifically: the coefficient of q^n in theta4^2 is the excess of representations of n as sum of 2 squares with both even over both odd. Verify: coeff(0)=1, coeff(1)=-4, coeff(2)=4, coeff(3)=0, coeff(4)=4.

**theta2 tests:**
6. `theta2_coefficients` -- theta2 returns series in X=q^{1/4}. Nonzero at exponents 1, 9, 25, 49, 81, 121, 169 (i.e., (2k+1)^2 for k=0,1,...). All coefficients are 2. All other exponents are 0. Test up to truncation_order = 200 (to capture (13)^2=169).

**Cross-theta identity:**
7. `theta_identity_theta3sq_theta4sq` -- Verify theta3(q)^4 - theta4(q)^4 has specific known structure (related to theta2 but requires matching variable conventions). Alternatively, just verify `theta3(q)^2 - theta4(q)^2` has known nonzero pattern. Since theta3^2 - theta4^2 = 4*(q + q^3 + q^5 + ...) ... actually verify: theta3^2 coeff(n) - theta4^2 coeff(n) for small n. At n=1: 4-(-4)=8. At n=2: 4-4=0. Hmm, let me use the reliable test: just theta3^2 matches r_2(n) values (test 3 above), and theta4 matches known coefficients. That's sufficient.
  </action>
  <verify>
Run `cargo test` -- all tests pass including new theta tests and all existing 253+ tests.
  </verify>
  <done>theta2, theta3, theta4 all produce correct series. theta3^2 matches sum-of-two-squares counts (r_2(n)). theta4 has correct alternating signs at perfect squares. theta2 correctly returns series in q^{1/4}.</done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests
- theta3 has coefficients 1, 2, 0, 0, 2, 0, 0, 0, 0, 2 at exponents 0-9
- theta4 has coefficients 1, -2, 0, 0, 2, 0, 0, 0, 0, -2 at exponents 0-9
- theta3^2 matches r_2(n): 1, 4, 4, 0, 4, 8, 0, 0, 4, 4, 8
</verification>

<success_criteria>
- All three theta functions produce correct series verified against known values
- theta2 convention (series in q^{1/4}) is clearly documented
- theta3^2 identity test passes, confirming end-to-end correctness
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-qseries-partitions/03-03-SUMMARY.md`
</output>
