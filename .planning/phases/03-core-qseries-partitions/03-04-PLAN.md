---
phase: 03-core-qseries-partitions
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/qsym-core/src/qseries/partitions.rs
  - crates/qsym-core/src/qseries/rank_crank.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_partitions_tests.rs
autonomous: true

must_haves:
  truths:
    - "partition_count(n) returns correct p(n) for n=0..200 matching OEIS A000041"
    - "partition_count(200) = 3972999029388"
    - "distinct_parts_gf produces series with coefficients matching OEIS A000009 for Q(0)..Q(20)"
    - "odd_parts_gf matches distinct_parts_gf coefficient-by-coefficient (Euler's theorem)"
    - "bounded_parts_gf(m, q, T) for m=3 gives correct partition counts with at most 3 parts"
    - "crank_gf at z=1 matches partition generating function 1/(q;q)_inf"
    - "rank_gf at z=1 matches partition generating function 1/(q;q)_inf"
  artifacts:
    - path: "crates/qsym-core/src/qseries/partitions.rs"
      provides: "partition_count, partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf"
      exports: ["partition_count", "partition_gf", "distinct_parts_gf", "odd_parts_gf", "bounded_parts_gf"]
    - path: "crates/qsym-core/src/qseries/rank_crank.rs"
      provides: "rank_gf and crank_gf generating functions"
      exports: ["rank_gf", "crank_gf"]
    - path: "crates/qsym-core/tests/qseries_partitions_tests.rs"
      provides: "Partition and rank/crank tests verified against OEIS"
      min_lines: 120
  key_links:
    - from: "crates/qsym-core/src/qseries/partitions.rs"
      to: "crates/qsym-core/src/series/generator.rs"
      via: "euler_function_generator for partition GF"
      pattern: "euler_function_generator"
    - from: "crates/qsym-core/src/qseries/partitions.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "invert for 1/(q;q)_inf and other partition GFs"
      pattern: "arithmetic::invert"
    - from: "crates/qsym-core/src/qseries/rank_crank.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "aqprod for building product factors"
      pattern: "aqprod"
---

<objective>
Implement partition functions (p(n) via pentagonal recurrence, generating functions for restricted partitions) and rank/crank generating functions.

Purpose: Partition counting and rank/crank are core capabilities matching Garvan's qseries package. The pentagonal recurrence gives efficient O(n*sqrt(n)) single-value computation. Restricted partition GFs (distinct parts, odd parts, bounded) cover common research use cases.

Output: `partitions.rs` and `rank_crank.rs` with comprehensive OEIS-verified tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-qseries-partitions/03-RESEARCH.md
@.planning/phases/03-core-qseries-partitions/03-01-SUMMARY.md

Key files:
@crates/qsym-core/src/series/generator.rs -- euler_function_generator, qpochhammer_inf_generator
@crates/qsym-core/src/series/arithmetic.rs -- mul, invert, add
@crates/qsym-core/src/series/mod.rs -- FormalPowerSeries
@crates/qsym-core/src/qseries/pochhammer.rs -- aqprod (from Plan 01)
@crates/qsym-core/src/qseries/mod.rs -- QMonomial, PochhammerOrder (from Plan 01)
@crates/qsym-core/tests/generator_tests.rs -- existing p(n) tests to O(q^20)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Partition functions -- partition_count and generating functions</name>
  <files>
    crates/qsym-core/src/qseries/partitions.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
**In `qseries/partitions.rs`:**

Implement `pub fn partition_count(n: i64) -> QRat`:
- Returns p(n), the number of partitions of n.
- Uses pentagonal number recurrence for O(n * sqrt(n)) computation.
- Edge cases: n < 0 returns 0. n == 0 returns 1.
- Build a table from p(0) to p(n) using:
  ```
  p(i) = sum_{k=1}^{...} (-1)^{k+1} * [p(i - k(3k-1)/2) + p(i - k(3k+1)/2)]
  ```
  where terms with negative indices contribute 0.
- The loop over k terminates when the first generalized pentagonal number k(3k-1)/2 exceeds i.
- Return table[n] as QRat (p(n) is always a non-negative integer, so store as QRat from integer for compatibility).
- Implementation detail: use `Vec<QRat>` for the table. Build from 0 to n.

Implement `pub fn partition_gf(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Returns the full partition generating function: sum_{n>=0} p(n) * q^n = 1/(q;q)_inf
- Use `euler_function_generator(variable, truncation_order)`, ensure_order, then `arithmetic::invert`.
- This is the series approach, useful when you need the whole generating function (not just one value).

Implement `pub fn distinct_parts_gf(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- Q(q) = prod_{k=1}^{inf}(1 + q^k) = (-q; q)_inf (starting at k=1 to avoid the (1+1)=2 factor at k=0)
- Actually: (-q;q)_inf = prod_{k>=0}(1-(-1)*q^{1+k}) = prod_{k>=0}(1+q^{1+k}) = prod_{n>=1}(1+q^n).
  Use `qpochhammer_inf_generator(-QRat::one(), 1, variable, truncation_order)`. This gives prod_{k>=0}(1-(-1)*q^{1+k}) = prod_{k>=0}(1+q^{1+k}).
- ensure_order(truncation_order), return into_series().

Implement `pub fn odd_parts_gf(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- prod_{k=0}^{inf} 1/(1-q^{2k+1})
- First compute the product prod_{k=0}^{inf}(1-q^{2k+1}) using a generator with factor k = (1 - q^{2k+1}). Then invert.
- Generator: start at k=0, factor k = (1-q^{2k+1}), exponent 2k+1. Need `(truncation_order + 1) / 2` factors.
- `arithmetic::invert(&product)` to get the generating function.
- Euler's theorem: odd_parts_gf == distinct_parts_gf (both count partitions into distinct parts / odd parts). This is testable.

Implement `pub fn bounded_parts_gf(max_parts: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- prod_{k=1}^{max_parts} 1/(1-q^k)
- Compute the product prod_{k=1}^{max_parts}(1-q^k) by iterating k from 1 to max_parts, building each factor as (1-q^k), multiplying sequentially.
- Then invert: `arithmetic::invert(&product)`.
- Edge case: max_parts <= 0 returns FormalPowerSeries::one (empty product = 1, inverted = 1).

**In `qseries/mod.rs`:** Add `pub mod partitions; pub mod rank_crank;` and re-export key functions.
  </action>
  <verify>
Run `cargo build` -- must compile.
  </verify>
  <done>partition_count uses pentagonal recurrence. partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf all produce correct generating functions.</done>
</task>

<task type="auto">
  <name>Task 2: Rank/crank generating functions and comprehensive tests</name>
  <files>
    crates/qsym-core/src/qseries/rank_crank.rs
    crates/qsym-core/tests/qseries_partitions_tests.rs
  </files>
  <action>
**In `qseries/rank_crank.rs`:**

Implement `pub fn crank_gf(z: &QRat, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- C(z, q) = (q;q)_inf / [(zq;q)_inf * (q/z;q)_inf]
- At z=1: C(1,q) should give 1/(q;q)_inf = partition GF (the singularity at z=1 cancels).
  BUT (zq;q)_inf at z=1 is (q;q)_inf, and (q/z;q)_inf at z=1 is (1;q)_inf. And (1;q)_inf has first factor (1-1)=0, making the denominator 0. This is a removable singularity. For z=1, handle separately: return partition_gf directly.
- For z != 1: compute three infinite products and combine.
  - numerator: euler_function_generator(variable, truncation_order) -> ensure_order -> series
  - denom1: (zq;q)_inf = qpochhammer_inf_generator(z, 1, variable, truncation_order). The product is prod_{k>=0}(1-z*q^{1+k}) = (z*q; q)_inf. Ensure_order, get series.
  - denom2: (q/z;q)_inf = qpochhammer_inf_generator(QRat::one()/z, 1, variable, truncation_order). Product is prod_{k>=0}(1-(1/z)*q^{1+k}).
  - result = numerator * invert(denom1 * denom2)
- Note: z is a pure QRat (number), not a QMonomial. The qpochhammer_inf_generator takes (a: QRat, offset: i64). For crank, a=z with offset=1 for the first factor, and a=1/z with offset=1 for the second.

Implement `pub fn rank_gf(z: &QRat, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
- R(z, q) = 1 + sum_{n=1}^{...} q^{n^2} / [(zq;q)_n * (q/z;q)_n]
- At z=1: each denominator (q;q)_n * (1;q)_n has (1;q)_n with first factor (1-1)=0 for n>=1. So for z=1, the sum terms are 0/0 -- removable singularity. Handle z=1 separately: return partition_gf.
- For z != 1:
  - Start with result = FPS::one(variable, truncation_order) (the n=0 term = 1).
  - Loop n from 1 while n*n < truncation_order:
    - Compute numerator: q^{n^2} as FPS::monomial(variable, QRat::one(), n*n, truncation_order)
    - Compute (zq;q)_n: finite product prod_{k=0}^{n-1}(1-z*q^{1+k}). Build each factor (1-z*q^{k+1}) as FPS with constant term 1 and coefficient -z at exponent k+1. Multiply sequentially.
    - Compute (q/z;q)_n: finite product prod_{k=0}^{n-1}(1-(1/z)*q^{1+k}). Same pattern with coefficient -(1/z).
    - Denominator = (zq;q)_n * (q/z;q)_n -- multiply the two products.
    - Term = numerator * invert(denominator)
    - result = result + term
  - Return result.
- The loop terminates when n^2 >= truncation_order. For truncation_order=200, that's n up to 14 terms.

**In `qseries_partitions_tests.rs`:**

Create comprehensive test file.

**partition_count tests:**
1. `partition_count_small` -- p(0)=1, p(1)=1, p(2)=2, p(3)=3, p(4)=5, p(5)=7, p(10)=42, p(20)=627. Direct comparison.
2. `partition_count_medium` -- p(50)=204226, p(100)=190569292.
3. `partition_count_200` -- p(200)=3972999029388. This is the key OEIS A000041 verification.
4. `partition_count_negative` -- p(-1)=0, p(-100)=0.
5. `partition_count_matches_series` -- partition_count(n) for n=0..30 matches coefficients of partition_gf(q, 31).

**distinct_parts_gf tests:**
6. `distinct_parts_oeis_a000009` -- Verify Q(0)..Q(20) = 1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64 (OEIS A000009).

**odd_parts_gf tests:**
7. `euler_theorem` -- distinct_parts_gf and odd_parts_gf produce identical coefficients to O(q^50). This verifies Euler's theorem that partitions into distinct parts equals partitions into odd parts.

**bounded_parts_gf tests:**
8. `bounded_parts_3` -- bounded_parts_gf(3, q, 20): partitions with at most 3 parts. Values: p_3(0)=1, p_3(1)=1, p_3(2)=2, p_3(3)=3, p_3(4)=4, p_3(5)=5, p_3(6)=7, p_3(7)=8, p_3(8)=10, p_3(9)=12.
9. `bounded_parts_equals_parts_bounded_by` -- bounded_parts_gf(m) = prod_{k=1}^{m} 1/(1-q^k), which also counts partitions with parts <= m. For m=3: partitions of n into parts {1,2,3} only. Verify a few values.

**crank_gf tests:**
10. `crank_at_z1_is_partition_gf` -- crank_gf(QRat::one(), q, 30) matches partition_gf(q, 30) coefficient by coefficient.
11. `crank_at_z_minus1` -- crank_gf(-1, q, 30): C(-1, q) = (q;q)_inf / [(-q;q)_inf * (-1;q)_inf]. The factor (-1;q)_inf starts with (1-(-1))=2, so (-1;q)_inf = 2 * prod_{n>=1}(1+q^n). Thus C(-1,q) = (q;q)_inf / [2 * prod(1+q^n) * (-q;q)_inf]. This simplifies to known values. Verify first few coefficients.

**rank_gf tests:**
12. `rank_at_z1_is_partition_gf` -- rank_gf(QRat::one(), q, 30) matches partition_gf(q, 30). (Uses z=1 special case.)
13. `rank_at_z_minus1` -- rank_gf(-1, q, 50): R(-1, q) generates the difference N(even rank, n) - N(odd rank, n). Known to relate to Ramanujan's partition congruences. Verify specific coefficients: for n < 5, R(-1,q) coeff should match known values. The generating function R(-1,q) = prod_{n>=1}(1-q^n)/(1+q^n)^2 ... verify numerically.
  Actually, simpler: R(-1,q) = 1 + sum_{n>=1} q^{n^2} / [(-q;q)_n * (-1;q)_n]... this gets complicated. Just compute and verify the first ~10 coefficients are reasonable (integer, match partition counts modulo known congruence structure).
  </action>
  <verify>
Run `cargo test` -- all tests pass including new partition/rank/crank tests and all existing tests (253+).
  </verify>
  <done>partition_count(200) = 3972999029388 (OEIS verified). distinct_parts and odd_parts match (Euler's theorem). crank_gf and rank_gf at z=1 match partition GF. All PART-01, PART-02, PART-03 requirements satisfied.</done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests
- partition_count(200) = 3972999029388
- distinct_parts_gf matches OEIS A000009
- Euler's theorem: distinct_parts_gf == odd_parts_gf
- rank_gf(1,q,T) == crank_gf(1,q,T) == partition_gf(q,T)
</verification>

<success_criteria>
- partition_count is O(n*sqrt(n)) via pentagonal recurrence, verified to p(200)
- All restricted partition GFs produce correct coefficients
- Rank and crank GFs produce correct results, with z=1 special case matching partition GF
- All OEIS verification values match exactly
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-qseries-partitions/03-04-SUMMARY.md`
</output>
