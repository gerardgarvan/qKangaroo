---
phase: 04-series-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/prodmake.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_prodmake_tests.rs
autonomous: true

must_haves:
  truths:
    - "prodmake recovers exponents a_n=-1 for all n from the Euler function (q;q)_inf"
    - "prodmake recovers the product form of 1/(q;q)_inf (partition generating function)"
    - "prodmake handles non-unit constant term by normalizing before applying Andrews' algorithm"
    - "mobius function returns correct values: mu(1)=1, mu(p)=-1, mu(p^2)=0, mu(pq)=1"
    - "divisors function returns all divisors of n in ascending order"
  artifacts:
    - path: "crates/qsym-core/src/qseries/prodmake.rs"
      provides: "prodmake function, InfiniteProductForm type, mobius, divisors helpers"
      exports: ["prodmake", "InfiniteProductForm"]
    - path: "crates/qsym-core/tests/qseries_prodmake_tests.rs"
      provides: "Tests for prodmake on Euler function, partition GF, and edge cases"
      min_lines: 60
  key_links:
    - from: "crates/qsym-core/src/qseries/prodmake.rs"
      to: "FormalPowerSeries::coeff"
      via: "coefficient extraction for Andrews algorithm"
      pattern: "f\\.coeff\\("
    - from: "crates/qsym-core/src/qseries/prodmake.rs"
      to: "QRat arithmetic"
      via: "exact rational arithmetic in Mobius inversion"
      pattern: "QRat::(one|zero|from)"
---

<objective>
Implement Andrews' algorithm (prodmake) to recover infinite product exponents from series coefficients, plus the required number theory helper functions (Mobius function and divisor enumeration).

Purpose: prodmake is the foundation for all series-to-product conversion (QSER-09). etamake, jacprodmake, mprodmake, and qetamake all post-process prodmake output.
Output: prodmake.rs with InfiniteProductForm type, prodmake function, mobius/divisors helpers, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md

@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/qseries/partitions.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement prodmake with number theory helpers</name>
  <files>
    crates/qsym-core/src/qseries/prodmake.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/prodmake.rs` with:

1. **Number theory helpers** (private to module):
   - `fn mobius(n: i64) -> i64`: Mobius function via trial factorization. For each prime p dividing n, if p^2 divides n return 0, otherwise flip sign. Return +1/-1/0. Handle n=1 -> 1 specially.
   - `fn divisors(n: i64) -> Vec<i64>`: Return all positive divisors of n in ascending order via trial division up to sqrt(n).

2. **Result type**:
   ```rust
   pub struct InfiniteProductForm {
       /// Exponents: maps n -> a_n where product is prod (1-q^n)^{-a_n}
       pub exponents: BTreeMap<i64, QRat>,
       /// How many terms were used
       pub terms_used: i64,
   }
   ```

3. **`prodmake(f: &FormalPowerSeries, max_n: i64) -> InfiniteProductForm`**:
   - Normalize: extract min_order shift and scalar. If f(0) == 0, find min_order k, divide by q^k (shift coefficients down), store k for later. Then divide by f(0) to normalize constant term to 1.
   - Step 1 (compute c_n): Use recurrence c_n = n*b_n - sum_{j=1}^{n-1} c_j * b_{n-j} where b_n = coeff of q^n in normalized series.
   - Step 2 (Mobius inversion): n*a_n = sum_{d|n} mu(n/d) * c_d. Compute for n=1..max_n.
   - Return InfiniteProductForm with nonzero exponents.
   - max_n should be capped at f.truncation_order() - 1 (can't use coefficients beyond truncation).

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add `pub mod prodmake;`
   - Add `pub use prodmake::{prodmake, InfiniteProductForm};`
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
prodmake.rs exists with prodmake function, InfiniteProductForm type, and helper functions. Module compiles and is re-exported from qseries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test prodmake against known infinite products</name>
  <files>
    crates/qsym-core/tests/qseries_prodmake_tests.rs
  </files>
  <action>
Create comprehensive test file `crates/qsym-core/tests/qseries_prodmake_tests.rs`:

1. **Helper tests**:
   - `test_mobius_values`: mu(1)=1, mu(2)=-1, mu(3)=-1, mu(4)=0, mu(5)=-1, mu(6)=1, mu(12)=0, mu(30)=-1
   - `test_divisors`: divisors(1)=[1], divisors(12)=[1,2,3,4,6,12], divisors(7)=[1,7]
   - Note: mobius and divisors are private. Test them indirectly through prodmake, OR make them pub(crate) if needed.

2. **prodmake on Euler function (q;q)_inf**:
   - Build (q;q)_inf series using existing `euler_function_generator` or by computing 1/(partition_gf). Actually, build it as product of (1-q^n) for n=1..N.
   - Run `prodmake(&euler_series, 20)`.
   - Since (q;q)_inf = prod (1-q^n)^1 = prod (1-q^n)^{-(-1)}, expect exponents a_n = -1 for all n=1..20.

3. **prodmake on partition generating function 1/(q;q)_inf**:
   - Build via `partition_gf` from Phase 3.
   - Run `prodmake(&pgf, 20)`.
   - Since 1/(q;q)_inf = prod (1-q^n)^{-1}, expect exponents a_n = 1 for all n=1..20.

4. **prodmake on (q^2;q^2)_inf / (q;q)_inf** (distinct parts GF = (-q;q)_inf):
   - This equals prod (1+q^n) = prod (1-q^{2n})/(1-q^n) = prod (1-q^n)^{-a_n} where a_n = -1 if n odd, 0 if n even... actually more precisely, prod(1+q^n) = prod (1-q^n)^{-a_n} needs careful analysis. Instead, compute distinct_parts_gf and verify prodmake returns sensible exponents that round-trip.

5. **Round-trip verification**: Take prodmake output, rebuild the product series from exponents, verify it matches the original series coefficient-by-coefficient to the tested order.

Use `SymbolRegistry` to create the q variable, matching the pattern from existing test files.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_prodmake_tests` -- all tests pass.
  </verify>
  <done>
At least 5 tests passing covering mobius/divisors helpers (indirectly), prodmake on Euler function, partition GF, and round-trip verification.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- prodmake correctly identifies Euler function exponents as -1 for all n
- prodmake correctly identifies partition GF exponents as +1 for all n
</verification>

<success_criteria>
- prodmake(euler_series, 20) returns a_n = -1 for n = 1..20
- prodmake(partition_gf, 20) returns a_n = 1 for n = 1..20
- Round-trip test: prodmake output re-expanded matches original series
- All existing 303 tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-01-SUMMARY.md`
</output>
