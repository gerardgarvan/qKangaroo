---
phase: 04-series-analysis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/factoring.rs
  - crates/qsym-core/src/qseries/utilities.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_factoring_tests.rs
autonomous: true

must_haves:
  truths:
    - "qfactor correctly factors (1-q)(1-q^2)(1-q^3) back into its cyclotomic components"
    - "sift(partition_gf, 5, 4) extracts the p(5n+4) subsequence, all coefficients divisible by 5"
    - "qdegree returns the highest nonzero exponent of a polynomial series"
    - "lqdegree returns the lowest nonzero exponent of a series"
  artifacts:
    - path: "crates/qsym-core/src/qseries/factoring.rs"
      provides: "qfactor and QFactorization type"
      exports: ["qfactor", "QFactorization"]
    - path: "crates/qsym-core/src/qseries/utilities.rs"
      provides: "sift, qdegree, lqdegree"
      exports: ["sift", "qdegree", "lqdegree"]
    - path: "crates/qsym-core/tests/qseries_factoring_tests.rs"
      provides: "Tests for qfactor, sift, qdegree, lqdegree"
      min_lines: 80
  key_links:
    - from: "crates/qsym-core/src/qseries/factoring.rs"
      to: "FormalPowerSeries arithmetic"
      via: "polynomial division via series operations"
      pattern: "arithmetic::(mul|invert|sub)"
    - from: "crates/qsym-core/src/qseries/utilities.rs"
      to: "FormalPowerSeries::coeff"
      via: "coefficient extraction for sifting"
      pattern: "f\\.coeff\\("
---

<objective>
Implement q-polynomial factoring (qfactor) and series utility functions (sift, qdegree, lqdegree) for extracting arithmetic subsequences and measuring degree bounds.

Purpose: qfactor (QSER-13) factors q-polynomials into (1-q^i) components. sift (QSER-14) extracts arithmetic subsequences critical for studying partition congruences. qdegree/lqdegree (QSER-15) provide degree bounds needed by relation discovery functions.
Output: factoring.rs with qfactor + QFactorization, utilities.rs with sift + qdegree + lqdegree, comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md

@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/qseries/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement qfactor and utility functions</name>
  <files>
    crates/qsym-core/src/qseries/factoring.rs
    crates/qsym-core/src/qseries/utilities.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/factoring.rs`:

1. **QFactorization result type**:
   ```rust
   pub struct QFactorization {
       /// Maps i -> multiplicity where product is prod (1-q^i)^{mult}
       pub factors: BTreeMap<i64, i64>,
       /// Scalar prefactor
       pub scalar: QRat,
       /// Whether factorization is exact (remainder is 1)
       pub is_exact: bool,
   }
   ```

2. **`qfactor(f: &FormalPowerSeries) -> QFactorization`**:
   - Normalize: extract scalar f(0), divide by it.
   - For i = 1, 2, 3, ... up to qdegree of remaining polynomial:
     - Build g_i(q) = 1 - q^i as a FPS.
     - While the current polynomial is divisible by g_i (test: after dividing, check no remainder by verifying the quotient * g_i == current):
       - Actually, implement polynomial division directly: if current has coeff c at the lowest nonzero positive exponent k, and k >= i, then check divisibility by trying: divide current by (1-q^i). For a polynomial f divisible by (1-q^i), f/(1-q^i) is computed via: multiply f by 1/(1-q^i) = 1 + q^i + q^{2i} + ... but this produces an infinite series. Instead, use iterative extraction: set quotient = 0, remainder = f. While remainder has terms: look at lowest-order nonzero term c*q^k, set quotient[k] += c, subtract c*q^k*(1-q^i) from remainder (i.e., remainder[k] -= c, remainder[k+i] += c). If after processing all terms, remainder is zero, the division is exact.
     - Increment multiplicity for each successful division.
   - After all i exhausted, if remainder == 1, is_exact = true.

Create `crates/qsym-core/src/qseries/utilities.rs`:

1. **`sift(f: &FormalPowerSeries, m: i64, j: i64) -> FormalPowerSeries`**:
   - Extract subsequence: output coeff at q^i = input coeff at q^{m*i+j}.
   - New truncation_order = floor((f.truncation_order() - j) / m) when j < f.truncation_order(), else 0.
   - Build new FPS by iterating i from 0..: src_exp = m*i + j. If src_exp >= f.truncation_order(), break. Set output coeff(i) = f.coeff(src_exp).
   - Handle j < 0: adjust so j is in range [0, m). Garvan convention: j can be any integer, residue class is j mod m.

2. **`qdegree(f: &FormalPowerSeries) -> Option<i64>`**:
   - Return the highest exponent with nonzero coefficient. Use `f.iter().last()` to get the largest key in the BTreeMap. Return None if zero series.

3. **`lqdegree(f: &FormalPowerSeries) -> Option<i64>`**:
   - Return the lowest exponent with nonzero coefficient. This is `f.min_order()` which already exists on FPS. Wrap it for API consistency.

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add `pub mod factoring;` and `pub mod utilities;`
   - Add `pub use factoring::{qfactor, QFactorization};`
   - Add `pub use utilities::{sift, qdegree, lqdegree};`

Note: zqfactor (two-variable factoring) is documented as unreliable by Garvan. Implement a stub that returns is_exact=false with a TODO comment for now -- the core qfactor is the essential function.
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
factoring.rs with qfactor + QFactorization, utilities.rs with sift + qdegree + lqdegree all compile and are re-exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test qfactor and utility functions</name>
  <files>
    crates/qsym-core/tests/qseries_factoring_tests.rs
  </files>
  <action>
Create comprehensive test file `crates/qsym-core/tests/qseries_factoring_tests.rs`:

1. **qfactor tests**:
   - `test_qfactor_single_factor`: Factor (1-q) -> {1: 1}, is_exact = true.
   - `test_qfactor_product`: Factor (1-q)(1-q^2)(1-q^3) (build by multiplying the polynomial series) -> {1:1, 2:1, 3:1}, is_exact = true.
   - `test_qfactor_power`: Factor (1-q)^3 -> {1: 3}, is_exact = true.
   - `test_qfactor_euler_truncated`: Factor the first few terms of (q;q)_inf truncated as a polynomial. Should get (1-q)(1-q^2)...(1-q^k) for appropriate k.

2. **sift tests**:
   - `test_sift_partition_mod5_residue4`: Build partition_gf to O(q^100), sift with m=5, j=4. Verify: output coeff(0)=p(4)=5, coeff(1)=p(9)=30, coeff(2)=p(14)=135. All should be divisible by 5 (Ramanujan's congruence).
   - `test_sift_identity`: sift(f, 1, 0) == f (trivial sift).
   - `test_sift_even_odd`: For a known series, sift(f, 2, 0) gives even-indexed coefficients, sift(f, 2, 1) gives odd-indexed.

3. **qdegree/lqdegree tests**:
   - `test_qdegree_polynomial`: For 1 + q + q^5, qdegree = 5.
   - `test_lqdegree_shifted`: For q^3 + q^7, lqdegree = 3.
   - `test_qdegree_zero`: For the zero series, qdegree = None.

Use `SymbolRegistry` and existing partition/q-series functions for test setup.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_factoring_tests` -- all tests pass.
  </verify>
  <done>
At least 8 tests passing covering qfactor factoring, sift with Ramanujan congruence verification, and qdegree/lqdegree.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- qfactor correctly decomposes known products
- sift extracts Ramanujan congruence subsequences correctly
</verification>

<success_criteria>
- qfactor((1-q)(1-q^2)(1-q^3)) returns {1:1, 2:1, 3:1} with is_exact=true
- sift(partition_gf, 5, 4) coefficients are all divisible by 5
- qdegree and lqdegree return correct bounds
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-02-SUMMARY.md`
</output>
