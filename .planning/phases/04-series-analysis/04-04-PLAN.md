---
phase: 04-series-analysis
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/qsym-core/src/qseries/prodmake.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_prodmake_tests.rs
autonomous: true

must_haves:
  truths:
    - "etamake correctly expresses (q;q)_inf as eta(tau) (single eta factor)"
    - "jacprodmake correctly expresses known Jacobi products in JAC(a,b) notation"
    - "mprodmake converts series to products of (1+q^n) factors"
    - "qetamake expresses series in (q^d;q^d)_inf notation"
  artifacts:
    - path: "crates/qsym-core/src/qseries/prodmake.rs"
      provides: "etamake, jacprodmake, mprodmake, qetamake plus result types"
      exports: ["etamake", "jacprodmake", "mprodmake", "qetamake", "EtaQuotient", "JacobiProductForm", "QEtaForm"]
    - path: "crates/qsym-core/tests/qseries_prodmake_tests.rs"
      provides: "Tests for all four post-processing functions"
      min_lines: 120
  key_links:
    - from: "crates/qsym-core/src/qseries/prodmake.rs (etamake)"
      to: "prodmake"
      via: "post-processes prodmake exponents into eta-quotient form"
      pattern: "prodmake\\("
    - from: "crates/qsym-core/src/qseries/prodmake.rs (jacprodmake)"
      to: "prodmake"
      via: "post-processes prodmake exponents into JAC(a,b) form"
      pattern: "prodmake\\("
---

<objective>
Implement etamake, jacprodmake, mprodmake, and qetamake as post-processing of prodmake output, completing all series-to-product conversion functions (QSER-10, QSER-11, QSER-12).

Purpose: These four functions interpret prodmake's raw exponents in mathematically meaningful forms -- eta-quotients for modular form theory, Jacobi products for combinatorial identities, (1+q^n) products for distinct partition theory, and q-eta notation for computational convenience.
Output: Four new functions + result types added to prodmake.rs, with comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md
@.planning/phases/04-series-analysis/04-01-SUMMARY.md

@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/products.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement etamake, jacprodmake, mprodmake, qetamake</name>
  <files>
    crates/qsym-core/src/qseries/prodmake.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Add to `crates/qsym-core/src/qseries/prodmake.rs`:

1. **Result types**:
   ```rust
   pub struct EtaQuotient {
       /// Maps delta -> r_delta where result is prod eta(delta*tau)^{r_delta}
       pub factors: BTreeMap<i64, i64>,
       /// q-shift prefactor exponent: sum_d r_d * d / 24
       pub q_shift: QRat,
   }

   pub struct JacobiProductForm {
       /// Maps (a, b) -> exponent where result is prod JAC(a,b)^exp
       pub factors: BTreeMap<(i64, i64), i64>,
       /// Scalar prefactor
       pub scalar: QRat,
       /// Whether conversion was successful (all exponents fit JAC pattern)
       pub is_exact: bool,
   }

   pub struct QEtaForm {
       /// Maps d -> r_d where result is prod (q^d;q^d)_inf^{r_d}
       pub factors: BTreeMap<i64, i64>,
       /// Power of q prefactor
       pub q_shift: QRat,
   }
   ```

2. **`etamake(f: &FormalPowerSeries, max_n: i64) -> EtaQuotient`**:
   - Run prodmake(f, max_n) to get exponents a_n.
   - Group exponents by divisor pattern: for each divisor d that divides all n with nonzero a_n in a group, compute r_d.
   - Key identity: eta(d*tau) = q^{d/24} * (q^d;q^d)_inf, so (q^d;q^d)_inf = prod_{k=1}^inf (1-q^{dk}).
   - The exponent a_{dk} from prodmake contributes to the eta(d*tau) factor.
   - Algorithm: For d = max_n down to 1: compute r_d = -a_d (since prodmake gives exponents for (1-q^n)^{-a_n} and eta has (1-q^{dk})^1). Then subtract r_d's contribution from all multiples: a_{dk} -= r_d for k=2,3,...
   - Compute q_shift = sum_d r_d * d / 24.

3. **`jacprodmake(f: &FormalPowerSeries, max_n: i64) -> JacobiProductForm`** and variant with optional period parameter:
   - Run prodmake to get exponents a_n.
   - Search for period b: try b = 1, 2, 3, ... up to max_n/2.
   - For each candidate period b:
     a. Group exponents by residue class: for r = 0..b-1, collect all (n, a_n) where n mod b == r.
     b. For each residue r != 0 (where r <= b/2 to avoid double-counting), check if exponents match the JAC(r,b) pattern. JAC(r,b) = (q^r;q^b)_inf * (q^{b-r};q^b)_inf * (q^b;q^b)_inf contributes exponents at all n where n mod b is in {r, b-r, 0}. Specifically:
        - At positions n = r, b+r, 2b+r, ...: exponent contribution from (q^r;q^b)_inf
        - At positions n = b-r, 2b-r, 3b-r, ...: exponent contribution from (q^{b-r};q^b)_inf
        - At positions n = b, 2b, 3b, ...: exponent contribution from (q^b;q^b)_inf
     c. For each residue class, compute the JAC(r,b) exponent as the common exponent value in that group. If all a_n in residue class r share the same value, that value becomes the JAC(r,b) exponent.
     d. Track how many exponents are matched vs unmatched (exponents not explained by any JAC(r,b) factor).
   - Pick the period b that explains the most exponents (ideally all of them).
   - Return JacobiProductForm with factors mapping (r,b) -> exponent.
   - Set is_exact = true only if ALL prodmake exponents are fully explained by the JAC factors.

4. **`mprodmake(f: &FormalPowerSeries, max_n: i64) -> BTreeMap<i64, i64>`**:
   - Converts to products of (1+q^n) factors.
   - Since (1+q^n) = (1-q^{2n})/(1-q^n), the prodmake exponents a_n for (1-q^n)^{-a_n} translate to: (1+q^n) factor contributes -1 to a_n and +1 to a_{2n}.
   - Algorithm: from prodmake exponents, extract the (1+q^n) representation by working from largest n down to 1.

5. **`qetamake(f: &FormalPowerSeries, max_n: i64) -> QEtaForm`**:
   - Like etamake but outputs in (q^d;q^d)_inf notation instead of eta(d*tau) notation.
   - The difference is only the q-shift computation (eta includes q^{d/24}, q-eta does not).
   - Reuse the etamake grouping logic, then strip the q^{d/24} factors.

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add re-exports for all new types and functions.
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
etamake, jacprodmake, mprodmake, qetamake all compile with correct result types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test all series-to-product post-processing functions</name>
  <files>
    crates/qsym-core/tests/qseries_prodmake_tests.rs
  </files>
  <action>
Add tests to existing `crates/qsym-core/tests/qseries_prodmake_tests.rs`:

1. **etamake tests**:
   - `test_etamake_euler_function`: etamake on (q;q)_inf should return eta(tau)^1 = {1: 1}, q_shift = 1/24.
   - `test_etamake_partition_gf`: etamake on 1/(q;q)_inf should return eta(tau)^{-1} = {1: -1}, q_shift = -1/24.
   - `test_etamake_theta3_squared`: If possible, test on a known eta-quotient.

2. **jacprodmake tests**:
   - `test_jacprodmake_euler`: jacprodmake on (q;q)_inf should find JAC(0,1) or equivalent.
   - `test_jacprodmake_jacobi_product`: Build jacprod(q,q^5) from Phase 3, run jacprodmake, verify it recovers JAC(1,5).
   - `test_jacprodmake_triple_product`: Build the Jacobi triple product (e.g., tripleprod(z,q) for a specific z value or use the series expansion of prod_{n>=1} (1-q^n)(1+zq^{n-1})(1+z^{-1}q^n) with z=q, which gives a known theta function). Run jacprodmake on the resulting series. Verify that it identifies the correct period and JAC factors, and that is_exact = true.
   - `test_jacprodmake_no_pattern`: Construct a product with non-periodic exponents, e.g., prod (1-q^n)^{-a_n} where a_n = n (linearly growing exponents that do not group into any JAC(r,b) pattern). Run jacprodmake on the resulting series and verify is_exact = false, since no single period can explain all exponents.

3. **mprodmake tests**:
   - `test_mprodmake_distinct_parts`: mprodmake on (-q;q)_inf = prod(1+q^n). Should recover exponents 1 for all n.

4. **qetamake tests**:
   - `test_qetamake_euler`: qetamake on (q;q)_inf should return {1: 1} with q_shift = 0 (since q-eta notation separates the q^{d/24} prefactor).

Verify all round-trip: convert series to product form, rebuild series from product form, compare coefficients.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_prodmake_tests` -- all tests pass (including Plan 01's tests).
  </verify>
  <done>
At least 8 new tests passing for etamake/jacprodmake/mprodmake/qetamake (including jacprodmake_triple_product and jacprodmake_no_pattern), plus all Plan 01 prodmake tests still passing.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- etamake correctly identifies (q;q)_inf as eta(tau)
- mprodmake correctly identifies prod(1+q^n) factors
- jacprodmake recovers JAC(1,5) from jacprod(q,q^5)
- jacprodmake returns is_exact=false for non-periodic exponents
</verification>

<success_criteria>
- etamake((q;q)_inf) returns {1: 1} with q_shift = 1/24
- jacprodmake on known Jacobi products recovers the JAC parameters
- jacprodmake on non-periodic exponents returns is_exact = false
- mprodmake on (-q;q)_inf recovers (1+q^n) exponents
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-04-SUMMARY.md`
</output>
