---
phase: 04-series-analysis
plan: 05
type: execute
wave: 2
depends_on: ["04-03"]
files_modified:
  - crates/qsym-core/src/qseries/relations.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_relations_tests.rs
autonomous: true

must_haves:
  truths:
    - "findlincombo discovers that f = c1*g1 + c2*g2 when given f and [g1, g2] as basis"
    - "findlincombo returns None when f is not a linear combination of the basis"
    - "findhom finds homogeneous degree-n polynomial relations among given series"
    - "findpoly discovers a polynomial relation between two series (e.g., x^2 + y^2 = 1 type)"
  artifacts:
    - path: "crates/qsym-core/src/qseries/relations.rs"
      provides: "findlincombo, findhom, findpoly core relation discovery functions"
      exports: ["findlincombo", "findhom", "findpoly"]
    - path: "crates/qsym-core/tests/qseries_relations_tests.rs"
      provides: "Tests for relation discovery with known relations"
      min_lines: 100
  key_links:
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "linalg::rational_null_space"
      via: "null space computation to find relations"
      pattern: "rational_null_space"
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "linalg::build_coefficient_matrix"
      via: "extracting coefficients from candidate series"
      pattern: "build_coefficient_matrix"
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "FormalPowerSeries arithmetic"
      via: "building monomial candidate series via mul/scalar_mul"
      pattern: "arithmetic::(mul|scalar_mul)"
---

<objective>
Implement the core relation discovery functions: findlincombo, findhom, and findpoly, which discover algebraic relations between q-series using coefficient matrices and null space computation (QSER-16, QSER-17, QSER-18).

Purpose: These are the most powerful analysis tools in Garvan's package -- they automatically discover linear combinations, homogeneous polynomial relations, and two-variable polynomial relations between q-series. This enables researchers to conjecture and verify identities computationally.
Output: relations.rs with findlincombo, findhom, findpoly, and comprehensive tests using known relations.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md
@.planning/phases/04-series-analysis/04-03-SUMMARY.md

@crates/qsym-core/src/qseries/linalg.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement findlincombo, findhom, findpoly</name>
  <files>
    crates/qsym-core/src/qseries/relations.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/relations.rs`:

1. **`findlincombo(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], topshift: i64) -> Option<Vec<QRat>>`**:
   - Find coefficients c_1, ..., c_k such that f = c_1*basis[0] + ... + c_k*basis[k-1].
   - Build candidates list: [f, basis[0], basis[1], ..., basis[k-1]]. The relation we seek is: 1*f - c_1*basis[0] - ... = 0, which is a null space vector with first component = 1.
   - Determine start_order: min of min_order across all candidates (or 0 if none negative).
   - Determine num_rows: (k+1) + topshift. Need more rows than columns for overdetermined system. Actually: num_rows = number of candidates + topshift = (k+1) + topshift. But should not exceed available coefficients.
   - Build coefficient matrix using build_coefficient_matrix with all candidates.
   - Compute null space. Look for a null space vector where the first component (corresponding to f) is nonzero.
   - If found, normalize so first component = 1, then coefficients are the negatives of remaining components.
   - Return Some(coefficients) or None if no relation found.

2. **`findhom(series: &[&FormalPowerSeries], degree: i64, topshift: i64) -> Vec<Vec<QRat>>`**:
   - Find all homogeneous degree-d polynomial relations among the given series.
   - Generate all monomials of degree d in the input series: all products s_1^{e_1} * ... * s_k^{e_k} where sum e_i = d.
   - For each monomial, compute the corresponding FPS by multiplying the series (use arithmetic::mul).
   - Build coefficient matrix from these monomial FPS.
   - Compute null space -- each vector gives a relation among the monomials.
   - Return the list of null space vectors, paired with monomial descriptions.
   - Helper: `fn generate_monomials(k: usize, degree: i64) -> Vec<Vec<i64>>` generates all k-tuples of nonneg integers summing to degree. Use recursive partitioning.
   - Helper: `fn compute_monomial_series(series: &[&FormalPowerSeries], exponents: &[i64]) -> FormalPowerSeries` multiplies series[i]^exponents[i] together.

3. **`findpoly(x: &FormalPowerSeries, y: &FormalPowerSeries, deg_x: i64, deg_y: i64, topshift: i64) -> Option<Vec<Vec<QRat>>>`**:
   - Find polynomial P(x,y) = 0 where P has degree <= deg_x in x and <= deg_y in y.
   - Candidates: all x^i * y^j for 0 <= i <= deg_x, 0 <= j <= deg_y.
   - Build coefficient matrix from these candidate series.
   - Compute null space.
   - Return the polynomial as a 2D coefficient array, or None if no relation found.
   - The polynomial is represented as coefficients[i][j] for x^i * y^j.

4. **Helper for power computation**: `fn fps_pow(f: &FormalPowerSeries, n: i64) -> FormalPowerSeries` computes f^n by repeated multiplication (for small n this is fine; series are truncated). Handle n=0 -> FPS::one, n=1 -> clone, n<0 -> invert then power.

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add `pub mod relations;`
   - Add `pub use relations::{findlincombo, findhom, findpoly};`
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
relations.rs compiles with findlincombo, findhom, findpoly all implemented using linalg infrastructure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test relation discovery with known mathematical relations</name>
  <files>
    crates/qsym-core/tests/qseries_relations_tests.rs
  </files>
  <action>
Create `crates/qsym-core/tests/qseries_relations_tests.rs`:

1. **findlincombo tests**:
   - `test_findlincombo_exact`: Create f1 = 1 + q + q^2, f2 = 1 + 2q + 3q^2, f3 = 3*f1 + 7*f2. Run findlincombo(f3, &[&f1, &f2], 0). Should return [3, 7].
   - `test_findlincombo_no_relation`: Create f1, f2, f3 where f3 is NOT a linear combination of f1, f2 (e.g., f3 has a coefficient pattern incompatible). Should return None.
   - `test_findlincombo_single_basis`: findlincombo(2*f, &[&f], 0) should return [2].
   - `test_findlincombo_partition_identity`: If a known q-series identity expresses one partition function as a linear combo of others, test it here.

2. **findhom tests**:
   - `test_findhom_degree2`: Create two series f, g where f^2 = g (so the relation f^2 - g = 0 is homogeneous degree 2 in the pair [f, g] if we weight f degree 1 and g degree 2... actually findhom finds sum c_I * prod s_i^{e_i} = 0 where sum e_i = degree. So for degree 2 with series [f, g]: monomials are f^2, f*g, g^2. If f^2 - g*1 is not degree 2... Let me think. findhom(series, degree=2) generates monomials s1^2, s1*s2, s2^2. We need a test where some degree-2 combination vanishes.
   - Better test: Create f1 = 1+q, f2 = 1+2q+q^2. Note f2 = f1^2 (to O(q^2)). So findhom([f1, f2], 2) should find the relation f1^2 - f2 = 0, i.e., monomial (2,0) has coeff 1 and monomial (0,1) has coeff -1.
   - Wait, degree 2 monomials for k=2 series: (2,0)=f1^2, (1,1)=f1*f2, (0,2)=f2^2. The relation f1^2 = f2 becomes: 1*f1^2 + 0*f1*f2 + (-1)*f2 = 0. But f2 is monomial (0,1) which is degree 1, not 2. findhom only looks at homogeneous degree d, so all monomials have sum e_i = d. The relation f1^2 - f2 = 0 mixes degree 2 and degree 1. We need findnonhom for that.
   - For a pure degree-2 test: create three series where a degree-2 combination vanishes. E.g., f1, f2, f3 where f1*f2 = f3*f3. Or simpler: take theta functions where a quadratic relation holds.
   - Simplest: create f, g, h = f*g. Then findhom([f, g, h], 2) should find f*g - h = 0... no, h is degree 1 as a monomial. Still a mixed-degree relation.
   - Actually, findhom of degree 2 with [f,g] only generates f^2, f*g, g^2. A relation like f^2 - 2*f*g + g^2 = 0 means (f-g)^2 = 0, meaning f = g. Let's instead: create f = 1+q+q^2, g = 1-q+q^2. Then f*g = 1 - q^2 + ... For a proper test, just verify that when NO degree-2 relation exists, findhom returns empty. And construct a synthetic case: create three series where a degree-2 homogeneous relation DOES hold.
   - Practical approach: compute f = theta3 and g = theta4 to some order. The Jacobi identity theta3^4 = theta2^4 + theta4^4 is degree 4. For degree 2, try findhom on carefully chosen series.
   - Simplest synthetic test: let s1, s2, s3 be series where s3 = s1 * s2 (element-wise product via arithmetic::mul). Then findhom([s1, s2, s3], 2) should find the monomial (1,1,0) - (0,0,1) = 0... wait (0,0,1) is degree 1. Still mixed.
   - I think the cleanest test is: findhom with degree 1 = findlincombo. With degree 2, construct an example: s1 = 1+q, s2 = 1+q^2, s3 = (1+q)(1+q^2) = 1+q+q^2+q^3. Then: s1*s2 - s3 = 0 is degree 2 in [s1,s2,s3]: monomial (1,1,0) has coeff 1, monomial (0,0,2) no, (0,0,1) has degree 1... This keeps being tricky because mixed degree.
   - Let's just use: s1, s2 with s1^2 + s2^2 = known (construct s1, s2 so this holds). Actually use four series: a, b, c, d where a*b = c*d. Then degree 2 monomial (1,1,0,0) = a*b and (0,0,1,1) = c*d. The null space contains [1,0,0,-1,...] for appropriate monomial ordering.
   - Keep it simple: test with two identical series f,f. findhom([f,f], 2) monomials are f^2, f*f, f^2 = all the same series. The coefficient matrix is rank 1, null space dimension 2.

3. **findpoly tests**:
   - `test_findpoly_linear`: x = y + 1 (construct x, y accordingly). findpoly(x, y, 1, 1) should find P(x,y) = x - y - 1 = 0.
   - `test_findpoly_quadratic`: Construct x, y where x^2 + y = 0. findpoly(x, y, 2, 1) should discover this.

Use fresh SymbolRegistry for each test. Keep series small (truncation ~30) for fast tests.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_relations_tests` -- all tests pass.
  </verify>
  <done>
At least 6 tests passing covering findlincombo (found, not found, single basis), findhom, and findpoly.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- findlincombo correctly discovers known linear combinations
- findlincombo returns None when no relation exists
- findpoly discovers polynomial relations between series
</verification>

<success_criteria>
- findlincombo(3*f1 + 7*f2, [f1, f2]) returns [3, 7]
- findlincombo returns None for linearly independent series
- findpoly discovers known polynomial relations
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-05-SUMMARY.md`
</output>
