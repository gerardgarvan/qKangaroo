---
phase: 04-series-analysis
plan: 05
type: execute
wave: 2
depends_on: ["04-03"]
files_modified:
  - crates/qsym-core/src/qseries/relations.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_relations_tests.rs
autonomous: true

must_haves:
  truths:
    - "findlincombo discovers that f = c1*g1 + c2*g2 when given f and [g1, g2] as basis"
    - "findlincombo returns None when f is not a linear combination of the basis"
    - "findhom finds homogeneous degree-n polynomial relations among given series"
    - "findpoly discovers a polynomial relation between two series (e.g., x^2 + y^2 = 1 type)"
  artifacts:
    - path: "crates/qsym-core/src/qseries/relations.rs"
      provides: "findlincombo, findhom, findpoly core relation discovery functions plus PolynomialRelation type"
      exports: ["findlincombo", "findhom", "findpoly", "PolynomialRelation"]
    - path: "crates/qsym-core/tests/qseries_relations_tests.rs"
      provides: "Tests for relation discovery with known relations"
      min_lines: 100
  key_links:
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "linalg::rational_null_space"
      via: "null space computation to find relations"
      pattern: "rational_null_space"
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "linalg::build_coefficient_matrix"
      via: "extracting coefficients from candidate series"
      pattern: "build_coefficient_matrix"
    - from: "crates/qsym-core/src/qseries/relations.rs"
      to: "FormalPowerSeries arithmetic"
      via: "building monomial candidate series via mul/scalar_mul"
      pattern: "arithmetic::(mul|scalar_mul)"
---

<objective>
Implement the core relation discovery functions: findlincombo, findhom, and findpoly, which discover algebraic relations between q-series using coefficient matrices and null space computation (QSER-16, QSER-17, QSER-18).

Purpose: These are the most powerful analysis tools in Garvan's package -- they automatically discover linear combinations, homogeneous polynomial relations, and two-variable polynomial relations between q-series. This enables researchers to conjecture and verify identities computationally.
Output: relations.rs with findlincombo, findhom, findpoly, PolynomialRelation type, and comprehensive tests using known relations.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md
@.planning/phases/04-series-analysis/04-03-SUMMARY.md

@crates/qsym-core/src/qseries/linalg.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement findlincombo, findhom, findpoly with PolynomialRelation type</name>
  <files>
    crates/qsym-core/src/qseries/relations.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/relations.rs`:

1. **PolynomialRelation return type for findpoly**:
   ```rust
   pub struct PolynomialRelation {
       /// coefficients[i][j] is the coefficient of x^i * y^j in the polynomial P(x,y)
       pub coefficients: Vec<Vec<QRat>>,
       /// Maximum degree in x
       pub deg_x: i64,
       /// Maximum degree in y
       pub deg_y: i64,
   }
   ```
   Include `PolynomialRelation` in the module's public exports.

2. **`findlincombo(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], topshift: i64) -> Option<Vec<QRat>>`**:
   - Find coefficients c_1, ..., c_k such that f = c_1*basis[0] + ... + c_k*basis[k-1].
   - Build candidates list: [f, basis[0], basis[1], ..., basis[k-1]]. The relation we seek is: 1*f - c_1*basis[0] - ... = 0, which is a null space vector with first component = 1.
   - Determine start_order: min of min_order across all candidates (or 0 if none negative).
   - Determine num_rows: (k+1) + topshift. Need more rows than columns for overdetermined system. Actually: num_rows = number of candidates + topshift = (k+1) + topshift. But should not exceed available coefficients.
   - Build coefficient matrix using build_coefficient_matrix with all candidates.
   - Compute null space. Look for a null space vector where the first component (corresponding to f) is nonzero.
   - If found, normalize so first component = 1, then coefficients are the negatives of remaining components.
   - Return Some(coefficients) or None if no relation found.

3. **`findhom(series: &[&FormalPowerSeries], degree: i64, topshift: i64) -> Vec<Vec<QRat>>`**:
   - Find all homogeneous degree-d polynomial relations among the given series.
   - Generate all monomials of degree d in the input series: all products s_1^{e_1} * ... * s_k^{e_k} where sum e_i = d.
   - For each monomial, compute the corresponding FPS by multiplying the series (use arithmetic::mul).
   - Build coefficient matrix from these monomial FPS.
   - Compute null space -- each vector gives a relation among the monomials.
   - Return the list of null space vectors, paired with monomial descriptions.
   - Helper: `fn generate_monomials(k: usize, degree: i64) -> Vec<Vec<i64>>` generates all k-tuples of nonneg integers summing to degree. Use recursive partitioning.
   - Helper: `fn compute_monomial_series(series: &[&FormalPowerSeries], exponents: &[i64]) -> FormalPowerSeries` multiplies series[i]^exponents[i] together.

4. **`findpoly(x: &FormalPowerSeries, y: &FormalPowerSeries, deg_x: i64, deg_y: i64, topshift: i64) -> Option<PolynomialRelation>`**:
   - Find polynomial P(x,y) = 0 where P has degree <= deg_x in x and <= deg_y in y.
   - Candidates: all x^i * y^j for 0 <= i <= deg_x, 0 <= j <= deg_y.
   - Build coefficient matrix from these candidate series.
   - Compute null space.
   - Return the polynomial as a PolynomialRelation, or None if no relation found.

5. **Helper for power computation**: `fn fps_pow(f: &FormalPowerSeries, n: i64) -> FormalPowerSeries` computes f^n by repeated multiplication (for small n this is fine; series are truncated). Handle n=0 -> FPS::one, n=1 -> clone, n<0 -> invert then power.

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add `pub mod relations;`
   - Add `pub use relations::{findlincombo, findhom, findpoly, PolynomialRelation};`
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
relations.rs compiles with findlincombo, findhom, findpoly, and PolynomialRelation all implemented using linalg infrastructure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test relation discovery with known mathematical relations</name>
  <files>
    crates/qsym-core/tests/qseries_relations_tests.rs
  </files>
  <action>
Create `crates/qsym-core/tests/qseries_relations_tests.rs`:

1. **findlincombo tests**:
   - `test_findlincombo_exact`: Create f1 = 1 + q + q^2, f2 = 1 + 2q + 3q^2, f3 = 3*f1 + 7*f2. Run findlincombo(f3, &[&f1, &f2], 0). Should return [3, 7].
   - `test_findlincombo_no_relation`: Create f1, f2, f3 where f3 is NOT a linear combination of f1, f2 (e.g., f3 has a coefficient pattern incompatible). Should return None.
   - `test_findlincombo_single_basis`: findlincombo(2*f, &[&f], 0) should return [2].
   - `test_findlincombo_partition_identity`: If a known q-series identity expresses one partition function as a linear combo of others, test it here.

2. **findhom tests**:
   - `test_findhom_jacobi_theta`: Use theta functions from Phase 3. The Jacobi identity theta3(q)^4 = theta2(q)^4 + theta4(q)^4 gives a degree-4 homogeneous relation among [theta2, theta3, theta4]. Compute theta2, theta3, theta4 as FPS to O(q^50). Run findhom(&[&theta2, &theta3, &theta4], 4, 0). The returned null space should contain a vector representing theta2^4 + theta4^4 - theta3^4 = 0 (or scalar multiple). Verify the relation vector is nonzero and corresponds to a valid identity.
   - `test_findhom_trivial_degree1`: Create f and g = 2*f. Run findhom(&[&f, &g], 1, 0). The degree-1 monomials are just [f, g], and the relation f - 0.5*g = 0 should be found (null space vector [1, -0.5] or scalar multiple).

3. **findpoly tests**:
   - `test_findpoly_linear`: x = y + 1 (construct x, y accordingly). findpoly(x, y, 1, 1) should find P(x,y) = x - y - 1 = 0. Verify the PolynomialRelation has deg_x=1, deg_y=1, and correct coefficients.
   - `test_findpoly_quadratic`: Construct x, y where x^2 + y = 0. findpoly(x, y, 2, 1) should discover this. Verify the PolynomialRelation coefficients.

Use fresh SymbolRegistry for each test. Keep series small (truncation ~30) for fast tests.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_relations_tests` -- all tests pass.
  </verify>
  <done>
At least 7 tests passing covering findlincombo (found, not found, single basis), findhom (Jacobi theta identity, trivial degree-1), and findpoly (linear, quadratic). PolynomialRelation returned with correct deg_x/deg_y fields.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- findlincombo correctly discovers known linear combinations
- findlincombo returns None when no relation exists
- findhom discovers the Jacobi theta identity theta3^4 = theta2^4 + theta4^4
- findpoly discovers polynomial relations between series and returns PolynomialRelation
</verification>

<success_criteria>
- findlincombo(3*f1 + 7*f2, [f1, f2]) returns [3, 7]
- findlincombo returns None for linearly independent series
- findhom([theta2, theta3, theta4], 4) finds the Jacobi identity relation
- findpoly discovers known polynomial relations and returns PolynomialRelation with correct fields
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-05-SUMMARY.md`
</output>
