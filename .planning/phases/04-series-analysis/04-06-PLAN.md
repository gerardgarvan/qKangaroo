---
phase: 04-series-analysis
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-05"]
files_modified:
  - crates/qsym-core/src/qseries/relations.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_relations_tests.rs
autonomous: true

must_haves:
  truths:
    - "findcong discovers Ramanujan's congruence p(5n+4) = 0 mod 5"
    - "findnonhom finds non-homogeneous polynomial relations (degree <= d)"
    - "findlincombomodp discovers linear combinations mod a prime p"
    - "findmaxind identifies the maximal linearly independent subset of series"
  artifacts:
    - path: "crates/qsym-core/src/qseries/relations.rs"
      provides: "Full relation discovery suite: findcong, findnonhom, findhomcombo, findnonhomcombo, modp variants, findmaxind, findprod"
      exports: ["findcong", "findnonhom", "findhomcombo", "findnonhomcombo", "findlincombomodp", "findhommodp", "findhomcombomodp", "findmaxind", "findprod"]
    - path: "crates/qsym-core/tests/qseries_relations_tests.rs"
      provides: "Tests for full discovery suite"
      min_lines: 180
  key_links:
    - from: "crates/qsym-core/src/qseries/relations.rs (findcong)"
      to: "sift"
      via: "extract subsequence p(An+B) before testing divisibility"
      pattern: "sift\\("
    - from: "crates/qsym-core/src/qseries/relations.rs (modp variants)"
      to: "linalg::modular_null_space"
      via: "null space over Z/pZ for modular relation discovery"
      pattern: "modular_null_space"
    - from: "crates/qsym-core/src/qseries/relations.rs (findmaxind)"
      to: "linalg::rational_null_space"
      via: "rank computation to find independent subset"
      pattern: "rational_null_space"
---

<objective>
Complete the full relation discovery suite (QSER-19): findcong, findnonhom, findhomcombo, findnonhomcombo, modp variants (findlincombomodp, findhommodp, findhomcombomodp), findmaxind, and findprod -- achieving complete qseries package parity.

Purpose: This completes all 28+ functions planned for Phase 4, giving researchers the full Garvan toolset for discovering congruences, polynomial relations, and product representations. findcong is particularly important for partition congruence research.
Output: 9 new functions added to relations.rs, full test coverage, all qseries package parity achieved.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-series-analysis/04-RESEARCH.md
@.planning/phases/04-series-analysis/04-02-SUMMARY.md
@.planning/phases/04-series-analysis/04-05-SUMMARY.md

@crates/qsym-core/src/qseries/relations.rs
@crates/qsym-core/src/qseries/linalg.rs
@crates/qsym-core/src/qseries/utilities.rs
@crates/qsym-core/src/qseries/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement findcong, findnonhom, combo variants, and modp functions</name>
  <files>
    crates/qsym-core/src/qseries/relations.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Add to `crates/qsym-core/src/qseries/relations.rs`:

1. **`findcong(f: &FormalPowerSeries, moduli: &[i64]) -> Vec<Congruence>`**:
   ```rust
   pub struct Congruence {
       pub modulus_m: i64,    // A in f(An+B)
       pub residue_b: i64,    // B in f(An+B)
       pub divisor_r: i64,    // R where f(An+B) = 0 mod R
   }
   ```
   - For each modulus m in moduli, for each residue j in 0..m:
     - Use sift(f, m, j) to extract the subsequence.
     - Check if all coefficients (up to available terms) are divisible by some R.
     - Try R = 2, 3, 5, 7, 11, ... and the modulus m itself.
     - If found, record Congruence { modulus_m: m, residue_b: j, divisor_r: R }.
   - Return all discovered congruences.

2. **`findnonhom(series: &[&FormalPowerSeries], degree: i64, topshift: i64) -> Vec<Vec<QRat>>`**:
   - Like findhom but generates ALL monomials of degree <= d (not just exactly d).
   - Include the constant monomial (all exponents 0 = the constant 1 series).
   - Otherwise same as findhom: build matrix, null space, return relations.

3. **`findhomcombo(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], degree: i64, topshift: i64) -> Option<Vec<QRat>>`**:
   - Express f as a homogeneous degree-d combination of the basis series.
   - Generate all degree-d monomials in basis.
   - Prepend f to the candidate list.
   - Build coefficient matrix, find null space vector with nonzero f-component.
   - Return the combination coefficients.

4. **`findnonhomcombo(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], degree: i64, topshift: i64) -> Option<Vec<QRat>>`**:
   - Like findhomcombo but with monomials of degree <= d.

5. **`findlincombomodp(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], p: i64, topshift: i64) -> Option<Vec<i64>>`**:
   - Like findlincombo but working mod p.
   - Convert QRat coefficients to i64 mod p: for each coeff a/b, compute a * b^{-1} mod p. If b is divisible by p, skip (or handle error).
   - Build i64 matrix, use modular_null_space.
   - Return coefficients mod p.

6. **`findhommodp(series: &[&FormalPowerSeries], p: i64, degree: i64, topshift: i64) -> Vec<Vec<i64>>`**:
   - Like findhom but over Z/pZ.

7. **`findhomcombomodp(f: &FormalPowerSeries, basis: &[&FormalPowerSeries], p: i64, degree: i64, topshift: i64) -> Option<Vec<i64>>`**:
   - Like findhomcombo but over Z/pZ.

8. **`findmaxind(series: &[&FormalPowerSeries], topshift: i64) -> Vec<usize>`**:
   - Find the maximal linearly independent subset of the given series.
   - Build coefficient matrix with all series as columns.
   - Perform Gaussian elimination (or use null space), track pivot columns.
   - Pivot columns correspond to the independent series.
   - Return indices of independent series.

9. **`findprod(series: &[&FormalPowerSeries], max_coeff: i64, max_exp: i64) -> Vec<Vec<i64>>`**:
   - Search over integer linear combinations with coefficients bounded by max_coeff.
   - For each combination, compute the resulting series.
   - Use prodmake to check if the result has a "nice" product form (integer exponents).
   - Return combinations that yield nice products.
   - This is a brute-force search; use max_exp to bound the exponent vectors.
   - Optimization: use findlincombo with the product forms rather than exhaustive search.

Update `crates/qsym-core/src/qseries/mod.rs`:
   - Add re-exports for all new functions and types.
  </action>
  <verify>
`cargo build --manifest-path crates/qsym-core/Cargo.toml` compiles without errors.
  </verify>
  <done>
All 9 functions compile and are re-exported. Full suite of 12+ relation discovery functions available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test full discovery suite with known mathematical results</name>
  <files>
    crates/qsym-core/tests/qseries_relations_tests.rs
  </files>
  <action>
Add tests to `crates/qsym-core/tests/qseries_relations_tests.rs`:

1. **findcong tests**:
   - `test_findcong_ramanujan_mod5`: Build partition_gf to high precision (O(q^200)). Run findcong(&pgf, &[5]). Should discover p(5n+4) = 0 mod 5 (Congruence { modulus_m: 5, residue_b: 4, divisor_r: 5 }).
   - `test_findcong_ramanujan_mod7`: Run findcong(&pgf, &[7]). Should discover p(7n+5) = 0 mod 7.
   - `test_findcong_ramanujan_mod11`: Run findcong(&pgf, &[11]). Should discover p(11n+6) = 0 mod 11.

2. **findnonhom tests**:
   - `test_findnonhom_affine_relation`: Create f, g where g = 2*f + 3 (affine, not homogeneous). findnonhom([f, g], 1, 0) should find the relation.

3. **findhomcombo tests**:
   - `test_findhomcombo_quadratic`: Create f = g1^2 + g2^2. findhomcombo(f, [g1, g2], 2, 0) should recover [1, 0, 1] (coefficients for g1^2, g1*g2, g2^2).

4. **findlincombomodp tests**:
   - `test_findlincombomodp`: Create known linear combination, verify discovery mod p=101.

5. **findmaxind tests**:
   - `test_findmaxind_independent`: Three linearly independent series -> returns all three indices.
   - `test_findmaxind_dependent`: Three series where one is a combo of the others -> returns two indices.

6. **Integration test**:
   - `test_full_suite_no_panic`: Run each function on simple inputs to verify no panics. This is a smoke test ensuring all 12+ functions are callable.

Keep test series small (truncation ~50) for fast execution. Use partition_gf at higher precision only for the Ramanujan congruence tests.
  </action>
  <verify>
`cargo test --manifest-path crates/qsym-core/Cargo.toml --test qseries_relations_tests` -- all tests pass.
  </verify>
  <done>
At least 8 new tests passing covering findcong (Ramanujan congruences), findnonhom, combo variants, modp functions, and findmaxind.
  </done>
</task>

</tasks>

<verification>
- `cargo build --manifest-path crates/qsym-core/Cargo.toml` succeeds
- `cargo test --manifest-path crates/qsym-core/Cargo.toml` -- all existing + new tests pass
- findcong discovers all three Ramanujan congruences (mod 5, 7, 11)
- findmaxind correctly identifies independent subsets
- All modp variants produce correct results
</verification>

<success_criteria>
- findcong discovers p(5n+4) = 0 mod 5, p(7n+5) = 0 mod 7, p(11n+6) = 0 mod 11
- findnonhom discovers non-homogeneous relations
- findmaxind correctly identifies linearly independent subsets
- Full suite of 12+ functions callable without error
- All existing tests continue to pass
- Phase 4 complete: all QSER-09 through QSER-19 requirements implemented
</success_criteria>

<output>
After completion, create `.planning/phases/04-series-analysis/04-06-SUMMARY.md`
</output>
