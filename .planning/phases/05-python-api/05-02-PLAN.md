---
phase: 05-python-api
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/src/session.rs
  - crates/qsym-python/src/expr.rs
  - crates/qsym-python/src/convert.rs
  - crates/qsym-python/python/qsymbolic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Python user can create a QSession and intern symbols via session.symbol('q')"
    - "Python user can create integer and rational expressions via session.integer(5) and session.rational(1, 2)"
    - "QExpr supports +, *, -, ** operators producing new QExpr objects"
    - "QExpr.__repr__() returns readable Unicode string"
    - "QExpr._repr_latex_() returns $..$ wrapped LaTeX string"
    - "QExpr objects keep session alive via Arc reference counting"
    - "Creating and discarding thousands of QExpr objects does not deadlock or crash"
  artifacts:
    - path: "crates/qsym-python/src/session.rs"
      provides: "QSession pyclass with frozen+Mutex pattern"
      contains: "#[pyclass(frozen)]"
      exports: ["QSession"]
    - path: "crates/qsym-python/src/expr.rs"
      provides: "QExpr pyclass with operator overloads and rendering"
      contains: "__repr__"
      exports: ["QExpr"]
    - path: "crates/qsym-python/src/convert.rs"
      provides: "rug QInt/QRat to Python int/Fraction conversion"
      contains: "qint_to_python"
  key_links:
    - from: "crates/qsym-python/src/expr.rs"
      to: "crates/qsym-python/src/session.rs"
      via: "Arc<Mutex<SessionInner>> back-reference"
      pattern: "Arc<Mutex<SessionInner>>"
    - from: "crates/qsym-python/src/expr.rs"
      to: "qsym_core::render"
      via: "to_latex and arena.display for rendering"
      pattern: "render::to_latex|arena\\.display"
    - from: "crates/qsym-python/src/expr.rs"
      to: "qsym_core::canonical"
      via: "make_add, make_mul, make_neg, make_pow for operators"
      pattern: "canonical::make_"
    - from: "crates/qsym-python/src/lib.rs"
      to: "session.rs and expr.rs"
      via: "m.add_class registration"
      pattern: "add_class::<QSession>|add_class::<QExpr>"
---

<objective>
Implement the core Python API: QSession (arena ownership), QExpr (expression handles with operators and rendering), and rug-to-Python type conversions.

Purpose: This is the foundational API surface that all other Python functionality builds on. QSession manages the arena; QExpr wraps ExprRef with Python operator overloads (+, *, -, **) and rendering (__repr__ for REPL, _repr_latex_ for Jupyter).

Output: A working Python API where users can create sessions, build symbolic expressions with natural operators, and see them rendered as Unicode or LaTeX.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-api/05-RESEARCH.md
@.planning/phases/05-python-api/05-01-SUMMARY.md
@crates/qsym-core/src/lib.rs
@crates/qsym-core/src/arena.rs
@crates/qsym-core/src/expr.rs
@crates/qsym-core/src/canonical.rs
@crates/qsym-core/src/render/mod.rs
@crates/qsym-core/src/render/unicode.rs
@crates/qsym-core/src/render/latex.rs
@crates/qsym-core/src/number.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QSession, QExpr, and type conversions</name>
  <files>
    crates/qsym-python/src/session.rs
    crates/qsym-python/src/expr.rs
    crates/qsym-python/src/convert.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
1. Create `crates/qsym-python/src/convert.rs`:
   - `pub fn qint_to_python<'py>(py: Python<'py>, val: &QInt) -> PyResult<Bound<'py, PyAny>>`: Convert rug Integer to Python int via string (val.0.to_string(), then Python builtins.int(s)). String conversion is reliable for arbitrary precision.
   - `pub fn qrat_to_python<'py>(py: Python<'py>, val: &QRat) -> PyResult<Bound<'py, PyAny>>`: Convert rug Rational to Python fractions.Fraction via numer/denom strings.
   - `pub fn python_int_to_i64(obj: &Bound<'_, PyAny>) -> PyResult<i64>`: Extract i64 from Python int for function parameters.

2. Create `crates/qsym-python/src/session.rs`:
   - Define `pub(crate) struct SessionInner { pub arena: ExprArena }` (NOT a pyclass -- internal only).
   - Define `#[pyclass(frozen)] #[derive(Clone)] pub struct QSession { pub(crate) inner: Arc<Mutex<SessionInner>> }`.
   - Implement `#[pymethods]`:
     - `#[new] fn new()` -- creates empty arena
     - `fn symbol(&self, name: &str) -> QExpr` -- interns symbol, returns QExpr
     - `fn symbols(&self, names: &str) -> Vec<QExpr>` -- split on whitespace, intern each
     - `fn integer(&self, val: i64) -> QExpr` -- interns integer literal
     - `fn rational(&self, num: i64, den: i64) -> PyResult<QExpr>` -- interns rational, error if den==0
     - `fn infinity(&self) -> QExpr` -- interns Expr::Infinity
     - `fn stats(&self) -> (usize, usize)` -- returns (arena.len(), symbols.len())
   - Use `self.inner.lock().unwrap()` for all locking. unwrap is acceptable: poison only happens on panic, which is a bug.

3. Create `crates/qsym-python/src/expr.rs`:
   - Define `#[pyclass(frozen)] #[derive(Clone)] pub struct QExpr { pub(crate) session: Arc<Mutex<SessionInner>>, pub(crate) expr_ref: ExprRef }`.
   - Implement `#[pymethods]`:
     - `fn __repr__(&self) -> String` -- lock session, use `format!("{}", session.arena.display(self.expr_ref))`
     - `fn __str__(&self) -> String` -- delegates to __repr__
     - `fn _repr_latex_(&self) -> String` -- lock session, use `qsym_core::render::to_latex(&session.arena, self.expr_ref)`, wrap in `format!("${}$", latex)`
     - `fn latex(&self) -> String` -- LaTeX without dollar signs
     - `fn __add__(&self, other: &QExpr) -> QExpr` -- lock, canonical::make_add, return new QExpr
     - `fn __radd__(&self, other: &QExpr) -> QExpr` -- same as __add__ (commutative)
     - `fn __mul__(&self, other: &QExpr) -> QExpr` -- lock, canonical::make_mul
     - `fn __rmul__(&self, other: &QExpr) -> QExpr` -- same as __mul__
     - `fn __neg__(&self) -> QExpr` -- lock, canonical::make_neg
     - `fn __sub__(&self, other: &QExpr) -> QExpr` -- self + (-other)
     - `fn __pow__(&self, exp: &QExpr, _modulo: Option<&Bound<'_, PyAny>>) -> QExpr` -- lock, canonical::make_pow
     - `fn __eq__(&self, other: &QExpr) -> bool` -- ExprRef equality (O(1) structural)
     - `fn __hash__(&self) -> u64` -- expr_ref.0 as u64
     - `fn simplify(&self) -> QExpr` -- lock, SimplificationEngine::new().simplify(), return new QExpr
     - `fn variant(&self) -> String` -- lock, arena.get(expr_ref).variant_name().to_string()
   - CRITICAL: QExpr does NOT implement Drop/dealloc that locks the session. Just drop the Arc naturally. This prevents deadlock with Python GC (Pitfall 2 from research).

4. Update `crates/qsym-python/src/lib.rs`:
   - Add `mod session; mod expr; mod convert;`
   - In the `#[pymodule]` function, register: `m.add_class::<session::QSession>()?;` and `m.add_class::<expr::QExpr>()?;`
   - Keep the version() function from Plan 01.
  </action>
  <verify>
`cargo check -p qsym-python` passes. If maturin is available: `maturin develop --release` then run:
```python
from qsymbolic import QSession
s = QSession()
q = s.symbol("q")
a = s.symbol("a")
expr = q + a
print(repr(expr))  # Should show Unicode
print(expr._repr_latex_())  # Should show $...$
print(s.stats())  # Should show (>0, 2)
```
  </verify>
  <done>
QSession and QExpr compile. Symbols can be created, operators (+, *, -, **) produce new QExpr objects, __repr__ returns Unicode, _repr_latex_ returns LaTeX wrapped in dollar signs. If Python is available, the import and basic operations work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Python package and add GC stress test</name>
  <files>
    crates/qsym-python/python/qsymbolic/__init__.py
  </files>
  <action>
1. Update `crates/qsym-python/python/qsymbolic/__init__.py`:
   - Import QSession, QExpr from ._qsymbolic
   - Add convenience function `symbols(names: str, session=None)` that creates a QSession if none provided, calls session.symbols(names), returns tuple if multiple or single QExpr if one name.
   - Export __all__ = ["QSession", "QExpr", "symbols", "__version__"]

2. If Python and maturin are available, create and run a GC stress test script (not a permanent test file -- run inline via `python -c`):
   ```python
   from qsymbolic import QSession
   import gc

   # Create and discard thousands of expressions
   s = QSession()
   for i in range(10000):
       x = s.symbol(f"x{i}")
       y = s.integer(i)
       z = x + y
       del x, y, z
   gc.collect()

   # Verify session still works after GC
   q = s.symbol("q")
   print(f"Stats after GC stress: {s.stats()}")
   print(f"q repr: {repr(q)}")

   # Test session kept alive by expressions
   expr = s.symbol("alive")
   del s  # Session should stay alive via Arc in expr
   print(f"After session del: {repr(expr)}")
   gc.collect()
   print("GC stress test PASSED")
   ```

   This validates PYTH-02 (arena ownership across GC). The test should complete without deadlock or crash.

3. If Python is not available, skip the stress test -- it will be validated when Python becomes available. Document this in the summary.
  </action>
  <verify>
If Python available: the GC stress test script completes without hanging or crashing, printing "GC stress test PASSED". The `symbols()` convenience function works: `q, a = symbols("q a")`.
If Python not available: `cargo check -p qsym-python` passes.
  </verify>
  <done>
Python package __init__.py re-exports all core types. GC stress test demonstrates no deadlock or crash when creating/discarding thousands of QExpr objects and using expressions after session deletion.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p qsym-python` passes with session.rs, expr.rs, convert.rs
- QSession creates arena, interns symbols/integers/rationals
- QExpr operators (+, *, -, **) produce correct canonical expressions
- __repr__ returns Unicode, _repr_latex_ returns $LaTeX$
- No deadlock when creating/discarding many expressions (GC safe)
- Session stays alive via Arc when QExpr outlives QSession variable
</verification>

<success_criteria>
Core QSession + QExpr API compiles and (if Python available) supports creating expressions with natural operators, rendering them as Unicode and LaTeX, and surviving GC stress without deadlock.
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-api/05-02-SUMMARY.md`
</output>
