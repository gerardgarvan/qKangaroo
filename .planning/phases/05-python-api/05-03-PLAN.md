---
phase: 05-python-api
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/src/series.rs
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/python/qsymbolic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Python user can call qpoch(session, a, q, n) to create q-Pochhammer series"
    - "Python user can call theta3(session, order) to compute theta function series"
    - "Python user can call partition_gf(session, order) to get partition generating function"
    - "Python user can call prodmake(series, max_n) for series-to-product conversion"
    - "Python user can call findlincombo(target, candidates) for relation discovery"
    - "QSeries supports coefficient access via series[k] returning Python Fraction"
    - "QSeries displays as string in REPL (e.g., '1 - q + q^2 + O(q^10)')"
    - "All Phase 3-4 public functions are callable from Python"
  artifacts:
    - path: "crates/qsym-python/src/series.rs"
      provides: "QSeries pyclass wrapping FormalPowerSeries"
      contains: "#[pyclass(frozen)]"
      exports: ["QSeries"]
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "Python DSL functions for all q-series operations"
      contains: "#[pyfunction]"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "qsym_core::qseries"
      via: "delegating all computation to Rust core"
      pattern: "qsym_core::qseries::"
    - from: "crates/qsym-python/src/series.rs"
      to: "qsym_core::series::FormalPowerSeries"
      via: "wrapping FPS in pyclass"
      pattern: "FormalPowerSeries"
    - from: "crates/qsym-python/src/series.rs"
      to: "crates/qsym-python/src/convert.rs"
      via: "coefficient extraction returns Python Fraction"
      pattern: "qrat_to_python"
    - from: "crates/qsym-python/src/lib.rs"
      to: "series.rs and dsl.rs"
      via: "module registration"
      pattern: "add_class::<.*QSeries>|add_function.*wrap_pyfunction"
---

<objective>
Implement QSeries wrapper for FormalPowerSeries and DSL functions exposing all Phase 3-4 q-series functions to Python.

Purpose: This makes the full Rust computation engine accessible from Python. Researchers can compute q-Pochhammer symbols, theta functions, partition functions, named products, factoring, prodmake, and relation discovery -- all from Python with natural function syntax.

Output: QSeries class with coefficient access and string display. 30+ DSL functions covering pochhammer, products, theta, partitions, rank/crank, factoring, utilities, prodmake, and relation discovery.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-api/05-RESEARCH.md
@.planning/phases/05-python-api/05-02-SUMMARY.md
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/qseries/theta.rs
@crates/qsym-core/src/qseries/partitions.rs
@crates/qsym-core/src/qseries/qbinomial.rs
@crates/qsym-core/src/qseries/rank_crank.rs
@crates/qsym-core/src/qseries/factoring.rs
@crates/qsym-core/src/qseries/utilities.rs
@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/qseries/relations.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-python/src/session.rs
@crates/qsym-python/src/expr.rs
@crates/qsym-python/src/convert.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QSeries pyclass wrapping FormalPowerSeries</name>
  <files>
    crates/qsym-python/src/series.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
1. Create `crates/qsym-python/src/series.rs`:
   - Define `#[pyclass(frozen)] pub struct QSeries { pub(crate) fps: FormalPowerSeries }`.
   - QSeries owns the FPS directly (not behind the session Mutex). FPS is a standalone computation result, not an arena expression (see Pitfall 5 in research).
   - Implement `#[pymethods]`:
     - `fn __repr__(&self) -> String` -- use `format!("{}", self.fps)` (FPS implements Display)
     - `fn __str__(&self) -> String` -- delegates to __repr__
     - `fn __getitem__(&self, py: Python<'_>, key: i64) -> PyResult<PyObject>` -- get coefficient at power `key`, convert QRat to Python Fraction via convert::qrat_to_python. Return Fraction(0) for zero coefficients.
     - `fn __len__(&self) -> usize` -- self.fps.num_nonzero()
     - `fn truncation_order(&self) -> i64` -- self.fps.truncation_order()
     - `fn min_order(&self) -> Option<i64>` -- self.fps.min_order()
     - `fn is_zero(&self) -> bool` -- self.fps.is_zero()
     - `fn coeffs(&self, py: Python<'_>) -> PyResult<Vec<(i64, PyObject)>>` -- iterate fps, convert each QRat to Python Fraction, return list of (power, Fraction) tuples
     - `fn to_dict(&self, py: Python<'_>) -> PyResult<PyObject>` -- return Python dict {power: Fraction}
     - `fn degree(&self) -> Option<i64>` -- qsym_core::qseries::qdegree(&self.fps)
     - `fn low_degree(&self) -> Option<i64>` -- qsym_core::qseries::lqdegree(&self.fps)

   - Series arithmetic as methods (these delegate to qsym_core::series::arithmetic):
     - `fn __add__(&self, other: &QSeries) -> QSeries` -- series::arithmetic::add
     - `fn __mul__(&self, other: &QSeries) -> QSeries` -- series::arithmetic::mul
     - `fn __neg__(&self) -> QSeries` -- series::arithmetic::negate
     - `fn __sub__(&self, other: &QSeries) -> QSeries` -- add(self, negate(other))
     - `fn invert(&self) -> QSeries` -- series::arithmetic::invert
     - `fn sift(&self, m: i64, j: i64) -> QSeries` -- qsym_core::qseries::sift

2. Update `crates/qsym-python/src/lib.rs`:
   - Add `mod series;`
   - Register `m.add_class::<series::QSeries>()?;`
  </action>
  <verify>
`cargo check -p qsym-python` passes. If Python available: create a QSeries from a DSL function (Task 2) and verify `series[0]`, `series[1]`, `len(series)`, `repr(series)` work.
  </verify>
  <done>
QSeries compiles with coefficient access, string representation, arithmetic operations, and utility methods. FPS computation results are usable from Python with natural indexing syntax.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement all DSL functions exposing Phase 3-4 Rust functions</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
    crates/qsym-python/python/qsymbolic/__init__.py
  </files>
  <action>
1. Create `crates/qsym-python/src/dsl.rs` with `#[pyfunction]` wrappers for ALL public qseries functions. Each function locks the session to get a SymbolId for "q" (the standard variable), calls the Rust function, and wraps the result.

The session parameter pattern: DSL functions that need a SymbolId for the series variable take a `session: &QSession` parameter. Lock the session, intern "q" to get the SymbolId, call the Rust function.

GROUP 1 -- Pochhammer and q-Binomial:
- `fn aqprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, n: i64, order: i64) -> QSeries`
  - Creates QMonomial from coeff_num/coeff_den and power
  - If n == i64::MAX (or a sentinel like 999999), use PochhammerOrder::Infinite, else Finite(n)
  - Actually: use a separate function signature. Use `n: Option<i64>` where None means infinite. OR: use a Python-side convention where `n=None` means infinite.
  - Best approach: `fn aqprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, n: Option<i64>, order: i64) -> QSeries` where n=None means Infinite.
- `fn qbin(session: &QSession, n: i64, k: i64, order: i64) -> QSeries`

GROUP 2 -- Named Products:
- `fn etaq(session: &QSession, b: i64, t: i64, order: i64) -> QSeries`
- `fn jacprod(session: &QSession, a: i64, b: i64, order: i64) -> QSeries`
- `fn tripleprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, order: i64) -> QSeries`
  - Constructs QMonomial from coeff params
- `fn quinprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, order: i64) -> QSeries`
- `fn winquist(session: &QSession, a_cn: i64, a_cd: i64, a_p: i64, b_cn: i64, b_cd: i64, b_p: i64, order: i64) -> QSeries`
  - Two QMonomials from 6 params

GROUP 3 -- Theta Functions:
- `fn theta2(session: &QSession, order: i64) -> QSeries`
- `fn theta3(session: &QSession, order: i64) -> QSeries`
- `fn theta4(session: &QSession, order: i64) -> QSeries`

GROUP 4 -- Partition Functions:
- `fn partition_count(n: i64) -> PyResult<PyObject>` -- returns Python int via qrat_to_python (partition_count returns QRat)
  - Actually, partition_count returns QRat which for integer n is always an integer. Convert to Python int.
- `fn partition_gf(session: &QSession, order: i64) -> QSeries`
- `fn distinct_parts_gf(session: &QSession, order: i64) -> QSeries`
- `fn odd_parts_gf(session: &QSession, order: i64) -> QSeries`
- `fn bounded_parts_gf(session: &QSession, max_part: i64, order: i64) -> QSeries`
- `fn rank_gf(session: &QSession, z_num: i64, z_den: i64, order: i64) -> QSeries`
  - z parameter as QRat from num/den
- `fn crank_gf(session: &QSession, z_num: i64, z_den: i64, order: i64) -> QSeries`

GROUP 5 -- Factoring and Utilities:
- `fn qfactor(series: &QSeries) -> PyResult<PyObject>` -- returns Python dict: {"scalar": Fraction, "factors": [(i, e), ...], "remainder": QSeries}
  - QFactorization has scalar (QRat), factors (Vec<(i64, i64)>), remainder (FPS)
- `fn sift(series: &QSeries, m: i64, j: i64) -> QSeries` -- already on QSeries but also as free function
- `fn qdegree(series: &QSeries) -> Option<i64>`
- `fn lqdegree(series: &QSeries) -> Option<i64>`

GROUP 6 -- Prodmake and Post-Processing:
- `fn prodmake(series: &QSeries, max_n: i64) -> PyResult<PyObject>` -- returns Python dict representing InfiniteProductForm: {"scalar": Fraction, "min_order": int, "factors": {n: exponent, ...}}
- `fn etamake(series: &QSeries, max_n: i64) -> PyResult<PyObject>` -- returns dict for EtaQuotient
- `fn jacprodmake(series: &QSeries, max_n: i64) -> PyResult<PyObject>` -- returns dict for JacobiProductForm
- `fn mprodmake(series: &QSeries, max_n: i64) -> PyResult<PyObject>` -- returns dict {n: exponent}
- `fn qetamake(series: &QSeries, max_n: i64) -> PyResult<PyObject>` -- returns dict for QEtaForm

GROUP 7 -- Relation Discovery:
- `fn findlincombo(target: &QSeries, candidates: Vec<QSeries>) -> PyResult<Option<PyObject>>` -- returns Optional list of Fraction coefficients
  - Need to convert Vec<QSeries> parameter. Use `candidates: Vec<PyRef<'_, QSeries>>` to borrow from Python.
  - Actually simpler: accept `&Bound<'_, PyList>` and extract each QSeries. OR: use Vec<QSeries> since QSeries: Clone (FPS: Clone).
  - Best: Use a Rust helper that takes `&[FormalPowerSeries]`. Extract FPS refs from QSeries objects.
- `fn findhom(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64) -> PyResult<Option<PyObject>>`
- `fn findpoly(series_list: Vec<PyRef<'_, QSeries>>, degree: i64) -> PyResult<Option<PyObject>>`
- `fn findcong(series: &QSeries, moduli: Vec<i64>) -> PyResult<PyObject>` -- returns list of {modulus, residue, divisor} dicts
- `fn findnonhom(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64) -> PyResult<Option<PyObject>>`
- `fn findhomcombo(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64) -> PyResult<Option<PyObject>>`
- `fn findnonhomcombo(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64) -> PyResult<Option<PyObject>>`
- `fn findlincombomodp(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, p: i64) -> PyResult<Option<PyObject>>`
- `fn findhommodp(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64, p: i64) -> PyResult<Option<PyObject>>`
- `fn findhomcombomodp(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64, p: i64) -> PyResult<Option<PyObject>>`
- `fn findmaxind(series_list: Vec<PyRef<'_, QSeries>>) -> Vec<usize>`
- `fn findprod(target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, max_coeff: i64) -> PyResult<Option<PyObject>>`

IMPLEMENTATION NOTES:
- For Vec<PyRef<'_, QSeries>> parameters, extract `&fps` references into a Vec<&FormalPowerSeries> or clone into Vec<FormalPowerSeries> as needed by the Rust function signatures.
- For return types that are complex Rust structs (InfiniteProductForm, EtaQuotient, etc.), convert to Python dicts. Do NOT try to make them pyclasses -- they're lightweight result types.
- The relation discovery functions return Option<Vec<QRat>> or similar. Convert to Option<list[Fraction]>.
- For functions that take QMonomial parameters from Python, accept the components as separate i64 args (coeff_num, coeff_den, power) and construct QMonomial in Rust.

2. Update `crates/qsym-python/src/lib.rs`:
   - Add `mod dsl;`
   - Register ALL DSL functions via `m.add_function(wrap_pyfunction!(dsl::aqprod, m)?)?;` etc.

3. Update `crates/qsym-python/python/qsymbolic/__init__.py`:
   - Import all DSL functions: `from ._qsymbolic import aqprod, qbin, etaq, jacprod, tripleprod, quinprod, winquist, theta2, theta3, theta4, partition_count, partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf, rank_gf, crank_gf, qfactor, sift, qdegree, lqdegree, prodmake, etamake, jacprodmake, mprodmake, qetamake, findlincombo, findhom, findpoly, findcong, findnonhom, findhomcombo, findnonhomcombo, findlincombomodp, findhommodp, findhomcombomodp, findmaxind, findprod`
   - Import QSeries: `from ._qsymbolic import QSeries`
   - Update __all__ to include all exports.
  </action>
  <verify>
`cargo check -p qsym-python` passes with all DSL functions registered. If Python available:
```python
from qsymbolic import QSession, theta3, partition_gf, prodmake, findlincombo
s = QSession()
# Theta function
t3 = theta3(s, 20)
print(t3)
print(t3[0], t3[1])  # coefficients
# Partition generating function
pgf = partition_gf(s, 20)
print(pgf[5])  # p(5) = 7
# Product form
pf = prodmake(pgf, 10)
print(pf)
```
  </verify>
  <done>
All 30+ Phase 3-4 functions are callable from Python via DSL functions. QSeries supports coefficient access and arithmetic. Complex return types (InfiniteProductForm, etc.) are converted to Python dicts. Relation discovery functions accept lists of QSeries and return Python-native results.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p qsym-python` passes with series.rs and dsl.rs
- All qseries module public functions have Python DSL wrappers
- QSeries supports __getitem__, __repr__, __len__, arithmetic
- DSL functions properly lock session, create SymbolId, delegate to Rust
- Complex Rust return types converted to Python dicts/lists
- Python __init__.py exports all functions
</verification>

<success_criteria>
All Phase 3-4 Rust functions are accessible from Python. QSeries wraps FormalPowerSeries with Pythonic coefficient access. Researchers can call qpoch, theta functions, partition functions, prodmake, and relation discovery functions from Python.
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-api/05-03-SUMMARY.md`
</output>
