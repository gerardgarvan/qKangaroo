---
phase: 05-python-api
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/src/series.rs
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/python/qsymbolic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Python user can call qpoch(session, a, q, n) to create q-Pochhammer series"
    - "Python user can call theta3(session, order) to compute theta function series"
    - "Python user can call partition_gf(session, order) to get partition generating function"
    - "Python user can call prodmake(series, max_n) for series-to-product conversion"
    - "Python user can call findlincombo(target, candidates, topshift) for relation discovery"
    - "QSeries supports coefficient access via series[k] returning Python Fraction"
    - "QSeries displays as string in REPL (e.g., '1 - q + q^2 + O(q^10)')"
    - "All Phase 3-4 public functions are callable from Python"
    - "All DSL functions use SessionInner.get_or_create_symbol_id() to obtain SymbolId"
  artifacts:
    - path: "crates/qsym-python/src/series.rs"
      provides: "QSeries pyclass wrapping FormalPowerSeries"
      contains: "#[pyclass(frozen)]"
      exports: ["QSeries"]
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "Python DSL functions for all q-series operations"
      contains: "#[pyfunction]"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "qsym_core::qseries"
      via: "delegating all computation to Rust core"
      pattern: "qsym_core::qseries::"
    - from: "crates/qsym-python/src/dsl.rs"
      to: "crates/qsym-python/src/session.rs"
      via: "get_or_create_symbol_id() for SymbolId"
      pattern: "get_or_create_symbol_id"
    - from: "crates/qsym-python/src/series.rs"
      to: "qsym_core::series::FormalPowerSeries"
      via: "wrapping FPS in pyclass"
      pattern: "FormalPowerSeries"
    - from: "crates/qsym-python/src/series.rs"
      to: "crates/qsym-python/src/convert.rs"
      via: "coefficient extraction returns Python Fraction"
      pattern: "qrat_to_python"
    - from: "crates/qsym-python/src/lib.rs"
      to: "series.rs and dsl.rs"
      via: "module registration"
      pattern: "add_class::<.*QSeries>|add_function.*wrap_pyfunction"
---

<objective>
Implement QSeries wrapper for FormalPowerSeries and DSL functions exposing all Phase 3-4 q-series functions to Python.

Purpose: This makes the full Rust computation engine accessible from Python. Researchers can compute q-Pochhammer symbols, theta functions, partition functions, named products, factoring, prodmake, and relation discovery -- all from Python with natural function syntax.

Output: QSeries class with coefficient access and string display. 30+ DSL functions covering pochhammer, products, theta, partitions, rank/crank, factoring, utilities, prodmake, and relation discovery. Split into 4 tasks for manageable scope: QSeries class, then three groups of DSL functions.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-api/05-RESEARCH.md
@.planning/phases/05-python-api/05-02-SUMMARY.md
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/qseries/theta.rs
@crates/qsym-core/src/qseries/partitions.rs
@crates/qsym-core/src/qseries/qbinomial.rs
@crates/qsym-core/src/qseries/rank_crank.rs
@crates/qsym-core/src/qseries/factoring.rs
@crates/qsym-core/src/qseries/utilities.rs
@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/qseries/relations.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-python/src/session.rs
@crates/qsym-python/src/expr.rs
@crates/qsym-python/src/convert.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QSeries pyclass wrapping FormalPowerSeries</name>
  <files>
    crates/qsym-python/src/series.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
1. Create `crates/qsym-python/src/series.rs`:
   - Define `#[pyclass(frozen)] pub struct QSeries { pub(crate) fps: FormalPowerSeries }`.
   - QSeries owns the FPS directly (not behind the session Mutex). FPS is a standalone computation result, not an arena expression (see Pitfall 5 in research).
   - Implement `#[pymethods]`:
     - `fn __repr__(&self) -> String` -- use `format!("{}", self.fps)` (FPS implements Display)
     - `fn __str__(&self) -> String` -- delegates to __repr__
     - `fn __getitem__(&self, py: Python<'_>, key: i64) -> PyResult<PyObject>` -- get coefficient at power `key`, convert QRat to Python Fraction via convert::qrat_to_python. Return Fraction(0) for zero coefficients.
     - `fn __len__(&self) -> usize` -- self.fps.num_nonzero()
     - `fn truncation_order(&self) -> i64` -- self.fps.truncation_order()
     - `fn min_order(&self) -> Option<i64>` -- self.fps.min_order()
     - `fn is_zero(&self) -> bool` -- self.fps.is_zero()
     - `fn coeffs(&self, py: Python<'_>) -> PyResult<Vec<(i64, PyObject)>>` -- iterate fps, convert each QRat to Python Fraction, return list of (power, Fraction) tuples
     - `fn to_dict(&self, py: Python<'_>) -> PyResult<PyObject>` -- return Python dict {power: Fraction}
     - `fn degree(&self) -> Option<i64>` -- qsym_core::qseries::qdegree(&self.fps)
     - `fn low_degree(&self) -> Option<i64>` -- qsym_core::qseries::lqdegree(&self.fps)

   - Series arithmetic as methods (these delegate to qsym_core::series::arithmetic):
     - `fn __add__(&self, other: &QSeries) -> QSeries` -- series::arithmetic::add
     - `fn __mul__(&self, other: &QSeries) -> QSeries` -- series::arithmetic::mul
     - `fn __neg__(&self) -> QSeries` -- series::arithmetic::negate
     - `fn __sub__(&self, other: &QSeries) -> QSeries` -- add(self, negate(other))
     - `fn invert(&self) -> QSeries` -- series::arithmetic::invert
     - `fn sift(&self, m: i64, j: i64) -> QSeries` -- qsym_core::qseries::sift

2. Update `crates/qsym-python/src/lib.rs`:
   - Add `mod series;`
   - Register `m.add_class::<series::QSeries>()?;`
  </action>
  <verify>
`cargo check -p qsym-python` passes. If Python available: create a QSeries from a DSL function (Task 2) and verify `series[0]`, `series[1]`, `len(series)`, `repr(series)` work.
  </verify>
  <done>
QSeries compiles with coefficient access, string representation, arithmetic operations, and utility methods. FPS computation results are usable from Python with natural indexing syntax.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DSL functions for q-Pochhammer, products, and theta (Groups 1-3)</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
Create `crates/qsym-python/src/dsl.rs` with `#[pyfunction]` wrappers. Each function that needs a SymbolId for the series variable takes a `session: &QSession` parameter, locks the session, and calls `session_inner.get_or_create_symbol_id("q")` to obtain the SymbolId.

CRITICAL: Use `session_inner.get_or_create_symbol_id("q")` (returns SymbolId), NOT `session_inner.arena.intern_symbol("q")` (returns ExprRef). All qsym_core::qseries functions take `variable: SymbolId`.

GROUP 1 -- Pochhammer and q-Binomial:

- `fn aqprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, n: Option<i64>, order: i64) -> QSeries`
  Rust sig: `aqprod(a: &QMonomial, variable: SymbolId, n: PochhammerOrder, truncation_order: i64) -> FPS`
  - Lock session, get sym_q via get_or_create_symbol_id("q")
  - Create QMonomial::new(QRat::from((coeff_num, coeff_den)), power)
  - n=None -> PochhammerOrder::Infinite, n=Some(k) -> PochhammerOrder::Finite(k)
  - Call qsym_core::qseries::aqprod(&monomial, sym_q, poch_order, order)

- `fn qbin(session: &QSession, n: i64, k: i64, order: i64) -> QSeries`
  Rust sig: `qbin(n: i64, k: i64, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call qbin(n, k, sym_q, order)

GROUP 2 -- Named Products:

- `fn etaq(session: &QSession, b: i64, t: i64, order: i64) -> QSeries`
  Rust sig: `etaq(b: i64, t: i64, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call etaq(b, t, sym_q, order)

- `fn jacprod(session: &QSession, a: i64, b: i64, order: i64) -> QSeries`
  Rust sig: `jacprod(a: i64, b: i64, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call jacprod(a, b, sym_q, order)

- `fn tripleprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, order: i64) -> QSeries`
  Rust sig: `tripleprod(z: &QMonomial, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, construct QMonomial, call tripleprod(&monomial, sym_q, order)

- `fn quinprod(session: &QSession, coeff_num: i64, coeff_den: i64, power: i64, order: i64) -> QSeries`
  Rust sig: `quinprod(z: &QMonomial, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, construct QMonomial, call quinprod(&monomial, sym_q, order)

- `fn winquist(session: &QSession, a_cn: i64, a_cd: i64, a_p: i64, b_cn: i64, b_cd: i64, b_p: i64, order: i64) -> QSeries`
  Rust sig: `winquist(a: &QMonomial, b: &QMonomial, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, construct two QMonomials, call winquist(&a, &b, sym_q, order)

GROUP 3 -- Theta Functions:

- `fn theta2(session: &QSession, order: i64) -> QSeries`
  Rust sig: `theta2(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call theta2(sym_q, order)

- `fn theta3(session: &QSession, order: i64) -> QSeries`
  Rust sig: `theta3(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call theta3(sym_q, order)

- `fn theta4(session: &QSession, order: i64) -> QSeries`
  Rust sig: `theta4(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call theta4(sym_q, order)

Add `mod dsl;` to lib.rs and register all Group 1-3 functions via `m.add_function(wrap_pyfunction!(dsl::aqprod, m)?)?;` etc.

NOTE: Groups 4-7 are implemented in Tasks 3 and 4 below. dsl.rs is a single file that will be extended across all three tasks.
  </action>
  <verify>
`cargo check -p qsym-python` passes with dsl.rs containing Groups 1-3 registered. If Python available:
```python
from qsymbolic import QSession, etaq, theta3, aqprod
s = QSession()
e = etaq(s, 1, 1, 20)
print(e)
print(e[0])  # Fraction(1)
t3 = theta3(s, 20)
print(t3)
qq = aqprod(s, 1, 1, 1, None, 20)  # (q;q)_inf
print(qq)
```
  </verify>
  <done>
Groups 1-3 (q-Pochhammer, q-binomial, named products, theta functions) all compile and are registered as Python functions. Each function correctly uses get_or_create_symbol_id("q") to get SymbolId.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement DSL functions for partitions, analysis, factoring, and prodmake (Groups 4-5)</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
Extend `crates/qsym-python/src/dsl.rs` with Groups 4-5 functions.

GROUP 4 -- Partition Functions:

- `fn partition_count(py: Python<'_>, n: i64) -> PyResult<PyObject>`
  Rust sig: `partition_count(n: i64) -> QRat`
  - Call qsym_core::qseries::partition_count(n), convert result to Python int via qint_to_python (partition_count returns QRat which is always an integer for non-negative n).
  - NOTE: No session needed -- pure computation on an integer, no FPS involved.

- `fn partition_gf(session: &QSession, order: i64) -> QSeries`
  Rust sig: `partition_gf(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call partition_gf(sym_q, order)

- `fn distinct_parts_gf(session: &QSession, order: i64) -> QSeries`
  Rust sig: `distinct_parts_gf(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call distinct_parts_gf(sym_q, order)

- `fn odd_parts_gf(session: &QSession, order: i64) -> QSeries`
  Rust sig: `odd_parts_gf(variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call odd_parts_gf(sym_q, order)

- `fn bounded_parts_gf(session: &QSession, max_part: i64, order: i64) -> QSeries`
  Rust sig: `bounded_parts_gf(max_parts: i64, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, call bounded_parts_gf(max_part, sym_q, order)

- `fn rank_gf(session: &QSession, z_num: i64, z_den: i64, order: i64) -> QSeries`
  Rust sig: `rank_gf(z: &QRat, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, construct QRat from z_num/z_den, call rank_gf(&z, sym_q, order)

- `fn crank_gf(session: &QSession, z_num: i64, z_den: i64, order: i64) -> QSeries`
  Rust sig: `crank_gf(z: &QRat, variable: SymbolId, truncation_order: i64) -> FPS`
  - Lock session, get sym_q, construct QRat, call crank_gf(&z, sym_q, order)

GROUP 5 -- Factoring, Utilities, and Prodmake/Post-processing:

- `fn qfactor(py: Python<'_>, series: &QSeries) -> PyResult<PyObject>`
  Rust sig: `qfactor(f: &FPS) -> QFactorization`
  - Call qsym_core::qseries::qfactor(&series.fps)
  - Returns Python dict: {"scalar": Fraction, "factors": {i: multiplicity, ...}, "is_exact": bool}
  - QFactorization has: scalar (QRat), factors (BTreeMap<i64, i64>), is_exact (bool)
  - Convert scalar to Python Fraction via qrat_to_python
  - Convert factors BTreeMap to Python dict {int: int}
  - NOTE: factors are (1-q^i)^multiplicity where multiplicity is i64, NOT QRat. Use plain Python ints.

- `fn sift_fn(series: &QSeries, m: i64, j: i64) -> QSeries`
  Rust sig: `sift(f: &FPS, m: i64, j: i64) -> FPS`
  - Name it `sift_fn` in Rust, register as "sift" in Python to avoid conflict with QSeries.sift() method.
  - Call qsym_core::qseries::sift(&series.fps, m, j)

- `fn qdegree(series: &QSeries) -> Option<i64>`
  Rust sig: `qdegree(f: &FPS) -> Option<i64>`
  - Direct delegation.

- `fn lqdegree(series: &QSeries) -> Option<i64>`
  Rust sig: `lqdegree(f: &FPS) -> Option<i64>`
  - Direct delegation.

- `fn prodmake(py: Python<'_>, series: &QSeries, max_n: i64) -> PyResult<PyObject>`
  Rust sig: `prodmake(f: &FPS, max_n: i64) -> InfiniteProductForm`
  - Call qsym_core::qseries::prodmake(&series.fps, max_n)
  - Returns Python dict: {"factors": {n: Fraction(exponent), ...}, "terms_used": int}
  - InfiniteProductForm has: exponents (BTreeMap<i64, QRat>), terms_used (i64)
  - Convert each exponent QRat to Python Fraction via qrat_to_python
  - NOTE: Exponents are QRat (rational, not always integer). Convert to Python Fraction.

- `fn etamake(py: Python<'_>, series: &QSeries, max_n: i64) -> PyResult<PyObject>`
  Rust sig: `etamake(f: &FPS, max_n: i64) -> EtaQuotient`
  - Returns dict: {"factors": {d: int, ...}, "q_shift": Fraction}
  - EtaQuotient has: factors (BTreeMap<i64, i64>), q_shift (QRat)

- `fn jacprodmake(py: Python<'_>, series: &QSeries, max_n: i64) -> PyResult<PyObject>`
  Rust sig: `jacprodmake(f: &FPS, max_n: i64) -> JacobiProductForm`
  - Returns dict: {"factors": {(a,b): int, ...}, "scalar": Fraction, "is_exact": bool}
  - JacobiProductForm has: factors (BTreeMap<(i64,i64), i64>), scalar (QRat), is_exact (bool)
  - Convert factor keys (i64,i64) to Python tuple (a,b)

- `fn mprodmake(py: Python<'_>, series: &QSeries, max_n: i64) -> PyResult<PyObject>`
  Rust sig: `mprodmake(f: &FPS, max_n: i64) -> BTreeMap<i64, i64>`
  - Returns dict: {n: int, ...}

- `fn qetamake(py: Python<'_>, series: &QSeries, max_n: i64) -> PyResult<PyObject>`
  Rust sig: `qetamake(f: &FPS, max_n: i64) -> QEtaForm`
  - Returns dict: {"factors": {d: int, ...}, "q_shift": Fraction}
  - QEtaForm has: factors (BTreeMap<i64, i64>), q_shift (QRat)

Register all Group 4-5 functions in lib.rs via wrap_pyfunction.
  </action>
  <verify>
`cargo check -p qsym-python` passes with Groups 4-5 added. If Python available:
```python
from qsymbolic import QSession, partition_gf, partition_count, prodmake, qfactor, etaq
s = QSession()
pgf = partition_gf(s, 30)
print(pgf[5])  # Fraction(7) -- p(5) = 7
print(partition_count(100))  # 190569292
pf = prodmake(pgf, 15)
print(pf)  # dict with QRat exponents as Fractions
euler = etaq(s, 1, 1, 20)
qf = qfactor(euler)
print(qf)  # {"scalar": Fraction(1), "factors": {...}, "is_exact": True}
```
  </verify>
  <done>
Groups 4-5 (partitions, rank/crank, factoring, utilities, prodmake and all post-processing) compile and are registered. Complex Rust return types (QFactorization, InfiniteProductForm, EtaQuotient, JacobiProductForm, QEtaForm) are correctly converted to Python dicts with QRat exponents as Fraction objects.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement DSL functions for relation discovery (Groups 6-7) and update Python exports</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
    crates/qsym-python/python/qsymbolic/__init__.py
  </files>
  <action>
Extend `crates/qsym-python/src/dsl.rs` with Groups 6-7 (relation discovery) functions.

CRITICAL: Every relation discovery function has a `topshift: i64` parameter that controls the number of extra rows used for overdetermination. This parameter MUST be exposed in the Python API. The Rust signatures have been audited below.

For functions taking `&[&FormalPowerSeries]` (slice of references): Accept `Vec<PyRef<'_, QSeries>>` in the Python wrapper, then extract FPS references: `let fps_vec: Vec<&FPS> = series_list.iter().map(|s| &s.fps).collect();`

GROUP 6 -- Relation Discovery (exact rational):

- `fn findlincombo(py: Python<'_>, target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findlincombo(f: &FPS, basis: &[&FPS], topshift: i64) -> Option<Vec<QRat>>`
  - Extract &fps refs from candidates, call findlincombo(&target.fps, &fps_refs, topshift)
  - Return: None if no relation, Some(list[Fraction]) if found

- `fn findhom(py: Python<'_>, series_list: Vec<PyRef<'_, QSeries>>, degree: i64, topshift: i64) -> PyResult<PyObject>`
  Rust sig: `findhom(series: &[&FPS], degree: i64, topshift: i64) -> Vec<Vec<QRat>>`
  - Returns list of relation vectors (list[list[Fraction]])

- `fn findpoly(py: Python<'_>, x: &QSeries, y: &QSeries, deg_x: i64, deg_y: i64, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findpoly(x: &FPS, y: &FPS, deg_x: i64, deg_y: i64, topshift: i64) -> Option<PolynomialRelation>`
  - PolynomialRelation has: coefficients (Vec<Vec<QRat>>), deg_x, deg_y
  - Returns dict: {"coefficients": list[list[Fraction]], "deg_x": int, "deg_y": int}

- `fn findcong(py: Python<'_>, series: &QSeries, moduli: Vec<i64>) -> PyResult<PyObject>`
  Rust sig: `findcong(f: &FPS, moduli: &[i64]) -> Vec<Congruence>`
  - NOTE: findcong does NOT take topshift.
  - Congruence has: modulus_m (i64), residue_b (i64), divisor_r (i64)
  - Returns list of dicts: [{"modulus": int, "residue": int, "divisor": int}, ...]

- `fn findnonhom(py: Python<'_>, series_list: Vec<PyRef<'_, QSeries>>, degree: i64, topshift: i64) -> PyResult<PyObject>`
  Rust sig: `findnonhom(series: &[&FPS], degree: i64, topshift: i64) -> Vec<Vec<QRat>>`
  - Returns list of relation vectors (list[list[Fraction]])

- `fn findhomcombo(py: Python<'_>, target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findhomcombo(f: &FPS, basis: &[&FPS], degree: i64, topshift: i64) -> Option<Vec<QRat>>`
  - Returns None or Some(list[Fraction])

- `fn findnonhomcombo(py: Python<'_>, target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, degree: i64, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findnonhomcombo(f: &FPS, basis: &[&FPS], degree: i64, topshift: i64) -> Option<Vec<QRat>>`
  - Returns None or Some(list[Fraction])

GROUP 7 -- Relation Discovery (modular and structural):

- `fn findlincombomodp(py: Python<'_>, target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, p: i64, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findlincombomodp(f: &FPS, basis: &[&FPS], p: i64, topshift: i64) -> Option<Vec<i64>>`
  - Returns None or Some(list[int]) -- coefficients are i64 mod p, not Fraction

- `fn findhommodp(py: Python<'_>, series_list: Vec<PyRef<'_, QSeries>>, p: i64, degree: i64, topshift: i64) -> PyResult<PyObject>`
  Rust sig: `findhommodp(series: &[&FPS], p: i64, degree: i64, topshift: i64) -> Vec<Vec<i64>>`
  - Returns list[list[int]] -- coefficients are i64 mod p

- `fn findhomcombomodp(py: Python<'_>, target: &QSeries, candidates: Vec<PyRef<'_, QSeries>>, p: i64, degree: i64, topshift: i64) -> PyResult<Option<PyObject>>`
  Rust sig: `findhomcombomodp(f: &FPS, basis: &[&FPS], p: i64, degree: i64, topshift: i64) -> Option<Vec<i64>>`
  - Returns None or Some(list[int]) -- coefficients mod p

- `fn findmaxind(series_list: Vec<PyRef<'_, QSeries>>, topshift: i64) -> Vec<usize>`
  Rust sig: `findmaxind(series: &[&FPS], topshift: i64) -> Vec<usize>`
  - Returns list[int] of indices

- `fn findprod(py: Python<'_>, series_list: Vec<PyRef<'_, QSeries>>, max_coeff: i64, max_exp: i64) -> PyResult<PyObject>`
  Rust sig: `findprod(series: &[&FPS], max_coeff: i64, max_exp: i64) -> Vec<Vec<i64>>`
  - NOTE: findprod does NOT take topshift. It takes max_coeff and max_exp.
  - Returns list[list[int]] -- coefficient vectors for combinations with nice product forms

Register all Group 6-7 functions in lib.rs.

Update `crates/qsym-python/python/qsymbolic/__init__.py`:
   - Import ALL DSL functions: `from ._qsymbolic import aqprod, qbin, etaq, jacprod, tripleprod, quinprod, winquist, theta2, theta3, theta4, partition_count, partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf, rank_gf, crank_gf, qfactor, sift, qdegree, lqdegree, prodmake, etamake, jacprodmake, mprodmake, qetamake, findlincombo, findhom, findpoly, findcong, findnonhom, findhomcombo, findnonhomcombo, findlincombomodp, findhommodp, findhomcombomodp, findmaxind, findprod`
   - Import QSeries: `from ._qsymbolic import QSeries`
   - Update __all__ to include all exports.
  </action>
  <verify>
`cargo check -p qsym-python` passes with all DSL functions registered. If Python available:
```python
from qsymbolic import QSession, theta3, partition_gf, findlincombo, findcong, findprod
s = QSession()
t3 = theta3(s, 20)
print(t3)
print(t3[0], t3[1])  # coefficients
pgf = partition_gf(s, 20)
print(pgf[5])  # p(5) = 7
# Test findcong (no topshift)
congs = findcong(pgf, [5])
print(congs)  # Should find Ramanujan's p(5n+4) = 0 mod 5
# Test findlincombo (with topshift)
result = findlincombo(t3, [t3], 5)
print(result)
```
  </verify>
  <done>
All 30+ Phase 3-4 functions are callable from Python via DSL functions. Relation discovery functions correctly expose topshift parameter. findpoly takes (x, y, deg_x, deg_y, topshift). findprod takes (series_list, max_coeff, max_exp). All modular variants return i64 lists (not Fraction). Python __init__.py exports everything.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p qsym-python` passes with series.rs and dsl.rs
- All qseries module public functions have Python DSL wrappers
- QSeries supports __getitem__, __repr__, __len__, arithmetic
- DSL functions use get_or_create_symbol_id("q") to get SymbolId (NOT intern_symbol which returns ExprRef)
- All relation discovery functions expose topshift parameter where the Rust API requires it
- findpoly takes (x, y, deg_x, deg_y, topshift) matching Rust sig
- findprod takes (series_list, max_coeff, max_exp) matching Rust sig
- Complex Rust return types converted to Python dicts/lists
- Python __init__.py exports all functions
</verification>

<success_criteria>
All Phase 3-4 Rust functions are accessible from Python. QSeries wraps FormalPowerSeries with Pythonic coefficient access. Researchers can call qpoch, theta functions, partition functions, prodmake, and relation discovery functions from Python. Function signatures exactly match audited Rust signatures.
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-api/05-03-SUMMARY.md`
</output>
