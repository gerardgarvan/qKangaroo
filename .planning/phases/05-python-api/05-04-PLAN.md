---
phase: 05-python-api
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - crates/qsym-python/src/session.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/python/qsymbolic/__init__.py
  - crates/qsym-python/tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "Batch generation can scan q-Pochhammer products over a parameter grid and return results"
    - "Batch results are returned as Python list of (params, QSeries) tuples"
    - "A Garvan tutorial example (finding a q-series identity) can be replicated end-to-end in Python"
    - "The tutorial script runs without error and produces the expected identity"
    - "batch_generate explicitly supports only generator-type functions"
  artifacts:
    - path: "crates/qsym-python/tests/test_integration.py"
      provides: "End-to-end integration test replicating Garvan tutorial"
      contains: "def test_garvan"
    - path: "crates/qsym-python/src/session.rs"
      provides: "batch_generate method on QSession"
      contains: "batch_generate"
  key_links:
    - from: "crates/qsym-python/src/session.rs"
      to: "qsym_core::qseries"
      via: "batch_generate delegates to Rust functions"
      pattern: "qsym_core::qseries::"
    - from: "crates/qsym-python/tests/test_integration.py"
      to: "qsymbolic"
      via: "import and use all major API features"
      pattern: "from qsymbolic import"
---

<objective>
Implement batch generation mode for systematic parameter searches and create an end-to-end integration test replicating a Garvan tutorial example.

Purpose: Batch generation (PYTH-05) lets researchers scan parameter grids systematically -- a key use case for discovering q-series identities. The Garvan tutorial replication (Success Criterion 5) proves the full API works for real research workflows.

Output: QSession.batch_generate() method for parameter grid scanning (generator functions only). Integration test demonstrating a complete q-series identity discovery workflow.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-api/05-RESEARCH.md
@.planning/phases/05-python-api/05-03-SUMMARY.md
@crates/qsym-python/src/session.rs
@crates/qsym-python/src/series.rs
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/python/qsymbolic/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement batch_generate on QSession</name>
  <files>
    crates/qsym-python/src/session.rs
    crates/qsym-python/src/lib.rs
    crates/qsym-python/python/qsymbolic/__init__.py
  </files>
  <action>
1. Add `batch_generate` method to QSession in `session.rs`:

```rust
/// Batch parameter search: generate q-series over a parameter grid.
///
/// IMPORTANT: This method supports only GENERATOR-type functions that produce
/// FormalPowerSeries from parameters. It does NOT support:
///   - Analysis functions (prodmake, etamake, qfactor) -- these take a QSeries input
///   - Relation discovery functions (findlincombo, findhom, etc.) -- these take multiple series
///   - Use the individual DSL functions directly for analysis and relation discovery.
///
/// Supported func_name values:
///   - "aqprod": params = [coeff_num, coeff_den, power, n_or_sentinel]
///     where n=-1 means PochhammerOrder::Infinite, else Finite(n)
///   - "etaq": params = [b, t]
///   - "jacprod": params = [a, b]
///   - "tripleprod": params = [coeff_num, coeff_den, power]
///   - "quinprod": params = [coeff_num, coeff_den, power]
///   - "theta2" / "theta3" / "theta4": params = [] (no params beyond truncation)
///   - "partition_gf": params = []
///   - "distinct_parts_gf": params = []
///   - "odd_parts_gf": params = []
///   - "bounded_parts_gf": params = [max_parts]
///   - "rank_gf": params = [z_num, z_den]
///   - "crank_gf": params = [z_num, z_den]
///   - "qbin": params = [n, k]
///
/// truncation_order: series precision for all generated series
///
/// Returns: list of (params, QSeries) tuples
fn batch_generate(
    &self,
    func_name: &str,
    param_grid: Vec<Vec<i64>>,
    truncation_order: i64,
) -> PyResult<Vec<(Vec<i64>, QSeries)>>
```

Implementation:
- Lock the session ONCE for the entire batch (not per iteration).
- Get sym_q via session_inner.get_or_create_symbol_id("q").
- Iterate over param_grid, dispatching to the appropriate qsym_core function:
  - "aqprod": QMonomial::new(QRat::from((params[0], params[1])), params[2]), PochhammerOrder from params[3] (-1 = Infinite, else Finite)
  - "etaq": etaq(params[0], params[1], sym_q, truncation_order)
  - "jacprod": jacprod(params[0], params[1], sym_q, truncation_order)
  - "tripleprod": QMonomial from params, tripleprod(&monomial, sym_q, truncation_order)
  - "quinprod": QMonomial from params, quinprod(&monomial, sym_q, truncation_order)
  - "theta2/3/4": no params, just compute with sym_q
  - "partition_gf": no params
  - "distinct_parts_gf": no params
  - "odd_parts_gf": no params
  - "bounded_parts_gf": bounded_parts_gf(params[0], sym_q, truncation_order)
  - "rank_gf": QRat from params, rank_gf(&z, sym_q, truncation_order)
  - "crank_gf": QRat from params, crank_gf(&z, sym_q, truncation_order)
  - "qbin": qbin(params[0], params[1], sym_q, truncation_order)
  - Unknown func_name: return PyValueError
- Collect results as Vec<(Vec<i64>, QSeries)>.
- Return outside the lock.

NOTE: Do NOT release the GIL (do NOT use py.detach()) for now. GMP thread safety with GIL released is an open question (Research Open Question 4). Keep it simple -- hold the GIL, lock the Mutex. If performance becomes an issue later, GIL release can be added.

2. Also add a convenience `generate` method on QSession for single computations:
```rust
/// Generate a single q-series.
/// Same func_name and params as batch_generate, but single params list.
fn generate(
    &self,
    func_name: &str,
    params: Vec<i64>,
    truncation_order: i64,
) -> PyResult<QSeries>
```

3. Update `__init__.py` to document the batch API. No new imports needed since batch_generate is a method on QSession. Add a comment or docstring noting:
```python
# batch_generate supports generator functions only:
# aqprod, etaq, jacprod, tripleprod, quinprod, theta2/3/4,
# partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf,
# rank_gf, crank_gf, qbin
# For analysis (prodmake, qfactor) and relation discovery (findlincombo, etc.),
# use the individual DSL functions directly.
```
  </action>
  <verify>
`cargo check -p qsym-python` passes. If Python available:
```python
from qsymbolic import QSession
s = QSession()
# Scan etaq over different b values
results = s.batch_generate("etaq", [[b, 1] for b in range(1, 6)], 20)
for params, series in results:
    print(f"etaq(b={params[0]}, t={params[1]}): {series}")
```
  </verify>
  <done>
batch_generate method dispatches to all generator q-series functions over parameter grids. Returns list of (params, QSeries) for systematic analysis. Single generate convenience method also available. Method explicitly documents that it supports generator functions only, not analysis or relation discovery.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test replicating Garvan tutorial example</name>
  <files>
    crates/qsym-python/tests/test_integration.py
  </files>
  <action>
1. Create `crates/qsym-python/tests/test_integration.py` -- a Python test script (runnable with `python tests/test_integration.py` or `pytest tests/test_integration.py` if pytest available).

The test replicates a classic Garvan workflow: discovering a q-series identity. Specifically, demonstrate that the Euler identity (partition function = inverse Euler product) can be found and verified:

```python
"""
Integration test: replicate a Garvan-style q-series identity discovery.

This test demonstrates the full Q-Symbolic Python API by:
1. Computing series from named products and partition functions
2. Using relation discovery to find identities
3. Verifying identities by series comparison
"""
from fractions import Fraction

def test_euler_identity():
    """
    Verify Euler's identity: product_{n=1}^{inf} 1/(1-q^n) = sum_{n=0}^{inf} p(n) q^n

    The partition generating function IS the inverse Euler product.
    We verify by computing both sides independently and checking coefficient agreement.
    """
    from qsymbolic import QSession, partition_gf, aqprod

    s = QSession()
    order = 50

    # Left side: partition generating function (via pentagonal recurrence)
    pgf = partition_gf(s, order)

    # Right side: (q;q)_inf inverted = 1 / prod_{n=1}^inf (1-q^n)
    # aqprod with a=q (coeff=1, power=1), n=None (infinite) gives (q;q)_inf
    qq_inf = aqprod(s, 1, 1, 1, None, order)  # (q;q)_inf
    euler_inv = qq_inf.invert()  # 1/(q;q)_inf

    # Verify: coefficients must match for all powers 0..49
    for k in range(order):
        assert pgf[k] == euler_inv[k], f"Mismatch at q^{k}: pgf={pgf[k]}, euler_inv={euler_inv[k]}"

    print(f"Euler identity verified to O(q^{order})")

def test_jacobi_triple_product():
    """
    Verify a case of the Jacobi triple product identity using series comparison.

    theta3(q) = (q^2;q^2)_inf * (-q;q^2)_inf * (-q;q^2)_inf
    = sum_{n=-inf}^{inf} q^{n^2}
    """
    from qsymbolic import QSession, theta3

    s = QSession()
    order = 30

    t3 = theta3(s, order)

    # theta3 coefficients: coeff of q^k is 2 if k is a nonzero perfect square,
    # 1 if k=0, 0 otherwise. (Since sum is over n from -inf to inf, both +n and -n contribute.)
    import math
    for k in range(order):
        expected = Fraction(0)
        if k == 0:
            expected = Fraction(1)
        else:
            sqrt_k = int(math.isqrt(k))
            if sqrt_k * sqrt_k == k:
                expected = Fraction(2)  # both +sqrt_k and -sqrt_k contribute
        assert t3[k] == expected, f"theta3 mismatch at q^{k}: got {t3[k]}, expected {expected}"

    print(f"Jacobi triple product (theta3) verified to O(q^{order})")

def test_findlincombo_identity():
    """
    Use findlincombo to discover a linear relation between q-series.

    We know: partition_gf(q) = 1/(q;q)_inf
    So: (q;q)_inf * partition_gf(q) = 1

    Build the product series, then use findlincombo to express it as a
    linear combination of [1] (the constant series).
    """
    from qsymbolic import QSession, partition_gf, aqprod, findlincombo

    s = QSession()
    order = 30

    pgf = partition_gf(s, order)
    qq_inf = aqprod(s, 1, 1, 1, None, order)

    # product = (q;q)_inf * pgf should be identically 1 + O(q^30)
    product = qq_inf * pgf

    # Check it's 1
    assert product[0] == Fraction(1), f"product[0] = {product[0]}, expected 1"
    for k in range(1, order):
        assert product[k] == Fraction(0), f"product[{k}] = {product[k]}, expected 0"

    print(f"(q;q)_inf * partition_gf = 1 verified to O(q^{order})")

def test_prodmake_roundtrip():
    """
    Test prodmake: compute a product, expand to series, recover the product form.

    Start with etaq(1, 1, q, N) = (q;q)_inf = prod_{n=1}^{inf} (1-q^n)
    Expand to series, then use prodmake to recover the factors.
    """
    from qsymbolic import QSession, etaq, prodmake

    s = QSession()
    order = 30

    # etaq(1, 1) gives (q;q)_inf = prod_{n=1}^{inf} (1 - q^n)
    euler = etaq(s, 1, 1, order)

    # Recover product form
    pf = prodmake(euler, 15)

    # Andrews' algorithm returns exponents as QRat -> Python Fraction.
    # For (q;q)_inf = prod (1-q^n)^{-a_n}, a_n should be -1 for all n.
    # prodmake convention: exponents map n -> a_n where prod is (1-q^n)^{-a_n}.
    # For (q;q)_inf = prod (1-q^n)^1, that means (1-q^n)^{-a_n} = (1-q^n)^1 => a_n = -1.
    print(f"prodmake result: {pf}")

    # Check that the exponents include a_n = -1 for small n
    factors = pf["factors"]
    for n in range(1, 10):
        assert n in factors, f"Missing exponent for n={n} in prodmake result"
        # Exponents are Fraction (QRat), compare with Fraction(-1)
        assert factors[n] == Fraction(-1), f"Exponent for n={n} is {factors[n]}, expected Fraction(-1)"

    print("prodmake roundtrip verified")

def test_batch_parameter_scan():
    """
    Test batch generation: scan etaq over a parameter grid.
    """
    from qsymbolic import QSession

    s = QSession()

    # Scan etaq(b, 1) for b = 1..5
    results = s.batch_generate("etaq", [[b, 1] for b in range(1, 6)], 20)

    assert len(results) == 5, f"Expected 5 results, got {len(results)}"

    for params, series in results:
        assert not series.is_zero(), f"etaq(b={params[0]}, t={params[1]}) should not be zero"
        assert series[0] == Fraction(1), f"etaq constant term should be 1"

    print("Batch parameter scan verified")

def test_symbols_and_expressions():
    """
    Test the symbolic expression API: create, combine, render.
    """
    from qsymbolic import QSession

    s = QSession()
    q_a_n = s.symbols("q a n")
    q, a, n = q_a_n[0], q_a_n[1], q_a_n[2]

    # Build expression: q^2 + a
    q2 = q ** s.integer(2)
    expr = q2 + a

    # Check rendering
    repr_str = repr(expr)
    assert len(repr_str) > 0, "repr should not be empty"

    latex_str = expr._repr_latex_()
    assert latex_str.startswith("$"), "LaTeX should start with $"
    assert latex_str.endswith("$"), "LaTeX should end with $"

    # Check structural equality
    q2_again = q ** s.integer(2)
    assert q2 == q2_again, "Same expression should have same ExprRef"

    # Check stats
    num_exprs, num_syms = s.stats()
    assert num_syms >= 3, f"Should have at least 3 symbols, got {num_syms}"

    print(f"Expression API verified: {repr_str}")
    print(f"LaTeX: {latex_str}")
    print(f"Stats: {num_exprs} expressions, {num_syms} symbols")

if __name__ == "__main__":
    test_euler_identity()
    test_jacobi_triple_product()
    test_findlincombo_identity()
    test_prodmake_roundtrip()
    test_batch_parameter_scan()
    test_symbols_and_expressions()
    print("\n=== ALL INTEGRATION TESTS PASSED ===")
```

2. IMPORTANT adaptation notes:
   - The exact Python API signatures may differ from what's written above depending on how Plans 02 and 03 implemented things. Read the actual `__init__.py` and `dsl.rs` before writing the test to match the real API.
   - The `s.symbols("q a n")` returns a Vec<QExpr> (list). Index with [0], [1], [2].
   - The `aqprod` parameter for infinite order is `None` per Plan 03.
   - The `prodmake` return type is a dict with "factors" key mapping n -> Fraction (QRat exponents). Use `Fraction(-1)` NOT `1` for comparisons.
   - The `batch_generate` method (not `batch_compute`) is the correct name per Plan 04 Task 1.
   - Adjust all test code to match the ACTUAL API as implemented, not the planned API.

3. If Python is not available: create the test file anyway as documentation of the expected API. It will be runnable once Python is installed.

4. If Python IS available: Run the test with `python crates/qsym-python/tests/test_integration.py`. All tests should pass.
  </action>
  <verify>
If Python available: `python crates/qsym-python/tests/test_integration.py` prints "ALL INTEGRATION TESTS PASSED".
If Python not available: the test file exists and is syntactically valid Python. `cargo check -p qsym-python` still passes.
  </verify>
  <done>
Integration test replicates Garvan-style workflow end-to-end: Euler identity verification, Jacobi triple product, prodmake roundtrip (with Fraction comparisons for QRat exponents), findlincombo relation discovery, batch parameter scanning (using batch_generate), and symbolic expression manipulation. All tests pass (or are ready to run once Python is available).
  </done>
</task>

</tasks>

<verification>
- batch_generate dispatches to generator q-series functions over parameter grids
- batch_generate does NOT support analysis or relation discovery functions (documented)
- Integration test covers all 5 success criteria:
  1. Natural DSL syntax (test_symbols_and_expressions, all function calls)
  2. GC safety (from Plan 02 stress test)
  3. LaTeX/Unicode rendering (test_symbols_and_expressions)
  4. Batch generation (test_batch_parameter_scan)
  5. Garvan tutorial (test_euler_identity, test_prodmake_roundtrip, test_findlincombo_identity)
- prodmake test uses Fraction(-1) for exponent comparisons (not int 1)
- All tests pass or are documented for later execution
</verification>

<success_criteria>
Batch generation works for parameter grid scanning of generator functions. A Garvan-style tutorial (identity discovery workflow) runs end-to-end. All Phase 5 success criteria are demonstrated in the integration test. Test assertions correctly use Fraction for QRat values.
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-api/05-04-SUMMARY.md`
</output>
