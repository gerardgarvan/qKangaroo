---
phase: 05-python-api
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - crates/qsym-python/src/session.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/python/qsymbolic/__init__.py
  - crates/qsym-python/tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "Batch computation can scan q-Pochhammer products over a parameter grid and return results"
    - "Batch results are returned as Python list of (params, QSeries) tuples"
    - "A Garvan tutorial example (finding a q-series identity) can be replicated end-to-end in Python"
    - "The tutorial script runs without error and produces the expected identity"
  artifacts:
    - path: "crates/qsym-python/tests/test_integration.py"
      provides: "End-to-end integration test replicating Garvan tutorial"
      contains: "def test_garvan"
    - path: "crates/qsym-python/src/session.rs"
      provides: "batch_compute method on QSession"
      contains: "batch_compute"
  key_links:
    - from: "crates/qsym-python/src/session.rs"
      to: "qsym_core::qseries"
      via: "batch_compute delegates to Rust functions"
      pattern: "qsym_core::qseries::"
    - from: "crates/qsym-python/tests/test_integration.py"
      to: "qsymbolic"
      via: "import and use all major API features"
      pattern: "from qsymbolic import"
---

<objective>
Implement batch computation mode for systematic parameter searches and create an end-to-end integration test replicating a Garvan tutorial example.

Purpose: Batch computation (PYTH-05) lets researchers scan parameter grids systematically -- a key use case for discovering q-series identities. The Garvan tutorial replication (Success Criterion 5) proves the full API works for real research workflows.

Output: QSession.batch_compute() method for parameter grid scanning. Integration test demonstrating a complete q-series identity discovery workflow.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-api/05-RESEARCH.md
@.planning/phases/05-python-api/05-03-SUMMARY.md
@crates/qsym-python/src/session.rs
@crates/qsym-python/src/series.rs
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/python/qsymbolic/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement batch_compute on QSession</name>
  <files>
    crates/qsym-python/src/session.rs
    crates/qsym-python/src/lib.rs
    crates/qsym-python/python/qsymbolic/__init__.py
  </files>
  <action>
1. Add `batch_compute` method to QSession in `session.rs`:

```rust
/// Batch parameter search: compute a q-series function over a parameter grid.
///
/// func_name: one of "aqprod", "etaq", "jacprod", "theta3", "theta4", "theta2",
///            "partition_gf", "distinct_parts_gf", "odd_parts_gf"
/// param_grid: list of parameter lists. Each inner list is the numeric args for the function
///   - "aqprod": [coeff_num, coeff_den, power, n_or_sentinel] where n=-1 means infinite
///   - "etaq": [b, t]
///   - "jacprod": [a, b]
///   - "theta3"/"theta4"/"theta2": [] (no params beyond truncation)
///   - "partition_gf"/"distinct_parts_gf"/"odd_parts_gf": [] (no params beyond truncation)
/// truncation_order: series precision
///
/// Returns: list of (params, QSeries) tuples
fn batch_compute(
    &self,
    func_name: &str,
    param_grid: Vec<Vec<i64>>,
    truncation_order: i64,
) -> PyResult<Vec<(Vec<i64>, QSeries)>>
```

Implementation:
- Lock the session ONCE for the entire batch (not per iteration).
- Intern "q" to get the SymbolId.
- Iterate over param_grid, dispatching to the appropriate qsym_core function:
  - "aqprod": QMonomial::new(QRat::from_ints(params[0], params[1]), params[2]), PochhammerOrder from params[3] (-1 = Infinite, else Finite)
  - "etaq": etaq(params[0], params[1], sym_q, truncation_order)
  - "jacprod": jacprod(params[0], params[1], sym_q, truncation_order)
  - "theta2/3/4": no params, just compute
  - "partition_gf": no params
  - "distinct_parts_gf": no params
  - "odd_parts_gf": no params
  - Unknown func_name: return PyValueError
- Collect results as Vec<(Vec<i64>, QSeries)>.
- Return outside the lock.

NOTE: Do NOT release the GIL (do NOT use py.detach()) for now. GMP thread safety with GIL released is an open question (Research Open Question 4). Keep it simple -- hold the GIL, lock the Mutex. If performance becomes an issue later, GIL release can be added.

2. Also add a convenience `compute` method on QSession for single computations:
```rust
/// Compute a single q-series function.
/// Same func_name and params as batch_compute, but single params list.
fn compute(
    &self,
    func_name: &str,
    params: Vec<i64>,
    truncation_order: i64,
) -> PyResult<QSeries>
```

3. Update `__init__.py` to document the batch API. No new imports needed since batch_compute is a method on QSession.
  </action>
  <verify>
`cargo check -p qsym-python` passes. If Python available:
```python
from qsymbolic import QSession
s = QSession()
# Scan etaq over different b values
results = s.batch_compute("etaq", [[b, 1] for b in range(1, 6)], 20)
for params, series in results:
    print(f"etaq(b={params[0]}, t={params[1]}): {series}")
```
  </verify>
  <done>
batch_compute method dispatches to all major q-series functions over parameter grids. Returns list of (params, QSeries) for systematic analysis. Single compute convenience method also available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test replicating Garvan tutorial example</name>
  <files>
    crates/qsym-python/tests/test_integration.py
  </files>
  <action>
1. Create `crates/qsym-python/tests/test_integration.py` -- a Python test script (runnable with `python tests/test_integration.py` or `pytest tests/test_integration.py` if pytest available).

The test replicates a classic Garvan workflow: discovering a q-series identity. Specifically, demonstrate that the Euler identity (partition function = inverse Euler product) can be found and verified:

```python
"""
Integration test: replicate a Garvan-style q-series identity discovery.

This test demonstrates the full Q-Symbolic Python API by:
1. Computing series from named products and partition functions
2. Using relation discovery to find identities
3. Verifying identities by series comparison
"""
from fractions import Fraction

def test_euler_identity():
    """
    Verify Euler's identity: product_{n=1}^{inf} 1/(1-q^n) = sum_{n=0}^{inf} p(n) q^n

    The partition generating function IS the inverse Euler product.
    We verify by computing both sides independently and checking coefficient agreement.
    """
    from qsymbolic import QSession, partition_gf, aqprod

    s = QSession()
    order = 50

    # Left side: partition generating function (via pentagonal recurrence)
    pgf = partition_gf(s, order)

    # Right side: (q;q)_inf inverted = 1 / prod_{n=1}^inf (1-q^n)
    # aqprod with a=q (coeff=1, power=1), n=None (infinite) gives (q;q)_inf
    qq_inf = aqprod(s, 1, 1, 1, None, order)  # (q;q)_inf
    euler_inv = qq_inf.invert()  # 1/(q;q)_inf

    # Verify: coefficients must match for all powers 0..49
    for k in range(order):
        assert pgf[k] == euler_inv[k], f"Mismatch at q^{k}: pgf={pgf[k]}, euler_inv={euler_inv[k]}"

    print("Euler identity verified to O(q^{order})")

def test_jacobi_triple_product():
    """
    Verify a case of the Jacobi triple product identity using series comparison.

    theta3(q) = (q^2;q^2)_inf * (-q;q^2)_inf * (-q;q^2)_inf
    = sum_{n=-inf}^{inf} q^{n^2}
    """
    from qsymbolic import QSession, theta3

    s = QSession()
    order = 30

    t3 = theta3(s, order)

    # theta3 coefficients: coeff of q^k is 2 if k is a nonzero perfect square,
    # 1 if k=0, 0 otherwise. (Since sum is over n from -inf to inf, both +n and -n contribute.)
    import math
    for k in range(order):
        expected = Fraction(0)
        if k == 0:
            expected = Fraction(1)
        else:
            sqrt_k = int(math.isqrt(k))
            if sqrt_k * sqrt_k == k:
                expected = Fraction(2)  # both +sqrt_k and -sqrt_k contribute
        assert t3[k] == expected, f"theta3 mismatch at q^{k}: got {t3[k]}, expected {expected}"

    print(f"Jacobi triple product (theta3) verified to O(q^{order})")

def test_findlincombo_identity():
    """
    Use findlincombo to discover a linear relation between q-series.

    We know: partition_gf(q) = 1/(q;q)_inf
    So: (q;q)_inf * partition_gf(q) = 1

    Build the product series, then use findlincombo to express it as a
    linear combination of [1] (the constant series).
    """
    from qsymbolic import QSession, partition_gf, aqprod, findlincombo

    s = QSession()
    order = 30

    pgf = partition_gf(s, order)
    qq_inf = aqprod(s, 1, 1, 1, None, order)

    # product = (q;q)_inf * pgf should be identically 1 + O(q^30)
    product = qq_inf * pgf

    # Check it's 1
    assert product[0] == Fraction(1), f"product[0] = {product[0]}, expected 1"
    for k in range(1, order):
        assert product[k] == Fraction(0), f"product[{k}] = {product[k]}, expected 0"

    print(f"(q;q)_inf * partition_gf = 1 verified to O(q^{order})")

def test_prodmake_roundtrip():
    """
    Test prodmake: compute a product, expand to series, recover the product form.

    Start with etaq(1, 1, q, N) = (q;q)_inf = prod_{n=1}^{inf} (1-q^n)
    Expand to series, then use prodmake to recover the factors.
    """
    from qsymbolic import QSession, etaq, prodmake

    s = QSession()
    order = 30

    # etaq(1, 1) gives (q;q)_inf = prod_{n=1}^{inf} (1 - q^n)
    euler = etaq(s, 1, 1, order)

    # Recover product form
    pf = prodmake(euler, 15)

    # Andrews' algorithm should find factors (1-q^n)^1 for n=1..15
    print(f"prodmake result: {pf}")

    # Check that the factors include (1-q^n)^1 for small n
    factors = pf["factors"]
    for n in range(1, 10):
        assert n in factors, f"Missing factor (1-q^{n}) in prodmake result"
        assert factors[n] == 1, f"Factor (1-q^{n}) has exponent {factors[n]}, expected 1"

    print("prodmake roundtrip verified")

def test_batch_parameter_scan():
    """
    Test batch computation: scan etaq over a parameter grid.
    """
    from qsymbolic import QSession

    s = QSession()

    # Scan etaq(b, 1) for b = 1..5
    results = s.batch_compute("etaq", [[b, 1] for b in range(1, 6)], 20)

    assert len(results) == 5, f"Expected 5 results, got {len(results)}"

    for params, series in results:
        assert not series.is_zero(), f"etaq(b={params[0]}, t={params[1]}) should not be zero"
        assert series[0] == Fraction(1), f"etaq constant term should be 1"

    print("Batch parameter scan verified")

def test_symbols_and_expressions():
    """
    Test the symbolic expression API: create, combine, render.
    """
    from qsymbolic import QSession, symbols

    s = QSession()
    q, a, n = s.symbols("q a n").values() if hasattr(s.symbols("q a n"), 'values') else s.symbols("q a n")

    # Build expression: q^2 + a
    q2 = q ** s.integer(2)
    expr = q2 + a

    # Check rendering
    repr_str = repr(expr)
    assert len(repr_str) > 0, "repr should not be empty"

    latex_str = expr._repr_latex_()
    assert latex_str.startswith("$"), "LaTeX should start with $"
    assert latex_str.endswith("$"), "LaTeX should end with $"

    # Check structural equality
    q2_again = q ** s.integer(2)
    assert q2 == q2_again, "Same expression should have same ExprRef"

    # Check stats
    num_exprs, num_syms = s.stats()
    assert num_syms >= 3, f"Should have at least 3 symbols, got {num_syms}"

    print(f"Expression API verified: {repr_str}")
    print(f"LaTeX: {latex_str}")
    print(f"Stats: {num_exprs} expressions, {num_syms} symbols")

if __name__ == "__main__":
    test_euler_identity()
    test_jacobi_triple_product()
    test_findlincombo_identity()
    test_prodmake_roundtrip()
    test_batch_parameter_scan()
    test_symbols_and_expressions()
    print("\n=== ALL INTEGRATION TESTS PASSED ===")
```

2. IMPORTANT adaptation notes:
   - The exact Python API signatures may differ from what's written above depending on how Plan 02 and 03 implemented things. Read the actual `__init__.py` and `dsl.rs` before writing the test to match the real API.
   - The `s.symbols("q a n")` return type may be a list (not tuple). Adjust unpacking accordingly.
   - The `aqprod` parameter for infinite order (None vs sentinel) depends on Plan 03's implementation.
   - The `prodmake` return type (dict structure) depends on Plan 03's implementation.
   - Adjust all test code to match the ACTUAL API as implemented, not the planned API.

3. If Python is not available: create the test file anyway as documentation of the expected API. It will be runnable once Python is installed.

4. If Python IS available: Run the test with `python crates/qsym-python/tests/test_integration.py`. All tests should pass.
  </action>
  <verify>
If Python available: `python crates/qsym-python/tests/test_integration.py` prints "ALL INTEGRATION TESTS PASSED".
If Python not available: the test file exists and is syntactically valid Python. `cargo check -p qsym-python` still passes.
  </verify>
  <done>
Integration test replicates Garvan-style workflow end-to-end: Euler identity verification, Jacobi triple product, prodmake roundtrip, findlincombo relation discovery, batch parameter scanning, and symbolic expression manipulation. All tests pass (or are ready to run once Python is available).
  </done>
</task>

</tasks>

<verification>
- batch_compute dispatches to multiple q-series functions over parameter grids
- Integration test covers all 5 success criteria:
  1. Natural DSL syntax (test_symbols_and_expressions, all function calls)
  2. GC safety (from Plan 02 stress test)
  3. LaTeX/Unicode rendering (test_symbols_and_expressions)
  4. Batch computation (test_batch_parameter_scan)
  5. Garvan tutorial (test_euler_identity, test_prodmake_roundtrip, test_findlincombo_identity)
- All tests pass or are documented for later execution
</verification>

<success_criteria>
Batch computation works for parameter grid scanning. A Garvan-style tutorial (identity discovery workflow) runs end-to-end. All Phase 5 success criteria are demonstrated in the integration test.
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-api/05-04-SUMMARY.md`
</output>
