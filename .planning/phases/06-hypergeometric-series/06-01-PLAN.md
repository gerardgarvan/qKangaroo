---
phase: 06-hypergeometric-series
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/src/qseries/hypergeometric.rs
  - crates/qsym-core/tests/qseries_hypergeometric_tests.rs
autonomous: true

must_haves:
  truths:
    - "_r phi_s series can be constructed with arbitrary QMonomial parameters and evaluated term-by-term to any truncation order"
    - "_r psi_s bilateral series can be constructed and evaluated with positive and negative index summation"
    - "QMonomial supports mul, div, is_q_neg_power, and try_sqrt arithmetic operations"
    - "eval_phi produces FPS matching hand-computed results for 1phi0, 2phi1, 3phi2 test cases"
    - "eval_psi produces FPS matching Ramanujan's 1psi1 closed form"
  artifacts:
    - path: "crates/qsym-core/src/qseries/hypergeometric.rs"
      provides: "HypergeometricSeries struct, BilateralHypergeometricSeries struct, eval_phi, eval_psi, SummationResult, TransformationResult"
      exports: ["HypergeometricSeries", "BilateralHypergeometricSeries", "eval_phi", "eval_psi", "SummationResult", "TransformationResult"]
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "QMonomial arithmetic methods (mul, div, is_q_neg_power, try_sqrt), hypergeometric module declaration and re-exports"
      contains: "pub mod hypergeometric"
    - path: "crates/qsym-core/tests/qseries_hypergeometric_tests.rs"
      provides: "Integration tests for eval_phi and eval_psi"
      min_lines: 80
  key_links:
    - from: "crates/qsym-core/src/qseries/hypergeometric.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "aqprod calls for closed-form verification"
      pattern: "aqprod"
    - from: "crates/qsym-core/src/qseries/hypergeometric.rs"
      to: "crates/qsym-core/src/series/arithmetic.rs"
      via: "FPS add, mul, invert for term accumulation"
      pattern: "arithmetic::(add|mul|invert)"
---

<objective>
Implement the foundational hypergeometric series infrastructure: QMonomial arithmetic helpers, HypergeometricSeries and BilateralHypergeometricSeries structs, eval_phi for _r phi_s evaluation, and eval_psi for _r psi_s bilateral evaluation.

Purpose: This is the computational core that all summation formulas and transformations build on. Without working eval_phi/eval_psi, nothing else in Phase 6 can be verified.

Output: hypergeometric.rs module with structs + evaluation functions, QMonomial arithmetic methods, integration tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hypergeometric-series/06-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: QMonomial arithmetic helpers and hypergeometric structs</name>
  <files>
    crates/qsym-core/src/qseries/mod.rs
    crates/qsym-core/src/qseries/hypergeometric.rs
  </files>
  <action>
**Step 1: Add QMonomial arithmetic methods in `mod.rs`.**

Add these `impl QMonomial` methods (after the existing `constant` method):

```rust
/// Multiply two QMonomials: (c1*q^p1) * (c2*q^p2) = (c1*c2)*q^{p1+p2}
pub fn mul(&self, other: &QMonomial) -> QMonomial {
    QMonomial::new(self.coeff.clone() * other.coeff.clone(), self.power + other.power)
}

/// Divide: (c1*q^p1) / (c2*q^p2) = (c1/c2)*q^{p1-p2}
/// Panics if other.coeff is zero.
pub fn div(&self, other: &QMonomial) -> QMonomial {
    assert!(!other.coeff.is_zero(), "Cannot divide QMonomial by zero");
    QMonomial::new(self.coeff.clone() / other.coeff.clone(), self.power - other.power)
}

/// Check if this is q^{-n} for some n >= 0 (coeff=1, power <= 0).
/// Returns Some(n) where n = -power, or None.
pub fn is_q_neg_power(&self) -> Option<i64> {
    if self.coeff == QRat::one() && self.power <= 0 {
        Some(-self.power)
    } else {
        None
    }
}

/// Attempt to compute sqrt of this QMonomial.
/// Returns Some(sqrt(c)*q^{p/2}) if c is a perfect rational square and p is even.
/// Returns None otherwise.
pub fn try_sqrt(&self) -> Option<QMonomial> {
    if self.power % 2 != 0 {
        return None;
    }
    // Check if coeff is a perfect rational square: num and den both perfect squares
    let (num, den) = self.coeff.clone().into_numer_denom();
    let num_sqrt = num.clone().abs().sqrt();
    let den_sqrt = den.clone().sqrt();
    if &num_sqrt * &num_sqrt == num.clone().abs() && &den_sqrt * &den_sqrt == den {
        let sign = if num >= 0 { QRat::one() } else { return None; }; // negative coeff has no real sqrt
        let sqrt_coeff = QRat::from((num_sqrt, den_sqrt));
        Some(QMonomial::new(sqrt_coeff, self.power / 2))
    } else {
        None
    }
}

/// Negate: -(c*q^p) = (-c)*q^p
pub fn neg(&self) -> QMonomial {
    QMonomial::new(-self.coeff.clone(), self.power)
}

/// Check if this QMonomial represents zero (coeff is zero).
pub fn is_zero(&self) -> bool {
    self.coeff.is_zero()
}

/// QMonomial representing 1 (= 1*q^0).
pub fn one() -> QMonomial {
    QMonomial::q_power(0)
}

/// QMonomial representing q (= 1*q^1).
pub fn q() -> QMonomial {
    QMonomial::q_power(1)
}
```

Note: `into_numer_denom()` and `sqrt()` are rug methods on `Integer`/`Rational`. Check the actual rug API -- `rug::Rational` has `numer()` and `denom()` methods returning references. The `QRat` wrapper may need `.inner()` or direct access. Adapt to match the actual QRat API in `number.rs`. If QRat wraps `rug::Rational`, use `self.coeff.numer().clone()` and `self.coeff.denom().clone()`.

**Step 2: Add `pub mod hypergeometric;` to qseries/mod.rs** and re-export key types.

Add after the existing `pub mod utilities;` line:
```rust
pub mod hypergeometric;
```

Add to re-exports:
```rust
pub use hypergeometric::{HypergeometricSeries, BilateralHypergeometricSeries, eval_phi, eval_psi, SummationResult, TransformationResult};
```

**Step 3: Create `hypergeometric.rs` with structs, eval_phi, and eval_psi.**

The file should contain:

1. **HypergeometricSeries struct** with `upper: Vec<QMonomial>`, `lower: Vec<QMonomial>`, `argument: QMonomial` fields. Methods: `r()`, `s()`, `termination_order()` (scans upper params for q^{-n}).

2. **BilateralHypergeometricSeries struct** with `upper: Vec<QMonomial>`, `lower: Vec<QMonomial>`, `argument: QMonomial` fields. Methods: `r()`, `s()`.

3. **SummationResult enum**: `ClosedForm(FormalPowerSeries)` or `NotApplicable`.

4. **TransformationResult struct**: `prefactor: FormalPowerSeries`, `transformed: HypergeometricSeries`.

5. **`eval_phi` function**: Evaluates _r phi_s to O(q^T) using FPS-based term accumulation.

   Implementation approach (FPS multiplication per term ratio):
   - Start with term = FPS::one, result = FPS::zero
   - For n = 0, 1, 2, ... up to min(termination_order, truncation_order):
     - result = add(result, term)
     - Build the ratio FPS for step n:
       - For each upper param a_i: numerator factor = (1 - a_i.coeff * q^{a_i.power + n})
       - Denominator factor = (1 - q^{n+1}) for the (q;q) part
       - For each lower param b_j: denominator factor = (1 - b_j.coeff * q^{b_j.power + n})
       - Extra factor: [(-1)^n * q^{n(n-1)/2}]^{1+s-r} -- only when 1+s-r != 0
       - Argument factor: z.coeff * q^{z.power}
     - Multiply numerator factors together, multiply denominator factors together, invert denominator, multiply all together to get ratio
     - term = mul(term, ratio)
     - if term.is_zero(), break

   Helper function `one_minus_cq_m(coeff: &QRat, m: i64, variable: SymbolId, trunc: i64) -> FPS`:
   - Creates the 2-term FPS: 1 - coeff*q^m
   - If m == 0: single-term FPS with value (1 - coeff) at q^0
   - If m > 0 and m < trunc: two terms, 1 at q^0 and -coeff at q^m
   - If m >= trunc or m < 0: just 1 at q^0 (the q^m term is beyond truncation or below zero)

   IMPORTANT: The extra factor `[(-1)^n * q^{n(n-1)/2}]^{1+s-r}` at step n (going from term n to term n+1) contributes a sign `(-1)^{(1+s-r)}` and a q-power of `n * (1+s-r)` to the ratio. Handle this as a monomial FPS.

   PERFORMANCE NOTE: Each term step involves (r + s + 1) FPS multiplications and (s + 1) FPS inversions. For moderate truncation orders (T <= 100) and small r+s (typical: r+s <= 6), this is acceptable. The total is O(max_n * (r+s) * T) which for 2phi1 at T=50 is ~150 FPS ops = fast.

   OPTIMIZATION: Instead of inverting each denominator factor separately, accumulate all denominator factors via multiplication, then invert once. This reduces inversions from (s+1) per step to 1 per step.

6. **`eval_psi` function**: Evaluates _r psi_s bilateral series.

   Implementation approach:
   - Compute the positive part (n = 0, 1, 2, ...) similar to eval_phi but WITHOUT the (q;q)_n denominator and with extra factor exponent `s-r` instead of `1+s-r`
   - Compute the negative part (n = -1, -2, ..., -max_neg):
     - For negative n, use (a;q)_{-m} = (-q/a)^m * q^{m(m-1)/2} / (q/a;q)_m
     - The n=-m term (m>0) has factors involving (q/a_i;q)_m in denominator and (q/b_j;q)_m in numerator
     - Simpler approach: build each negative-n term via the explicit product formula, not ratio recurrence
     - Use aqprod to compute (a_i;q)_{-m} for each parameter, then multiply
   - max_neg: compute how many negative terms contribute below truncation_order. Since the argument z contributes z^n = z^{-m}, and z = c*q^p, the q-power contribution from z alone is -m*p. For this to be < truncation_order, we need roughly m < truncation_order / |p|. Cap at truncation_order for safety.
   - Sum positive and negative parts.

   IMPORTANT for psi: The formula is:
   ```
   _r psi_s = sum_{n=-inf}^{inf} [(a_1;q)_n * ... * (a_r;q)_n] / [(b_1;q)_n * ... * (b_s;q)_n]
              * [(-1)^n * q^{n(n-1)/2}]^{s-r} * z^n
   ```
   Note: NO (q;q)_n in denominator (unlike phi).

7. **`verify_transformation` function**: Takes original series + TransformationResult, evaluates both sides, compares FPS.

Include `use` imports: `crate::number::QRat`, `crate::series::{FormalPowerSeries, arithmetic}`, `crate::symbol::SymbolId`, `super::{QMonomial, PochhammerOrder, aqprod}`.
  </action>
  <verify>
    `cargo build -p qsym-core` compiles without errors. The module is declared, structs are defined, eval_phi and eval_psi functions exist with correct signatures.
  </verify>
  <done>
    QMonomial has mul/div/is_q_neg_power/try_sqrt/neg/is_zero/one/q methods. HypergeometricSeries and BilateralHypergeometricSeries structs exist with r(), s(), termination_order(). eval_phi and eval_psi are implemented. SummationResult and TransformationResult types exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for eval_phi and eval_psi</name>
  <files>
    crates/qsym-core/tests/qseries_hypergeometric_tests.rs
  </files>
  <action>
Create integration test file `qseries_hypergeometric_tests.rs` with these test cases:

**Test helpers:**
- `make_sym_q()` -> SymbolId: create a SymbolRegistry + register "q", return SymbolId. Follow the pattern from existing test files (e.g., qseries_pochhammer_tests.rs).
- `qm(power: i64)` -> QMonomial shorthand for QMonomial::q_power(power)
- `qm_rat(num: i64, den: i64, power: i64)` -> QMonomial::new(QRat::from((num, den)), power)

**Test 1: QMonomial arithmetic**
- `qm(2).mul(&qm(3))` == `qm(5)` (q^2 * q^3 = q^5)
- `qm(5).div(&qm(2))` == `qm(3)`
- `qm(-3).is_q_neg_power()` == Some(3)
- `qm(2).is_q_neg_power()` == None
- `qm(4).try_sqrt()` == Some(qm(2))
- `qm(3).try_sqrt()` == None (odd power)
- `qm_rat(4, 9, 2).try_sqrt()` == Some(qm_rat(2, 3, 1))

**Test 2: 1phi0 q-binomial theorem**
```
_1 phi_0 (a ; - ; q, z) = (az;q)_inf / (z;q)_inf
```
Use a = q^2, z = q. Then:
- LHS: eval_phi with upper=[q^2], lower=[], argument=q, truncation=30
- RHS: aqprod(q^3, q, inf, 30) * invert(aqprod(q, q, inf, 30))
- Assert LHS == RHS (FPS equality)

Note: For 1phi0, r=1, s=0, so 1+s-r=0 and the extra factor is 1. The formula simplifies to:
```
sum_{n=0}^{inf} (a;q)_n / (q;q)_n * z^n = (az;q)_inf / (z;q)_inf
```

**Test 3: terminating 2phi1**
```
_2 phi_1 (q^{-3}, q^2 ; q^4 ; q, q) -- terminating at n=3
```
Compute via eval_phi and verify it terminates (only 4 nonzero terms: n=0,1,2,3).
Verify the result has finite support (no terms beyond some power).

**Test 4: eval_phi with known simple case**
```
_2 phi_1 (q, q ; q^2 ; q, q)
```
Evaluate to O(q^20). Verify first few coefficients by hand:
- n=0 term: 1
- n=1 term: (1-q)(1-q)/[(1-q)(1-q^2)] * q = q/(1-q^2) -- expand in FPS
Actually, for testing just verify the result is a well-formed FPS with known leading terms. Compare with a second independent computation using aqprod products if a closed form is known.

**Test 5: bilateral 1psi1 (Ramanujan's summation)**
```
_1 psi_1 (q ; q^3 ; q, q^2)
```
The closed form is:
```
(q;q)_inf * (q^2;q)_inf * (q^3;q)_inf * (q^{-1};q)_inf
/ [(q^3;q)_inf * (1;q)_inf * (q^2;q)_inf * (q;q)_inf]
```
Wait -- Ramanujan's 1psi1 formula:
```
_1 psi_1 (a ; b ; q, z) = (q;q)_inf * (b/a;q)_inf * (az;q)_inf * (q/(az);q)_inf
                         / [(b;q)_inf * (q/a;q)_inf * (z;q)_inf * (b/(az);q)_inf]
```

Use a=q, b=q^3, z=q. Then:
- b/a = q^2, az = q^2, q/(az) = q^{-1}
- RHS numerator: (q;q)_inf * (q^2;q)_inf * (q^2;q)_inf * (q^{-1};q)_inf
- RHS denominator: (q^3;q)_inf * (1;q)_inf * (q;q)_inf * (q;q)_inf

But (q^{-1};q)_inf and (1;q)_inf involve divergent products ((1;q)_inf has factor (1-1)=0 at k=0). Choose parameters more carefully to avoid this.

**Better 1psi1 test:** Use a=q^2, b=q^4, z=q. Then:
- b/a = q^2, az = q^3, q/(az) = q^{-2}
- (q^{-2};q)_inf still has issues.

**Simplest bilateral test:** Just verify eval_psi produces a valid FPS for _1 psi_1 (q^2 ; q^5 ; q, q) by checking it against term-by-term hand computation of the first few terms. Verify the n=0 term is 1, the n=1 term includes factor (1-q^2)/(1-q^5)*q, and the n=-1 term includes the negative-index contribution.

**Test 6: eval_phi produces zero after termination**
Build a terminating series with upper param q^{-2}. Verify that eval_phi returns the same FPS as manually computing the 3 terms (n=0, 1, 2).
  </action>
  <verify>
    `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass.
  </verify>
  <done>
    At least 5 tests pass covering: QMonomial arithmetic (mul, div, is_q_neg_power, try_sqrt), eval_phi for 1phi0 q-binomial theorem, terminating 2phi1, and eval_psi bilateral series. The 1phi0 test verifies FPS equality against the known closed-form product.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles without errors
2. `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all 379+ existing tests still pass (no regressions)
</verification>

<success_criteria>
- HypergeometricSeries struct can represent any _r phi_s with QMonomial parameters
- BilateralHypergeometricSeries struct can represent any _r psi_s
- eval_phi correctly evaluates terminating and non-terminating series to O(q^T)
- eval_psi correctly evaluates bilateral series with positive and negative index terms
- 1phi0 q-binomial theorem test passes (eval_phi matches closed-form product)
- QMonomial mul, div, is_q_neg_power, try_sqrt all work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypergeometric-series/06-01-SUMMARY.md`
</output>
