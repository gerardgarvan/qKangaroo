---
phase: 06-hypergeometric-series
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/qsym-core/src/qseries/hypergeometric.rs
  - crates/qsym-core/tests/qseries_hypergeometric_tests.rs
autonomous: true

must_haves:
  truths:
    - "q-Gauss summation is automatically applied when a 2phi1 has z = c/(ab) and returns correct closed-form FPS"
    - "q-Vandermonde summation detects terminating 2phi1 with z=q or z=cq^n/a and returns correct finite Pochhammer ratio"
    - "q-Saalschutz summation detects balanced terminating 3phi2 and returns correct closed-form FPS"
    - "q-Kummer (Bailey-Daum) summation detects 2phi1 with c=aq/b and z=-q/b and returns correct FPS involving q^2-Pochhammer symbols"
    - "q-Dixon summation detects the characteristic 3phi2 pattern and returns correct finite Pochhammer ratio"
    - "try_all_summations convenience function tries all 5 formulas in order"
  artifacts:
    - path: "crates/qsym-core/src/qseries/hypergeometric.rs"
      provides: "try_q_gauss, try_q_vandermonde, try_q_saalschutz, try_q_kummer, try_q_dixon, try_all_summations"
      exports: ["try_q_gauss", "try_q_vandermonde", "try_q_saalschutz", "try_q_kummer", "try_q_dixon", "try_all_summations"]
    - path: "crates/qsym-core/tests/qseries_hypergeometric_tests.rs"
      provides: "Tests verifying each summation formula against eval_phi expansion"
  key_links:
    - from: "try_q_gauss"
      to: "aqprod with PochhammerOrder::Infinite"
      via: "closed-form product evaluation"
      pattern: "aqprod.*Infinite"
    - from: "try_q_vandermonde"
      to: "aqprod with PochhammerOrder::Finite"
      via: "finite Pochhammer ratio"
      pattern: "aqprod.*Finite"
    - from: "each summation function"
      to: "eval_phi"
      via: "tests verify summation result matches term-by-term expansion"
      pattern: "eval_phi.*==.*ClosedForm"
---

<objective>
Implement 5 classical summation formulas for basic hypergeometric series: q-Gauss, q-Vandermonde, q-Saalschutz, q-Kummer (Bailey-Daum), and q-Dixon. Each formula pattern-matches the series parameters and returns a closed-form FPS when applicable.

Purpose: Summation formulas are the core "simplification" capability -- they recognize when a hypergeometric series has a known closed form and return it directly, avoiding expensive term-by-term evaluation. This enables HYPR-03 through HYPR-06.

Output: 6 public functions (5 individual + 1 convenience) in hypergeometric.rs, verified against eval_phi expansion.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hypergeometric-series/06-RESEARCH.md
@.planning/phases/06-hypergeometric-series/06-01-SUMMARY.md

@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/series/arithmetic.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 5 summation formulas</name>
  <files>
    crates/qsym-core/src/qseries/hypergeometric.rs
  </files>
  <action>
Add 6 public functions to hypergeometric.rs. All take `&HypergeometricSeries, SymbolId, i64` (series, variable, truncation_order) and return `SummationResult`.

**1. try_q_gauss** (DLMF 17.6.1):
```
_2 phi_1 (a, b ; c ; q, c/(ab)) = (c/a;q)_inf * (c/b;q)_inf / [(c;q)_inf * (c/(ab);q)_inf]
```
- Check: r==2, s==1
- Compute expected_z = c.div(&a.mul(&b)) where a=upper[0], b=upper[1], c=lower[0]
- Compare z == expected_z (QMonomial equality -- exact QRat comparison)
- If match: evaluate 4 infinite q-Pochhammer products via aqprod(..., Infinite, trunc), multiply numerators, invert+multiply denominators
- Return ClosedForm(result) or NotApplicable

**2. try_q_vandermonde** (DLMF 17.6.2, 17.6.3):
Two forms. Check r==2, s==1. Find which upper param is q^{-n} via is_q_neg_power(). Let the other upper param be `a`, lower be `c`, termination order be `n`.

*First form* (z = c*q^n/a):
```
_2 phi_1 (a, q^{-n} ; c ; q, c*q^n/a) = (c/a;q)_n / (c;q)_n
```
- expected_z = c.mul(&QMonomial::q_power(n)).div(&a)
- If z matches: compute (c/a;q)_n and (c;q)_n as finite aqprod, divide.

*Second form* (z = q):
```
_2 phi_1 (a, q^{-n} ; c ; q, q) = a^n * (c/a;q)_n / (c;q)_n
```
- Check z == QMonomial::q_power(1)
- If match: compute a^n as QMonomial (a.coeff^n * q^{a.power*n}), then finite Pochhammer ratio.
- a^n as FPS: FormalPowerSeries::monomial(variable, a.coeff.clone().pow(n as u32), a.power * n, trunc)
- Note: QRat::pow takes u32. For large n, this is fine (n from termination_order is typically small).

**3. try_q_saalschutz** (DLMF 17.7.4):
```
_3 phi_2 (a, b, q^{-n} ; c, abq^{1-n}/c ; q, q) = (c/a;q)_n * (c/b;q)_n / [(c;q)_n * (c/(ab);q)_n]
```
- Check: r==3, s==2, z == q^1
- Find which upper param is q^{-n}. Let the other two be a, b.
- Check balance condition: one of the lower params must equal a.mul(&b).mul(&QMonomial::q_power(1 - n)).div(&c) where c is the other lower param.
- Try all assignments of (a, b, q^{-n}) from upper and (c, d) from lower to find a valid match.
- If match: evaluate 4 finite q-Pochhammer products via aqprod(..., Finite(n), trunc).

**4. try_q_kummer** (Bailey-Daum, DLMF 17.6.5):
```
_2 phi_1 (a, b ; aq/b ; q, -q/b) = (-q;q)_inf * (aq;q^2)_inf * (aq^2/b^2;q^2)_inf
                                    / [(-q/b;q)_inf * (aq/b;q)_inf]
```
- Check: r==2, s==1
- Let a=upper[0], b=upper[1], c=lower[0]
- Check: c == a.mul(&QMonomial::q_power(1)).div(&b) (i.e., c = aq/b)
- Check: z == QMonomial::new(-QRat::one(), 1).div(&b) (i.e., z = -q/b)
- Note: -q/b means coeff = -1/b.coeff, power = 1-b.power.
- If both match, compute RHS:
  - (-q;q)_inf: aqprod with a = QMonomial::new(-QRat::one(), 1), Infinite
  - (aq;q^2)_inf: This is a q^2-Pochhammer. Use etaq(a.power+1, 2, variable, trunc) from products module, OR compute directly: prod_{k=0}^{inf} (1 - a.coeff * q^{a.power+1+2k}). Use aqprod approach but with step=2. Since aqprod doesn't support step, implement as a loop of factors: for k=0,1,2,..., multiply (1 - aq^{1+2k}) while 1+2k < trunc. Actually, use the existing `etaq` function: etaq(offset, step, var, trunc) = prod_{k>=0} (1 - q^{offset+k*step}).
  - IMPORTANT: (aq;q^2)_inf with general a = c*q^m means prod_{k>=0}(1 - c*q^{m+1+2k}). This is NOT directly etaq (which has coeff=1). Implement as a manual loop: start with FPS::one, for k=0,1,2,... while a.power+1+2k < trunc, multiply by (1 - a.coeff*q^{a.power+1+2k}).
  - Similarly for (aq^2/b^2; q^2)_inf.
  - For the manual loop, use the same `one_minus_cq_m` helper from Plan 01.

**5. try_q_dixon** (Jackson, DLMF 17.7.6):
```
_3 phi_2 (q^{-2n}, b, c ; q^{1-2n}/b, q^{1-2n}/c ; q, q^{2-n}/(bc))
  = (b;q)_n * (c;q)_n * (q;q)_{2n} * (bc;q)_{2n}
    / [(q;q)_n * (bc;q)_n * (b;q)_{2n} * (c;q)_{2n}]
```
- Check: r==3, s==2
- Find upper param that is q^{-m} with m even (m=2n). Let the other two be b, c.
- Check z == q^{2-n}/(b*c), and lower params match q^{1-2n}/b and q^{1-2n}/c.
- Try all permutations. This is a complex pattern match.
- If match: compute 8 finite aqprod values (4 numerator, 4 denominator).

**6. try_all_summations** convenience function:
```rust
pub fn try_all_summations(
    series: &HypergeometricSeries,
    variable: SymbolId,
    truncation_order: i64,
) -> SummationResult {
    // Try each formula in order; return first match
    for try_fn in [try_q_gauss, try_q_vandermonde, try_q_saalschutz, try_q_kummer, try_q_dixon] {
        if let SummationResult::ClosedForm(fps) = try_fn(series, variable, truncation_order) {
            return SummationResult::ClosedForm(fps);
        }
    }
    SummationResult::NotApplicable
}
```

Add all 6 functions to the re-exports in mod.rs.

IMPORTANT: For QMonomial equality checks in pattern matching, both coeff (QRat) and power (i64) must match exactly. QRat from rug is always in lowest terms, so this is reliable.
  </action>
  <verify>
    `cargo build -p qsym-core` compiles. `cargo test -p qsym-core` -- all existing + new tests pass.
  </verify>
  <done>
    All 5 summation functions (try_q_gauss, try_q_vandermonde, try_q_saalschutz, try_q_kummer, try_q_dixon) and try_all_summations are implemented and compile. Each detects the applicable parameter pattern and returns ClosedForm with correct FPS.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests verifying summation formulas against eval_phi</name>
  <files>
    crates/qsym-core/tests/qseries_hypergeometric_tests.rs
  </files>
  <action>
Add test cases to the existing hypergeometric test file. Each test follows the same pattern:
1. Construct a HypergeometricSeries matching the summation formula's conditions
2. Call try_q_XXX -- assert it returns ClosedForm
3. Call eval_phi on the same series -- get term-by-term result
4. Assert the closed-form FPS == the eval_phi FPS (exact QRat equality)

**Test: q-Gauss summation**
```
_2 phi_1 (q, q^2 ; q^5 ; q, q^2)
```
- a=q, b=q^2, c=q^5, z=q^2
- Check: c/(ab) = q^5/(q*q^2) = q^2 = z. Match!
- Call try_q_gauss, expect ClosedForm
- Call eval_phi with trunc=30
- Assert both FPS are equal

**Test: q-Vandermonde (second form, z=q)**
```
_2 phi_1 (q^2, q^{-3} ; q^4 ; q, q)
```
- a=q^2, q^{-3} (terminating at n=3), c=q^4, z=q
- Call try_q_vandermonde, expect ClosedForm
- Call eval_phi with trunc=30
- Assert FPS equality
- Also verify the result is a polynomial (finite support) since the series terminates

**Test: q-Vandermonde (first form)**
```
_2 phi_1 (q^3, q^{-2} ; q^4 ; q, q^3)
```
- a=q^3, q^{-2} (n=2), c=q^4, z should be c*q^n/a = q^4*q^2/q^3 = q^3. Match!
- Call try_q_vandermonde, expect ClosedForm
- Call eval_phi with trunc=30
- Assert FPS equality

**Test: q-Saalschutz summation**
Construct a balanced terminating 3phi2. Use n=3, a=q, b=q^2, c=q^4:
- d (second lower) = a*b*q^{1-n}/c = q*q^2*q^{-2}/q^4 = q^{-3}
- Series: _3 phi_2 (q, q^2, q^{-3} ; q^4, q^{-3} ; q, q)
- Call try_q_saalschutz, expect ClosedForm
- Call eval_phi, assert equality

**Test: q-Kummer (Bailey-Daum)**
Use a=q^2, b=q. Then c=aq/b=q^2, z=-q/b=-1 (coeff=-1, power=0).
- Series: _2 phi_1 (q^2, q ; q^2 ; q, -1)
- Wait, c=aq/b = q^2*q/q = q^2. But c is also a lower param. And a is also an upper param equal to c. This might make the series degenerate.
- Better: a=q^4, b=q^2. c=aq/b = q^4*q/q^2 = q^3. z=-q/b = -q/q^2 = -q^{-1} = QMonomial::new(-QRat::one(), -1).
- Series: _2 phi_1 (q^4, q^2 ; q^3 ; q, -q^{-1})
- Call try_q_kummer with trunc=20 (convergence may be slower for this)
- Call eval_phi, assert FPS equality to trunc=20

**Test: q-Dixon**
Use n=2 (so 2n=4), b=q, c=q^2.
- Upper: q^{-4}, q, q^2
- Lower: q^{1-4}/q = q^{-3}/1 = q^{-3}, q^{1-4}/q^2 = q^{-3}/q^2... wait. Lower params: q^{1-2n}/b = q^{1-4}/q = q^{-4}, q^{1-2n}/c = q^{-3}/q^2... let me recompute.

Actually from DLMF 17.7.6: lower_1 = q^{1-2n}/b, lower_2 = q^{1-2n}/c.
With n=2: lower_1 = q^{-3}/b, lower_2 = q^{-3}/c.
With b=q, c=q^2: lower_1 = q^{-4}, lower_2 = q^{-5}.
z = q^{2-n}/(bc) = q^0/(q*q^2) = q^{-3}/(1) -- wait: z = q^{2-n}/(bc) = q^{2-2}/(q*q^2) = 1/(q^3) = q^{-3}.

- Series: _3 phi_2 (q^{-4}, q, q^2 ; q^{-4}, q^{-5} ; q, q^{-3})
- This involves negative-power lower params which may cause issues with (b;q)_n having b=q^{-4}. The finite aqprod should handle this.
- Call try_q_dixon, expect ClosedForm
- Call eval_phi with trunc=20
- Assert FPS equality

**Test: try_all_summations returns NotApplicable for generic series**
Construct a 2phi1 that doesn't match any formula (e.g., _2phi1(q, q^2; q^3; q, q^4) -- z=q^4 != q^3/(q*q^2)=1).
Assert try_all_summations returns NotApplicable.

**Test: try_all_summations returns ClosedForm for q-Gauss case**
Reuse the q-Gauss test parameters. Assert it returns ClosedForm and matches eval_phi.
  </action>
  <verify>
    `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass including the new summation tests.
  </verify>
  <done>
    At least 7 new tests pass: q-Gauss, q-Vandermonde (both forms), q-Saalschutz, q-Kummer, q-Dixon summation formulas, and try_all_summations. Each summation test verifies the closed-form FPS matches eval_phi term-by-term expansion.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles
2. `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all 379+ existing tests still pass
4. Each summation formula produces ClosedForm that exactly matches eval_phi expansion to O(q^20+)
</verification>

<success_criteria>
- q-Gauss, q-Vandermonde, q-Saalschutz, q-Kummer, q-Dixon all correctly detect applicable patterns
- Each returns ClosedForm FPS that matches eval_phi to O(q^20+)
- try_all_summations correctly dispatches and returns NotApplicable for non-matching series
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypergeometric-series/06-02-SUMMARY.md`
</output>
