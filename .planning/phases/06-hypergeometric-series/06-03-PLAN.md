---
phase: 06-hypergeometric-series
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - crates/qsym-core/src/qseries/hypergeometric.rs
  - crates/qsym-core/tests/qseries_hypergeometric_tests.rs
autonomous: true

must_haves:
  truths:
    - "Heine's first transformation correctly converts a 2phi1 into a different 2phi1 with product prefactor"
    - "Heine's second transformation produces the second iterate form"
    - "Heine's third transformation produces the third iterate form"
    - "Sears' 4phi3 transformation correctly converts a balanced terminating 4phi3 into a different 4phi3 with finite product prefactor"
    - "All transformations are verified by expanding both sides to O(q^50) and confirming FPS equality"
  artifacts:
    - path: "crates/qsym-core/src/qseries/hypergeometric.rs"
      provides: "heine_transform_1, heine_transform_2, heine_transform_3, sears_transform"
      exports: ["heine_transform_1", "heine_transform_2", "heine_transform_3", "sears_transform"]
    - path: "crates/qsym-core/tests/qseries_hypergeometric_tests.rs"
      provides: "Tests verifying each transformation via expansion comparison"
  key_links:
    - from: "heine_transform_1"
      to: "eval_phi + verify_transformation"
      via: "tests evaluate original and transformed+prefactor, compare FPS"
      pattern: "verify_transformation"
    - from: "sears_transform"
      to: "eval_phi"
      via: "tests compare 4phi3 LHS with transformed 4phi3 * prefactor RHS"
      pattern: "eval_phi.*sears"
---

<objective>
Implement Heine's transformation (all 3 forms) for 2phi1 series and Sears' transformation for balanced terminating 4phi3 series. Each transformation converts a hypergeometric series into a different one with a product prefactor.

Purpose: Transformations are the key tool for relating different hypergeometric representations, enabling researchers to simplify and verify hypergeometric identities. Heine's transformation is the most fundamental (q-analog of Euler's transformation), and Sears' extends this to 4phi3 balanced series.

Output: 4 transformation functions in hypergeometric.rs, verified by expanding both sides to O(q^50).
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hypergeometric-series/06-RESEARCH.md
@.planning/phases/06-hypergeometric-series/06-01-SUMMARY.md
@.planning/phases/06-hypergeometric-series/06-02-SUMMARY.md

@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/series/arithmetic.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Heine's 3 transformations and Sears' transformation</name>
  <files>
    crates/qsym-core/src/qseries/hypergeometric.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Add 4 transformation functions to hypergeometric.rs. Each takes a `&HypergeometricSeries`, `SymbolId`, and `i64` (truncation_order) and returns `Option<TransformationResult>` (None if not applicable).

**1. heine_transform_1** (Gasper-Rahman 1.4.1):
```
_2 phi_1 (a, b ; c ; q, z)
  = [(b;q)_inf * (az;q)_inf] / [(c;q)_inf * (z;q)_inf]
    * _2 phi_1 (c/b, z ; az ; q, b)
```

Conditions: r=2, s=1 (it's a 2phi1). Convergence requires |z| < 1 and |b| < 1, but for FPS computation we just need the formal equality.

Implementation:
- Check r==2, s==1. If not, return None.
- Extract a=upper[0], b=upper[1], c=lower[0], z=argument.
- Compute transformed parameters:
  - new upper: [c.div(&b), z.clone()] (i.e., c/b and z)
  - new lower: [a.mul(&z)] (i.e., az)
  - new argument: b.clone()
- Compute prefactor as FPS:
  - numerator: aqprod(b, var, Infinite, trunc) * aqprod(a.mul(&z), var, Infinite, trunc)
  - denominator: aqprod(c, var, Infinite, trunc) * aqprod(z, var, Infinite, trunc)
  - prefactor = numerator * invert(denominator)
- Return Some(TransformationResult { prefactor, transformed: new_series })

**2. heine_transform_2** (Gasper-Rahman 1.4.2):
```
_2 phi_1 (a, b ; c ; q, z)
  = [(c/b;q)_inf * (bz;q)_inf] / [(c;q)_inf * (z;q)_inf]
    * _2 phi_1 (abz/c, b ; bz ; q, c/b)
```

Same conditions as transform 1.
- new upper: [a.mul(&b).mul(&z).div(&c), b.clone()]
- new lower: [b.mul(&z)]
- new argument: c.div(&b)
- prefactor: (c/b;q)_inf * (bz;q)_inf / [(c;q)_inf * (z;q)_inf]

**3. heine_transform_3** (Gasper-Rahman 1.4.3):
```
_2 phi_1 (a, b ; c ; q, z)
  = [(abz/c;q)_inf] / [(z;q)_inf]
    * _2 phi_1 (c/a, c/b ; c ; q, abz/c)
```

Same conditions.
- new upper: [c.div(&a), c.div(&b)]
- new lower: [c.clone()]
- new argument: a.mul(&b).mul(&z).div(&c)
- prefactor: (abz/c;q)_inf / (z;q)_inf

**4. sears_transform** (Sears-Whipple for balanced terminating 4phi3):
```
_4 phi_3 (q^{-n}, a, b, c ; d, e, f ; q, q)  where def = abcq^{1-n}
  = [(e/a;q)_n * (f/a;q)_n] / [(e;q)_n * (f;q)_n]
    * _4 phi_3 (q^{-n}, a, d/b, d/c ; d, aq^{1-n}/e, aq^{1-n}/f ; q, q)
```

Conditions: r=4, s=3, one upper param is q^{-n}, z=q, balanced (d*e*f = a*b*c*q^{1-n}).

Implementation:
- Check r==4, s==3, z == QMonomial::q_power(1)
- Find which upper param is q^{-n} via is_q_neg_power(). Let the other three be (a, b, c).
- Let the three lower params be (d, e, f).
- Check balance: d.mul(&e).mul(&f) == a.mul(&b).mul(&c).mul(&QMonomial::q_power(1 - n))
- If not balanced, try all permutations of (d, e, f) as lower params, and permutations of (a, b, c) as upper params. The balance condition constrains the assignment. There are 3! * 3! = 36 permutations but in practice just try assigning the roles.
- SIMPLIFICATION: Try each of the 3 upper non-q^{-n} params as "a" (the distinguished param in the formula), and for each, try each of the 3 lower params as "d". The other two upper become "b" and "c", the other two lower become "e" and "f". Check balance for each assignment. This is at most 3*3=9 checks.
- Once a valid assignment is found:
  - new upper: [q^{-n}, a, d.div(&b), d.div(&c)]
  - new lower: [d, a.mul(&QMonomial::q_power(1-n)).div(&e), a.mul(&QMonomial::q_power(1-n)).div(&f)]
  - new argument: QMonomial::q_power(1)
  - prefactor as FPS: aqprod(e.div(&a), var, Finite(n), trunc) * aqprod(f.div(&a), var, Finite(n), trunc) / [aqprod(e, var, Finite(n), trunc) * aqprod(f, var, Finite(n), trunc)]

Add all 4 functions to the re-exports in mod.rs.

IMPORTANT: For Heine's transformations, the prefactor involves infinite products that may have zero constant term if the argument to aqprod is q^0 = 1 (since (1;q)_inf = 0). Avoid test parameters that create this degenerate case.
  </action>
  <verify>
    `cargo build -p qsym-core` compiles. All 4 transformation functions exist with correct signatures.
  </verify>
  <done>
    heine_transform_1, heine_transform_2, heine_transform_3, and sears_transform are implemented. Each returns Option<TransformationResult> with correct parameter transformations and prefactors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests verifying transformations via expansion comparison</name>
  <files>
    crates/qsym-core/tests/qseries_hypergeometric_tests.rs
  </files>
  <action>
Add test cases to the hypergeometric test file. The verification strategy for each transformation:
1. Construct original series
2. Call the transformation function -- assert it returns Some
3. Evaluate original via eval_phi to O(q^30)
4. Evaluate transformed series via eval_phi, multiply by prefactor
5. Assert LHS FPS == RHS FPS (or use verify_transformation helper)

**Test: Heine's first transformation**
```
_2 phi_1 (q^2, q^3 ; q^5 ; q, q)
```
Parameters chosen to avoid degenerate products (no param is q^0=1).
- a=q^2, b=q^3, c=q^5, z=q
- Call heine_transform_1, expect Some(result)
- Verify: eval_phi(original, q, 30) == mul(result.prefactor, eval_phi(result.transformed, q, 30))

**Test: Heine's second transformation**
Same parameters as above.
- Call heine_transform_2, expect Some(result)
- Same verification pattern.

**Test: Heine's third transformation**
Same parameters.
- Call heine_transform_3, expect Some(result)
- Same verification pattern.

**Test: All 3 Heine forms produce the same original expansion**
Using the same _2phi1(q^2, q^3; q^5; q, q), verify that:
- eval_phi(original)
- prefactor_1 * eval_phi(transformed_1)
- prefactor_2 * eval_phi(transformed_2)
- prefactor_3 * eval_phi(transformed_3)
All 4 are equal to O(q^30).

**Test: Heine returns None for non-2phi1**
Construct a 3phi2 series. Call heine_transform_1. Assert None.

**Test: Sears' transformation**
Construct a balanced terminating 4phi3:
Use n=3, a=q, b=q^2, c=q^3.
- d*e*f = a*b*c*q^{1-n} = q*q^2*q^3*q^{-2} = q^4
- Choose d=q, e=q, f=q^2 (product = q^4). Check!
- Series: _4 phi_3 (q^{-3}, q, q^2, q^3 ; q, q, q^2 ; q, q)
- Wait, d=e=q and f=q^2 means the lower params have duplicates. That's fine mathematically.

Actually let me pick cleaner params. n=2, a=q^2, b=q, c=q^3.
- d*e*f = q^2*q*q^3*q^{-1} = q^5
- Choose d=q^2, e=q, f=q^2 (product = q^5). Check!
- Series: _4 phi_3 (q^{-2}, q^2, q, q^3 ; q^2, q, q^2 ; q, q)

Call sears_transform. Expect Some. Verify both sides match to O(q^30).

**Test: Sears returns None for unbalanced 4phi3**
Construct a 4phi3 with z=q but unbalanced lower params. Assert None.
  </action>
  <verify>
    `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass including transformation tests.
  </verify>
  <done>
    At least 6 new tests pass: Heine transforms 1, 2, 3 individually, all-3-equal verification, Sears transformation, and non-applicability tests. Each transformation is verified by expanding both sides and confirming FPS equality to O(q^30).
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles
2. `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all existing tests still pass
4. Heine's 3 forms and Sears' transformation all verified by expansion comparison
</verification>

<success_criteria>
- Heine's 3 transformations correctly produce new 2phi1 series + prefactors that agree with the original to O(q^30)
- Sears' transformation correctly handles balanced terminating 4phi3 series
- Non-applicable cases return None cleanly
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypergeometric-series/06-03-SUMMARY.md`
</output>
</output>
