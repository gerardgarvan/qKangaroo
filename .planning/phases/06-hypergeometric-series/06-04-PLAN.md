---
phase: 06-hypergeometric-series
plan: 04
type: execute
wave: 4
depends_on: ["06-02", "06-03"]
files_modified:
  - crates/qsym-core/src/qseries/hypergeometric.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_hypergeometric_tests.rs
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "Watson's transformation reduces a very-well-poised 8phi7 to a 4phi3 with product prefactor"
    - "Bailey's transformation (DLMF 17.7.12 form) handles the terminating 4phi3 with q^2 base correctly"
    - "Python users can construct and evaluate phi and psi series via the DSL"
    - "Python users can apply summation formulas and transformations"
    - "Researchers can verify a hypergeometric identity by constructing both sides in Python and comparing"
    - "Python integration test constructs a 2phi1, applies try_summation, and confirms the closed form matches the term-by-term evaluation"
  artifacts:
    - path: "crates/qsym-core/src/qseries/hypergeometric.rs"
      provides: "watson_transform, bailey_transform"
      exports: ["watson_transform", "bailey_transform"]
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "phi, psi, q_gauss, q_vandermonde, q_saalschutz, heine_transform Python functions"
      exports: ["phi", "psi", "q_gauss", "heine1", "heine2", "heine3"]
    - path: "crates/qsym-core/tests/qseries_hypergeometric_tests.rs"
      provides: "Watson and Bailey transformation tests"
    - path: "crates/qsym-python/tests/test_integration.py"
      provides: "test_hypergeometric_identity_verification end-to-end Python test"
  key_links:
    - from: "watson_transform"
      to: "eval_phi + QMonomial::try_sqrt"
      via: "very-well-poised detection requires sqrt(a_1)"
      pattern: "try_sqrt"
    - from: "crates/qsym-python/src/dsl.rs"
      to: "crates/qsym-core/src/qseries/hypergeometric.rs"
      via: "PyO3 function wrappers calling Rust hypergeometric functions"
      pattern: "qseries::hypergeometric"
    - from: "crates/qsym-python/tests/test_integration.py"
      to: "phi + try_summation"
      via: "Python test calls phi() for term-by-term and try_summation() for closed form, compares coefficients"
      pattern: "test_hypergeometric_identity_verification"
---

<objective>
Implement Watson's and Bailey's transformations for very-well-poised hypergeometric series, add Python API bindings for all Phase 6 functionality (eval_phi, eval_psi, summation formulas, transformations), and add a Python integration test verifying end-to-end hypergeometric identity verification.

Purpose: Watson's and Bailey's transformations are the most powerful structural tools in the hypergeometric toolkit, reducing high-order series (8phi7, 10phi9) to simpler ones. Python bindings make all Phase 6 capabilities accessible to researchers, completing the phase goal. The integration test ensures the full workflow (construct series, apply summation, compare results) works end-to-end from Python.

Output: watson_transform, bailey_transform in Rust; Python DSL functions for phi/psi/summations/transformations; Python integration test for identity verification.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hypergeometric-series/06-RESEARCH.md
@.planning/phases/06-hypergeometric-series/06-01-SUMMARY.md
@.planning/phases/06-hypergeometric-series/06-02-SUMMARY.md
@.planning/phases/06-hypergeometric-series/06-03-SUMMARY.md

@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/tests/test_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Watson's and Bailey's transformations</name>
  <files>
    crates/qsym-core/src/qseries/hypergeometric.rs
    crates/qsym-core/src/qseries/mod.rs
    crates/qsym-core/tests/qseries_hypergeometric_tests.rs
  </files>
  <action>
**Watson's transformation** (HYPR-09):
```
_8 phi_7 (a, q*sqrt(a), -q*sqrt(a), b, c, d, e, f ;
          sqrt(a), -sqrt(a), aq/b, aq/c, aq/d, aq/e, aq/f ;
          q, a^2*q^2/(bcdef))
  = [(aq;q)_inf * (aq/(de);q)_inf * (aq/(df);q)_inf * (aq/(ef);q)_inf]
    / [(aq/d;q)_inf * (aq/e;q)_inf * (aq/f;q)_inf * (aq/(def);q)_inf]
    * _4 phi_3 (aq/(bc), d, e, f ; aq/b, aq/c, def/a ; q, q)
```

Implement `watson_transform(series: &HypergeometricSeries, variable: SymbolId, truncation_order: i64) -> Option<TransformationResult>`:

Detection algorithm:
1. Check r==8, s==7
2. Identify a_1 (the base parameter "a"): try each upper param. For candidate a_1, compute sqrt(a_1) via try_sqrt(). If None, skip.
3. Check that q*sqrt(a_1) and -q*sqrt(a_1) are among the remaining upper params. These are the very-well-poised markers.
   - q*sqrt(a) = QMonomial::q_power(1).mul(&sqrt_a)
   - -q*sqrt(a) = QMonomial::q_power(1).mul(&sqrt_a).neg()
4. Check that sqrt(a) and -sqrt(a) are among the lower params (the "half" parameters).
5. The remaining 5 upper params are b, c, d, e, f (in some order).
6. Check that the remaining 5 lower params are aq/b, aq/c, aq/d, aq/e, aq/f.
   - For each remaining upper param x, check if a_1.mul(&QMonomial::q_power(1)).div(&x) is in the remaining lower params.
7. Check z = a^2*q^2/(bcdef).
8. At least one of d, e, f should be q^{-N} (terminating condition for the standard form). However, Watson's also works non-terminating for convergent cases.

For the matching algorithm, since there are 5 remaining upper params and we need to identify which are b, c vs d, e, f:
- The convention is that d, e, f appear in the 4phi3 result. The choice of which params are "d, e, f" vs "b, c" matters.
- Try all (5 choose 3) = 10 ways to pick d, e, f from the 5 non-special upper params. For each, check if z matches a^2*q^2/(bcdef) where {b,c} is the complement.
- Return the first valid assignment.

If match found:
- Construct 4phi3: upper = [aq/(bc), d, e, f], lower = [aq/b, aq/c, def/a], argument = q
- Compute prefactor: 4 infinite products in numerator and denominator
  - num: (aq;q)_inf * (aq/(de);q)_inf * (aq/(df);q)_inf * (aq/(ef);q)_inf
  - den: (aq/d;q)_inf * (aq/e;q)_inf * (aq/f;q)_inf * (aq/(def);q)_inf
- Return Some(TransformationResult { prefactor, transformed })

PERFORMANCE NOTE: The 8phi7 has 16 parameters. Detection involves trying permutations, but the total is bounded (8 * 10 = 80 checks at most). This is negligible.

**Bailey's transformation** (HYPR-10, DLMF 17.7.12 form):
```
_4 phi_3 (a, aq, b^2*q^{2n}, q^{-2n} ; b, bq, a^2*q^2 ; q^2, q^2)
  = a^n * (-q;q)_n * (b/a;q)_n / [(-aq;q)_n * (b;q)_n]
```

Note: This uses base q^2, not q. The series variable in the FPS is still q, but the Pochhammer symbols use step 2.

Implement `bailey_transform(series: &HypergeometricSeries, variable: SymbolId, truncation_order: i64) -> SummationResult`:

This is actually a summation (closed form), not a transformation to another series.

Detection:
1. Check r==4, s==3.
2. Find upper param that is q^{-2n} for some n (i.e., is_q_neg_power returns Some(2n) with 2n even).
3. Check if another upper param has the form b^2*q^{2n} -- this requires matching.
4. Check remaining two upper params: one should be "a" and the other "aq" (a.mul(q)).
5. Check lower params: b, bq, a^2*q^2.
6. Check argument == q^2 (QMonomial::q_power(2)).

This is complex pattern matching. Simplify:
- Identify the q^{-2n} param first. Extract n.
- Among remaining upper params, find a pair (x, y) where y = x.mul(&QMonomial::q_power(1)), making x="a" and y="aq".
- The remaining upper param should be b^2*q^{2n} for some b.
  - To find b: the param is p. We need p = b^2*q^{2n}, so b^2 = p.coeff, 2n = p.power - (implied base power). Actually b is a QMonomial, b^2 = b.mul(&b). So we need p.coeff to be a perfect rational square, p.power to be even, and the resulting "b" from try_sqrt should satisfy lower params b, bq, a^2*q^2.
  - Simpler: try_sqrt on the param at q^{-2n_power + actual_power} to find b.

SIMPLIFICATION: Given the complexity, implement a more direct approach:
- Accept parameters and check the specific structure.
- For the terminating case: check one upper param is q^{-m} with m even (set n=m/2).
- Check z == q^2.
- Try to match the remaining structure by brute force over parameter assignments.

If match found, compute closed form:
- a^n as monomial
- (-q;q)_n: aqprod(QMonomial::new(-QRat::one(), 1), var, Finite(n), trunc)
- (b/a;q)_n: aqprod(b.div(&a), var, Finite(n), trunc)
- (-aq;q)_n: aqprod(a.neg().mul(&QMonomial::q_power(1)), var, Finite(n), trunc)
  Wait: -aq = (-a.coeff) * q^{a.power+1}. So aqprod(QMonomial::new(-a.coeff, a.power+1), var, Finite(n), trunc).
- (b;q)_n: aqprod(b, var, Finite(n), trunc)
- Combine: a^n * numer / denom

Return SummationResult::ClosedForm or NotApplicable.

NOTE: The q^2 base means this is actually a _4phi3 with base q^2, not base q. In the eval_phi function, the Pochhammer symbols use (a;q)_n, not (a;q^2)_n. So for evaluation of the LHS, we'd need an eval_phi variant that uses q^2 as the nome. However, for Phase 6's initial implementation, skip the eval_phi verification for Bailey and instead verify the closed form by direct computation of the 3 terms (n=0, 1, 2 for a small n) of the q^2-based series.

ALTERNATIVE SIMPLER APPROACH for Bailey: Instead of pattern-matching on HypergeometricSeries (which assumes base q), implement bailey_closed_form as a standalone function:
```rust
pub fn bailey_4phi3_q2(a: &QMonomial, b: &QMonomial, n: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries
```
That directly computes the closed form a^n * (-q;q)_n * (b/a;q)_n / [(-aq;q)_n * (b;q)_n], without pattern-matching. Document that this is Bailey's identity DLMF 17.7.12 for the specific 4phi3 with q^2 base. The user calls it when they know their series matches.

**Tests for Watson:**
Use a = q^4 (so sqrt(a) = q^2), b=q, c=q^2, d=q^3, e=q^{-2} (terminating at n=2), f=q^5.
- Check z = a^2*q^2/(bcdef) = q^8*q^2/(q*q^2*q^3*q^{-2}*q^5) = q^{10}/(q^9) = q. So z=q.
- Upper: q^4, q^3 (=q*q^2), -q^3 (=-q*q^2), q, q^2, q^3, q^{-2}, q^5
  Wait, q*sqrt(a) = q*q^2 = q^3. But q^3 already appears as d. This creates ambiguity.
  Choose a = q^6, sqrt(a)=q^3. Then q*sqrt(a) = q^4, -q*sqrt(a) = -q^4 (QMonomial::new(-1, 4)).
  Upper: q^6, q^4, QM(-1,4), b, c, d, e, f with b=q, c=q^2, d=q^3, e=q^{-2}, f=q.
  Wait, b and f can't both be q -- each upper param must be distinct for the formula to make sense. Let me use different params.

  a = q^4, sqrt(a)=q^2, q*sqrt(a)=q^3, -q*sqrt(a)=QM(-1,3).
  Let b=q^5, c=q^6, d=q, e=q^{-1}, f=q^2.
  z = a^2*q^2/(bcdef) = q^8*q^2/(q^5*q^6*q*q^{-1}*q^2) = q^{10}/q^{13} = q^{-3}.
  Hmm, z=q^{-3} is negative power, which means the series argument has small |z| for |q|<1.

  Actually for a simpler test, use the terminating case with a small example. The key test is that Watson's detection works and the 4phi3 result matches.

  Better approach for testing: Just construct the 8phi7 directly from known (a, b, c, d, e, f) parameters, compute eval_phi of the 8phi7 LHS, apply watson_transform, compute eval_phi of the 4phi3 * prefactor RHS, and compare. Use a=q^2 (sqrt=q), b=q^3, c=q^4, d=q^5, e=q^{-4} (terminating at 4), f=q^6.
  - z = q^4*q^2/(q^3*q^4*q^5*q^{-4}*q^6) = q^6/q^{14} = q^{-8}
  - Upper 8 params: q^2, q^2 (q*q=q^2? No: q*sqrt(q^2)=q*q=q^2. But a=q^2 is already in the list. This creates duplication.

  The very-well-poised structure requires a_1=a, a_2=q*sqrt(a), a_3=-q*sqrt(a). For a=q^2: sqrt(q^2)=q, so a_2=q^2 = a_1. This is degenerate.

  Use a = q^4. sqrt(q^4) = q^2. a_2 = q*q^2 = q^3. a_3 = -q^3 = QM(-1,3). Good, no duplication.
  b=q, c=q^2, d=q^{-2} (terminating at n=2), e=q^3, f=q^5.
  z = (q^4)^2 * q^2 / (q * q^2 * q^{-2} * q^3 * q^5) = q^{10} / q^9 = q.
  Lower 7: q^2 (sqrt(a)), -q^2 (=-sqrt(a), QM(-1,2)), q^4*q/q = q^4 (aq/b), q^4*q/q^2 = q^3 (aq/c), q^4*q/q^{-2} = q^7 (aq/d), q^4*q/q^3 = q^2 (aq/e)... but aq/e=q^2 = sqrt(a). Duplication again!

  The problem is that with small parameters, lower params collide. Use larger powers.
  a=q^{10}, sqrt=q^5, a2=q^6, a3=QM(-1,6). b=q, c=q^2, d=q^{-2}, e=q^3, f=q^4.
  Lower: q^5, QM(-1,5), q^{10}*q/q=q^{10}, q^{10}*q/q^2=q^9, q^{10}*q/q^{-2}=q^{13}, q^{10}*q/q^3=q^8, q^{10}*q/q^4=q^7.
  z = q^{20}*q^2/(q*q^2*q^{-2}*q^3*q^4) = q^{22}/q^8 = q^{14}.
  This is fine but truncation order needs to be large enough to capture terms at q^{14*n}. With trunc=30, only 2 terms fit. Use trunc=50 for a meaningful test.

  This is getting complicated. A pragmatic test approach: construct a small Watson's case with n=1 (terminating at 1 term beyond the constant), compute both sides, verify.

  d=q^{-1} (n=1): Only 2 terms (n=0, n=1).
  a=q^{10}, b=q, c=q^2, d=q^{-1}, e=q^3, f=q^4.
  z=q^{22}/q^9 = q^{13}. Upper: q^{10}, q^6, QM(-1,6), q, q^2, q^{-1}, q^3, q^4. Lower: q^5, QM(-1,5), q^{10}, q^9, q^{12}, q^8, q^7.
  eval_phi of this 8phi7 at trunc=30 should be a polynomial (terminating). The 4phi3 result: aq/(bc)=q^{10}*q/(q*q^2)=q^8, d=q^{-1}, e=q^3, f=q^4, lower: aq/b=q^{10}, aq/c=q^9, def/a=q^{-1}*q^3*q^4/q^{10}=q^{-4}.
  4phi3(q^8, q^{-1}, q^3, q^4; q^{10}, q^9, q^{-4}; q, q). Terminating at n=1. Evaluate and compare.

For Bailey test: use the standalone function approach. Pick a=q, b=q^3, n=2. Compute the closed form and verify by direct term-by-term computation of the 3 terms (k=0,1,2) of _4phi3(q, q^2, q^7, q^{-4}; q^3, q^4, q^4; q^2, q^2). Note: this 4phi3 uses base q^2, so each Pochhammer (x;q^2)_k = prod_{j=0}^{k-1}(1 - x*q^{2j}).

Add these tests to the test file.
  </action>
  <verify>
    `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass including Watson and Bailey.
  </verify>
  <done>
    watson_transform detects very-well-poised 8phi7 structure and produces correct 4phi3 + prefactor. bailey_4phi3_q2 computes correct closed form. Both verified by expansion comparison.
  </done>
</task>

<task type="auto">
  <name>Task 2: Python API bindings for hypergeometric functions</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
Add Python DSL functions for all Phase 6 hypergeometric functionality. Follow the existing pattern in dsl.rs (take QSession, return QSeries).

**Helper**: Create a `parse_qmonomials` helper that converts Python lists of (num, den, power) tuples into Vec<QMonomial>:
```rust
fn parse_qmonomials(params: Vec<(i64, i64, i64)>) -> Vec<QMonomial> {
    params.iter()
        .map(|(n, d, p)| QMonomial::new(QRat::from((*n, *d)), *p))
        .collect()
}
```

**1. phi function** -- evaluate _r phi_s:
```rust
#[pyfunction]
#[pyo3(signature = (session, upper, lower, z_num, z_den, z_pow, order))]
pub fn phi(
    session: &QSession,
    upper: Vec<(i64, i64, i64)>,   // list of (num, den, power) tuples
    lower: Vec<(i64, i64, i64)>,
    z_num: i64, z_den: i64, z_pow: i64,
    order: i64,
) -> QSeries
```
- Parse upper/lower into Vec<QMonomial>
- Build HypergeometricSeries
- Call eval_phi
- Return QSeries

**2. psi function** -- evaluate _r psi_s:
```rust
#[pyfunction]
#[pyo3(signature = (session, upper, lower, z_num, z_den, z_pow, order))]
pub fn psi(
    session: &QSession,
    upper: Vec<(i64, i64, i64)>,
    lower: Vec<(i64, i64, i64)>,
    z_num: i64, z_den: i64, z_pow: i64,
    order: i64,
) -> QSeries
```

**3. try_summation function** -- try all summation formulas:
```rust
#[pyfunction]
#[pyo3(signature = (session, upper, lower, z_num, z_den, z_pow, order))]
pub fn try_summation(
    session: &QSession,
    upper: Vec<(i64, i64, i64)>,
    lower: Vec<(i64, i64, i64)>,
    z_num: i64, z_den: i64, z_pow: i64,
    order: i64,
) -> Option<QSeries>
```
Returns Some(QSeries) if a summation formula applies, None otherwise.

**4. heine1, heine2, heine3 functions** -- Heine's transformations:
Each takes (session, a, b, c, z, order) where a/b/c/z are (num, den, power) tuples.
Returns a Python tuple (prefactor: QSeries, transformed_upper, transformed_lower, transformed_z) or a PyDict with keys "prefactor", "upper", "lower", "argument".

Actually, simpler: return a tuple of (prefactor_series: QSeries, result_series: QSeries) where result_series = prefactor * eval_phi(transformed). The user gets the final FPS directly.

```rust
#[pyfunction]
#[pyo3(signature = (session, upper, lower, z_num, z_den, z_pow, order))]
pub fn heine1(
    session: &QSession,
    upper: Vec<(i64, i64, i64)>,
    lower: Vec<(i64, i64, i64)>,
    z_num: i64, z_den: i64, z_pow: i64,
    order: i64,
) -> PyResult<(QSeries, QSeries)>
```
Returns (prefactor, transformed_evaluation) as tuple of QSeries. Raises ValueError if not a 2phi1.
Same signature for heine2, heine3.

**5. Register new functions in lib.rs:**
Add phi, psi, try_summation, heine1, heine2, heine3 to the module registration in lib.rs, following the existing pattern (m.add_function(wrap_pyfunction!(dsl::phi, m)?)?;).

Add a GROUP comment header in dsl.rs:
```rust
// ===========================================================================
// GROUP 6: Hypergeometric Series
// ===========================================================================
```

IMPORTANT: Follow the existing DSL pattern exactly. Use `session.inner.lock().unwrap()` to get the session, `inner.get_or_create_symbol_id("q")` for the variable. Return QSeries { fps }.

Watson and Bailey Python bindings are optional for Phase 6 (the Rust API is the primary interface; researchers who need Watson/Bailey can call via Rust). If time permits, add watson_transform and bailey_closed_form as Python functions, but they are lower priority than phi/psi/try_summation/heine.
  </action>
  <verify>
    `cargo build -p qsym-python` compiles. Python functions are registered. If a virtual environment is available, run `maturin develop` and test import:
    ```python
    from qsymbolic import QSession, phi, psi, try_summation, heine1
    s = QSession()
    # 1phi0 q-binomial theorem test
    result = phi(s, [(1,1,2)], [], 1, 1, 1, 20)
    print(result)
    ```
  </verify>
  <done>
    Python DSL has phi, psi, try_summation, heine1, heine2, heine3 functions. All compile and are registered in the module. Researchers can construct hypergeometric series, evaluate them, try summation formulas, and apply Heine's transformations from Python.
  </done>
</task>

<task type="auto">
  <name>Task 3: Python integration test for hypergeometric identity verification</name>
  <files>
    crates/qsym-python/tests/test_integration.py
  </files>
  <action>
Add a new integration test `test_hypergeometric_identity_verification` to `crates/qsym-python/tests/test_integration.py`. This test verifies Success Criterion #5: "Researchers can verify a hypergeometric identity by constructing both sides and confirming series agreement to arbitrary precision."

Follow the existing test patterns in the file (use `from qsymbolic import ...`, use `Fraction` for coefficient comparison, use assertion messages).

**Test implementation:**

```python
def test_hypergeometric_identity_verification():
    """
    Verify a hypergeometric identity end-to-end from Python:
    Construct a 2phi1 matching q-Gauss parameters, evaluate term-by-term via phi(),
    get closed form via try_summation(), and confirm both sides agree.

    q-Gauss: _2phi1(a, b; c; q, c/(ab)) = (c/a;q)_inf * (c/b;q)_inf / [(c;q)_inf * (c/(ab);q)_inf]

    Using a=q (1,1,1), b=q^2 (1,1,2), c=q^5 (1,1,5):
    z = c/(ab) = q^5 / (q * q^2) = q^2 = (1,1,2)
    """
    from qsymbolic import QSession, phi, try_summation
    from fractions import Fraction

    s = QSession()
    order = 30

    # Define q-Gauss parameters: _2phi1(q, q^2; q^5; q, q^2)
    upper = [(1, 1, 1), (1, 1, 2)]   # a=q, b=q^2
    lower = [(1, 1, 5)]               # c=q^5
    z_num, z_den, z_pow = 1, 1, 2     # z=q^2 = c/(ab)

    # Side 1: Term-by-term evaluation via phi()
    term_by_term = phi(s, upper, lower, z_num, z_den, z_pow, order)

    # Side 2: Closed form via try_summation()
    closed_form = try_summation(s, upper, lower, z_num, z_den, z_pow, order)

    # try_summation should recognize q-Gauss and return a result
    assert closed_form is not None, \
        "try_summation should recognize q-Gauss pattern for _2phi1(q, q^2; q^5; q, q^2)"

    # Compare coefficients: both sides must agree to O(q^order)
    for k in range(order):
        assert term_by_term[k] == closed_form[k], \
            f"Identity mismatch at q^{k}: phi={term_by_term[k]}, summation={closed_form[k]}"

    # Sanity check: the series is not trivially zero or constant
    assert term_by_term[0] == Fraction(1), \
        f"Constant term should be 1, got {term_by_term[0]}"
    has_nonzero_higher = any(term_by_term[k] != Fraction(0) for k in range(1, min(10, order)))
    assert has_nonzero_higher, \
        "Series should have nonzero higher-order terms (not a trivial identity)"

    print(f"Hypergeometric identity (q-Gauss) verified to O(q^{order})")
```

Also add `test_hypergeometric_identity_verification` to the `if __name__ == "__main__":` block at the bottom of the file, before the final "ALL INTEGRATION TESTS PASSED" print.

Verify the test follows the same style as the 8 existing tests:
- Docstring explaining the mathematical identity
- Imports from qsymbolic at function level
- Fraction-based coefficient comparison
- Assertion messages with useful diagnostics
- Print statement confirming success
  </action>
  <verify>
    If a virtual environment with maturin is available: `cd crates/qsym-python && maturin develop && python -m pytest tests/test_integration.py::test_hypergeometric_identity_verification -v`. Otherwise: verify the test file is syntactically valid with `python -c "import ast; ast.parse(open('crates/qsym-python/tests/test_integration.py').read()); print('Syntax OK')"`.
  </verify>
  <done>
    test_integration.py contains test_hypergeometric_identity_verification that constructs a 2phi1 with q-Gauss parameters, evaluates via phi(), gets closed form via try_summation(), and asserts all coefficients match to O(q^30). The test is registered in the __main__ block.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles
2. `cargo test -p qsym-core --test qseries_hypergeometric_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all 379+ existing tests still pass
4. `cargo build -p qsym-python` -- compiles
5. Watson's 8phi7 test verified by expansion comparison
6. Bailey's closed form verified against direct term computation
7. Python phi/psi/try_summation/heine functions compile and are registered
8. Python integration test test_hypergeometric_identity_verification passes (constructs 2phi1, applies try_summation, confirms coefficient match)
</verification>

<success_criteria>
- Watson's transformation correctly detects very-well-poised 8phi7 and reduces to 4phi3
- Bailey's closed form produces correct results for DLMF 17.7.12
- Python API exposes phi, psi, try_summation, heine1/2/3 with correct signatures
- Python integration test verifies end-to-end identity verification workflow
- All Phase 6 requirements (HYPR-01 through HYPR-10) are covered
- All 5 Roadmap success criteria are achievable with the implemented functions
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypergeometric-series/06-04-SUMMARY.md`
</output>
</output>
