---
phase: 07-identity-proving
plan: "07-01"
title: "JAC and ETA Symbolic Models with Conversion"
wave: 1
depends_on: []
requirements: ["IDPR-01", "IDPR-02"]
files_modified:
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/src/qseries/prodmake.rs
files_created:
  - crates/qsym-core/src/qseries/identity/mod.rs
  - crates/qsym-core/src/qseries/identity/jac.rs
  - crates/qsym-core/src/qseries/identity/eta.rs
  - crates/qsym-core/tests/qseries_identity_jac_eta_tests.rs
estimated_tasks: 3

must_haves:
  truths:
    - "JacExpression can represent arbitrary products of JAC(a,b)^e with scalar and q-shift prefactors"
    - "EtaExpression can represent arbitrary eta quotients prod eta(delta*tau)^{r_delta} with computed level, weight, and q-shift"
    - "EtaExpression.check_modularity() correctly validates Newman's four conditions for Gamma_0(N)"
    - "JAC expressions can be expanded to FormalPowerSeries via existing jacprod infrastructure"
    - "ETA expressions can be expanded to FormalPowerSeries via existing etaq infrastructure"
    - "Conversion from prodmake EtaQuotient to identity EtaExpression works correctly"
  artifacts:
    - path: "crates/qsym-core/src/qseries/identity/mod.rs"
      provides: "Module re-exports for identity submodule"
      contains: "pub mod jac"
    - path: "crates/qsym-core/src/qseries/identity/jac.rs"
      provides: "JacFactor, JacExpression structs with to_series conversion"
      exports: ["JacFactor", "JacExpression"]
    - path: "crates/qsym-core/src/qseries/identity/eta.rs"
      provides: "EtaExpression struct with weight, q_shift, check_modularity, to_series, from_etaquotient"
      exports: ["EtaExpression", "ModularityResult"]
    - path: "crates/qsym-core/tests/qseries_identity_jac_eta_tests.rs"
      provides: "Integration tests for JAC and ETA symbolic models"
      min_lines: 150
  key_links:
    - from: "crates/qsym-core/src/qseries/identity/jac.rs"
      to: "crates/qsym-core/src/qseries/products.rs"
      via: "jacprod function for FPS expansion"
      pattern: "products::jacprod"
    - from: "crates/qsym-core/src/qseries/identity/eta.rs"
      to: "crates/qsym-core/src/qseries/products.rs"
      via: "etaq function for FPS expansion"
      pattern: "products::etaq"
    - from: "crates/qsym-core/src/qseries/identity/eta.rs"
      to: "crates/qsym-core/src/qseries/prodmake.rs"
      via: "divisors function for Newman condition checks"
      pattern: "prodmake::divisors"
    - from: "crates/qsym-core/src/qseries/mod.rs"
      to: "crates/qsym-core/src/qseries/identity/mod.rs"
      via: "pub mod identity declaration"
      pattern: "pub mod identity"
---

<objective>
Create the JAC and ETA symbolic representation models -- structured data types that capture the algebraic form of Jacobi products and eta quotients without expanding to formal power series. These are the foundational inputs to the identity proving pipeline.

Purpose: IDPR-01 and IDPR-02 require that researchers can work with JAC and ETA expressions as structured data, manipulate them symbolically, check modularity conditions, and convert between representations. This is the base layer everything else builds on.

Output: identity/ submodule with jac.rs, eta.rs, integration tests, wired into qseries/mod.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-identity-proving/07-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/lib.rs
@crates/qsym-core/tests/qseries_prodmake_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire identity submodule, make mobius/divisors pub(crate), create JacExpression</name>
  <files>
    crates/qsym-core/src/qseries/mod.rs
    crates/qsym-core/src/qseries/prodmake.rs
    crates/qsym-core/src/qseries/identity/mod.rs
    crates/qsym-core/src/qseries/identity/jac.rs
  </files>
  <action>
**Step 1: Make `mobius` and `divisors` pub(crate) in prodmake.rs.**

Change `fn mobius(n: i64) -> i64` to `pub(crate) fn mobius(n: i64) -> i64` (line 58).
Change `fn divisors(n: i64) -> Vec<i64>` to `pub(crate) fn divisors(n: i64) -> Vec<i64>` (line 93).

These functions are needed by cusps.rs (Plan 07-02) and eta.rs (this plan) for divisor enumeration and Mobius inversion. They are small, correct, well-tested functions already in the codebase.

**Step 2: Add `pub mod identity;` to qseries/mod.rs.**

Add after the existing `pub mod hypergeometric;` line (line 34):
```rust
pub mod identity;
```

Add to the module-level doc comment (top of file) a new bullet:
```
//! - Identity proving: [`identity`] module for JAC/ETA symbolic models, cusps, and proving engine
```

Add re-exports at the bottom of the existing `pub use` block:
```rust
pub use identity::{JacFactor, JacExpression, EtaExpression, ModularityResult};
```

**Step 3: Create `identity/mod.rs` with sub-module declarations.**

```rust
//! Symbolic identity representations and proving engine.
//!
//! This module provides:
//! - [`jac`]: Jacobi triple product symbolic representation
//! - [`eta`]: Eta quotient symbolic representation with Newman modularity checks

pub mod jac;
pub mod eta;

pub use jac::{JacFactor, JacExpression};
pub use eta::{EtaExpression, ModularityResult};
```

**Step 4: Create `identity/jac.rs` with JacFactor and JacExpression.**

```rust
//! JAC symbolic representation: Jacobi triple products as structured data.
//!
//! JAC(a, b) = (q^a; q^b)_inf * (q^{b-a}; q^b)_inf * (q^b; q^b)_inf
//!
//! A JacExpression represents: scalar * q^shift * prod_i JAC(a_i, b_i)^{e_i}
```

Structs:

1. **JacFactor** -- `#[derive(Clone, Debug, PartialEq, Eq)]`:
   - `pub a: i64` -- first parameter (0 < a < b)
   - `pub b: i64` -- modulus parameter
   - `pub exponent: i64` -- power of this JAC factor

   Methods:
   - `pub fn new(a: i64, b: i64, exponent: i64) -> Self` -- validates 0 < a < b, panics otherwise
   - `pub fn is_valid(&self) -> bool` -- checks 0 < a < b

2. **JacExpression** -- `#[derive(Clone, Debug)]`:
   - `pub scalar: QRat` -- rational scalar prefactor
   - `pub q_shift: QRat` -- fractional power of q prefactor (can be 0, or e.g. 1/24)
   - `pub factors: Vec<JacFactor>` -- list of JAC(a,b)^e factors

   Methods:
   - `pub fn new(scalar: QRat, q_shift: QRat, factors: Vec<JacFactor>) -> Self`
   - `pub fn single(a: i64, b: i64) -> Self` -- convenience: scalar=1, q_shift=0, single JAC(a,b)^1
   - `pub fn is_empty(&self) -> bool` -- no factors
   - `pub fn to_series(&self, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
     - Start with result = FPS::one
     - For each factor: compute `jacprod(factor.a, factor.b, variable, truncation_order)`, raise to `factor.exponent` using fps_pow, multiply into result
     - Multiply by scalar (use `arithmetic::scalar_mul`)
     - If q_shift is nonzero and is an integer, shift the series (multiply by q^shift FPS monomial). If q_shift is fractional, this indicates the expression involves fractional q-powers -- for now, panic with a clear message since FPS only supports integer exponents. (In practice, q_shift is 0 for JAC-only expressions.)
     - Return result

   The `fps_pow` helper: implement as a private function in jac.rs (same logic as `relations.rs::fps_pow` -- it's private there so cannot be imported). Uses repeated squaring with `arithmetic::mul` and `arithmetic::invert`.

   ```rust
   fn fps_pow(f: &FormalPowerSeries, n: i64) -> FormalPowerSeries {
       if n == 0 {
           return FormalPowerSeries::one(f.variable(), f.truncation_order());
       }
       let (base, exp) = if n < 0 {
           (arithmetic::invert(f), (-n) as u64)
       } else {
           (f.clone(), n as u64)
       };
       let mut result = FormalPowerSeries::one(base.variable(), base.truncation_order());
       let mut power = base;
       let mut e = exp;
       while e > 0 {
           if e & 1 == 1 {
               result = arithmetic::mul(&result, &power);
           }
           e >>= 1;
           if e > 0 {
               power = arithmetic::mul(&power, &power);
           }
       }
       result
   }
   ```

Imports needed:
```rust
use crate::number::QRat;
use crate::series::{FormalPowerSeries, arithmetic};
use crate::symbol::SymbolId;
use crate::qseries::products::jacprod;
```
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo build -p qsym-core 2>&1` compiles without errors. The identity module is declared, JacFactor and JacExpression exist with to_series method.
  </verify>
  <done>
    JacFactor and JacExpression structs are defined. JacExpression.to_series() produces FormalPowerSeries via existing jacprod infrastructure. The identity/ submodule is wired into qseries/mod.rs. mobius and divisors are pub(crate).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EtaExpression with Newman modularity checks and FPS conversion</name>
  <files>
    crates/qsym-core/src/qseries/identity/eta.rs
  </files>
  <action>
Create `identity/eta.rs` implementing the ETA symbolic representation.

```rust
//! ETA symbolic representation: eta quotients as structured data.
//!
//! An eta quotient is: prod_{delta | N} eta(delta * tau)^{r_delta}
//! where eta(tau) = q^{1/24} * (q;q)_inf is the Dedekind eta function.
//!
//! The `EtaExpression` struct captures the structure (delta -> r_delta mapping)
//! and provides methods for computing weight, q-shift, and validating
//! Newman's modularity conditions on Gamma_0(N).
```

1. **ModularityResult enum** -- `#[derive(Clone, Debug)]`:
   ```rust
   pub enum ModularityResult {
       /// All Newman conditions satisfied for modular function on Gamma_0(N)
       Modular,
       /// One or more conditions failed
       NotModular { failed_conditions: Vec<String> },
   }
   ```
   Methods: `pub fn is_modular(&self) -> bool`

2. **EtaExpression struct** -- `#[derive(Clone, Debug)]`:
   - `pub factors: BTreeMap<i64, i64>` -- maps delta -> r_delta (only nonzero entries)
   - `pub level: i64` -- the level N (all deltas must divide N)

   Methods:

   - `pub fn new(factors: BTreeMap<i64, i64>, level: i64) -> Self`:
     Validate that every delta in factors divides level. Panic if not.

   - `pub fn from_factors(pairs: &[(i64, i64)], level: i64) -> Self`:
     Convenience constructor from slice of (delta, r_delta) pairs.

   - `pub fn from_etaquotient(eq: &EtaQuotient) -> Self`:
     Convert from the existing `prodmake::EtaQuotient` struct. The EtaQuotient has `factors: BTreeMap<i64, i64>` and `q_shift: QRat`. Compute level as LCM of all deltas (since an EtaQuotient from prodmake doesn't store a level). Use the formula: level = lcm of all keys in factors.
     ```rust
     fn lcm(a: i64, b: i64) -> i64 {
         (a / gcd(a, b)) * b
     }
     ```
     where gcd is the local helper (see below).

   - `pub fn weight(&self) -> QRat`:
     Returns sum(r_delta) / 2 as QRat. (Weight k = sum of exponents / 2.)

   - `pub fn q_shift(&self) -> QRat`:
     Returns sum(delta * r_delta) / 24 as QRat.

   - `pub fn check_modularity(&self) -> ModularityResult`:
     Check Newman's four conditions for modularity on Gamma_0(N):

     **Condition 0 (divisibility):** Every delta in self.factors must divide self.level. (Already enforced by constructor, but re-check.)

     **Condition 1:** sum(delta * r_delta) must be divisible by 24. Compute as i64 sum, check `% 24 == 0`. If not, push error string.

     **Condition 2:** sum((N/delta) * r_delta) must be divisible by 24. Same approach.

     **Condition 3:** prod(delta^|r_delta|) must be a perfect square. Use rug::Integer for this:
     ```rust
     let mut product = rug::Integer::from(1);
     for (&delta, &r) in &self.factors {
         let r_abs = r.unsigned_abs() as u32;
         let delta_int = rug::Integer::from(delta);
         product *= delta_int.pow(r_abs);
     }
     let sqrt = product.clone().sqrt();
     if &sqrt * &sqrt != product {
         errors.push("prod(delta^|r_delta|) is not a perfect square".to_string());
     }
     ```

     **Condition 4 (weight zero for modular functions):** sum(r_delta) must be 0. If nonzero, push error noting the weight.

     Return `ModularityResult::Modular` if no errors, `NotModular { failed_conditions: errors }` otherwise.

   - `pub fn to_series(&self, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`:
     Expand to FPS using the existing `etaq` function from products.rs.

     eta(delta*tau)^{r_delta} as a q-series:
     - eta(delta*tau) = q^{delta/24} * (q^delta; q^delta)_inf = q^{delta/24} * etaq(delta, delta, var, trunc)
     - But FPS has integer exponents only, so we cannot represent q^{delta/24} directly.
     - Instead, work with the (q^delta;q^delta)_inf product form and track the total q-shift separately.

     Algorithm:
     1. Compute total_q_shift = self.q_shift() = sum(delta * r_delta) / 24
     2. Verify total_q_shift is an integer (panicking otherwise -- non-integer q-shifts indicate the eta quotient does not have integer q-powers, which is unusual for valid identities)
     3. Start with result = FPS::one
     4. For each (delta, r_delta) in self.factors:
        - Compute `etaq(delta, delta, variable, truncation_order)` -- this is (q^delta; q^delta)_inf
        - Raise to power r_delta using fps_pow
        - Multiply into result
     5. Multiply by q^{total_q_shift}: create monomial FPS with coeff=1 at power=total_q_shift_as_i64, multiply into result
     6. Return result

     Reuse the same `fps_pow` helper from jac.rs. Since it's private there, either:
     (a) Define a `pub(crate) fn fps_pow` in `identity/mod.rs` and have both jac.rs and eta.rs use it, OR
     (b) Duplicate the small function in eta.rs.

     Prefer option (a): add `pub(crate) fn fps_pow(...)` to `identity/mod.rs` and `use super::fps_pow;` in both jac.rs and eta.rs. Update jac.rs to remove its local copy.

   Helper functions (private to eta.rs):
   ```rust
   fn gcd(a: i64, b: i64) -> i64 {
       let (mut a, mut b) = (a.abs(), b.abs());
       while b != 0 { let t = b; b = a % b; a = t; }
       a
   }

   fn lcm(a: i64, b: i64) -> i64 {
       if a == 0 || b == 0 { return 0; }
       (a / gcd(a, b)) * b
   }
   ```

Imports:
```rust
use std::collections::BTreeMap;
use crate::number::QRat;
use crate::series::{FormalPowerSeries, arithmetic};
use crate::symbol::SymbolId;
use crate::qseries::products::etaq;
use crate::qseries::prodmake::EtaQuotient;
```
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo build -p qsym-core 2>&1` compiles without errors. EtaExpression exists with weight(), q_shift(), check_modularity(), to_series(), and from_etaquotient().
  </verify>
  <done>
    EtaExpression struct captures eta quotients as BTreeMap<delta, r_delta> with level. weight(), q_shift(), and check_modularity() compute structural properties. to_series() expands to FPS via etaq. from_etaquotient() converts from the prodmake EtaQuotient type. ModularityResult enum distinguishes Modular from NotModular with specific failure details. fps_pow is shared via identity/mod.rs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for JAC and ETA symbolic models</name>
  <files>
    crates/qsym-core/tests/qseries_identity_jac_eta_tests.rs
  </files>
  <action>
Create integration test file with the following test cases. Follow the pattern from existing test files (e.g., qseries_prodmake_tests.rs) for helper setup.

**Test helpers:**
```rust
use qsym_core::number::QRat;
use qsym_core::symbol::SymbolId;
use qsym_core::ExprArena;
use qsym_core::qseries::identity::{JacFactor, JacExpression, EtaExpression, ModularityResult};
use qsym_core::qseries::{etaq, jacprod, etamake};
use qsym_core::series::{FormalPowerSeries, arithmetic};
use qsym_core::series::generator::euler_function_generator;
use std::collections::BTreeMap;

fn q_var() -> SymbolId {
    let mut arena = ExprArena::new();
    arena.symbols_mut().intern("q")
}

fn qrat(n: i64, d: i64) -> QRat {
    QRat::from((n, d))
}
```

**Test 1: JacFactor construction and validation**
- `JacFactor::new(1, 5, 1)` succeeds (a=1, b=5, exponent=1)
- `JacFactor::new(2, 5, -1)` succeeds (negative exponent is fine)
- `JacFactor::new(0, 5, 1)` panics (a must be > 0) -- use `#[should_panic]`
- `JacFactor::new(5, 5, 1)` panics (a must be < b) -- use `#[should_panic]`

**Test 2: JacExpression::single and to_series**
- Create `JacExpression::single(1, 5)` -- represents JAC(1,5)
- Call `to_series(q, 20)` and compare with `jacprod(1, 5, q, 20)`
- Assert FPS equality

**Test 3: JacExpression with multiple factors**
- Create expression with JAC(1,5)^1 * JAC(2,5)^1
- Expand to FPS via to_series
- Independently compute jacprod(1,5) * jacprod(2,5) via arithmetic::mul
- Assert equality

**Test 4: JacExpression with negative exponent**
- Create JAC(1,2)^{-1} (inverse of Jacobi triple product)
- Expand to series
- Multiply by jacprod(1,2,q,20) -- should get FPS::one (up to truncation)
- Assert the product equals 1 + O(q^20)

**Test 5: EtaExpression construction and basic properties**
- Create eta quotient with factors {1: 24} at level 1 -- this is eta(tau)^{24} = Delta
- weight() should be QRat(24, 2) = QRat(12, 1)
- q_shift() should be QRat(24, 24) = QRat(1, 1)

**Test 6: EtaExpression -- modularity check passes**
- eta(tau)^{24} on Gamma_0(1): level=1, factors={1: 24}
  - sum(delta * r_delta) = 24, divisible by 24: OK
  - sum((N/delta) * r_delta) = (1/1)*24 = 24, divisible by 24: OK
  - prod(delta^|r_delta|) = 1^24 = 1, perfect square: OK
  - But sum(r_delta) = 24 != 0, so weight is 12, NOT a modular function
  - check_modularity() should return NotModular with message about weight

**Test 7: EtaExpression -- modular function passes all conditions**
- The eta quotient eta(tau)^{-24} * eta(2*tau)^{48} * eta(4*tau)^{-24} on Gamma_0(4):
  - factors = {1: -24, 2: 48, 4: -24}, level = 4
  - sum(r_delta) = -24 + 48 - 24 = 0 (weight 0): OK
  - sum(delta * r_delta) = -24 + 96 - 96 = -24, not divisible by 24... that's 0 remainder actually: -24 % 24 == 0: OK
  Wait, let me compute more carefully:
  - sum(delta * r_delta) = 1*(-24) + 2*48 + 4*(-24) = -24 + 96 - 96 = -24. And -24 % 24 == 0: OK
  - sum((N/delta) * r_delta) = (4/1)*(-24) + (4/2)*48 + (4/4)*(-24) = -96 + 96 - 24 = -24. -24 % 24 == 0: OK
  - prod(delta^|r_delta|) = 1^24 * 2^48 * 4^24 = 2^48 * 2^48 = 2^96, sqrt = 2^48: perfect square: OK
  - check_modularity() should return Modular

  Actually, a simpler known modular function: eta(tau)^8 * eta(2*tau)^{-8} * eta(4*tau)^8 * ... Let me use the classic:

  A cleaner example: the modular function j(tau) involves eta^24, but let's use a well-known weight-0 eta quotient.

  **Use:** f = eta(5*tau)^6 / eta(tau)^6 on Gamma_0(5):
  - factors = {1: -6, 5: 6}, level = 5
  - sum(r_delta) = -6 + 6 = 0: OK (weight 0)
  - sum(delta * r_delta) = -6 + 30 = 24. 24 % 24 == 0: OK
  - sum((N/delta) * r_delta) = 5*(-6) + 1*6 = -30 + 6 = -24. -24 % 24 == 0: OK
  - prod(delta^|r_delta|) = 1^6 * 5^6 = 5^6 = 15625. sqrt(15625) = 125 = 5^3. 125*125 = 15625: perfect square: OK
  - check_modularity() should return Modular

**Test 8: EtaExpression -- modularity check fails (condition 1)**
- factors = {1: 1, 2: -1}, level = 2
  - sum(delta * r_delta) = 1 - 2 = -1. -1 % 24 != 0: FAIL
  - check_modularity() should return NotModular

**Test 9: EtaExpression.to_series produces correct FPS**
- Create eta quotient eta(tau)^1 at level 1: factors = {1: 1}
- q_shift = 1/24 -- this is NOT an integer, so to_series should panic.
- Use #[should_panic] for this test.

**Test 10: EtaExpression.to_series for valid integral q-shift**
- Use the modular function from Test 7: f = eta(5*tau)^6 / eta(tau)^6 on Gamma_0(5)
- q_shift = sum(delta * r_delta) / 24 = (1*(-6) + 5*6) / 24 = 24/24 = 1
- to_series(q, 30) should succeed
- Independently compute: q^1 * etaq(5,5,q,30)^6 / etaq(1,1,q,30)^6
- Actually etaq(1,1,q,trunc) = (q;q)_inf, so etaq(1,1)^6 is (q;q)_inf^6, inverted is 1/(q;q)_inf^6
- Compute both and assert equality

**Test 11: from_etaquotient conversion**
- Compute etamake from the Euler function (q;q)_inf to get an EtaQuotient
- Convert via EtaExpression::from_etaquotient
- Check that factors = {1: 1} (or {1: -1} depending on convention -- the Euler function is (q;q)_inf = q^{-1/24} * eta(tau), and etamake should return factors mapping d -> r_d)
- Verify the level is computed correctly

Note: Be careful with the sign convention. The existing `etamake` returns `EtaQuotient { factors, q_shift }` where factors maps d -> r_d and the result is `prod eta(d*tau)^{r_d}`. For the Euler function (q;q)_inf = eta(tau) * q^{-1/24}, so the EtaQuotient should have factors = {1: 1}. Check the actual etamake output in the test.
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib --tests -p qsym-core --test qseries_identity_jac_eta_tests 2>&1` -- all tests pass.

    Also verify no regressions: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib --tests -p qsym-core 2>&1` -- all existing tests still pass.
  </verify>
  <done>
    At least 10 tests pass covering: JacFactor validation (valid + panic cases), JacExpression.to_series matching jacprod, multi-factor and negative-exponent JAC expressions, EtaExpression weight/q_shift computation, Newman modularity checks (pass and fail cases), EtaExpression.to_series expansion, and from_etaquotient conversion from prodmake output.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles without errors
2. `cargo test -p qsym-core --test qseries_identity_jac_eta_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all existing tests still pass (no regressions from pub(crate) change)
4. JacExpression::single(1,5).to_series(q, 20) == jacprod(1, 5, q, 20)
5. EtaExpression with {1: -6, 5: 6} at level 5 returns ModularityResult::Modular
</verification>

<success_criteria>
- JacFactor and JacExpression capture Jacobi product structure as data, not expanded series
- EtaExpression captures eta quotient structure with level, weight, q-shift
- Newman's four modularity conditions are correctly checked by check_modularity()
- to_series() on both types produces FPS matching independent computation via jacprod/etaq
- from_etaquotient() converts from existing prodmake types
- identity/ submodule is properly wired into qseries/mod.rs with re-exports
- mobius and divisors are pub(crate) for use by later plans
</success_criteria>

<output>
After completion, create `.planning/phases/07-identity-proving/07-01-SUMMARY.md`
</output>
