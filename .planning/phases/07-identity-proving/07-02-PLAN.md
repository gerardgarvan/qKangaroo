---
phase: 07-identity-proving
plan: "07-02"
title: "Cusp Computation and Order-at-Cusp Formulas"
wave: 2
depends_on: ["07-01"]
requirements: ["IDPR-03", "IDPR-04"]
files_modified:
  - crates/qsym-core/src/qseries/identity/mod.rs
files_created:
  - crates/qsym-core/src/qseries/identity/cusps.rs
  - crates/qsym-core/src/qseries/identity/orders.rs
  - crates/qsym-core/tests/qseries_identity_cusps_tests.rs
estimated_tasks: 3

must_haves:
  truths:
    - "cuspmake(N) returns the correct set of inequivalent cusps for Gamma_0(N) with count matching sum_{d|N} phi(gcd(d, N/d))"
    - "cuspmake1(N) returns the correct set of inequivalent cusps for Gamma_1(N)"
    - "num_cusps_gamma0(N) matches known values: N=1->1, N=2->2, N=4->3, N=6->4, N=12->6"
    - "eta_order_at_cusp correctly computes the Ligozat formula for known eta quotients at all cusps"
    - "The total weighted order across all cusps sums to 0 for weight-0 modular functions"
  artifacts:
    - path: "crates/qsym-core/src/qseries/identity/cusps.rs"
      provides: "Cusp struct, cuspmake, cuspmake1, num_cusps_gamma0, euler_phi, gcd helper"
      exports: ["Cusp", "cuspmake", "cuspmake1", "num_cusps_gamma0"]
    - path: "crates/qsym-core/src/qseries/identity/orders.rs"
      provides: "eta_order_at_cusp (Ligozat formula), cusp_width, total_order"
      exports: ["eta_order_at_cusp", "cusp_width", "total_order"]
    - path: "crates/qsym-core/tests/qseries_identity_cusps_tests.rs"
      provides: "Integration tests for cusp computation and order formulas"
      min_lines: 180
  key_links:
    - from: "crates/qsym-core/src/qseries/identity/orders.rs"
      to: "crates/qsym-core/src/qseries/identity/eta.rs"
      via: "EtaExpression input to order computation"
      pattern: "EtaExpression"
    - from: "crates/qsym-core/src/qseries/identity/orders.rs"
      to: "crates/qsym-core/src/qseries/identity/cusps.rs"
      via: "Cusp struct and cuspmake for iteration"
      pattern: "Cusp|cuspmake"
    - from: "crates/qsym-core/src/qseries/identity/cusps.rs"
      to: "crates/qsym-core/src/qseries/prodmake.rs"
      via: "divisors function for enumerating divisors of N"
      pattern: "prodmake::divisors"
---

<objective>
Implement cusp computation algorithms (cuspmake for Gamma_0(N), cuspmake1 for Gamma_1(N)) and the Ligozat order-at-cusp formula for eta quotients. These are the number-theoretic core of the proving engine.

Purpose: IDPR-03 and IDPR-04 require computing cusps and orders at cusps. The proving engine (Plan 07-03) needs to iterate over all cusps and check that orders are non-negative. Without correct cusp enumeration and order computation, no identity can be proved.

Output: cusps.rs and orders.rs modules with comprehensive tests against known values.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-identity-proving/07-RESEARCH.md

@crates/qsym-core/src/qseries/identity/mod.rs
@crates/qsym-core/src/qseries/identity/eta.rs
@crates/qsym-core/src/qseries/prodmake.rs
@crates/qsym-core/src/number.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cusp struct and cuspmake algorithms</name>
  <files>
    crates/qsym-core/src/qseries/identity/cusps.rs
    crates/qsym-core/src/qseries/identity/mod.rs
  </files>
  <action>
**Step 1: Update identity/mod.rs to declare new submodules.**

Add to the module declarations:
```rust
pub mod cusps;
pub mod orders;
```

Add to the re-exports:
```rust
pub use cusps::{Cusp, cuspmake, cuspmake1, num_cusps_gamma0};
pub use orders::{eta_order_at_cusp, cusp_width, total_order};
```

**Step 2: Create cusps.rs with Cusp, helper functions, and cusp enumeration.**

```rust
//! Cusp computation for congruence subgroups Gamma_0(N) and Gamma_1(N).
//!
//! A cusp of a congruence subgroup is an equivalence class of points in
//! P^1(Q) = Q union {infinity} under the action of the subgroup.
//!
//! This module provides:
//! - [`Cusp`]: representation of a cusp as a/c with gcd(a,c)=1
//! - [`cuspmake`]: enumerate cusps of Gamma_0(N) (Garvan's algorithm)
//! - [`cuspmake1`]: enumerate cusps of Gamma_1(N)
//! - [`num_cusps_gamma0`]: count cusps without enumerating
```

**Cusp struct** -- `#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]`:
```rust
pub struct Cusp {
    pub numer: i64,  // numerator a
    pub denom: i64,  // denominator c (0 for infinity, represented as 1/0)
}
```

Methods:
- `pub fn infinity() -> Self` -- returns `Cusp { numer: 1, denom: 0 }`
- `pub fn new(a: i64, c: i64) -> Self` -- creates cusp a/c, reducing to lowest terms via gcd. If c == 0, normalize to 1/0. If c < 0, negate both. Reduce: let g = gcd(a.abs(), c.abs()); store (a/g, c/g).
- `pub fn is_infinity(&self) -> bool` -- self.denom == 0
- `impl std::fmt::Display` -- format as "a/c" or "inf" for infinity

**Helper functions (pub(crate) so orders.rs can use them):**

```rust
pub(crate) fn gcd(a: i64, b: i64) -> i64 {
    let (mut a, mut b) = (a.abs(), b.abs());
    while b != 0 { let t = b; b = a % b; a = t; }
    a
}

pub(crate) fn euler_phi(n: i64) -> i64 {
    if n <= 0 { return 0; }
    let mut result = n;
    let mut m = n;
    let mut p = 2i64;
    while p * p <= m {
        if m % p == 0 {
            while m % p == 0 { m /= p; }
            result -= result / p;
        }
        p += 1;
    }
    if m > 1 {
        result -= result / m;
    }
    result
}
```

**num_cusps_gamma0(n: i64) -> i64:**
```rust
/// Number of cusps of Gamma_0(N) = sum_{d | N} phi(gcd(d, N/d))
pub fn num_cusps_gamma0(n: i64) -> i64 {
    use crate::qseries::prodmake::divisors;
    let mut count = 0i64;
    for d in divisors(n) {
        count += euler_phi(gcd(d, n / d));
    }
    count
}
```

**cuspmake(n: i64) -> Vec<Cusp>:**

Based on Garvan's ETA package algorithm (see research). Enumerates inequivalent cusps of Gamma_0(N).

```rust
/// Enumerate inequivalent cusps of Gamma_0(N).
///
/// Algorithm (Garvan's ETA package):
/// 1. Start with {infinity} (= 1/0)
/// 2. For each divisor c of N with c > 1:
///    a. Compute gc = gcd(c, N/c)
///    b. For each d in 1..c with gcd(d, c) = 1:
///       If d mod gc has not been seen for this c, add d/c as a new cusp
/// 3. Return all collected cusps
///
/// The number of cusps equals sum_{d|N} phi(gcd(d, N/d)).
pub fn cuspmake(n: i64) -> Vec<Cusp> {
    use crate::qseries::prodmake::divisors;

    assert!(n >= 1, "cuspmake: N must be >= 1, got {}", n);

    let mut cusps = vec![Cusp::infinity()];

    if n == 1 {
        return cusps;
    }

    let divs = divisors(n);
    for &c in &divs {
        if c <= 1 { continue; }
        let gc = gcd(c, n / c);
        let mut seen_residues: Vec<i64> = Vec::new();
        for d in 1..c {
            if gcd(d, c) != 1 { continue; }
            let r = d % gc;
            // Also check gc - r to handle the +/- equivalence
            // Two cusps d1/c and d2/c are equivalent if d1 = +/- d2 (mod gc)
            let r_neg = if r == 0 { 0 } else { gc - r };
            if !seen_residues.contains(&r) && !seen_residues.contains(&r_neg) {
                seen_residues.push(r);
                cusps.push(Cusp::new(d, c));
            }
        }
    }

    cusps
}
```

IMPORTANT: The equivalence for Gamma_0(N) cusps is: d1/c ~ d2/c iff d1 = d2 (mod gcd(c, N/c)) OR d1 = -d2 (mod gcd(c, N/c)). The +/- symmetry halves the count. Include this in the seen_residues check by also marking the negative residue as seen.

After implementation, add an assertion: `debug_assert_eq!(cusps.len() as i64, num_cusps_gamma0(n))` at the end of cuspmake to verify the count matches.

**cuspmake1(n: i64) -> Vec<Cusp>:**

```rust
/// Enumerate inequivalent cusps of Gamma_1(N).
///
/// Cusp equivalence for Gamma_1(N):
/// Two cusps u1/v1 and u2/v2 (with v1, v2 > 0, gcd(ui,vi)=1) are equivalent iff:
///   v1 = v2 and u1 = u2 (mod gcd(v1, N))
///   OR v1 = v2 and u1 = -u2 (mod gcd(v1, N)) [only when -I is in Gamma_1(N), i.e., N <= 2]
///
/// For N >= 3, -I is NOT in Gamma_1(N), so equivalence is stricter (no +/- folding).
///
/// Algorithm: For each divisor c of N, enumerate reduced fractions d/c
/// with 0 <= d < c, gcd(d,c) = 1, grouping by residue class d mod gcd(c, N).
pub fn cuspmake1(n: i64) -> Vec<Cusp> {
    use crate::qseries::prodmake::divisors;

    assert!(n >= 1, "cuspmake1: N must be >= 1, got {}", n);

    let mut cusps = vec![Cusp::infinity()];

    if n == 1 {
        return cusps;
    }

    let divs = divisors(n);
    for &c in &divs {
        if c <= 1 { continue; }
        let gc = gcd(c, n);  // Note: gcd(c, N) for Gamma_1, not gcd(c, N/c)
        let mut seen_residues: Vec<i64> = Vec::new();
        for d in 1..c {
            if gcd(d, c) != 1 { continue; }
            let r = d % gc;
            if n <= 2 {
                // -I in Gamma_1(N) for N <= 2, so +/- equivalence
                let r_neg = if r == 0 { 0 } else { gc - r };
                if !seen_residues.contains(&r) && !seen_residues.contains(&r_neg) {
                    seen_residues.push(r);
                    cusps.push(Cusp::new(d, c));
                }
            } else {
                // N >= 3: no +/- folding
                if !seen_residues.contains(&r) {
                    seen_residues.push(r);
                    cusps.push(Cusp::new(d, c));
                }
            }
        }
    }

    cusps
}
```

Note: cuspmake1 is less commonly used than cuspmake (most ETA identities use Gamma_0). The implementation should be correct but test coverage can be lighter.
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo build -p qsym-core 2>&1` compiles without errors.
  </verify>
  <done>
    Cusp struct with infinity(), new(), is_infinity(), Display. cuspmake(N) enumerates Gamma_0(N) cusps with +/- equivalence. cuspmake1(N) enumerates Gamma_1(N) cusps. num_cusps_gamma0(N) computes the count formula. Helper functions gcd and euler_phi are pub(crate).
  </done>
</task>

<task type="auto">
  <name>Task 2: Order-at-cusp computation via Ligozat formula</name>
  <files>
    crates/qsym-core/src/qseries/identity/orders.rs
  </files>
  <action>
Create `orders.rs` implementing the Ligozat formula for computing the order of vanishing of an eta quotient at a cusp.

```rust
//! Order of vanishing at cusps for eta quotients.
//!
//! Uses the Ligozat formula to compute the order of an eta quotient
//! at a cusp of Gamma_0(N), and provides cusp width computation.
```

**eta_order_at_cusp(eta: &EtaExpression, cusp: &Cusp) -> QRat:**

The Ligozat formula for the order of vanishing of f = prod eta(delta*tau)^{r_delta} at cusp c/d of Gamma_0(N):

```
ord_{c/d}(f) = (N / 24) * sum_{delta | N} [ gcd(d, delta)^2 * r_delta / (gcd(d, N/d) * d * delta) ]
```

Key insight: the order depends only on d (the denominator of the cusp), NOT on c (the numerator). For the cusp at infinity (1/0), use d = 0 which requires special handling: the order at infinity equals q_shift = sum(delta * r_delta) / 24.

Implementation:
```rust
pub fn eta_order_at_cusp(eta: &EtaExpression, cusp: &Cusp) -> QRat {
    let n = eta.level;

    if cusp.is_infinity() {
        // Order at infinity = q-shift = sum(delta * r_delta) / 24
        return eta.q_shift();
    }

    let d = cusp.denom.abs();
    let g = gcd(d, n / d);

    let mut sum = QRat::zero();
    for (&delta, &r_delta) in &eta.factors {
        if r_delta == 0 { continue; }
        let gcd_d_delta = gcd(d, delta);
        // Contribution: gcd(d, delta)^2 * r_delta / (gcd(d, N/d) * d * delta)
        let numer = gcd_d_delta * gcd_d_delta * r_delta;
        let denom = g * d * delta;
        sum = sum + QRat::from((numer, denom));
    }

    // Multiply by N/24
    sum * QRat::from((n, 24i64))
}
```

**cusp_width(n: i64, cusp: &Cusp) -> i64:**

The width of cusp c/d on Gamma_0(N).

```rust
/// Compute the width of a cusp on Gamma_0(N).
///
/// For cusp c/d (Garvan convention):
///   width = N / gcd(d^2, N)
///
/// For infinity (d=0): width = 1
pub fn cusp_width(n: i64, cusp: &Cusp) -> i64 {
    if cusp.is_infinity() {
        return 1;
    }
    let d = cusp.denom.abs();
    n / gcd(d * d, n)
}
```

Wait -- the research says "Width of cusp c/d on Gamma_0(N) = N / gcd(N, d^2) [Garvan convention]". But in cusp representation, the Cusp struct stores numer=a, denom=c, so the cusp is a/c. The "d" in the Ligozat formula corresponds to "c" (the denominator of the cusp fraction). Let me reconcile:

In the cusp a/c:
- c is the denominator
- The Ligozat formula uses d where d = c (the denominator)
- Width = N / gcd(c^2, N)

So cusp_width should use `cusp.denom`:
```rust
pub fn cusp_width(n: i64, cusp: &Cusp) -> i64 {
    if cusp.is_infinity() {
        return 1;
    }
    let c = cusp.denom.abs();
    n / gcd(c * c, n)
}
```

And eta_order_at_cusp should use `cusp.denom` as d in the formula. This is already correct in the code above since we set `d = cusp.denom.abs()`.

**total_order(eta: &EtaExpression, cusps: &[Cusp]) -> QRat:**

Compute the sum of weighted orders across all cusps. For a weight-0 modular function, this should be 0.

```rust
/// Compute the total weighted order of an eta quotient across all cusps.
///
/// total = sum_{cusp s} width(s) * ord_s(f)
///
/// For a weight-0 modular function on Gamma_0(N), this total should be 0.
pub fn total_order(eta: &EtaExpression, cusps: &[Cusp]) -> QRat {
    let n = eta.level;
    let mut total = QRat::zero();
    for cusp in cusps {
        let ord = eta_order_at_cusp(eta, cusp);
        let width = QRat::from((cusp_width(n, cusp), 1i64));
        total = total + ord * width;
    }
    total
}
```

Actually, re-reading the research more carefully:
- `cuspord(GP, cusp)` = invariant order = the Ligozat formula result
- `cuspORD(GP, N, cusp)` = weighted order = cuspord * width
- The valence formula says: sum of cuspORD across all cusps = k * index / 12, where k is the weight

For weight 0: sum of weighted orders = 0.

But for the proving engine, we actually care about the invariant orders being non-negative (not the weighted orders). The valence formula says: if f is a modular function (weight 0) with no poles, then sum of all orders (invariant) equals 0, and if all are >= 0, then f is constant.

Actually, re-checking: the sum of the invariant orders at all cusps (counting with appropriate multiplicity/width) should equal 0. But the key check for the proving engine is: "are ALL invariant orders >= 0?" If yes, f is constant.

Let me keep it simple. The `total_order` function computes the sum of `cusp_width * ord` as a correctness check. The proving engine (Plan 07-03) will check each individual order.

Imports:
```rust
use crate::number::QRat;
use super::cusps::{Cusp, gcd};
use super::eta::EtaExpression;
```
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo build -p qsym-core 2>&1` compiles without errors.
  </verify>
  <done>
    eta_order_at_cusp implements the Ligozat formula using QRat exact arithmetic. cusp_width computes N/gcd(c^2, N). total_order sums weighted orders across all cusps. Special case for infinity handled correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for cusp computation and orders</name>
  <files>
    crates/qsym-core/tests/qseries_identity_cusps_tests.rs
  </files>
  <action>
Create integration test file with thorough tests against known values from the research document and standard references.

**Imports:**
```rust
use qsym_core::number::QRat;
use qsym_core::qseries::identity::{
    Cusp, cuspmake, cuspmake1, num_cusps_gamma0,
    EtaExpression, eta_order_at_cusp, cusp_width, total_order,
};
use std::collections::BTreeMap;

fn qrat(n: i64, d: i64) -> QRat {
    QRat::from((n, d))
}
```

**Test group 1: num_cusps_gamma0 -- known cusp counts**
```rust
#[test]
fn num_cusps_gamma0_known_values() {
    assert_eq!(num_cusps_gamma0(1), 1);
    assert_eq!(num_cusps_gamma0(2), 2);
    assert_eq!(num_cusps_gamma0(3), 2);
    assert_eq!(num_cusps_gamma0(4), 3);
    assert_eq!(num_cusps_gamma0(5), 2);
    assert_eq!(num_cusps_gamma0(6), 4);
    assert_eq!(num_cusps_gamma0(7), 2);
    assert_eq!(num_cusps_gamma0(8), 4);
    assert_eq!(num_cusps_gamma0(10), 4);
    assert_eq!(num_cusps_gamma0(12), 6);
    assert_eq!(num_cusps_gamma0(24), 8);
    assert_eq!(num_cusps_gamma0(36), 12);
}
```

**Test group 2: cuspmake -- correct cusps for small N**

```rust
#[test]
fn cuspmake_n1() {
    let cusps = cuspmake(1);
    assert_eq!(cusps.len(), 1);
    assert!(cusps.contains(&Cusp::infinity()));
}

#[test]
fn cuspmake_n2() {
    let cusps = cuspmake(2);
    assert_eq!(cusps.len(), 2);
    assert!(cusps.contains(&Cusp::infinity()));
    assert!(cusps.contains(&Cusp::new(1, 2)));  // = 0 cusp (but represented as 1/2)
}

#[test]
fn cuspmake_n4() {
    let cusps = cuspmake(4);
    assert_eq!(cusps.len(), 3);
    assert!(cusps.contains(&Cusp::infinity()));
    // Should contain cusps with denominators 2 and 4
}

#[test]
fn cuspmake_n6() {
    let cusps = cuspmake(6);
    assert_eq!(cusps.len(), 4);
    // Known cusps: infinity (1/0), and cusps with denom 2, 3, 6
}

#[test]
fn cuspmake_n12() {
    let cusps = cuspmake(12);
    assert_eq!(cusps.len(), 6);
}

#[test]
fn cuspmake_count_matches_formula() {
    // Verify cuspmake output length matches num_cusps_gamma0 for N = 1..50
    for n in 1..=50 {
        let cusps = cuspmake(n);
        let expected = num_cusps_gamma0(n) as usize;
        assert_eq!(cusps.len(), expected,
            "cuspmake({}) returned {} cusps, expected {}", n, cusps.len(), expected);
    }
}
```

**Test group 3: Cusp struct**
```rust
#[test]
fn cusp_infinity() {
    let inf = Cusp::infinity();
    assert!(inf.is_infinity());
    assert_eq!(inf.numer, 1);
    assert_eq!(inf.denom, 0);
}

#[test]
fn cusp_new_reduces() {
    let c = Cusp::new(2, 4);
    assert_eq!(c.numer, 1);
    assert_eq!(c.denom, 2);
}

#[test]
fn cusp_display() {
    assert_eq!(format!("{}", Cusp::infinity()), "inf");
    assert_eq!(format!("{}", Cusp::new(1, 3)), "1/3");
}
```

**Test group 4: cusp_width**
```rust
#[test]
fn cusp_width_infinity() {
    assert_eq!(cusp_width(12, &Cusp::infinity()), 1);
}

#[test]
fn cusp_width_values_n12() {
    // For Gamma_0(12):
    // width(inf) = 1 (d=0 -> special case)
    // width(1/2) = 12/gcd(4,12) = 12/4 = 3
    // width(1/3) = 12/gcd(9,12) = 12/3 = 4
    // width(1/4) = 12/gcd(16,12) = 12/4 = 3
    // width(1/6) = 12/gcd(36,12) = 12/12 = 1
    // width(0) = width(1/12) = 12/gcd(144,12) = 12/12 = 1
    assert_eq!(cusp_width(12, &Cusp::new(1, 2)), 3);
    assert_eq!(cusp_width(12, &Cusp::new(1, 3)), 4);
    assert_eq!(cusp_width(12, &Cusp::new(1, 4)), 3);
    assert_eq!(cusp_width(12, &Cusp::new(1, 6)), 1);
}
```

**Test group 5: eta_order_at_cusp -- Ligozat formula**

Test with the known modular function f = eta(5*tau)^6 / eta(tau)^6 on Gamma_0(5):
```rust
#[test]
fn eta_order_at_cusp_level5() {
    let eta = EtaExpression::from_factors(&[(1, -6), (5, 6)], 5);
    let cusps = cuspmake(5);
    assert_eq!(cusps.len(), 2); // infinity and 0 (represented as 1/5 or similar)

    // Order at infinity = q_shift = sum(delta*r_delta)/24 = (-6 + 30)/24 = 24/24 = 1
    let ord_inf = eta_order_at_cusp(&eta, &Cusp::infinity());
    assert_eq!(ord_inf, qrat(1, 1));

    // Find the non-infinity cusp
    let other_cusp = cusps.iter().find(|c| !c.is_infinity()).unwrap();
    let ord_other = eta_order_at_cusp(&eta, other_cusp);

    // For weight-0 modular function, total weighted order should be 0
    let total = total_order(&eta, &cusps);
    assert_eq!(total, qrat(0, 1),
        "Total weighted order should be 0 for weight-0 modular function");
}
```

**Test group 6: total_order sanity check**
```rust
#[test]
fn total_order_zero_for_modular_function() {
    // eta(2*tau)^12 / (eta(tau)^6 * eta(4*tau)^6) on Gamma_0(4)
    // factors = {1: -6, 2: 12, 4: -6}, level = 4
    // weight = (-6+12-6)/2 = 0
    let eta = EtaExpression::from_factors(&[(1, -6), (2, 12), (4, -6)], 4);
    let cusps = cuspmake(4);
    let total = total_order(&eta, &cusps);
    assert_eq!(total, qrat(0, 1));
}
```

**Test group 7: eta_order_at_cusp -- all orders non-negative**
```rust
#[test]
fn eta_orders_nonnegative_for_known_identity() {
    // f = eta(5*tau)^6 / eta(tau)^6 is a modular function on Gamma_0(5)
    // with non-negative orders at all cusps (it's a holomorphic modular function)
    let eta = EtaExpression::from_factors(&[(1, -6), (5, 6)], 5);
    let cusps = cuspmake(5);
    for cusp in &cusps {
        let ord = eta_order_at_cusp(&eta, cusp);
        assert!(ord >= qrat(0, 1),
            "Order at cusp {} should be >= 0, got {}", cusp, ord);
    }
}
```

**Test group 8: cuspmake1 basic test**
```rust
#[test]
fn cuspmake1_n1() {
    let cusps = cuspmake1(1);
    assert_eq!(cusps.len(), 1);
}

#[test]
fn cuspmake1_n5() {
    // Gamma_1(5) has more cusps than Gamma_0(5)
    let cusps1 = cuspmake1(5);
    let cusps0 = cuspmake(5);
    assert!(cusps1.len() >= cusps0.len(),
        "Gamma_1(N) should have at least as many cusps as Gamma_0(N)");
}
```
  </action>
  <verify>
    `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib --tests -p qsym-core --test qseries_identity_cusps_tests 2>&1` -- all tests pass.

    Also verify no regressions: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib --tests -p qsym-core 2>&1` -- all existing tests still pass.
  </verify>
  <done>
    All cusp computation tests pass: num_cusps_gamma0 matches known values for N=1..50, cuspmake produces correct cusp sets verified by count formula, cuspmake1 produces valid Gamma_1(N) cusps, Ligozat formula gives correct orders at cusps for known eta quotients, total weighted order is 0 for weight-0 modular functions, and all orders are non-negative for known holomorphic modular functions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-core` -- compiles without errors
2. `cargo test -p qsym-core --test qseries_identity_cusps_tests` -- all tests pass
3. `cargo test -p qsym-core` -- all existing tests still pass (no regressions)
4. cuspmake(N).len() == num_cusps_gamma0(N) for N = 1..50
5. total_order is 0 for weight-0 modular functions on at least 2 different levels
</verification>

<success_criteria>
- cuspmake(N) correctly enumerates Gamma_0(N) cusps with count matching sum_{d|N} phi(gcd(d, N/d)) for all N up to 50
- cuspmake1(N) correctly enumerates Gamma_1(N) cusps
- eta_order_at_cusp produces exact QRat results via the Ligozat formula
- cusp_width computes N/gcd(c^2, N) correctly
- total_order sums to 0 for known weight-0 modular functions
- All helper functions (gcd, euler_phi) are pub(crate) for reuse
</success_criteria>

<output>
After completion, create `.planning/phases/07-identity-proving/07-02-SUMMARY.md`
</output>
