---
phase: 08-mock-theta-bailey-chains
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/mock_theta.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_mock_theta_tests.rs
autonomous: true

must_haves:
  truths:
    - "Third-order mock theta functions f, phi, psi, chi, omega, nu, rho produce correct coefficients matching OEIS A000025, A053250, A053251, A053252, A053253, A053254, A053255"
    - "Fifth-order mock theta functions f0, f1, F0, F1, phi0, phi1, psi0, psi1, chi0, chi1 produce correct coefficients matching OEIS sequences"
    - "Seventh-order mock theta functions F0_7, F1_7, F2_7 produce correct series expansions"
    - "All mock theta functions handle truncation_order correctly and terminate"
  artifacts:
    - path: "crates/qsym-core/src/qseries/mock_theta.rs"
      provides: "All 20 classical mock theta function implementations"
      min_lines: 400
    - path: "crates/qsym-core/tests/qseries_mock_theta_tests.rs"
      provides: "OEIS coefficient verification for all mock theta functions"
      min_lines: 200
  key_links:
    - from: "crates/qsym-core/src/qseries/mock_theta.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "FormalPowerSeries::zero/one/monomial + arithmetic::add/mul/invert"
      pattern: "arithmetic::(add|mul|invert)"
    - from: "crates/qsym-core/src/qseries/mock_theta.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "aqprod for q-Pochhammer denominator factors"
      pattern: "aqprod"
    - from: "crates/qsym-core/src/qseries/mod.rs"
      to: "crates/qsym-core/src/qseries/mock_theta.rs"
      via: "pub mod + pub use re-exports"
      pattern: "pub mod mock_theta"
---

<objective>
Implement all 20 classical mock theta functions (7 third-order, 10 fifth-order, 3 seventh-order) as explicit q-series with term-by-term accumulation and incremental denominator products.

Purpose: PART-04 and PART-05 require correct series expansions of Ramanujan's mock theta functions, verified against published OEIS tables. These are the foundational objects that Appell-Lerch sums (Plan 02) will unify.

Output: `mock_theta.rs` with 20 public functions, all producing FormalPowerSeries with correct coefficients.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mock-theta-bailey-chains/08-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/series/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock_theta.rs with all 20 classical mock theta functions</name>
  <files>
    crates/qsym-core/src/qseries/mock_theta.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/mock_theta.rs` with:

**Helper functions (private):**

1. `fn make_factor_1_plus_q_m(m: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Returns `1 + q^m` as FPS (for (-q;q)_n factors). If m >= truncation_order, return FPS::one.

2. `fn make_factor_1_minus_q_m(m: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Returns `1 - q^m` as FPS (for (q;q^2)_n factors).

3. `fn make_factor_cyclotomic3(m: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Returns `1 - q^m + q^{2m}` as FPS (for chi and rho non-Pochhammer factors). Set coefficients: constant=1, q^m=-1, q^{2m}=+1.

4. `fn make_factor_1_plus_q_m_plus_q2m(m: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Returns `1 + q^m + q^{2m}` as FPS (for rho factors). Set coefficients: constant=1, q^m=+1, q^{2m}=+1.

**Third-order mock theta functions (7 functions, all pub):**

All functions have signature: `pub fn mock_theta_XXX(variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

Use the naming convention: `mock_theta_f3` (third-order f), `mock_theta_phi3` (third-order phi), etc.

1. `mock_theta_f3`: f(q) = sum_{n>=0} q^{n^2} / (-q;q)_n^2. Maintain running denominator `denom_sq` starting at FPS::one. Each step: compute term = q^{n^2} * invert(denom_sq), add to result, then update denom_sq *= (1+q^{n+1})^2. Break when n^2 >= truncation_order.

2. `mock_theta_phi3`: phi(q) = sum_{n>=0} q^{n^2} / (-q^2;q^2)_n. Maintain running denominator. Each step: term = q^{n^2} * invert(denom), add to result, then denom *= (1+q^{2(n+1)}). Note the step-2 base: factors are (1+q^2)(1+q^4)(1+q^6)...

3. `mock_theta_psi3`: psi(q) = sum_{n>=1} q^{n^2} / (q;q^2)_n. Starts at n=1. Maintain running denominator. Each step: denom *= (1-q^{2n-1}), then term = q^{n^2} * invert(denom). Factors are (1-q)(1-q^3)(1-q^5)...

4. `mock_theta_chi3`: chi(q) = sum_{n>=0} q^{n^2} / prod_{k=1}^{n} (1-q^k+q^{2k}). Maintain running denominator using make_factor_cyclotomic3. Each step: for n>0 update denom *= cyclotomic3(n), then term = q^{n^2} * invert(denom). For n=0, denom is 1 (empty product).

5. `mock_theta_omega3`: omega(q) = sum_{n>=0} q^{2n(n+1)} / (q;q^2)_{n+1}^2. Running denominator squared. Each step: first update denom *= (1-q^{2n+1}), then term = q^{2n(n+1)} * invert(denom_sq). Break when 2n(n+1) >= truncation_order.

6. `mock_theta_nu3`: nu(q) = sum_{n>=0} q^{n(n+1)} / (-q;q^2)_{n+1}. Running denominator. Each step: first update denom *= (1+q^{2n+1}), note factors are (1+q)(1+q^3)(1+q^5)... , then term = q^{n(n+1)} * invert(denom). Break when n(n+1) >= truncation_order.

7. `mock_theta_rho3`: rho(q) = sum_{n>=0} q^{2n(n+1)} / prod_{k=0}^{n} (1+q^{2k+1}+q^{4k+2}). Running denominator using make_factor_1_plus_q_m_plus_q2m. Each step: update denom *= factor(2n+1), term = q^{2n(n+1)} * invert(denom). Break when 2n(n+1) >= truncation_order.

**Fifth-order mock theta functions (10 functions):**

Use naming convention: `mock_theta_f0_5`, `mock_theta_f1_5`, `mock_theta_F0_5` (capital F), etc.

1. `mock_theta_f0_5`: f0(q) = sum_{n>=0} q^{n^2} / (-q;q)_n. Single (-q;q)_n denominator (not squared). Incremental denom *= (1+q^{n+1}).

2. `mock_theta_f1_5`: f1(q) = sum_{n>=0} q^{n^2+n} / (-q;q)_n. Same denominator pattern as f0, but numerator q^{n^2+n}.

3. `mock_theta_cap_f0_5`: F0(q) = sum_{n>=0} q^{2n^2} / (q;q^2)_n. Denominator (q;q^2)_n = (1-q)(1-q^3)...(1-q^{2n-1}). For n=0, denom=1. For n>=1, denom *= (1-q^{2n-1}).

4. `mock_theta_cap_f1_5`: F1(q) = sum_{n>=0} q^{2n^2+2n} / (q;q^2)_{n+1}. Denominator starts with (1-q) for n=0. Each step: update denom *= (1-q^{2n+1}).

5. `mock_theta_phi0_5`: phi0(q) = sum_{n>=0} (-q;q^2)_n * q^{n^2}. NUMERATOR product: maintain running numerator numer *= (1+q^{2n-1}) for n>=1. Term = numer * q^{n^2}. For n=0, numer=1 (empty product).

6. `mock_theta_phi1_5`: phi1(q) = sum_{n>=0} (-q;q^2)_n * q^{(n+1)^2}. Same numerator as phi0, but power is (n+1)^2.

7. `mock_theta_psi0_5`: psi0(q) = sum_{n>=0} (-1;q)_n * q^{n(n+1)/2}. (-1;q)_n = prod_{k=0}^{n-1}(1+q^k) = (1+1)(1+q)(1+q^2)...(1+q^{n-1}). For n=0, empty product = 1. For n=1, factor is (1+q^0)=2. Maintain running numerator. Note: (-1;q)_n involves a factor (1+q^0) = 2 at k=0. The q^{n(n+1)/2} exponent must be computed carefully: for n=0 gives 0, n=1 gives 1, n=2 gives 3, etc. Only include terms where n(n+1)/2 is an integer (it always is).

8. `mock_theta_psi1_5`: psi1(q) = sum_{n>=0} (-q;q)_n * q^{n(n+1)/2}. (-q;q)_n = (1+q)(1+q^2)...(1+q^n). For n=0, empty product = 1. Different from psi0: starts with factor (1+q) not (1+1).

9. `mock_theta_chi0_5`: chi0(q) = 2*F0(q) - phi0(-q). Compute from already-defined functions. For phi0(-q), substitute: pass QMonomial::new(-QRat::one(), 0) as the "negate q" parameter. ACTUALLY: phi0(-q) means evaluate phi0 with q replaced by -q. Since FPS is in q, implement a helper `negate_variable(fps)` that maps coeff[k] -> coeff[k] * (-1)^k. Then chi0 = 2*F0 - negate_variable(phi0).

10. `mock_theta_chi1_5`: chi1(q) = 2*F1(q) + q^{-1}*phi1(-q). The q^{-1} factor means shifting the series down by 1 power. Implement as: compute phi1_neg = negate_variable(phi1), shift by -1, then add 2*F1. Use FPS shift or manual coefficient remapping. IMPORTANT: if q^{-1} leads to negative powers, compute phi1(-q) first, check that its lowest power is >= 1 (so the shift produces non-negative powers), then remap coefficients.

**Helper for fifth-order chi functions:**
`fn negate_variable(fps: &FormalPowerSeries) -> FormalPowerSeries` -- returns new FPS where coeff[k] *= (-1)^k. This is the formal substitution q -> -q.

**Seventh-order mock theta functions (3 functions):**

1. `mock_theta_cap_f0_7`: F0(q) = sum_{n>=0} q^{n^2} / (q^{n+1};q)_n. Denominator (q^{n+1};q)_n = (1-q^{n+1})(1-q^{n+2})...(1-q^{2n}). For n=0, empty product = 1. Each n requires computing a fresh denominator product since the base shifts with n. Use aqprod with a=QMonomial::q_power(n+1), order=Finite(n).

2. `mock_theta_cap_f1_7`: F1(q) = sum_{n>=0} q^{n^2} / (q^n;q)_n. Denominator (q^n;q)_n = (1-q^n)(1-q^{n+1})...(1-q^{2n-1}). For n=0, empty product = 1. For n=1, (1-q). Use aqprod with a=QMonomial::q_power(n), order=Finite(n). CAREFUL: for n=1, a=q^1, order=1 gives (1-q), correct. For n=0, order=0 gives 1, correct.

3. `mock_theta_cap_f2_7`: F2(q) = sum_{n>=0} q^{n^2+n} / (q^{n+1};q)_{n+1}. Denominator (q^{n+1};q)_{n+1} = (1-q^{n+1})...(1-q^{2n+1}). Use aqprod with a=QMonomial::q_power(n+1), order=Finite(n+1).

NOTE for seventh-order: The denominator base shifts with n, so we CANNOT use incremental products. Use aqprod directly for each n. This is O(N^2) per function which is acceptable since the q^{n^2} exponent limits N to about sqrt(truncation_order).

**Module registration in mod.rs:**
- Add `pub mod mock_theta;` to the module declarations
- Add `pub use mock_theta::*;` or selectively re-export all 20 functions
- Update the module doc comment to mention mock theta functions

Do NOT add Python bindings in this plan (that is Plan 04).
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build 2>&1 | tail -5` -- must compile without errors.
  </verify>
  <done>mock_theta.rs exists with 20 pub functions (7 third-order, 10 fifth-order, 3 seventh-order), all compiling. Module registered in mod.rs with re-exports.</done>
</task>

<task type="auto">
  <name>Task 2: OEIS verification tests for all 20 mock theta functions</name>
  <files>
    crates/qsym-core/tests/qseries_mock_theta_tests.rs
  </files>
  <action>
Create `crates/qsym-core/tests/qseries_mock_theta_tests.rs` with comprehensive coefficient verification.

**Test setup:**
```rust
use qsym_core::symbol::SymbolRegistry;
use qsym_core::qseries::*;
use qsym_core::number::{QRat, QInt};

fn var() -> qsym_core::symbol::SymbolId {
    let mut reg = SymbolRegistry::new();
    reg.intern("q")
}
```

**Third-order tests (7 tests):**

1. `test_mock_theta_f3_oeis` -- OEIS A000025: Verify first 15+ coefficients. f(q) = 1 + q - 2q^2 + 3q^3 - 3q^4 + 3q^5 - 5q^6 + 7q^7 - 6q^8 + 6q^9 - 10q^10 + 12q^11 - 11q^12 + ... Use truncation_order=20.

2. `test_mock_theta_phi3_oeis` -- OEIS A053250: phi(q) starts 1, 1, 0, -1, 1, 1, -1, -1, 0, 2, ... Verify first 12+ terms.

3. `test_mock_theta_psi3_oeis` -- OEIS A053251: psi(q) starts 0, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5, ... (note: starts with 0 since sum starts at n=1). Verify first 12+ terms.

4. `test_mock_theta_chi3_oeis` -- OEIS A053252: chi(q) starts 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, -1, ... Verify first 12+ terms.

5. `test_mock_theta_omega3_coefficients` -- OEIS A053253: verify against published values. omega(q) = sum q^{2n(n+1)}/(q;q^2)_{n+1}^2. Use truncation_order=30 to get enough nonzero terms.

6. `test_mock_theta_nu3_coefficients` -- OEIS A053254: verify against published values.

7. `test_mock_theta_rho3_coefficients` -- OEIS A053255: verify against published values.

**Fifth-order tests (10 tests):**

8. `test_mock_theta_f0_5_oeis` -- OEIS A053256: f0(q) starts 1, 1, -1, 1, 0, 0, -1, 1, 0, 1, -2, ... Verify first 12+ terms.

9-17. Similar tests for f1_5, cap_f0_5, cap_f1_5, phi0_5, phi1_5, psi0_5, psi1_5, chi0_5, chi1_5 with known OEIS coefficients.

**Seventh-order tests (3 tests):**

18-20. Tests for cap_f0_7, cap_f1_7, cap_f2_7 verifying first 10+ coefficients.

**IMPORTANT for OEIS verification:** When exact OEIS sequences are not available from memory, verify structural properties instead:
- Check that constant term matches expected value (0 or 1)
- Check that coefficients are integers (QRat with denominator 1)
- Check relationships between functions (e.g., chi0 = 2*F0 - phi0(-q))
- Check consistency: evaluating at higher truncation_order doesn't change lower coefficients

**Additional structural tests:**

21. `test_mock_theta_chi0_5_relation` -- Verify chi0(q) = 2*F0(q) - phi0(-q) by computing all three independently and checking equality.

22. `test_mock_theta_chi1_5_relation` -- Verify chi1(q) = 2*F1(q) + q^{-1}*phi1(-q).

23. `test_mock_theta_truncation_consistency` -- For f3, verify that computing with truncation_order=20 and truncation_order=50 gives the same first 20 coefficients.

24. `test_mock_theta_all_functions_terminate` -- Call each of the 20 functions with truncation_order=30, verify they return without hanging and produce non-trivial results (not all zeros except where expected).

Target: 20+ tests covering all functions.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test mock_theta 2>&1 | tail -20` -- all tests pass.
  </verify>
  <done>All 20 mock theta functions produce correct coefficients verified against OEIS data and structural relations. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test mock_theta` -- all mock theta tests pass
3. `cargo test` -- all existing tests still pass (no regressions)
4. mock_theta.rs contains 20 pub functions
5. mod.rs re-exports all 20 functions
</verification>

<success_criteria>
- All 20 classical mock theta functions implemented with correct term-by-term accumulation
- Incremental denominator products used (not recomputed each step) for O(N^2) not O(N^3) complexity
- Non-Pochhammer factors (chi, rho) handled via explicit polynomial FPS factors
- OEIS coefficients match for all functions with available sequences
- Fifth-order chi0/chi1 computed correctly via composition relations
- Seventh-order functions use aqprod with shifted base parameters
</success_criteria>

<output>
After completion, create `.planning/phases/08-mock-theta-bailey-chains/08-01-SUMMARY.md`
</output>
