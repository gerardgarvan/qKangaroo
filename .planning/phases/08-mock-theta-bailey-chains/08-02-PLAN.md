---
phase: 08-mock-theta-bailey-chains
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/appell_lerch.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_appell_lerch_tests.rs
autonomous: true

must_haves:
  truths:
    - "Appell-Lerch sum m(q^a, q, q^b) computes correctly as FPS for integer specializations a, b"
    - "Universal mock theta functions g2(q^a, q) and g3(q^a, q) produce correct series expansions"
    - "Appell-Lerch sums satisfy known functional equations when verified via FPS comparison"
    - "Zwegers completion is represented symbolically and completion relations are verifiable"
  artifacts:
    - path: "crates/qsym-core/src/qseries/appell_lerch.rs"
      provides: "Appell-Lerch m(x,q,z), universal mock theta g2/g3, ZwegersCompletion"
      min_lines: 250
    - path: "crates/qsym-core/tests/qseries_appell_lerch_tests.rs"
      provides: "Tests for Appell-Lerch sums, g2/g3, functional equations"
      min_lines: 150
  key_links:
    - from: "crates/qsym-core/src/qseries/appell_lerch.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "aqprod for Jacobi theta j(z;q) and Pochhammer products"
      pattern: "aqprod"
    - from: "crates/qsym-core/src/qseries/appell_lerch.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "FPS arithmetic for bilateral sum accumulation"
      pattern: "arithmetic::(add|mul|invert)"
    - from: "crates/qsym-core/src/qseries/mod.rs"
      to: "crates/qsym-core/src/qseries/appell_lerch.rs"
      via: "pub mod + pub use re-exports"
      pattern: "pub mod appell_lerch"
---

<objective>
Implement Appell-Lerch sums m(x,q,z), universal mock theta functions g2 and g3, and Zwegers completion symbolic representation.

Purpose: PART-07 (Appell-Lerch sums), PART-08 (universal mock theta), and PART-06 (Zwegers completions) provide the unifying framework that connects all classical mock theta functions. The Appell-Lerch sum m(x,q,z) is the canonical building block; g2/g3 are the universal mock theta functions through which all classical mock theta functions can be expressed.

Output: `appell_lerch.rs` with bilateral sum evaluation, geometric series expansion, universal mock theta functions, and symbolic Zwegers completion struct.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mock-theta-bailey-chains/08-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/series/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create appell_lerch.rs with m(x,q,z), g2, g3, and Zwegers completion</name>
  <files>
    crates/qsym-core/src/qseries/appell_lerch.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/appell_lerch.rs` with:

**Helper functions (private):**

1. `fn geometric_series_q_power(k: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Returns 1/(1 - q^k) as FPS, computed as sum_{m>=0} q^{mk} for mk < truncation_order. If k == 0, this diverges -- return a panic since 1/(1-1) is undefined (caller must avoid). If k < 0, this means 1/(1 - q^{-|k|}) = -q^{|k|} / (1 - q^{|k|}) = -q^{|k|} * sum_{m>=0} q^{m|k|} -- careful with signs and shifts. ACTUALLY: for the Appell-Lerch sum, k = a_pow + r + z_pow which can be any integer including 0 and negative. If k > 0: standard geometric series. If k < 0: 1/(1-q^k) = 1/(1-q^{-|k|}) -- multiply numerator and denominator by q^{|k|}: = q^{|k|}/(q^{|k|}-1) = -q^{|k|}/(1-q^{|k|}) = -q^{|k|} * sum_{m>=0} q^{m|k|}. If k == 0: pole, skip this term in the bilateral sum.

2. `fn jacobi_theta_j(z_pow: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries` -- Computes j(q^z_pow; q) = (q^z_pow;q)_inf * (q^{1-z_pow};q)_inf * (q;q)_inf. Uses three calls to aqprod with PochhammerOrder::Infinite and multiplies.

**Public functions:**

1. `pub fn appell_lerch_m(a_pow: i64, z_pow: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

Computes m(q^{a_pow}, q, q^{z_pow}) following Hickerson-Mortenson notation:
```
m(x, q, z) = (1/j(z;q)) * sum_{r in Z} (-1)^r * q^{r(r-1)/2} * z^r / (1 - x*q^r*z)
```

Specializing x = q^{a_pow}, z = q^{z_pow}:
```
m(q^a, q, q^b) = (1/j(q^b;q)) * sum_{r in Z} (-1)^r * q^{r(r-1)/2 + b*r} / (1 - q^{a+r+b})
```

Implementation:
- Compute j_z_inv = invert(jacobi_theta_j(z_pow, ...))
- Bilateral sum: positive part (r >= 0) and negative part (r < 0)
- For each r, compute q_exp = r*(r-1)/2 + z_pow*r
- If q_exp >= truncation_order AND |r| > 0, break that direction
- The denominator power is denom_pow = a_pow + r + z_pow
- If denom_pow == 0: SKIP this r (pole in geometric series -- the contribution cancels in the full Appell-Lerch sum due to the j(z;q) prefactor)
- Otherwise: term = (-1)^r * q^{q_exp} * geometric_series(denom_pow, ...)
- Sum all terms, multiply by j_z_inv

IMPORTANT: For the negative r direction, compute r = -1, -2, -3, ... The q_exp = (-r)*(-r-1)/2 + z_pow*(-r) = r*(r+1)/2 - z_pow*r. Check sign carefully: for r negative, r*(r-1)/2 uses the actual negative r value.

2. `pub fn universal_mock_theta_g3(a_pow: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

g3(q^a, q) = sum_{n>=0} q^{n(n+1)/2} / [(q^a;q)_{n+1} * (q^{1-a};q)_{n+1}]

Implementation:
- Maintain running denominator incrementally is NOT straightforward here because the Pochhammer base depends on a_pow and shifts. Instead, for each n compute:
  - numer = q^{n(n+1)/2}
  - denom_part1 = aqprod(QMonomial::q_power(a_pow), variable, Finite(n+1), truncation_order)
  - denom_part2 = aqprod(QMonomial::q_power(1-a_pow), variable, Finite(n+1), truncation_order)
  - denom = mul(denom_part1, denom_part2)
  - term = mul(numer, invert(denom))
- Add each term to result. Break when n(n+1)/2 >= truncation_order.
- OPTIMIZATION: Actually we CAN maintain running products incrementally. denom_part1 for n+1 = denom_part1_for_n * (1 - q^{a_pow+n+1}). Similarly denom_part2. So maintain two running products and multiply by one new factor each step. This gives O(N^2) not O(N^3).

3. `pub fn universal_mock_theta_g2(a_pow: i64, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

g2(q^a, q) = q^{-a} * (-q;q)_inf * sum_{n>=0} q^{n(n+1)/2} * (-q;q)_n / [(q^a;q)_{n+1} * (q^{1-a};q)_{n+1}]

Implementation:
- Compute neg_q_inf = aqprod(QMonomial::new(-QRat::one(), 1), variable, Infinite, truncation_order)  -- this is (-q;q)_inf
- Maintain running products for (q^a;q)_{n+1} and (q^{1-a};q)_{n+1} incrementally
- Also maintain running (-q;q)_n product incrementally: numer_poch *= (1+q^{n+1})
- For each n: term = q^{n(n+1)/2} * numer_poch_n / (denom1_n * denom2_n)
- Sum all terms, multiply by neg_q_inf
- Shift by -a_pow: if a_pow > 0, this means the result has a q^{-a} prefactor. Since FPS can't represent negative powers, the caller must ensure a_pow >= 0 and handle the shift. For a_pow = 0, the q^{-a} = 1. For a_pow > 0, shift each coefficient: coeff[k] of inner sum becomes coeff[k-a_pow] of result. Implement as: compute inner sum, then create new FPS with shifted coefficients.

4. `pub struct ZwegersCompletion` -- Symbolic representation:

```rust
#[derive(Clone, Debug)]
pub struct ZwegersCompletion {
    /// Name of the mock theta function being completed
    pub mock_theta_name: String,
    /// The holomorphic part (the mock theta function itself as FPS)
    pub holomorphic_part: FormalPowerSeries,
    /// Description of the non-holomorphic correction R(z; tau)
    pub correction_description: String,
    /// Known modular weight of the completed form
    pub weight: (i64, i64),  // (numerator, denominator) for weight 1/2 etc.
    /// Known modular level
    pub level: i64,
}

impl ZwegersCompletion {
    /// Create a completion for a third-order mock theta function.
    /// The holomorphic part is the mock theta FPS; the non-holomorphic
    /// part is described symbolically (involves erfc, cannot be computed exactly).
    pub fn third_order(name: &str, holomorphic: FormalPowerSeries) -> Self { ... }

    /// Verify that two completions are compatible: their holomorphic parts
    /// satisfy a known linear relation when checked as FPS to the given order.
    pub fn verify_relation(&self, other: &ZwegersCompletion, relation_coeffs: &[(QRat, QRat)]) -> bool { ... }
}
```

This is a lightweight symbolic container -- NOT attempting to compute erfc. The weight for third-order mock theta completions is (1, 2) meaning weight 1/2.

**Module registration in mod.rs:**
- Add `pub mod appell_lerch;` (IMPORTANT: this plan modifies mod.rs independently of Plan 01 -- if running in parallel, Plan 01 adds mock_theta, Plan 02 adds appell_lerch. The executor should handle merge conflicts by combining both additions.)
- Add re-exports: `pub use appell_lerch::{appell_lerch_m, universal_mock_theta_g2, universal_mock_theta_g3, ZwegersCompletion};`
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build 2>&1 | tail -5` -- must compile without errors.
  </verify>
  <done>appell_lerch.rs compiles with appell_lerch_m, universal_mock_theta_g2, universal_mock_theta_g3, and ZwegersCompletion. Module registered in mod.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for Appell-Lerch sums, universal mock theta, and functional equations</name>
  <files>
    crates/qsym-core/tests/qseries_appell_lerch_tests.rs
  </files>
  <action>
Create `crates/qsym-core/tests/qseries_appell_lerch_tests.rs` with:

**Test setup:** Same var() helper as mock theta tests.

**Appell-Lerch sum tests:**

1. `test_appell_lerch_m_basic` -- Compute m(q, q, q) (a_pow=1, z_pow=1) with truncation_order=20. Verify the result is a well-formed FPS with rational coefficients. Check first few terms are nonzero.

2. `test_appell_lerch_m_symmetry` -- The Appell-Lerch sum satisfies m(x,q,z) + m(x,q,1/(qz)) = 0 when properly normalized (Hickerson-Mortenson Eq. 1.1b, up to additive correction). Test: compute m(q^2, q, q) and m(q^2, q, q^{-1}) -- check if their sum has specific structure (may be a theta function quotient).

3. `test_appell_lerch_m_different_params` -- Compute m(q^2, q, q^3) and m(q^3, q, q^2) with truncation_order=25. Verify both are non-trivial and have integer-looking coefficient denominators.

4. `test_appell_lerch_jacobi_theta_j` -- Verify that the Jacobi theta product j(q;q) = (q;q)_inf * (1;q)_inf * (q;q)_inf. Since (1;q)_inf = (1-1)(1-q)... = 0, j(q;q) should be zero-ish. Actually j(q^b;q) = 0 when b is an integer because (q^b;q)_inf has a factor (1-q^b*q^k) = (1-q^{b+k}) which is zero at k=0 when b=0. Test with z_pow=1: j(q;q) has factor (q;q)_inf which is nonzero, and (q^{1-1};q)_inf = (1;q)_inf which vanishes since first factor is (1-1)=0. So j(q;q) = 0. This means m(x,q,q) has a pole -- test that m with z_pow != 0 and z_pow not a non-positive integer works correctly.

ACTUALLY, re-examine: j(q^b;q) = (q^b;q)_inf * (q^{1-b};q)_inf * (q;q)_inf. For b=1: (q;q)_inf * (1;q)_inf * (q;q)_inf. (1;q)_inf = prod(1-q^k) for k=0,1,... = (1-1)(1-q)... = 0. So j = 0 when z = q (b=1). Similarly j=0 when b=0 (first factor has (1;q)_inf). The function m(x,q,z) is well-defined when z is NOT a power of q (i.e., z not in q^Z). For our specialization z = q^b, we need b to be a NON-INTEGER or accept that certain values give poles. In practice, use half-integer-like parameters by working with shifted sums.

REVISED approach: Test with z = -1 (not a power of q in the standard sense) or use b values where j doesn't vanish. The simplest non-degenerate case: work with Appell-Lerch sums at specific parameter values where the published literature gives known evaluations in terms of theta functions.

Better test strategy: Verify the Appell-Lerch sum reproduces known mock theta function representations. From the research: all classical mock theta functions can be expressed via m(x,q,z). Test that appell_lerch_m with appropriate parameters matches a known mock theta function (this verifies both the Appell-Lerch implementation and provides cross-validation with Plan 01's mock theta functions if available, or standalone verification if not).

5. `test_appell_lerch_m_avoids_degenerate_z` -- Verify that z_pow values where j(q^z_pow;q)=0 are handled (either by skipping poles or by documenting the restriction).

**Universal mock theta function tests:**

6. `test_g3_basic` -- Compute g3(q, q) (a_pow=1) with truncation_order=20. Verify nonzero result.

7. `test_g3_coefficients` -- Verify first several coefficients of g3(q^2, q) match expected values (cross-check with direct summation formula).

8. `test_g2_basic` -- Compute g2(q^2, q) (a_pow=2) with truncation_order=20. Verify result is well-formed. Use a_pow >= 2 to avoid the q^{-a} shift producing negative powers.

9. `test_g2_g3_relation` -- g2(x,q) and g3(x,q) satisfy known relations. The simplest: verify that g3(q,q) with truncation_order=20 produces coefficients consistent with being an odd-order mock theta function universal formula.

**Zwegers completion tests:**

10. `test_zwegers_completion_construction` -- Create a ZwegersCompletion for f3 (third-order f), verify fields are set correctly, weight is (1,2), level is 2.

11. `test_zwegers_completion_verify_relation` -- If two third-order mock theta completions are created, verify that their holomorphic parts can be compared.

**Structural tests:**

12. `test_appell_lerch_truncation_consistency` -- Compute m(q^2, q, q^3) at truncation_order=15 and 30, verify first 15 coefficients match.

13. `test_g3_incremental_denominator` -- Verify g3 produces correct results by computing with a small truncation and checking the first few terms manually. For n=0: q^0 / [(q^a;q)_1 * (q^{1-a};q)_1] = 1/[(1-q^a)(1-q^{1-a})].

Target: 12+ tests.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test appell_lerch 2>&1 | tail -20` -- all tests pass.
  </verify>
  <done>Appell-Lerch m(x,q,z) correctly evaluates as bilateral sum with geometric series expansion. Universal mock theta g2/g3 produce correct series. ZwegersCompletion provides symbolic representation. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test appell_lerch` -- all Appell-Lerch tests pass
3. `cargo test` -- all existing tests still pass (no regressions)
4. appell_lerch.rs contains appell_lerch_m, universal_mock_theta_g2, universal_mock_theta_g3, ZwegersCompletion
5. mod.rs re-exports all public items
</verification>

<success_criteria>
- Appell-Lerch sum m(q^a, q, q^b) evaluates correctly as bilateral FPS sum
- Bilateral sum handles both positive and negative r indices
- Geometric series expansion 1/(1-q^k) correctly handles positive, negative, and zero k
- Universal mock theta g2, g3 use incremental denominator products for efficiency
- ZwegersCompletion struct stores symbolic representation without attempting erfc computation
- Functional equations verified via FPS comparison
</success_criteria>

<output>
After completion, create `.planning/phases/08-mock-theta-bailey-chains/08-02-SUMMARY.md`
</output>
