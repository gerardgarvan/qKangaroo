---
phase: 08-mock-theta-bailey-chains
plan: "03"
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/bailey.rs
  - crates/qsym-core/src/qseries/mod.rs
  - crates/qsym-core/tests/qseries_bailey_tests.rs
autonomous: true

must_haves:
  truths:
    - "Bailey pair database stores unit, Rogers-Ramanujan, and q-Binomial pairs by type"
    - "Bailey lemma transforms a pair (alpha, beta) into a new pair (alpha', beta') that satisfies the Bailey pair relation"
    - "Bailey chain iteration (repeated lemma application) produces correct new pairs"
    - "Weak Bailey lemma identity holds when verified via FPS expansion"
  artifacts:
    - path: "crates/qsym-core/src/qseries/bailey.rs"
      provides: "BaileyPair, BaileyPairType, BaileyDatabase, bailey_lemma, bailey_chain, weak_bailey_lemma"
      min_lines: 350
    - path: "crates/qsym-core/tests/qseries_bailey_tests.rs"
      provides: "Tests for Bailey pair evaluation, lemma, chain, weak lemma"
      min_lines: 200
  key_links:
    - from: "crates/qsym-core/src/qseries/bailey.rs"
      to: "crates/qsym-core/src/qseries/pochhammer.rs"
      via: "aqprod for Pochhammer factors in pair evaluation and lemma"
      pattern: "aqprod"
    - from: "crates/qsym-core/src/qseries/bailey.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "FPS for weak Bailey lemma series evaluation"
      pattern: "FormalPowerSeries"
    - from: "crates/qsym-core/src/qseries/mod.rs"
      to: "crates/qsym-core/src/qseries/bailey.rs"
      via: "pub mod + pub use re-exports"
      pattern: "pub mod bailey"
---

<objective>
Implement Bailey pair database, Bailey lemma, chain iteration, and weak Bailey lemma for systematic q-series identity generation.

Purpose: PART-09 (Bailey pair database) and PART-10 (Bailey lemma and chain) provide the algebraic machinery for automated identity generation. The Bailey lemma is the engine that transforms known pairs into new ones, and chains of lemma applications produce infinite families of identities.

Output: `bailey.rs` with typed Bailey pair enum, evaluation methods, database, lemma application, chain iteration, and weak Bailey lemma.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mock-theta-bailey-chains/08-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/pochhammer.rs
@crates/qsym-core/src/series/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bailey.rs with pair types, database, lemma, and chain</name>
  <files>
    crates/qsym-core/src/qseries/bailey.rs
    crates/qsym-core/src/qseries/mod.rs
  </files>
  <action>
Create `crates/qsym-core/src/qseries/bailey.rs` with:

**Core types:**

```rust
use crate::number::QRat;
use crate::series::{FormalPowerSeries, arithmetic};
use crate::symbol::SymbolId;
use super::{QMonomial, PochhammerOrder, aqprod};
```

1. `BaileyPairType` enum (derive Clone, Debug):
   - `Unit` -- alpha_0 = 1, alpha_n = 0 for n > 0; beta_n = 1/[(q;q)_n * (aq;q)_n]
   - `RogersRamanujan` -- alpha_n per DLMF 17.12.6; beta_n = 1/(q;q)_n
   - `QBinomial { z: QRat }` -- alpha_n = (-1)^n * z^n * q^{n(n-1)/2}; beta_n involves (z;q)_n
   - `Tabulated { alphas: Vec<QRat>, betas: Vec<QRat> }` -- explicit coefficient tables (result of lemma application)

2. `BaileyPair` struct (derive Clone, Debug):
```rust
pub struct BaileyPair {
    pub name: String,
    pub pair_type: BaileyPairType,
    pub tags: Vec<String>,
}
```

Note: The parameter `a` is NOT stored in the pair -- it is passed at evaluation time. Most classical pairs are "relative to a" meaning they work for general a.

3. Evaluation methods on `BaileyPair`:

`pub fn alpha(&self, n: i64, a: &QMonomial, variable: SymbolId, truncation_order: i64) -> QRat`

For each pair type:
- **Unit:** if n == 0 return QRat::one(), else QRat::zero()
- **RogersRamanujan:**
  alpha_n = (a;q)_n * (1 - a*q^{2n}) * (-1)^n * q^{n(3n-1)/2} * a^n / [(q;q)_n * (1-a)]
  - (a;q)_n: evaluate aqprod at Finite(n), extract constant term (since a is a monomial, the "evaluation" means getting the rational coefficient from the FPS). ACTUALLY: for alpha/beta evaluation, we need the RATIONAL VALUE of the Pochhammer product at specific q-power arguments. Since (a;q)_n is a polynomial in q, and we need the value as a rational number... No, the Bailey pair coefficients alpha_n and beta_n are SEQUENCES of rationals (or q-series terms). alpha_n depends on n and involves q-powers.

  RE-THINK: alpha_n is NOT a single rational -- it involves powers of q. alpha_n = coefficient-sequence-in-q. For example, Rogers-Ramanujan alpha_n includes q^{n(3n-1)/2}. So alpha_n should return a QMonomial (coeff * q^power) or more generally an FPS term.

  BETTER APPROACH: Return the n-th alpha as an FPS term that contributes to the Bailey sum. For the weak Bailey lemma:
  sum_{n>=0} q^{n^2} * a^n * alpha_n = series in q

  So alpha_n needs to be something that when multiplied by q^{n^2} * a^n gives a q-series term.

  REVISED: alpha_n and beta_n should be computed as FPS contributions. Change the interface:

  `pub fn alpha_term(&self, n: i64, a: &QMonomial, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

  Returns the n-th alpha as an FPS. For Unit: alpha_0 = FPS::one, alpha_n = FPS::zero for n > 0. For Rogers-Ramanujan: returns the full product expression as FPS.

  `pub fn beta_term(&self, n: i64, a: &QMonomial, variable: SymbolId, truncation_order: i64) -> FormalPowerSeries`

  Returns the n-th beta as an FPS.

  For **Tabulated** type: alphas[n] and betas[n] are QRat scalars (no q-dependence), so return FPS::monomial with coeff=alphas[n], power=0.

**Pair evaluation implementations:**

For **Unit** pair relative to a (where a = c*q^p):
- alpha_term(0) = FPS::one. alpha_term(n>0) = FPS::zero.
- beta_term(n) = 1/[(q;q)_n * (a*q;q)_n]. Compute (q;q)_n via aqprod(q_power(1), Finite(n)) and (aq;q)_n via aqprod(a.mul(&QMonomial::q()), Finite(n)), multiply, invert.

For **RogersRamanujan** pair:
- alpha_term(n):
  - a_poch_n = aqprod(a, variable, Finite(n), trunc) -- this is (a;q)_n as FPS
  - one_minus_aq2n: FPS representing (1 - a*q^{2n}). Create as 1 - coeff*q^{a.power+2n}.
  - sign_factor = (-1)^n
  - q_power_factor = FPS::monomial(variable, sign_factor, n*(3*n-1)/2 + a.power*n, trunc)
  - q_q_n = aqprod(QMonomial::q(), Finite(n), trunc) -- (q;q)_n
  - one_minus_a: FPS representing (1 - a.coeff*q^{a.power})
  - alpha = a_poch_n * one_minus_aq2n * q_power_factor / (q_q_n * one_minus_a)
  - For n == 0: alpha_0 = (1)(1-a) * 1 * 1 / (1 * (1-a)) = 1.

- beta_term(n): 1/(q;q)_n. Compute aqprod(q_power(1), Finite(n)), invert.

For **QBinomial** pair with parameter z:
- alpha_term(n) = (-1)^n * z^n * q^{n(n-1)/2}. Return FPS::monomial.
- beta_term(n) = more complex, involves (z;q)_n and (q/z;q)_n.

For **Tabulated:**
- alpha_term(n) = FPS::monomial(variable, alphas[n], 0, trunc) if n < alphas.len(), else FPS::zero.
- beta_term(n) = FPS::monomial(variable, betas[n], 0, trunc) if n < betas.len(), else FPS::zero.

4. `pub fn verify_bailey_pair(pair: &BaileyPair, a: &QMonomial, max_n: i64, variable: SymbolId, truncation_order: i64) -> bool`

Verify the Bailey pair relation: beta_n = sum_{j=0}^{n} alpha_j / [(q;q)_{n-j} * (aq;q)_{n+j}].

For each n from 0 to max_n:
- Compute beta_n from pair.beta_term(n, ...)
- Compute the sum: sum_{j=0}^{n} alpha_j / [(q;q)_{n-j} * (aq;q)_{n+j}]
- Compare the two FPS (should be equal to truncation_order)

Return true if all match.

5. **Bailey lemma:**

`pub fn bailey_lemma(pair: &BaileyPair, a: &QMonomial, b: &QMonomial, c: &QMonomial, max_n: i64, variable: SymbolId, truncation_order: i64) -> BaileyPair`

Given (alpha, beta) relative to a, and parameters b, c, produce new pair (alpha', beta'):

alpha'_n = [(b;q)_n * (c;q)_n * (aq/(bc))^n] / [(aq/b;q)_n * (aq/c;q)_n] * alpha_n

beta'_n = [1/((aq/b;q)_n * (aq/c;q)_n)] * sum_{k=0}^{n} [(b;q)_k * (c;q)_k * (aq/(bc);q)_{n-k} * (aq/(bc))^k / (q;q)_{n-k}] * beta_k

Implementation:
- Precompute aq = a.mul(&QMonomial::q())
- aq_over_b = aq.div(b), aq_over_c = aq.div(c), aq_over_bc = aq.div(&b.mul(c))
- For each n 0..=max_n:
  - Compute alpha'_n by evaluating all Pochhammer factors via aqprod at Finite(n) and multiplying as FPS
  - Compute beta'_n by the inner sum over k
- Collect into BaileyPair with Tabulated type

Return BaileyPair { name: format!("lemma({}, b={:?}, c={:?})", pair.name, b, c), pair_type: Tabulated { ... }, tags: vec!["derived".into()] }

6. **Bailey chain:**

`pub fn bailey_chain(pair: &BaileyPair, a: &QMonomial, b: &QMonomial, c: &QMonomial, depth: usize, max_n: i64, variable: SymbolId, truncation_order: i64) -> Vec<BaileyPair>`

Apply bailey_lemma `depth` times with the same b, c parameters. Return the chain of pairs [original, after 1 application, after 2, ...].

7. **Weak Bailey lemma:**

`pub fn weak_bailey_lemma(pair: &BaileyPair, a: &QMonomial, max_n: i64, variable: SymbolId, truncation_order: i64) -> (FormalPowerSeries, FormalPowerSeries)`

The weak Bailey lemma states:
sum_{n>=0} q^{n^2} * a^n * beta_n = [1/(aq;q)_inf] * sum_{n>=0} q^{n^2} * a^n * alpha_n

Compute both sides and return (lhs, rhs). The caller can verify equality.

LHS: sum_{n=0}^{max_n} q^{n^2} * a^n * beta_term(n). The q^{n^2} * a^n means q^{n^2 + a.power*n} with coefficient a.coeff^n.

RHS: [1/(aq;q)_inf] * sum_{n=0}^{max_n} q^{n^2} * a^n * alpha_term(n). Compute (aq;q)_inf via aqprod, invert, multiply.

8. **Database:**

`pub struct BaileyDatabase { pairs: Vec<BaileyPair> }`

Methods:
- `pub fn new() -> Self` -- creates with default canonical pairs (Unit, RogersRamanujan, QBinomial with z=1)
- `pub fn add(&mut self, pair: BaileyPair)`
- `pub fn search_by_tag(&self, tag: &str) -> Vec<&BaileyPair>` -- case-insensitive
- `pub fn search_by_name(&self, name: &str) -> Vec<&BaileyPair>` -- case-insensitive substring
- `pub fn all_pairs(&self) -> &[BaileyPair]`
- `pub fn len(&self) -> usize`

**Module registration in mod.rs:**
- Add `pub mod bailey;`
- Add re-exports: `pub use bailey::{BaileyPair, BaileyPairType, BaileyDatabase, bailey_lemma, bailey_chain, weak_bailey_lemma, verify_bailey_pair};`
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build 2>&1 | tail -5` -- must compile without errors.
  </verify>
  <done>bailey.rs compiles with BaileyPair (4 type variants), evaluation methods, verify_bailey_pair, bailey_lemma, bailey_chain, weak_bailey_lemma, and BaileyDatabase. Module registered in mod.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for Bailey pairs, lemma, chain, and weak lemma</name>
  <files>
    crates/qsym-core/tests/qseries_bailey_tests.rs
  </files>
  <action>
Create `crates/qsym-core/tests/qseries_bailey_tests.rs` with:

**Test setup:**
```rust
use qsym_core::symbol::SymbolRegistry;
use qsym_core::qseries::*;
use qsym_core::number::{QRat, QInt};
use qsym_core::series::{FormalPowerSeries, arithmetic};

fn var() -> qsym_core::symbol::SymbolId {
    let mut reg = SymbolRegistry::new();
    reg.intern("q")
}
```

**Unit pair tests:**

1. `test_unit_pair_alpha` -- Verify alpha_0 = 1 (FPS::one), alpha_1 = 0, alpha_5 = 0.

2. `test_unit_pair_beta` -- For a = q (QMonomial::q()), verify beta_0 = 1 (empty products), beta_1 = 1/[(q;q)_1 * (q^2;q)_1] = 1/[(1-q)(1-q^2)]. Compute and check first few coefficients of the FPS.

3. `test_unit_pair_relation` -- Verify the Bailey pair relation holds for the unit pair with a = q, checking n = 0, 1, 2, 3 via verify_bailey_pair.

**Rogers-Ramanujan pair tests:**

4. `test_rr_pair_alpha_0` -- For a = q, verify alpha_0 of Rogers-Ramanujan pair is 1 (or FPS::one).

5. `test_rr_pair_alpha_1` -- For a = q, verify alpha_1 has the correct form: (q;q)_1 * (1-q^3) * (-1) * q^1 * q / [(q;q)_1 * (1-q)]. Simplify and check.

6. `test_rr_pair_relation` -- Verify the Bailey pair relation holds for Rogers-Ramanujan with a = q, checking n = 0, 1, 2 via verify_bailey_pair.

**QBinomial pair tests:**

7. `test_qbinomial_pair_alpha` -- For z=1: alpha_n = (-1)^n * q^{n(n-1)/2}. Check alpha_0 = 1, alpha_1 = -1, alpha_2 = q.

8. `test_qbinomial_pair_relation` -- Verify pair relation for z=1, a=q, n=0,1,2.

**Bailey lemma tests:**

9. `test_bailey_lemma_unit_pair` -- Apply bailey_lemma to unit pair with a=q, b=q^2, c=q^3, max_n=5. Verify the resulting Tabulated pair satisfies the Bailey pair relation (via verify_bailey_pair).

10. `test_bailey_lemma_preserves_relation` -- Apply lemma to Rogers-Ramanujan pair, verify the output pair satisfies the Bailey pair relation for n=0,1,2,3.

**Bailey chain tests:**

11. `test_bailey_chain_depth_1` -- Chain of depth 1 = [original, lemma(original)]. Verify length is 2.

12. `test_bailey_chain_depth_2` -- Chain of depth 2. Verify length is 3 and each pair satisfies the Bailey pair relation.

**Weak Bailey lemma tests:**

13. `test_weak_bailey_lemma_unit_pair` -- For unit pair with a=q: LHS = sum q^{n^2+n} * beta_n, RHS = 1/(q^2;q)_inf * sum q^{n^2+n} * alpha_n = 1/(q^2;q)_inf * q (only n=0 contributes to alpha sum). Verify LHS == RHS as FPS.

14. `test_weak_bailey_lemma_rr_pair` -- For Rogers-Ramanujan pair with a=1 (QMonomial::one()): the weak Bailey lemma should give the Rogers-Ramanujan identity. LHS = sum q^{n^2} * 1/(q;q)_n. Verify LHS equals a product form (related to 1/[(q;q^5)_inf * (q^4;q^5)_inf] -- first Rogers-Ramanujan identity).

**Database tests:**

15. `test_database_default_pairs` -- BaileyDatabase::new() has 3+ pairs (unit, R-R, q-binomial).

16. `test_database_search_by_tag` -- Search by tag "canonical" finds pairs.

17. `test_database_search_by_name` -- Search by name "rogers" finds Rogers-Ramanujan.

18. `test_database_add_pair` -- Add a custom Tabulated pair, verify it's findable.

Target: 15+ tests.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test bailey 2>&1 | tail -20` -- all tests pass.
  </verify>
  <done>All Bailey pair types evaluate correctly. Bailey lemma produces pairs that satisfy the relation. Chain iteration produces chains of valid pairs. Weak Bailey lemma verified via FPS comparison. Database search works. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test bailey` -- all Bailey tests pass
3. `cargo test` -- all existing tests still pass (no regressions)
4. bailey.rs contains BaileyPair with 4 type variants, verify_bailey_pair, bailey_lemma, bailey_chain, weak_bailey_lemma, BaileyDatabase
5. mod.rs re-exports all public items
</verification>

<success_criteria>
- Bailey pair types (Unit, RogersRamanujan, QBinomial, Tabulated) correctly evaluate alpha_n and beta_n
- verify_bailey_pair confirms pairs satisfy the defining relation
- bailey_lemma produces new pairs that satisfy the relation (verified)
- bailey_chain correctly iterates lemma applications
- weak_bailey_lemma LHS and RHS agree as FPS for unit and Rogers-Ramanujan pairs
- BaileyDatabase stores and searches pairs by name and tag
</success_criteria>

<output>
After completion, create `.planning/phases/08-mock-theta-bailey-chains/08-03-SUMMARY.md`
</output>
