---
phase: 08-mock-theta-bailey-chains
plan: "04"
type: execute
wave: 2
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - crates/qsym-core/src/qseries/bailey.rs
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-core/tests/qseries_bailey_tests.rs
autonomous: true

must_haves:
  truths:
    - "Automated Bailey pair discovery can verify a conjectured identity by searching the pair database and applying the lemma"
    - "Python users can compute all 20 mock theta functions via DSL"
    - "Python users can evaluate Appell-Lerch sums and universal mock theta functions"
    - "Python users can create Bailey pairs, apply the lemma, and run chain iteration"
    - "Python users can run automated Bailey pair discovery"
  artifacts:
    - path: "crates/qsym-core/src/qseries/bailey.rs"
      provides: "bailey_discover function for automated pair matching"
      contains: "pub fn bailey_discover"
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "Group 10: Mock Theta, Appell-Lerch & Bailey Python DSL functions"
      contains: "GROUP 10"
    - path: "crates/qsym-python/src/lib.rs"
      provides: "Registration of all Group 10 functions"
      contains: "Group 10"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "crates/qsym-core/src/qseries/mock_theta.rs"
      via: "Calling mock_theta_* functions from Python DSL"
      pattern: "mock_theta"
    - from: "crates/qsym-python/src/dsl.rs"
      to: "crates/qsym-core/src/qseries/appell_lerch.rs"
      via: "Calling appell_lerch_m, g2, g3 from Python DSL"
      pattern: "appell_lerch"
    - from: "crates/qsym-python/src/dsl.rs"
      to: "crates/qsym-core/src/qseries/bailey.rs"
      via: "Calling bailey_lemma, bailey_chain, bailey_discover from Python DSL"
      pattern: "bailey"
    - from: "crates/qsym-core/src/qseries/bailey.rs"
      to: "crates/qsym-core/src/qseries/relations.rs"
      via: "findlincombo for coefficient matching in discovery"
      pattern: "findlincombo"
---

<objective>
Implement automated Bailey pair discovery and Python API bindings for all Phase 8 functionality (mock theta, Appell-Lerch, Bailey machinery).

Purpose: PART-11 (automated discovery) completes the Bailey machinery by enabling researchers to verify conjectured identities through pair database search. The Python API (Group 10) exposes all Phase 8 functions for interactive use.

Output: `bailey_discover` function in bailey.rs, comprehensive Python DSL bindings in dsl.rs for 20+ new functions.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mock-theta-bailey-chains/08-RESEARCH.md

@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/bailey.rs
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs

# Prior plan summaries (needed: uses types/exports from all three prior plans)
@.planning/phases/08-mock-theta-bailey-chains/08-01-SUMMARY.md
@.planning/phases/08-mock-theta-bailey-chains/08-02-SUMMARY.md
@.planning/phases/08-mock-theta-bailey-chains/08-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Automated Bailey pair discovery</name>
  <files>
    crates/qsym-core/src/qseries/bailey.rs
    crates/qsym-core/tests/qseries_bailey_tests.rs
  </files>
  <action>
Add to `crates/qsym-core/src/qseries/bailey.rs`:

**Discovery result type:**

```rust
#[derive(Clone, Debug)]
pub struct DiscoveryResult {
    /// Whether a matching Bailey pair was found
    pub found: bool,
    /// Name of the matching pair (if found)
    pub pair_name: Option<String>,
    /// Chain depth at which the match was found (0 = direct match)
    pub chain_depth: usize,
    /// The matching pair (if found)
    pub matching_pair: Option<BaileyPair>,
    /// Description of how the identity was verified
    pub verification: String,
}
```

**Main discovery function:**

`pub fn bailey_discover(lhs: &FormalPowerSeries, rhs: &FormalPowerSeries, db: &BaileyDatabase, a: &QMonomial, max_chain_depth: usize, variable: SymbolId, truncation_order: i64) -> DiscoveryResult`

Algorithm:
1. Compute target = arithmetic::add(lhs, &arithmetic::negate(rhs)). If target is all-zero, the identity is trivially true -- return found=true with verification="direct equality".

2. For each pair in db.all_pairs():
   a. Check if LHS matches the "beta side" of the weak Bailey lemma: LHS should be expressible as sum_{n>=0} q^{n^2} * a^n * beta_n. Extract candidate beta_n coefficients by reading off: for each n, beta_n * q^{n^2+a.power*n} contributes to LHS. Check if the coefficient at q^{n^2+a.power*n} in LHS is consistent with pair.beta_term(n).

   SIMPLER APPROACH: Compute the weak Bailey lemma for each pair in the database. If weak_bailey_lemma(pair, a, ...) returns (wbl_lhs, wbl_rhs) where wbl_lhs == wbl_rhs, AND one of lhs/rhs matches wbl_lhs, then the identity can be verified via the weak Bailey lemma.

   EVEN SIMPLER (practical approach):
   a. Compute weak_bailey_lemma(pair, a, max_n, variable, truncation_order) -> (wbl_lhs, wbl_rhs)
   b. Check if lhs == wbl_lhs (comparing FPS coefficients to truncation_order)
   c. If yes: check if rhs matches wbl_rhs (or can be related to the product-side formula)
   d. If match found: return DiscoveryResult with found=true

3. If no direct match, try chain iteration: for depth 1..=max_chain_depth:
   a. For each pair in db.all_pairs():
     - Apply bailey_chain(pair, a, b_default, c_default, depth, max_n, variable, truncation_order)
     - For the last pair in the chain, compute weak_bailey_lemma
     - Check if lhs matches
   b. Use b = q^2, c = q^3 as default parameters (reasonable general choice)

4. If no match found at any depth, return found=false.

**Helper for FPS comparison:**

`fn fps_equal(a: &FormalPowerSeries, b: &FormalPowerSeries) -> bool` -- Compare two FPS by checking all coefficients up to the shared truncation_order. Use arithmetic::add(a, &arithmetic::negate(b)) and check if all coefficients are zero.

**Add discovery tests to the existing test file:**

19. `test_bailey_discover_trivial` -- Discovery with lhs == rhs returns found=true with "direct equality".

20. `test_bailey_discover_rr_identity` -- The first Rogers-Ramanujan identity: sum q^{n^2}/(q;q)_n = prod 1/[(1-q^{5k+1})(1-q^{5k+4})]. Compute LHS as the sum (this is the beta side of the RR pair with a=1). Compute RHS as the product. Run bailey_discover -- should find the RR pair.

21. `test_bailey_discover_no_match` -- Give two unrelated series. Discovery should return found=false.

22. `test_bailey_discover_chain_depth_1` -- Construct an identity that requires chain depth 1 to find. Apply the lemma to the unit pair once, compute the weak Bailey lemma for the derived pair, use that as the LHS/RHS. Discovery with max_chain_depth=1 should find it.

Target: 4 additional tests in the existing test file.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test bailey_discover 2>&1 | tail -10` -- all discovery tests pass.
  </verify>
  <done>bailey_discover searches the pair database, applies the weak Bailey lemma, and tries chain iteration to verify conjectured identities. DiscoveryResult reports match status and chain depth.</done>
</task>

<task type="auto">
  <name>Task 2: Python API bindings for all Phase 8 functions (Group 10)</name>
  <files>
    crates/qsym-python/src/dsl.rs
    crates/qsym-python/src/lib.rs
  </files>
  <action>
Add Group 10 to `crates/qsym-python/src/dsl.rs`:

```rust
// ===========================================================================
\ GROUP 10: Mock Theta Functions, Appell-Lerch Sums & Bailey Machinery
// ===========================================================================
```

**Mock theta function DSL (20 functions):**

Each mock theta function gets a thin wrapper with the pattern:
```rust
#[pyfunction]
pub fn mock_theta_f3(session: &QSession, truncation_order: i64) -> PyResult<QSeries> {
    let inner = session.inner.lock().map_err(|e| pyo3::exceptions::PyRuntimeError::new_err(e.to_string()))?;
    let var = inner.get_or_create_symbol_id("q");
    drop(inner);
    let fps = qsym_core::qseries::mock_theta_f3(var, truncation_order);
    Ok(QSeries { fps })
}
```

Create all 20 wrapper functions:
- mock_theta_f3, mock_theta_phi3, mock_theta_psi3, mock_theta_chi3, mock_theta_omega3, mock_theta_nu3, mock_theta_rho3 (third-order)
- mock_theta_f0_5, mock_theta_f1_5, mock_theta_cap_f0_5, mock_theta_cap_f1_5, mock_theta_phi0_5, mock_theta_phi1_5, mock_theta_psi0_5, mock_theta_psi1_5, mock_theta_chi0_5, mock_theta_chi1_5 (fifth-order)
- mock_theta_cap_f0_7, mock_theta_cap_f1_7, mock_theta_cap_f2_7 (seventh-order)

**Appell-Lerch DSL (3 functions):**

```rust
#[pyfunction]
pub fn appell_lerch_m(session: &QSession, a_pow: i64, z_pow: i64, truncation_order: i64) -> PyResult<QSeries> {
    let inner = session.inner.lock().map_err(|e| ...)?;
    let var = inner.get_or_create_symbol_id("q");
    drop(inner);
    let fps = qsym_core::qseries::appell_lerch_m(a_pow, z_pow, var, truncation_order);
    Ok(QSeries { fps })
}

#[pyfunction]
pub fn universal_mock_theta_g2(session: &QSession, a_pow: i64, truncation_order: i64) -> PyResult<QSeries> { ... }

#[pyfunction]
pub fn universal_mock_theta_g3(session: &QSession, a_pow: i64, truncation_order: i64) -> PyResult<QSeries> { ... }
```

**Bailey machinery DSL (4 functions):**

1. `bailey_weak_lemma(session, pair_name: &str, a_num: i64, a_den: i64, a_pow: i64, max_n: i64, truncation_order: i64) -> PyResult<(QSeries, QSeries)>`
   - Construct QMonomial a from (a_num, a_den, a_pow) like the hypergeometric DSL pattern
   - Look up pair by name in a default BaileyDatabase
   - Call weak_bailey_lemma, return (lhs, rhs) tuple

2. `bailey_apply_lemma(session, pair_name: &str, a: (i64, i64, i64), b: (i64, i64, i64), c: (i64, i64, i64), max_n: i64, truncation_order: i64) -> PyResult<Bound<PyDict>>`
   - Apply bailey_lemma, return dict with name, pair_type, etc.

3. `bailey_chain_fn(session, pair_name: &str, a: (i64, i64, i64), b: (i64, i64, i64), c: (i64, i64, i64), depth: usize, max_n: i64, truncation_order: i64) -> PyResult<Bound<PyList>>`
   - Register as 'bailey_chain' in Python (use pyo3(name))
   - Return list of dicts, each with pair info

4. `bailey_discover_fn(session, lhs: &QSeries, rhs: &QSeries, a: (i64, i64, i64), max_chain_depth: usize, truncation_order: i64) -> PyResult<Bound<PyDict>>`
   - Register as 'bailey_discover' in Python
   - Return dict: { found: bool, pair_name: Option<str>, chain_depth: int, verification: str }

**Helper for QMonomial construction from Python tuples:**

```rust
fn qmonomial_from_tuple(num: i64, den: i64, pow: i64) -> QMonomial {
    let coeff = QRat::from(rug::Rational::from((num, den)));
    QMonomial::new(coeff, pow)
}
```

**Register in lib.rs:**

Add to the `_qsymbolic` function:

```rust
// Group 10: Mock Theta, Appell-Lerch & Bailey
m.add_function(wrap_pyfunction!(dsl::mock_theta_f3, m)?)?;
m.add_function(wrap_pyfunction!(dsl::mock_theta_phi3, m)?)?;
// ... all 20 mock theta functions ...
m.add_function(wrap_pyfunction!(dsl::appell_lerch_m, m)?)?;
m.add_function(wrap_pyfunction!(dsl::universal_mock_theta_g2, m)?)?;
m.add_function(wrap_pyfunction!(dsl::universal_mock_theta_g3, m)?)?;
m.add_function(wrap_pyfunction!(dsl::bailey_weak_lemma, m)?)?;
m.add_function(wrap_pyfunction!(dsl::bailey_apply_lemma, m)?)?;
m.add_function(wrap_pyfunction!(dsl::bailey_chain_fn, m)?)?;
m.add_function(wrap_pyfunction!(dsl::bailey_discover_fn, m)?)?;
```

IMPORTANT: The import in dsl.rs needs to be updated to include the new qseries types. Update the `use qsym_core::qseries::` import to include BaileyDatabase, BaileyPair, bailey_lemma, bailey_chain, weak_bailey_lemma, bailey_discover, appell_lerch_m (the function), universal_mock_theta_g2, universal_mock_theta_g3, and all mock_theta_* functions.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build --manifest-path crates/qsym-python/Cargo.toml 2>&1 | tail -10` -- Python crate compiles without errors.
  </verify>
  <done>Group 10 Python DSL has 27 functions: 20 mock theta, 3 Appell-Lerch/universal, 4 Bailey machinery. All registered in lib.rs and compiling.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors (both qsym-core and qsym-python)
2. `cargo test bailey_discover` -- all discovery tests pass
3. `cargo test` -- all existing tests still pass (no regressions)
4. bailey.rs contains bailey_discover and DiscoveryResult
5. dsl.rs contains GROUP 10 with 27 functions
6. lib.rs registers all Group 10 functions
</verification>

<success_criteria>
- bailey_discover searches pair database with weak Bailey lemma matching
- bailey_discover tries chain iteration up to max_chain_depth
- Rogers-Ramanujan identity discoverable via RR pair in database
- All 20 mock theta functions callable from Python
- Appell-Lerch m(x,q,z) and g2/g3 callable from Python with integer parameters
- Bailey lemma, chain, and discovery callable from Python
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/08-mock-theta-bailey-chains/08-04-SUMMARY.md`
</output>
