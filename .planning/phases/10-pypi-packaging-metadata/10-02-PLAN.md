---
phase: 10-pypi-packaging-metadata
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - crates/qsym-python/python/q_kangaroo/py.typed
  - crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
  - crates/qsym-python/python/q_kangaroo/__init__.pyi
autonomous: true

must_haves:
  truths:
    - "IDE autocomplete shows function signatures and docstrings for all 73 DSL functions"
    - "Type stubs cover all 3 classes (QSession, QExpr, QSeries) with correct method signatures"
    - "py.typed marker file exists so type checkers discover the stubs"
  artifacts:
    - path: "crates/qsym-python/python/q_kangaroo/py.typed"
      provides: "PEP 561 marker for inline type stubs"
      min_lines: 0
    - path: "crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi"
      provides: "Type stubs for native module (3 classes + 73 functions + version)"
      min_lines: 100
    - path: "crates/qsym-python/python/q_kangaroo/__init__.pyi"
      provides: "Type stubs for package re-exports (matches __init__.py __all__)"
      min_lines: 50
  key_links:
    - from: "crates/qsym-python/python/q_kangaroo/__init__.pyi"
      to: "crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi"
      via: "re-exports from native module"
      pattern: "from q_kangaroo._q_kangaroo import"
    - from: "crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi"
      to: "crates/qsym-python/src/dsl.rs"
      via: "function signatures match Rust pyfunction definitions"
      pattern: "def aqprod"
---

<objective>
Create PEP 561 type stubs (.pyi files) for IDE autocomplete covering all 3 classes and 73 DSL functions, then build the ABI3 wheel with bundled DLLs and verify the complete installation flow.

Purpose: Type stubs enable researchers to discover function signatures and docstrings in their IDE. The wheel build + install verification proves the entire packaging pipeline works end-to-end.
Output: py.typed marker, _q_kangaroo.pyi, __init__.pyi stubs; verified ABI3 wheel.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-pypi-packaging-metadata/10-RESEARCH.md
@.planning/phases/10-pypi-packaging-metadata/10-01-SUMMARY.md
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/session.rs
@crates/qsym-python/src/series.rs
@crates/qsym-python/src/expr.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/python/q_kangaroo/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PEP 561 type stubs for all classes and DSL functions</name>
  <files>
    crates/qsym-python/python/q_kangaroo/py.typed
    crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
    crates/qsym-python/python/q_kangaroo/__init__.pyi
  </files>
  <action>
1. Create `py.typed` as an empty file (PEP 561 marker).

2. Create `_q_kangaroo.pyi` with complete type stubs for the native module. Derive all signatures from the Rust source (dsl.rs, session.rs, series.rs, expr.rs):

**Classes:**

```python
from fractions import Fraction
from typing import Optional

class QSession:
    def __init__(self) -> None: ...
    def symbol(self, name: str) -> QExpr: ...
    def symbols(self, names: str) -> list[QExpr]: ...
    def integer(self, val: int) -> QExpr: ...
    def rational(self, num: int, den: int) -> QExpr: ...
    def infinity(self) -> QExpr: ...
    def stats(self) -> tuple[int, int]: ...
    def generate(self, func_name: str, params: list[int], truncation_order: int) -> QSeries: ...
    def batch_generate(self, func_name: str, param_grid: list[list[int]], truncation_order: int) -> list[tuple[list[int], QSeries]]: ...

class QExpr:
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def _repr_latex_(self) -> str: ...
    def latex(self) -> str: ...
    def __add__(self, other: QExpr) -> QExpr: ...
    def __radd__(self, other: QExpr) -> QExpr: ...
    def __mul__(self, other: QExpr) -> QExpr: ...
    def __rmul__(self, other: QExpr) -> QExpr: ...
    def __neg__(self) -> QExpr: ...
    def __sub__(self, other: QExpr) -> QExpr: ...
    def __pow__(self, exp: QExpr, modulo: object = ...) -> QExpr: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def simplify(self) -> QExpr: ...
    def variant(self) -> str: ...

class QSeries:
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __getitem__(self, key: int) -> Fraction: ...
    def __len__(self) -> int: ...
    def truncation_order(self) -> int: ...
    def min_order(self) -> Optional[int]: ...
    def is_zero(self) -> bool: ...
    def coeffs(self) -> list[tuple[int, Fraction]]: ...  # Note: actually PyObject but typed as Fraction
    def to_dict(self) -> dict[int, Fraction]: ...
    def degree(self) -> Optional[int]: ...
    def low_degree(self) -> Optional[int]: ...
    def __add__(self, other: QSeries) -> QSeries: ...
    def __mul__(self, other: QSeries) -> QSeries: ...
    def __neg__(self) -> QSeries: ...
    def __sub__(self, other: QSeries) -> QSeries: ...
    def invert(self) -> QSeries: ...
    def sift(self, m: int, j: int) -> QSeries: ...
```

**Functions (all 73 + version):**

Include ALL functions from each group, with exact parameter names matching the Rust #[pyfunction] signatures. Use these return types:
- Functions returning QSeries -> QSeries
- Functions returning PyResult<QSeries> -> QSeries (Python sees no PyResult)
- Functions returning PyObject (dicts) -> use `dict[str, ...]` with appropriate value types
- Functions returning Option<T> -> Optional[T]
- Functions returning Vec<T> -> list[T]

For each function, include a one-line docstring derived from the Rust doc comment. Group functions with comments matching the groups in __init__.py.

Key signatures to get right (common sources of error):
- `aqprod(session: QSession, coeff_num: int, coeff_den: int, power: int, n: Optional[int], order: int) -> QSeries`
- `partition_count(n: int) -> int` (no session param, returns int not Fraction)
- `qfactor(series: QSeries) -> dict[str, ...]` (no session)
- `sift(series: QSeries, m: int, j: int) -> QSeries` (module-level, not method)
- `findlincombo(target: QSeries, candidates: list[QSeries], topshift: int) -> Optional[list[Fraction]]`
- `findcong(series: QSeries, moduli: list[int]) -> list[dict[str, int]]` (no topshift)
- `findprod(series_list: list[QSeries], max_coeff: int, max_exp: int) -> list[list[int]]` (no topshift)
- `phi/psi(session, upper: list[tuple[int,int,int]], lower: list[tuple[int,int,int]], z_num, z_den, z_pow, order) -> QSeries`
- `heine1/2/3(...)  -> tuple[QSeries, QSeries]`
- `prove_eta_id(session, lhs_factors: list[tuple[int,int]], rhs_factors: list[tuple[int,int]], level: int) -> dict[str, ...]`
- `search_identities(query: str, search_type: str = "pattern", db_path: Optional[str] = None) -> list[dict[str, ...]]`
- Mock theta functions: `mock_theta_*(session: QSession, truncation_order: int) -> QSeries`
- `appell_lerch_m(session, a_pow: int, z_pow: int, truncation_order: int) -> QSeries`
- `universal_mock_theta_g2/g3(session, a_pow: int, truncation_order: int) -> QSeries`
- `bailey_weak_lemma(session, pair_name: str, a_num, a_den, a_pow, max_n, truncation_order) -> tuple[QSeries, QSeries]`
- `bailey_apply_lemma(session, pair_name: str, a: tuple[int,int,int], b: tuple[int,int,int], c: tuple[int,int,int], max_n, truncation_order) -> dict[str, ...]`
- `bailey_chain(session, pair_name: str, a, b, c: tuple[int,int,int], depth: int, max_n, truncation_order) -> list[dict[str, ...]]`
- `bailey_discover(session, lhs: QSeries, rhs: QSeries, a: tuple[int,int,int], max_chain_depth: int, truncation_order: int) -> dict[str, ...]`

3. Create `__init__.pyi` that mirrors `__init__.py`'s exports:
   - Re-export all items from _q_kangaroo (matching __all__)
   - Include `symbols(names: str, session: Optional[QSession] = None) -> ...` with overloads:
     - Single name returns QExpr
     - Multiple names returns tuple[QExpr, ...]
   - Include `__version__: str`
   - Include `__all__: list[str]`

Use `from typing import overload` for the `symbols` function if needed, or simply type it as returning `QExpr | tuple[QExpr, ...]`.
  </action>
  <verify>
- Confirm py.typed exists (empty file)
- Confirm _q_kangaroo.pyi contains stubs for all 73 DSL functions: `grep -c "^def " crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi` should be >= 74 (73 DSL + version)
- Confirm __init__.pyi re-exports all items from __all__
- Run: `cd crates/qsym-python && .venv/Scripts/python -c "from q_kangaroo import *; print('import OK')"` to confirm stubs don't break runtime imports
  </verify>
  <done>
py.typed marker exists. _q_kangaroo.pyi has complete type stubs for 3 classes + 73 DSL functions + version(). __init__.pyi re-exports everything matching __all__. Runtime imports still work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build ABI3 wheel with bundled DLLs and verify end-to-end installation</name>
  <files>
    (no new files -- builds and verifies artifacts from Task 1 and Plan 01)
  </files>
  <action>
1. **Copy DLLs for bundling:** From the crates/qsym-python directory:
   ```bash
   cp /c/mingw64-gcc/mingw64/bin/libgmp-10.dll python/q_kangaroo/
   cp /c/mingw64-gcc/mingw64/bin/libmpfr-6.dll python/q_kangaroo/
   cp /c/mingw64-gcc/mingw64/bin/libmpc-3.dll python/q_kangaroo/
   cp /c/mingw64-gcc/mingw64/bin/libgcc_s_seh-1.dll python/q_kangaroo/
   cp /c/mingw64-gcc/mingw64/bin/libwinpthread-1.dll python/q_kangaroo/
   ```

2. **Build the wheel** with ABI3 and release mode:
   ```bash
   export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
   export PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1
   export PYO3_PYTHON="$(cygpath -w .venv/Scripts/python.exe)"
   maturin build --release
   ```

3. **Verify ABI3 wheel filename:** Check that `target/wheels/` contains a file matching `q_kangaroo-*-cp39-abi3-win_amd64.whl`. If filename shows `cp314-cp314` instead of `cp39-abi3`, the ABI3 feature is not propagating -- debug by checking `maturin build` output for feature resolution.

4. **Verify wheel contents:** Use Python's zipfile to list the wheel contents:
   ```bash
   python -c "import zipfile; z=zipfile.ZipFile('target/wheels/q_kangaroo-0.1.0-cp39-abi3-win_amd64.whl'); [print(n) for n in sorted(z.namelist())]"
   ```
   Confirm the wheel contains:
   - `q_kangaroo/__init__.py`
   - `q_kangaroo/_q_kangaroo.pyd` (or .so)
   - `q_kangaroo/py.typed`
   - `q_kangaroo/_q_kangaroo.pyi`
   - `q_kangaroo/__init__.pyi`
   - `q_kangaroo/libgmp-10.dll` (and the other 4 DLLs)
   - `q_kangaroo-0.1.0.dist-info/METADATA`
   - `q_kangaroo-0.1.0.dist-info/licenses/LICENSE` (or similar)

5. **Install in fresh venv and verify:**
   ```bash
   # Create a fresh test venv (separate from dev venv)
   python -m venv /tmp/test-install-venv
   /tmp/test-install-venv/Scripts/pip install target/wheels/q_kangaroo-*-cp39-abi3-*.whl

   # Verify import works
   /tmp/test-install-venv/Scripts/python -c "import q_kangaroo; print(q_kangaroo.__version__)"

   # Verify metadata
   /tmp/test-install-venv/Scripts/pip show q-kangaroo

   # Verify a DSL function works
   /tmp/test-install-venv/Scripts/python -c "from q_kangaroo import QSession, partition_count; print(partition_count(5)); s=QSession(); print('OK')"

   # Verify type stubs are present in installed package
   /tmp/test-install-venv/Scripts/python -c "import q_kangaroo, os; pkg=os.path.dirname(q_kangaroo.__file__); print('py.typed:', os.path.isfile(os.path.join(pkg,'py.typed'))); print('pyi:', os.path.isfile(os.path.join(pkg,'_q_kangaroo.pyi')))"

   # Clean up
   rm -rf /tmp/test-install-venv
   ```

6. **Clean up DLLs from source tree:**
   ```bash
   rm python/q_kangaroo/*.dll
   ```

Note: Use Cygwin paths for shell commands. The temp venv path may need to be `C:/cygwin64/tmp/test-install-venv` or similar -- adjust to whatever works in the Cygwin environment. If creating a venv fails with that path, use `crates/qsym-python/test-venv` instead and clean up after.
  </action>
  <verify>
- Wheel file exists with abi3 in filename: `ls target/wheels/q_kangaroo-*-cp39-abi3-*.whl`
- Fresh venv install succeeds: `import q_kangaroo` works
- `pip show q-kangaroo` output includes: License: MIT, Author:, Summary:, Home-page:
- Type stub files present in installed package (py.typed, _q_kangaroo.pyi, __init__.pyi)
- DSL function works from fresh install: `partition_count(5)` returns 7
  </verify>
  <done>
ABI3 wheel builds successfully with cp39-abi3 filename pattern. Wheel contains bundled DLLs, type stubs, and py.typed marker. Fresh venv install succeeds -- import works, pip show displays complete metadata, partition_count(5)==7, and type stubs are present in installed package.
  </done>
</task>

</tasks>

<verification>
Phase 10 success criteria validation:
1. `pip install q-kangaroo` from local wheel succeeds on fresh Windows venv -- VERIFIED by Task 2
2. `pip show q-kangaroo` displays complete metadata -- VERIFIED by Task 2
3. ABI3 wheel filename pattern `*-cp39-abi3-*.whl` -- VERIFIED by Task 2
4. Type stubs present and valid for all 73 DSL functions + 3 classes -- VERIFIED by Task 1 + Task 2
5. LICENSE and CITATION.cff exist -- VERIFIED by Plan 01

Note: PKG-01 (Linux install) cannot be verified on this Windows machine. Research recommends deferring Linux wheel to Phase 11 CI. The metadata and structure proven correct on Windows will transfer to Linux wheels built in CI.
</verification>

<success_criteria>
- py.typed exists as empty marker file
- _q_kangaroo.pyi has type stubs for 73+ functions and 3 classes
- __init__.pyi re-exports all items from __all__
- ABI3 wheel builds with cp39-abi3 filename
- Wheel contains 5 bundled DLLs
- Fresh venv install succeeds and import q_kangaroo works
- pip show displays license, classifiers, URLs
- partition_count(5) returns 7 from fresh install
</success_criteria>

<output>
After completion, create `.planning/phases/10-pypi-packaging-metadata/10-02-SUMMARY.md`
</output>
