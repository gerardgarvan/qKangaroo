---
phase: 12-documentation-ux-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-python/src/dsl.rs
autonomous: true

must_haves:
  truths:
    - "Every Python function has a NumPy-style docstring with Parameters, Returns, and Examples sections"
    - "help(etaq) in Python shows parameter names, types, math notation, and usage example"
    - "Error messages include the function name and describe what went wrong with the parameter"
    - "LaTeX mathematical notation appears correctly in docstrings"
  artifacts:
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "73 NumPy-style docstrings on all pyfunction definitions"
      contains: "Parameters\n/// ----------"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "Python help() output"
      via: "PyO3 passes /// doc comments as __doc__ strings"
      pattern: "/// Parameters"
---

<objective>
Rewrite all 73 DSL function docstrings in dsl.rs to NumPy-style format with Parameters, Returns, Examples, and mathematical notation. Add improved error messages to functions that validate input.

Purpose: Satisfies DOC-06 (NumPy-style docstrings on all 73 Python functions), DOC-07 (LaTeX notation in docstrings), UX-03 (error messages with function name + suggestions), UX-05 (Pythonic conventions via keyword arguments). This is the single largest documentation task -- every public function gets a proper docstring.

Output: Fully rewritten dsl.rs with comprehensive docstrings on all 73 #[pyfunction] definitions.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-documentation-ux-polish/12-RESEARCH.md
@crates/qsym-python/src/dsl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite all 73 DSL function docstrings to NumPy-style with error messages</name>
  <files>crates/qsym-python/src/dsl.rs</files>
  <action>
Read the full dsl.rs file and rewrite every `///` doc comment block on all 73 `#[pyfunction]` functions to follow the NumPy-style docstring format. Also add input validation with descriptive error messages where appropriate.

**Docstring template for each function:**

```rust
/// One-line summary with mathematical notation: $formula$.
///
/// Longer description with mathematical context (1-3 sentences).
///
/// Parameters
/// ----------
/// session : QSession
///     The computation session.
/// param_name : type
///     Description. Mathematical notation: $formula$.
///
/// Returns
/// -------
/// QSeries
///     Description of what the returned series represents.
///
/// Raises
/// ------
/// ValueError
///     If [condition].
///
/// Examples
/// --------
/// >>> from q_kangaroo import QSession, function_name
/// >>> s = QSession()
/// >>> result = function_name(s, ...)
/// >>> result[0]
/// Fraction(1, 1)
///
/// Notes
/// -----
/// Mathematical background or relationship to other functions.
///
/// See Also
/// --------
/// related_func : Brief description.
```

**Group-by-group instructions:**

**Group 1: Pochhammer and q-Binomial (aqprod, qbin)**
- aqprod: Document the general q-Pochhammer symbol $(a;q)_n$. Parameters: session, coeff_num, coeff_den, power (together defining monomial $a = \frac{c_n}{c_d} q^p$), n (None for infinite), order. Note: "Use n=None for the infinite product $(a;q)_\infty$."
- qbin: Document q-binomial coefficient $\binom{n}{k}_q$. Note recurrence relation.

**Group 2: Named Products (etaq, jacprod, tripleprod, quinprod, winquist)**
- etaq: $(q^b; q^t)_\infty$. Note connection to Dedekind eta function. See Also: aqprod, jacprod.
- jacprod: JAC(a,b) = three-factor product. Note: "Requires $0 < a < b$."
- tripleprod: Jacobi triple product with monomial z.
- quinprod: Quintuple product with monomial z.
- winquist: Winquist's identity product with two monomials a, b. Document all 8 parameters.

**Group 3: Theta Functions (theta2, theta3, theta4)**
- theta2: Note returned in $q^{1/4}$ convention. See Also: theta3, theta4.
- theta3: $\theta_3(q) = 1 + 2\sum_{n=1}^{\infty} q^{n^2}$. Classical theta function.
- theta4: $\theta_4(q) = 1 + 2\sum_{n=1}^{\infty} (-1)^n q^{n^2}$.

**Group 4: Partition Functions (partition_count, partition_gf, distinct_parts_gf, odd_parts_gf, bounded_parts_gf, rank_gf, crank_gf)**
- partition_count: Note pentagonal recurrence. No session needed. Returns Python int.
- partition_gf: $\sum p(n)q^n = 1/(q;q)_\infty$.
- distinct_parts_gf: $\prod_{n \ge 1}(1+q^n)$.
- odd_parts_gf: $\prod_{k \ge 0} 1/(1-q^{2k+1})$.
- bounded_parts_gf: Document max_part parameter.
- rank_gf: Document z parameter as z_num/z_den. Note z=1 gives partition_gf.
- crank_gf: Same as rank_gf pattern.

**Group 5: Factoring, Utilities, Prodmake (qfactor, sift_fn, qdegree, lqdegree, prodmake, etamake, jacprodmake, mprodmake, qetamake)**
- qfactor: Returns dict with "scalar", "factors", "is_exact". Document dict structure.
- sift_fn: Document sifting operation $g[i] = f[mi + j]$.
- qdegree/lqdegree: Simple single-parameter functions.
- prodmake: Andrews' algorithm. Document the dict return format.
- etamake: Eta-quotient representation. Document return format.
- jacprodmake: Jacobi product form. Document return format.
- mprodmake: $(1+q^n)$ factors. Document return format.
- qetamake: $(q^d;q^d)_\infty$ notation. Document return format.

**Group 6: Relation Discovery exact (findlincombo, findhom, findpoly, findcong, findnonhom, findhomcombo, findnonhomcombo)**
- findlincombo: $f = \sum c_i \cdot g_i$. Document topshift parameter. Returns None or list[Fraction].
- findhom: Degree-d homogeneous relations. Returns matrix.
- findpoly: Polynomial relation $P(x,y)=0$. Returns None or dict.
- findcong: Partition congruences. Note: does NOT take topshift. Document return format.
- findnonhom: Non-homogeneous version of findhom.
- findhomcombo: Target as homogeneous combo.
- findnonhomcombo: Target as non-homogeneous combo.

**Group 7: Relation Discovery modular (findlincombomodp, findhommodp, findhomcombomodp, findmaxind, findprod)**
- All modp functions: Note coefficients are i64 mod p, not Fraction.
- findmaxind: Returns indices. Document topshift.
- findprod: Brute-force search for nice products. Note: does NOT take topshift, takes max_coeff and max_exp.

**Group 8: Hypergeometric Series (phi, psi, try_summation, heine1, heine2, heine3)**
- phi: $_r\phi_s$ basic hypergeometric. Document tuple-based parameter format: each param is (num, den, power) representing $\frac{n}{d} q^p$. DLMF 17.4.1.
- psi: $_r\psi_s$ bilateral. Same tuple format.
- try_summation: Document which formulas are tried (q-Gauss, q-Vandermonde, q-Saalschutz, q-Kummer, q-Dixon).
- heine1/2/3: Document returns tuple (prefactor, result). Note 2phi1 requirement.

**Group 9: Identity Proving (prove_eta_id, search_identities)**
- prove_eta_id: Document factor format (delta, r_delta). Document return dict statuses.
- search_identities: Document search_type options.

**Group 10: Mock Theta, Appell-Lerch, Bailey (20 mock theta + 3 Appell-Lerch + 4 Bailey)**
- All 20 mock_theta_* functions: Each gets a one-line description with the standard name, order, and mathematical formula. Group by order (third, fifth, seventh). Parameters are just session + truncation_order.
- appell_lerch_m: Bilateral sum $m(q^a, q, q^z)$.
- universal_mock_theta_g2/g3: Document a_pow >= 2 requirement.
- bailey_weak_lemma: Document pair_name, a parameters, returns (lhs, rhs).
- bailey_apply_lemma: Document a, b, c tuple format.
- bailey_chain_fn: Document depth parameter, chain output format.
- bailey_discover_fn: Document discovery process, return dict format.

**Error message improvements:**

For functions that can fail, add input validation with descriptive errors. Priority functions:
- etaq: validate b > 0, t > 0 (`etaq(): parameter 'b' must be positive, got b={b}`)
- jacprod: validate 0 < a < b (`jacprod(): requires 0 < a < b, got a={a}, b={b}`)
- bounded_parts_gf: validate max_part > 0
- phi/psi: validate upper/lower are non-empty lists
- heine1/2/3: already have ValueError but improve message to include parameter details
- prove_eta_id: validate level > 0
- appell_lerch_m/g2/g3: validate a_pow constraints
- bailey_weak_lemma/apply_lemma: already have good error for missing pair name

Add `PyResult<QSeries>` return type (instead of bare `QSeries`) for functions that gain validation. For functions that currently return `QSeries` directly and gain validation, change return type to `PyResult<QSeries>`.

**Important implementation notes:**
- Rust `///` doc comments pass backslashes through verbatim to Python -- so `$\frac{1}{2}$` works correctly (no double-escaping needed).
- Keep existing function signatures UNCHANGED. Only modify doc comments and add validation at the top of function bodies.
- Keep existing `#[pyo3(signature = ...)]` attributes unchanged.
- Do NOT modify the helper functions (extract_fps_refs, qrat_vec_to_pylist, etc.) -- they are internal.
- For mock theta functions, a brief 2-3 line docstring per function is acceptable since there are 20 of them with identical parameter patterns. Include the function's standard mathematical notation and order.
  </action>
  <verify>
Build and run all tests:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd crates/qsym-python && PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1 cargo test --locked
```
Then verify docstrings are accessible via Python:
```bash
cd crates/qsym-python && PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1 maturin develop --release && python -c "
from q_kangaroo import etaq, qbin, partition_count, findlincombo, phi, mock_theta_f3

# Verify NumPy-style sections exist
for fn in [etaq, qbin, partition_count, findlincombo, phi, mock_theta_f3]:
    doc = fn.__doc__ or ''
    assert 'Parameters' in doc or fn is partition_count, f'{fn.__name__} missing Parameters section'
    name = fn.__name__
    print(f'{name}: {len(doc)} chars, has Parameters={\"Parameters\" in doc}')

# Verify error messages include function name
import traceback
try:
    from q_kangaroo import QSession, jacprod
    s = QSession()
    jacprod(s, 5, 3, 20)  # a > b, should error
except (ValueError, Exception) as e:
    msg = str(e)
    assert 'jacprod' in msg.lower() or 'requires' in msg.lower(), f'Error should mention function: {msg}'
    print(f'Error message OK: {msg[:80]}')

print('All docstring checks passed')
"
```
Run the full Python test suite to ensure no regressions:
```bash
cd crates/qsym-python && pytest tests/ -v
```
  </verify>
  <done>All 73 DSL functions have NumPy-style docstrings with Parameters, Returns, and Examples. Key functions have input validation with descriptive error messages naming the function and parameters. `help(etaq)` in Python shows full parameter documentation with LaTeX notation.</done>
</task>

</tasks>

<verification>
- `cargo test --workspace --locked` passes
- `pytest tests/ -v` passes (all 9 integration tests)
- `help(etaq)` shows Parameters/Returns/Examples in NumPy format
- Error messages for invalid inputs include function name
- Docstrings contain LaTeX notation ($...$)
</verification>

<success_criteria>
- DOC-06 satisfied: All 73 Python functions have NumPy-style docstrings
- DOC-07 partially satisfied: LaTeX notation present in docstrings (rendering verified in Plan 03)
- UX-03 satisfied: Error messages include function name and helpful context
- UX-05 satisfied: API uses snake_case, keyword arguments documented
</success_criteria>

<output>
After completion, create `.planning/phases/12-documentation-ux-polish/12-02-SUMMARY.md`
</output>
