---
phase: 13-polynomial-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/poly/mod.rs
  - crates/qsym-core/src/poly/arithmetic.rs
  - crates/qsym-core/src/lib.rs
autonomous: true
must_haves:
  truths:
    - "QRatPoly can be constructed from coefficients, constants, monomials, and the indeterminate x"
    - "QRatPoly add, sub, mul produce correct results with trailing zeros stripped"
    - "QRatPoly div_rem returns correct quotient and remainder for all edge cases"
    - "QRatPoly pseudo_rem returns lc(b)^(d+1) * a mod b exactly"
    - "QRatPoly content extracts GCD of all coefficients correctly"
    - "QRatPoly eval uses Horner's method and returns exact QRat"
    - "Two equal polynomials compare as equal; different ones do not"
  artifacts:
    - path: "crates/qsym-core/src/poly/mod.rs"
      provides: "QRatPoly struct, constructors, queries, content/primitive_part/make_monic, eval, Display, PartialEq/Eq"
      contains: "pub struct QRatPoly"
    - path: "crates/qsym-core/src/poly/arithmetic.rs"
      provides: "Add, Sub, Mul, Neg trait impls, scalar_mul, scalar_div, div_rem, exact_div, pseudo_rem"
      contains: "impl Add for QRatPoly"
    - path: "crates/qsym-core/src/lib.rs"
      provides: "pub mod poly declaration"
      contains: "pub mod poly"
  key_links:
    - from: "crates/qsym-core/src/poly/arithmetic.rs"
      to: "crates/qsym-core/src/poly/mod.rs"
      via: "use super::QRatPoly"
      pattern: "use super::QRatPoly"
    - from: "crates/qsym-core/src/poly/mod.rs"
      to: "crates/qsym-core/src/number.rs"
      via: "use crate::number::QRat"
      pattern: "use crate::number::QRat"
    - from: "crates/qsym-core/src/lib.rs"
      to: "crates/qsym-core/src/poly/mod.rs"
      via: "pub mod poly"
      pattern: "pub mod poly"
---

<objective>
Create the QRatPoly dense univariate polynomial type with full arithmetic, forming the foundation for Phase 13's polynomial infrastructure.

Purpose: QRatPoly is the core type that all subsequent polynomial operations (GCD, resultant, q-shift, rational functions) build upon. Without correct polynomial arithmetic, nothing downstream works.

Output: `crates/qsym-core/src/poly/mod.rs` and `crates/qsym-core/src/poly/arithmetic.rs` with complete QRatPoly type, plus `lib.rs` updated with `pub mod poly`.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-polynomial-infrastructure/13-RESEARCH.md
@crates/qsym-core/src/number.rs
@crates/qsym-core/src/lib.rs
@crates/qsym-core/src/series/mod.rs (pattern reference only -- do NOT reuse FPS for polynomials)
</context>

<tasks>

<task type="auto">
  <name>Task 1: QRatPoly struct, constructors, queries, and Display</name>
  <files>crates/qsym-core/src/poly/mod.rs, crates/qsym-core/src/lib.rs</files>
  <action>
Create `crates/qsym-core/src/poly/` directory and `mod.rs`.

In `mod.rs`, implement `QRatPoly`:

**Struct:**
```rust
#[derive(Clone, Debug)]
pub struct QRatPoly {
    coeffs: Vec<QRat>,  // ascending degree, invariant: empty OR last element nonzero
}
```

**Private helper:**
- `normalize(&mut self)` -- strip trailing zero coefficients via `while self.coeffs.last().map_or(false, |c| c.is_zero()) { self.coeffs.pop(); }`

**Constructors:**
- `zero() -> Self` -- empty Vec
- `one() -> Self` -- vec![QRat::one()]
- `constant(c: QRat) -> Self` -- zero if c is zero, else vec![c]
- `x() -> Self` -- vec![QRat::zero(), QRat::one()]
- `monomial(c: QRat, deg: usize) -> Self` -- c * x^deg (zero if c is zero)
- `linear(a: QRat, b: QRat) -> Self` -- a + b*x, via from_vec
- `from_vec(coeffs: Vec<QRat>) -> Self` -- strip trailing zeros
- `from_i64_coeffs(coeffs: &[i64]) -> Self` -- convenience for tests: from_vec of QRat::from((c, 1))

**Queries:**
- `degree() -> Option<usize>` -- None for zero poly, else coeffs.len() - 1
- `leading_coeff() -> Option<QRat>` -- coeffs.last().cloned()
- `coeff(&self, i: usize) -> QRat` -- coeffs.get(i).cloned().unwrap_or(QRat::zero())
- `is_zero() -> bool` -- coeffs.is_empty()
- `is_constant() -> bool` -- degree is None or Some(0)
- `is_one() -> bool` -- coeffs == [QRat::one()]
- `coeffs(&self) -> &[QRat]` -- public slice access

**Content/Primitive Part/Monic:**
- `content() -> QRat` -- GCD of all coefficient numerators / LCM of all coefficient denominators. Use rug::Integer::gcd and rug::Integer::lcm. For zero poly, return QRat::zero(). Access inner rug::Rational via `.0` field, then `.numer()` and `.denom()`.
- `primitive_part() -> QRatPoly` -- self / content. Guard against zero content.
- `make_monic() -> QRatPoly` -- divide all coefficients by leading_coeff. Return zero for zero poly.

**Evaluation:**
- `eval(&self, x: &QRat) -> QRat` -- Horner's method: iterate coeffs in reverse, result = result * x + c_i.

**Display:**
- Implement `fmt::Display` for human-readable format: "3x^2 + 2x + 1". Handle: zero poly prints "0", coefficient 1 on x^k prints just "x^k" (not "1x^k"), negative coefficients print "- |c|x^k" (not "+ -cx^k"), constant term has no "x", degree-1 term prints "x" not "x^1".

**PartialEq/Eq:**
- Derive or implement PartialEq by comparing coeffs slices (since invariant guarantees canonical form, direct Vec comparison works). Need to compare QRat values. Implement manually: both normalized, compare element-wise.

**Module declaration:**
- Add `pub mod arithmetic;` in mod.rs
- Add `pub mod poly;` in `crates/qsym-core/src/lib.rs` (after `pub mod number;` line)
- Add re-export: `pub use poly::QRatPoly;` in lib.rs

**Tests in mod.rs:**
- Constructor round-trips (from_vec strips zeros, monomial with zero coeff returns zero poly)
- degree/leading_coeff/is_zero/is_constant queries
- content of 6x^2 + 4x + 2 = 2, primitive_part = 3x^2 + 2x + 1
- content with rational coefficients: (1/2)x + (1/3) should give content 1/6
- make_monic of 2x^2 + 4x + 6 = x^2 + 2x + 3
- eval: (x^2 + x + 1).eval(2) = 7
- eval: (3x - 1).eval(1/3) = 0
- Display formatting tests
- PartialEq: equal polys compare true, different polys compare false
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly::tests -- --nocapture
```
All constructor, query, content, eval, Display, and equality tests pass.
  </verify>
  <done>QRatPoly struct exists with all constructors, queries, content/primitive_part/make_monic, Horner eval, Display, and PartialEq/Eq. All tests pass. Module is declared in lib.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Polynomial arithmetic operations</name>
  <files>crates/qsym-core/src/poly/arithmetic.rs</files>
  <action>
Create `arithmetic.rs` implementing all arithmetic operations on QRatPoly.

**Trait implementations (by reference AND by value):**
Follow the pattern from `number.rs` where both `impl Add for QRat` and `impl Add<&QRat> for &QRat` exist.

- `Add` for QRatPoly: pad shorter to length of longer, add coefficient-wise, normalize.
- `Sub` for QRatPoly: same as Add but subtract.
- `Mul` for QRatPoly: schoolbook O(n*m) convolution. Result has degree deg(a)+deg(b). For each pair (i,j), result[i+j] += a[i] * b[j]. Normalize after.
- `Neg` for QRatPoly: negate all coefficients.

Implement four variants for Add, Sub, Mul: `(T, T)`, `(&T, &T)`, `(&T, T)`, `(T, &T)` -- delegate non-reference versions to the reference version via clone.

**Scalar operations (methods, not traits):**
- `scalar_mul(&self, c: &QRat) -> QRatPoly` -- multiply each coefficient by c. If c is zero, return zero poly.
- `scalar_div(&self, c: &QRat) -> QRatPoly` -- divide each coefficient by c. Panic if c is zero.

**Division:**
- `div_rem(&self, divisor: &QRatPoly) -> (QRatPoly, QRatPoly)` -- Euclidean polynomial division. Panic if divisor is zero. If deg(self) < deg(divisor), return (zero, self.clone()). Otherwise, standard long division algorithm: iterate from highest degree down, compute quotient coefficient = remainder[idx] / lc(divisor), subtract divisor*q_coeff shifted. Return (quotient, remainder) both via from_vec.
- `exact_div(&self, divisor: &QRatPoly) -> QRatPoly` -- call div_rem, assert remainder is zero with descriptive panic message "exact_div: nonzero remainder", return quotient.
- `pseudo_rem(&self, other: &QRatPoly) -> QRatPoly` -- Compute lc(other)^(deg(self) - deg(other) + 1) * self mod other. Scale self by lc(other)^delta first, then div_rem, return remainder. Handle edge cases: self is zero -> return zero; deg(self) < deg(other) -> return self.clone().

**Tests in arithmetic.rs:**
- Add: (x^2 + 1) + (2x + 3) = x^2 + 2x + 4
- Add with cancellation: (x^2 + x) + (-x^2 + 1) = x + 1 (trailing zero stripped)
- Sub: (x^2 + x + 1) - (x^2 + x + 1) = 0
- Mul: (x + 1)(x - 1) = x^2 - 1
- Mul: (x + 1)^2 = x^2 + 2x + 1
- Neg: -(x + 1) = -x - 1
- scalar_mul: 3 * (x^2 + 1) = 3x^2 + 3
- scalar_mul by zero returns zero poly
- div_rem: (x^2 - 1) / (x - 1) = (x + 1, 0)
- div_rem: x^2 / (x - 1) = (x + 1, 1)
- div_rem: x / (x^2 + 1) = (0, x)
- div_rem: (6x^2 + 4) / 2 = (3x^2 + 2, 0) [constant divisor]
- exact_div: (x^2 - 1).exact_div(x - 1) = x + 1
- pseudo_rem: verified against manual computation
- Ring axioms with small polynomials: commutativity of add/mul, associativity, distributivity, additive identity, additive inverse
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly -- --nocapture
```
All arithmetic tests pass. Full test suite still passes (no regressions).
  </verify>
  <done>QRatPoly has Add, Sub, Mul, Neg traits (by value and reference), scalar_mul, scalar_div, div_rem, exact_div, pseudo_rem. All arithmetic tests pass including ring axiom checks. Zero trailing-zero invariant never violated.</done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core 2>&1 | tail -5
```
All existing tests pass (no regressions). New poly tests pass.
</verification>

<success_criteria>
1. QRatPoly can be constructed from Vec, constants, monomials, x(), linear()
2. All arithmetic operations produce correct results with trailing zeros stripped
3. div_rem, exact_div, pseudo_rem handle all edge cases correctly
4. content/primitive_part/make_monic work for integer and rational coefficients
5. Horner eval returns exact QRat values
6. Display shows human-readable polynomial format
7. PartialEq/Eq correctly compares normalized polynomials
8. Full crate test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/13-polynomial-infrastructure/13-01-SUMMARY.md`
</output>
