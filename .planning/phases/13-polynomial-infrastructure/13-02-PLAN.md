---
phase: 13-polynomial-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - crates/qsym-core/src/poly/gcd.rs
  - crates/qsym-core/src/poly/mod.rs
autonomous: true
must_haves:
  truths:
    - "poly_gcd returns monic GCD without coefficient explosion for degree 5-30 polynomials"
    - "poly_gcd of coprime polynomials returns 1"
    - "poly_gcd of polynomial with itself returns the polynomial (monic)"
    - "poly_resultant is zero iff polynomials share a common root"
    - "poly_resultant of coprime polynomials is nonzero"
    - "q_shift(p, q_val) produces p(q_val * x) via O(n) coefficient scaling"
    - "q_shift_n(p, q_val, j) equals j successive q_shifts"
  artifacts:
    - path: "crates/qsym-core/src/poly/gcd.rs"
      provides: "poly_gcd (subresultant PRS), poly_resultant, q_shift, q_shift_n"
      contains: "pub fn poly_gcd"
    - path: "crates/qsym-core/src/poly/mod.rs"
      provides: "pub mod gcd declaration and re-exports"
      contains: "pub mod gcd"
  key_links:
    - from: "crates/qsym-core/src/poly/gcd.rs"
      to: "crates/qsym-core/src/poly/mod.rs"
      via: "use super::QRatPoly"
      pattern: "use super::QRatPoly"
    - from: "crates/qsym-core/src/poly/gcd.rs"
      to: "crates/qsym-core/src/poly/arithmetic.rs"
      via: "pseudo_rem, exact_div, scalar_div methods"
      pattern: "pseudo_rem|exact_div|scalar_div"
---

<objective>
Implement polynomial GCD via subresultant PRS, resultant computation, and q-shift operations on QRatPoly.

Purpose: GCD is the critical algorithm for rational function simplification (Plan 03) and the q-dispersion computation in Phase 14 (q-Gosper). Subresultant PRS prevents coefficient explosion that would make q-Zeilberger unusable. Resultant detects shared roots for q-dispersion. q-shift is the core operation for shifting polynomials by powers of q.

Output: `crates/qsym-core/src/poly/gcd.rs` with poly_gcd, poly_resultant, q_shift, q_shift_n.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-polynomial-infrastructure/13-RESEARCH.md
@.planning/phases/13-polynomial-infrastructure/13-01-SUMMARY.md
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/arithmetic.rs
@crates/qsym-core/src/number.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Subresultant PRS GCD and resultant</name>
  <files>crates/qsym-core/src/poly/gcd.rs, crates/qsym-core/src/poly/mod.rs</files>
  <action>
Create `gcd.rs` with the subresultant PRS algorithm.

**Helper function:**
- `qrat_pow(base: &QRat, exp: u32) -> QRat` -- raise QRat to u32 power. Use repeated multiplication (rug has pow for Integer but not Rational, so implement manually or via rug's `Rational::from(Pow::pow(...))` if available; if not, loop multiply).

**poly_gcd(a: &QRatPoly, b: &QRatPoly) -> QRatPoly:**

Implementation per the research document's subresultant PRS algorithm:

1. Handle trivial cases: a is zero -> return b.make_monic(); b is zero -> return a.make_monic(); both constant -> return QRatPoly::one().
2. Ensure deg(f) >= deg(g). If not, swap.
3. Extract content from both: cont_f = f.content(), cont_g = g.content(). Compute cont_gcd = gcd(cont_f, cont_g) as QRat (numerator gcd / denominator lcm).
4. Work with primitive parts: f = f.primitive_part(), g = g.primitive_part().
5. Initialize subresultant PRS variables:
   - `psi = QRat::from((-1i64, 1i64))` (i.e., -1)
   - First iteration is special: beta = (-1)^(delta+1) where delta = deg(f) - deg(g)
6. Loop:
   a. h = f.pseudo_rem(&g)
   b. If h is zero, g (primitive part, made monic) is the GCD. Return it.
   c. Compute delta = deg(f) - deg(g) (the degree drop)
   d. Compute beta = -lc(f) * psi^delta
   e. Divide h by beta: h = h.scalar_div(&beta) -- this MUST be exact
   f. Update psi: if delta == 1, psi = -lc(f). If delta > 1, psi = (-lc(f))^delta / psi^(delta-1).
   g. Shift: f = g, g = h.
7. If loop ends with g being constant (degree 0), GCD is 1 (coprime). Return QRatPoly::one().
8. Final result: g.primitive_part().make_monic() scaled by cont_gcd -- but since we want monic GCD over Q[x], just return g.primitive_part().make_monic().

IMPORTANT: The content GCD factor is for the "content-and-primitive-part" decomposition. Over Q[x], the monic GCD convention means we return the monic version of the primitive GCD. Do NOT multiply by cont_gcd -- that would change the leading coefficient from 1. The purpose of content extraction is to reduce coefficient sizes during the PRS computation, not to scale the result.

**poly_resultant(a: &QRatPoly, b: &QRatPoly) -> QRat:**

The resultant can be computed alongside the subresultant PRS. Use the formula:

If gcd(a,b) has degree > 0, resultant is 0.
Otherwise, track the accumulated scalar through the PRS chain.

Implementation approach (simpler and correct): Run a modified subresultant PRS that tracks the result scalar.

Alternative simpler approach: Since we have poly_gcd, check if gcd is trivial (degree 0). If gcd has degree > 0, return QRat::zero(). Otherwise, compute resultant via the classical formula using the PRS chain with sign tracking.

Concrete algorithm for resultant via subresultant chain:
1. If either is zero, return QRat::zero().
2. Let deg_a = deg(a), deg_b = deg(b). Ensure deg_a >= deg_b (swap with sign correction: res(a,b) = (-1)^(deg_a * deg_b) * res(b,a)).
3. Track `s = QRat::one()` (accumulated sign/scale).
4. Run PRS loop similar to GCD:
   - At each step, the degree drops contribute to the resultant via the formula.
5. When the remainder has degree 0, the resultant is the constant value (with accumulated corrections).

For simplicity and correctness, implement using the determinant-based definition ONLY IF the subresultant approach is too tricky. However, the recommended approach from research is:

Use a standalone resultant function that runs its own PRS tracking the resultant accumulation. The key relation is:
```
res(f, g) = (-1)^(deg_f * deg_g) * lc(g)^(deg_f - deg_r) * res(g, r) / lc(g)^(something)
```
where r = f mod g (pseudo-remainder form).

Practical implementation: Run the Euclidean-like algorithm tracking the scalar factor. Reference SymPy's `dmp_resultant` for the exact accumulation formula. The algorithm:

```
res = 1
f, g with deg(f) >= deg(g)
while deg(g) > 0:
    delta = deg(f) - deg(g)
    if deg(f) and deg(g) both odd: res = -res
    res *= lc(g)^delta  (simplified -- actual formula depends on PRS variant)
    f, g = g, prem(f, g) / (lc_scale)
when deg(g) == 0:
    res *= g[0]^deg(f)
```

Actually, the cleanest approach for our case: Since we already have poly_gcd telling us if gcd is nontrivial, and resultant is zero iff gcd is nontrivial, we can implement resultant as:

1. If gcd(a, b) has degree > 0: return QRat::zero()
2. Otherwise: compute via the Euclidean algorithm tracking the resultant formula:

```rust
pub fn poly_resultant(a: &QRatPoly, b: &QRatPoly) -> QRat {
    if a.is_zero() || b.is_zero() { return QRat::zero(); }
    let deg_a = a.degree().unwrap();
    let deg_b = b.degree().unwrap();
    if deg_a == 0 && deg_b == 0 { return QRat::one(); }
    if deg_a == 0 { return qrat_pow(&a.coeff(0), deg_b as u32); }
    if deg_b == 0 { return qrat_pow(&b.coeff(0), deg_a as u32); }

    // Ensure deg(f) >= deg(g)
    let (f, g, swapped) = if deg_a >= deg_b {
        (a.clone(), b.clone(), false)
    } else {
        (b.clone(), a.clone(), true)
    };
    let mut sign = if swapped && (deg_a * deg_b) % 2 == 1 {
        QRat::from((-1i64, 1i64))
    } else {
        QRat::one()
    };

    // Collins' resultant via PRS
    let mut f = f;
    let mut g = g;
    let mut res = QRat::one();

    // Run PRS collecting resultant
    // [Use the standard PRS-based resultant formula from Brown 1978]
    // This tracks: res(f,g) via the remainders
    ...
}
```

Given the complexity, implement the resultant using the SIMPLEST correct approach:
1. Compute via recursive formula: res(f, g) = (-1)^(mn) * res(g, f mod g) * lc(g)^(deg_f - deg_rem) where we use actual Euclidean remainder (over Q, not pseudo-remainder).
2. Base case: res(f, c) = c^deg(f) when g is constant.

This avoids subresultant tracking for resultant (we only need subresultant for GCD to control growth). For resultant over Q[x], the Euclidean algorithm works fine because Q is a field (no coefficient explosion in Euclidean remainder over a field).

```rust
pub fn poly_resultant(a: &QRatPoly, b: &QRatPoly) -> QRat {
    if a.is_zero() || b.is_zero() { return QRat::zero(); }
    let m = a.degree().unwrap();
    let n = b.degree().unwrap();
    if m == 0 { return qrat_pow(&a.coeff(0), n as u32); }
    if n == 0 { return qrat_pow(&b.coeff(0), m as u32); }

    let (_, r) = a.div_rem(b);
    if r.is_zero() {
        return QRat::zero();
    }
    let k = r.degree().unwrap();
    let sign = if (m * n) % 2 == 1 { QRat::from((-1i64, 1i64)) } else { QRat::one() };
    let lc_b_power = qrat_pow(&b.leading_coeff().unwrap(), (m - k) as u32);
    sign * lc_b_power * poly_resultant(b, &r)
}
```

**Add to mod.rs:**
- `pub mod gcd;`
- Re-export: `pub use gcd::{poly_gcd, poly_resultant};`

**Tests in gcd.rs:**

GCD tests:
- Coprime linears: gcd(x-1, x-2) = 1
- Common factor: gcd((x-1)(x-2), (x-1)(x-3)) = (x-1) -- test result is monic
- One divides other: gcd((x-1)^2, (x-1)) = (x-1)
- Same polynomial: gcd(p, p) = p (monic)
- Zero cases: gcd(0, p) = p.make_monic(), gcd(p, 0) = p.make_monic()
- Both constant: gcd(6, 4) = 1 (monic over Q)
- Content extraction: gcd of polynomials with large rational coefficients -- verify no coefficient explosion
- Degree 10 polynomials with known GCD factor

Resultant tests:
- Common root: resultant((x-1)(x-2), (x-1)(x-3)) = 0
- No common root: resultant(x-1, x-2) != 0
- Classical: resultant(x^2-1, x-1) = 0
- Classical: resultant(x^2+1, x^2-1) != 0 (roots are i,-i vs 1,-1, no common root)
- Known value: resultant(x-a, x-b) = a-b (up to sign)
- Constant case: resultant(x+1, 3) = 3^1 = 3
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly::gcd -- --nocapture
```
All GCD and resultant tests pass. No coefficient explosion on degree-10 test.
  </verify>
  <done>poly_gcd uses subresultant PRS with content extraction, returns monic GCD. poly_resultant correctly identifies common roots. All GCD and resultant tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: q-shift operations</name>
  <files>crates/qsym-core/src/poly/gcd.rs, crates/qsym-core/src/poly/mod.rs</files>
  <action>
Add q-shift operations to `gcd.rs` (they live here because they are algorithmic operations on QRatPoly, not basic arithmetic, and are closely related to GCD usage in q-dispersion).

Alternatively, add them as methods on QRatPoly in `mod.rs` since they are conceptually "evaluation-like" operations. Choose: add as methods on QRatPoly in mod.rs (cleaner API).

**Methods on QRatPoly (in mod.rs):**

- `q_shift(&self, q_val: &QRat) -> QRatPoly`:
  p(x) -> p(q_val * x). Each coefficient c_i is multiplied by q_val^i.
  ```
  if self.is_zero() || q_val is one: return self.clone()
  let mut result = Vec::with_capacity(self.coeffs.len());
  let mut q_power = QRat::one();
  for c in &self.coeffs {
      result.push(c.clone() * q_power.clone());
      q_power = q_power * q_val.clone();
  }
  QRatPoly::from_vec(result)  // from_vec handles normalization
  ```

- `q_shift_n(&self, q_val: &QRat, j: i64) -> QRatPoly`:
  p(x) -> p(q_val^j * x).
  If j == 0: return self.clone().
  If j > 0: compute q_val^j via repeated multiplication, then call q_shift.
  If j < 0: compute q_val^|j| then invert (1 / q_val^|j|), then call q_shift.
  Panic if q_val is zero and j < 0.

**Helper in mod.rs or gcd.rs:**
- `qrat_pow_signed(base: &QRat, exp: i64) -> QRat` -- base^exp for signed exponent. For negative exp, compute base^|exp| then invert.

**Tests (in mod.rs or gcd.rs tests section):**
- Identity shift: (x^2 + x + 1).q_shift(&QRat::one()) = x^2 + x + 1
- Simple shift: (x^2 + x + 1).q_shift(&QRat::from((2,1))) = 4x^2 + 2x + 1
- Zero poly shift: zero.q_shift(anything) = zero
- Evaluation identity: for several p, q, x: p.q_shift(q).eval(x) == p.eval(q*x)
- Double shift: p.q_shift(q).q_shift(q) == p.q_shift_n(q, 2)
- Negative shift: p.q_shift_n(q, -1).q_shift(q) == p (round-trip)
- q_shift_n with j=0 returns original
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly -- --nocapture
```
All q-shift tests pass. Evaluation identity verified for multiple test cases.
  </verify>
  <done>q_shift and q_shift_n methods on QRatPoly work correctly. Evaluation identity p.q_shift(q).eval(x) == p.eval(q*x) verified. Full test suite passes.</done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core 2>&1 | tail -5
```
All existing tests pass. All new poly::gcd tests pass. No regressions.
</verification>

<success_criteria>
1. poly_gcd uses subresultant PRS with content extraction, returns monic GCD
2. poly_gcd of coprime polynomials returns QRatPoly::one()
3. poly_gcd handles zero inputs, same-polynomial inputs, nested-factor inputs
4. No coefficient explosion on degree-10+ polynomial GCD
5. poly_resultant returns zero iff polynomials share a common root
6. poly_resultant returns correct nonzero values for coprime polynomials
7. q_shift produces p(q*x) via O(n) coefficient scaling
8. q_shift_n handles positive, negative, and zero shift exponents
9. Evaluation identity: p.q_shift(q).eval(x) == p.eval(q*x)
10. Full crate test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/13-polynomial-infrastructure/13-02-SUMMARY.md`
</output>
