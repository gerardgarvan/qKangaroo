---
phase: 13-polynomial-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["13-01", "13-02"]
files_modified:
  - crates/qsym-core/src/poly/ratfunc.rs
  - crates/qsym-core/src/poly/mod.rs
  - crates/qsym-core/src/lib.rs
autonomous: true
must_haves:
  truths:
    - "QRatRationalFunc auto-reduces to lowest terms on construction"
    - "QRatRationalFunc denominator is always monic"
    - "Rational function arithmetic (add, sub, mul, div, neg) produces correctly simplified results"
    - "QRatRationalFunc from polynomial with common factor simplifies: (x^2-1)/(x-1) = (x+1)/1"
    - "Rational function q-shift shifts both numerator and denominator"
    - "Rational function equality works via normalized form comparison"
  artifacts:
    - path: "crates/qsym-core/src/poly/ratfunc.rs"
      provides: "QRatRationalFunc struct, constructor with auto-simplification, arithmetic, q_shift, Display, PartialEq"
      contains: "pub struct QRatRationalFunc"
    - path: "crates/qsym-core/src/poly/mod.rs"
      provides: "pub mod ratfunc declaration, re-exports of QRatRationalFunc"
      contains: "pub mod ratfunc"
    - path: "crates/qsym-core/src/lib.rs"
      provides: "Re-export of QRatRationalFunc at crate root"
      contains: "QRatRationalFunc"
  key_links:
    - from: "crates/qsym-core/src/poly/ratfunc.rs"
      to: "crates/qsym-core/src/poly/gcd.rs"
      via: "poly_gcd for auto-simplification"
      pattern: "poly_gcd"
    - from: "crates/qsym-core/src/poly/ratfunc.rs"
      to: "crates/qsym-core/src/poly/mod.rs"
      via: "QRatPoly type"
      pattern: "use super::QRatPoly"
    - from: "crates/qsym-core/src/poly/ratfunc.rs"
      to: "crates/qsym-core/src/poly/arithmetic.rs"
      via: "Mul, exact_div operations on QRatPoly"
      pattern: "exact_div|\\* &"
---

<objective>
Implement QRatRationalFunc (rational function type) with auto-simplification on construction and full arithmetic support.

Purpose: Rational functions are the coefficient type in q-Gosper's key equation (Phase 14) and appear throughout q-Zeilberger (Phase 15). Auto-simplification via GCD keeps expression sizes manageable. This completes Phase 13's polynomial infrastructure.

Output: `crates/qsym-core/src/poly/ratfunc.rs` with QRatRationalFunc, completing the `poly/` module.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-polynomial-infrastructure/13-RESEARCH.md
@.planning/phases/13-polynomial-infrastructure/13-01-SUMMARY.md
@.planning/phases/13-polynomial-infrastructure/13-02-SUMMARY.md
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/arithmetic.rs
@crates/qsym-core/src/poly/gcd.rs
@crates/qsym-core/src/number.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: QRatRationalFunc struct with auto-simplification</name>
  <files>crates/qsym-core/src/poly/ratfunc.rs, crates/qsym-core/src/poly/mod.rs, crates/qsym-core/src/lib.rs</files>
  <action>
Create `ratfunc.rs` implementing the rational function type.

**Struct:**
```rust
/// Rational function p(x)/q(x) in lowest terms with monic denominator.
///
/// Invariants:
///   1. gcd(numer, denom) = 1
///   2. denom is monic (leading coefficient = 1)
///   3. denom is nonzero
#[derive(Clone, Debug)]
pub struct QRatRationalFunc {
    pub numer: QRatPoly,
    pub denom: QRatPoly,
}
```

**Constructor (enforces all invariants):**
- `new(numer: QRatPoly, denom: QRatPoly) -> Self`:
  1. Assert denom is not zero (panic with "Rational function denominator cannot be zero")
  2. If numer is zero, return { numer: zero, denom: one }
  3. Compute g = poly_gcd(&numer, &denom)
  4. n = numer.exact_div(&g), d = denom.exact_div(&g)
  5. Make denom monic: lc = d.leading_coeff().unwrap(); if lc != 1, scale both: n = n.scalar_div(&lc), d = d.scalar_div(&lc)
  6. Return Self { numer: n, denom: d }

**Convenience constructors:**
- `from_poly(p: QRatPoly) -> Self` -- creates p/1
- `from_qrat(c: QRat) -> Self` -- creates constant(c)/1
- `zero() -> Self` -- 0/1
- `one() -> Self` -- 1/1

**Arithmetic:**
- `add(&self, other: &Self) -> Self`:
  numer = &self.numer * &other.denom + &self.denom * &other.numer
  denom = &self.denom * &other.denom
  Self::new(numer, denom) -- auto-reduces

- `sub(&self, other: &Self) -> Self`:
  numer = &self.numer * &other.denom - &self.denom * &other.numer
  denom = &self.denom * &other.denom
  Self::new(numer, denom)

- `mul(&self, other: &Self) -> Self`:
  Cross-cancel optimization to keep intermediate sizes small:
  g1 = poly_gcd(&self.numer, &other.denom)
  g2 = poly_gcd(&other.numer, &self.denom)
  n1 = self.numer.exact_div(&g1), d2 = other.denom.exact_div(&g1)
  n2 = other.numer.exact_div(&g2), d1 = self.denom.exact_div(&g2)
  Self::new(&n1 * &n2, &d1 * &d2)

- `div(&self, other: &Self) -> Self`:
  Assert other is not zero. Multiply self by reciprocal of other.
  Self::new(&self.numer * &other.denom, &self.denom * &other.numer)

- `neg(&self) -> Self`:
  Self { numer: -self.numer.clone(), denom: self.denom.clone() }
  (No need for new() since negation doesn't affect GCD or monicity)

**Implement std::ops traits:**
- Add, Sub, Mul, Div, Neg for both by-value and by-reference variants (same pattern as QRatPoly arithmetic)

**Queries:**
- `is_zero() -> bool` -- numer.is_zero()
- `is_polynomial() -> bool` -- denom.is_one()
- `eval(&self, x: &QRat) -> Option<QRat>` -- compute numer.eval(x) / denom.eval(x). Return None if denom.eval(x) is zero (pole).

**q-shift:**
- `q_shift(&self, q_val: &QRat) -> Self`:
  Self::new(self.numer.q_shift(q_val), self.denom.q_shift(q_val))
  (Constructor auto-reduces, though shifting coprime polys should remain coprime)
- `q_shift_n(&self, q_val: &QRat, j: i64) -> Self`:
  Self::new(self.numer.q_shift_n(q_val, j), self.denom.q_shift_n(q_val, j))

**PartialEq/Eq:**
- Compare normalized forms: self.numer == other.numer && self.denom == other.denom
  (Valid because both are in canonical form: lowest terms, monic denominator)

**Display:**
- If denom is one: display numer only
- Otherwise: display "({numer}) / ({denom})"

**Module wiring in mod.rs:**
- Add `pub mod ratfunc;`
- Add re-exports: `pub use ratfunc::QRatRationalFunc;`

**Re-export in lib.rs:**
- Add `QRatRationalFunc` to the poly re-exports: `pub use poly::{QRatPoly, QRatRationalFunc};`
- Also re-export poly_gcd and poly_resultant: `pub use poly::{poly_gcd, poly_resultant};`

**Tests in ratfunc.rs:**

Construction and auto-reduction:
- (x^2-1)/(x-1) simplifies to (x+1)/1
- (2x)/(2x+2) simplifies to x/(x+1) -- monic denominator
- (6x^2 + 3x)/(3x) simplifies to (2x+1)/1
- zero numerator -> 0/1 regardless of denominator
- #[should_panic] for zero denominator

Arithmetic:
- 1/x + 1/(x+1) = (2x+1)/(x^2+x)
- (x+1)/1 * (x-1)/1 = (x^2-1)/1
- ((x+1)/(x-1)) * ((x-1)/(x+2)) = (x+1)/(x+2) -- cross-cancellation
- Division: (1/x) / (1/(x+1)) = (x+1)/x
- Negation: -(x/(x+1)) = (-x)/(x+1)

Queries:
- is_zero on 0/1 = true
- is_polynomial on (x+1)/1 = true
- is_polynomial on x/(x+1) = false
- eval: (x+1)/x at x=2 gives 3/2
- eval: x/(x-1) at x=1 gives None (pole)

q-shift:
- Rational function q_shift shifts both numer and denom
- q_shift_n round-trip: rf.q_shift_n(q, 2).q_shift_n(q, -2) == rf

Equality:
- Two constructions of same rational function compare equal
- Different rational functions compare unequal
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly::ratfunc -- --nocapture
```
All rational function tests pass. Then verify no regressions:
```bash
cargo test -p qsym-core 2>&1 | tail -5
```
  </verify>
  <done>QRatRationalFunc auto-reduces on construction, supports full arithmetic with cross-cancellation, q-shift, evaluation, and equality. All tests pass. Module fully wired in mod.rs and lib.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests and final verification</name>
  <files>crates/qsym-core/src/poly/mod.rs</files>
  <action>
Add integration-level tests in a `tests` module at the bottom of `poly/mod.rs` that verify cross-module interactions and the phase success criteria.

**Integration tests to add:**

1. **POLY-01 verification**: Construct QRatPoly from coefficients, perform add/sub/mul/div/rem, verify exact QRat results.
   ```rust
   // (x^3 - 2x^2 + x) / (x - 1) = (x^2 - x)
   // (x^2 - x) * (x - 1) + 0 = x^3 - 2x^2 + x
   ```

2. **POLY-02 verification**: GCD of two degree-5+ polynomials with known common factor, verify result is monic and correct without coefficient explosion.
   ```rust
   // p = (x^2 + 1)(x^3 - x + 1), q = (x^2 + 1)(x^2 - 3x + 2)
   // gcd(p, q) = x^2 + 1
   ```

3. **POLY-03 verification**: Resultant correctly identifies shared roots.
   ```rust
   // resultant(x^2 - 5x + 6, x^2 - 3x + 2) = 0  (share root x=2)
   // resultant(x^2 + 1, x^2 - 1) != 0  (no common root over Q)
   ```

4. **POLY-04 verification**: q-shift evaluation identity holds.
   ```rust
   // For p = x^3 + 2x + 1, q = 3/7:
   // p.q_shift(&q).eval(&x) == p.eval(&(q * x))  for several x values
   ```

5. **POLY-05 verification**: Rational function auto-simplification and arithmetic.
   ```rust
   // (x^3 - x) / (x^2 - 1) = x/1  (since x^3-x = x(x^2-1))
   // 1/(x-1) + 1/(x+1) = 2x/(x^2-1)
   ```

6. **Round-trip test**: Build rational function from factors, decompose, recompose.
   ```rust
   // rf = (x+1)(x+2) / ((x+3)(x+4))
   // rf * ((x+3)(x+4) / (x+1)(x+2)) == 1/1
   ```

7. **Coefficient size test**: GCD of degree-10 polynomials with 3-digit QRat coefficients. Verify intermediate results don't have coefficients exceeding ~10 digits (subresultant PRS keeps growth polynomial).

**Count total tests added across all files.** Target: 40+ new tests for the poly module.
  </action>
  <verify>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-core poly -- --nocapture 2>&1 | grep -E "test result|running"
cargo test -p qsym-core 2>&1 | tail -3
```
All poly module tests pass. Full crate test suite passes. Count new tests (should be 40+).
  </verify>
  <done>All 5 phase success criteria verified by integration tests. 40+ tests in poly module. Full crate test suite passes with no regressions. Phase 13 polynomial infrastructure is complete.</done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
# All poly tests pass
cargo test -p qsym-core poly -- --nocapture
# Full crate - no regressions
cargo test -p qsym-core 2>&1 | tail -5
# Count total tests
cargo test -p qsym-core 2>&1 | grep "test result"
```
Total test count should be 578 + ~40-50 new = ~620+ tests.
</verification>

<success_criteria>
1. QRatRationalFunc auto-reduces (x^2-1)/(x-1) to (x+1)/1 on construction
2. Rational function arithmetic produces correctly simplified results
3. Cross-cancellation in multiplication keeps intermediate polynomial sizes small
4. q-shift on rational functions shifts both numerator and denominator
5. All 5 phase success criteria (POLY-01 through POLY-05) verified by integration tests
6. 40+ new tests in the poly module
7. Total crate test count >= 618 (578 existing + 40 new)
8. No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/13-polynomial-infrastructure/13-03-SUMMARY.md`
</output>
