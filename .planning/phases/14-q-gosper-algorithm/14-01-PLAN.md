---
phase: 14-q-gosper-algorithm
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/gosper.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "Term ratio t(k+1)/t(k) of a HypergeometricSeries is correctly extracted as a rational function of x = q^k"
    - "q-dispersion set correctly identifies all non-negative j where gcd(a(x), b(q^j*x)) is nontrivial"
  artifacts:
    - path: "crates/qsym-core/src/qseries/gosper.rs"
      provides: "Term ratio extraction and q-dispersion computation"
      exports: ["extract_term_ratio", "q_dispersion", "QGosperResult", "GosperNormalForm"]
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "Module registration and re-exports for gosper"
      contains: "pub mod gosper"
  key_links:
    - from: "crates/qsym-core/src/qseries/gosper.rs"
      to: "crates/qsym-core/src/poly/mod.rs"
      via: "QRatPoly, QRatRationalFunc, poly_gcd imports"
      pattern: "use crate::poly"
    - from: "crates/qsym-core/src/qseries/gosper.rs"
      to: "crates/qsym-core/src/qseries/mod.rs"
      via: "QMonomial, HypergeometricSeries imports"
      pattern: "use super::.*QMonomial"
---

<objective>
Create the gosper.rs module with term ratio extraction (GOSP-01) and q-dispersion computation (GOSP-02).

Purpose: These are the foundational building blocks of the q-Gosper algorithm. Term ratio extraction converts a HypergeometricSeries into a rational function of x = q^k, and q-dispersion finds the integer shifts where two polynomials share common factors under q-shift -- the key input to the Gosper normal form decomposition.

Output: `crates/qsym-core/src/qseries/gosper.rs` with public types (QGosperResult, GosperNormalForm) and functions (extract_term_ratio, q_dispersion), plus module registration in mod.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-q-gosper-algorithm/14-RESEARCH.md
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/gcd.rs
@crates/qsym-core/src/poly/ratfunc.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gosper.rs with types, helpers, term ratio extraction, and q-dispersion</name>
  <files>crates/qsym-core/src/qseries/gosper.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Create `crates/qsym-core/src/qseries/gosper.rs` with the following:

**Module-level doc comment:** Explain this implements the q-Gosper algorithm for indefinite q-hypergeometric summation. Reference Koornwinder 1993, Paule-Riese 1997.

**Imports:**
- `use crate::number::QRat;`
- `use crate::poly::{QRatPoly, QRatRationalFunc, poly_gcd};`
- `use super::{QMonomial, HypergeometricSeries};`

**Public types:**

1. `QGosperResult` enum:
   - `Summable { certificate: QRatRationalFunc }` -- the rational function certificate
   - `NotSummable` -- no q-hypergeometric antidifference exists

2. `GosperNormalForm` struct (public fields):
   - `sigma: QRatPoly` -- numerator factor
   - `tau: QRatPoly` -- denominator factor
   - `c: QRatPoly` -- adjustment polynomial
   These satisfy: original_ratio = sigma(x)/tau(x) * c(qx)/c(x), with gcd(sigma(x), tau(q^j*x)) = 1 for all j >= 1.

**Private helper:**

`fn eval_qmonomial(mono: &QMonomial, q_val: &QRat) -> QRat`
- Evaluates c * q_val^power. For power == 0, return coeff directly.
- For positive power, use repeated squaring (reuse the qrat_pow_signed pattern from poly/mod.rs).
- For negative power, compute q_val^|power| then invert.
- Import or redefine the helper. Since qrat_pow_signed is private in poly/mod.rs, redefine a local version here. Name it `qrat_pow_i64(base: &QRat, exp: i64) -> QRat`. Use repeated squaring for the absolute value, then invert if negative.

**Public function: `extract_term_ratio`**

```rust
pub fn extract_term_ratio(
    series: &HypergeometricSeries,
    q_val: &QRat,
) -> QRatRationalFunc
```

Given a HypergeometricSeries with upper params a_1,...,a_r, lower params b_1,...,b_s, and argument z, build the term ratio t_{k+1}/t_k as a rational function of x = q^k:

- **Numerator polynomial:** Start with QRatPoly::one(). For each upper param `a_i`, evaluate a_i_eval = eval_qmonomial(&a_i, q_val), then multiply by the linear factor `QRatPoly::linear(QRat::one(), -a_i_eval)` (representing 1 - a_i_eval * x).

- **Denominator polynomial:** Start with `QRatPoly::linear(QRat::one(), -q_val.clone())` (representing 1 - q*x, the (q;q) factor). For each lower param `b_j`, evaluate b_j_eval = eval_qmonomial(&b_j, q_val), multiply by `QRatPoly::linear(QRat::one(), -b_j_eval)`.

- **Extra factor:** Compute `extra = 1 + s - r` (as i64, where s = series.s(), r = series.r()). Evaluate z_eval = eval_qmonomial(&series.argument, q_val). Compute sign = if extra % 2 == 0 { 1 } else { -1 }. Compute extra_coeff = sign * z_eval.
  - If extra >= 0: create monomial `QRatPoly::monomial(extra_coeff, extra as usize)` and multiply into numerator.
  - If extra < 0: create monomial `QRatPoly::monomial(QRat::one(), (-extra) as usize)` and multiply into denominator, then scalar_mul the numerator by extra_coeff.

- Return `QRatRationalFunc::new(numer, denom)` which auto-reduces via GCD.

**Important:** Handle the edge case where extra_coeff is negative -- the sign from (-1)^{1+s-r} must be correctly applied. The QRat negation handles this naturally.

**Public function: `q_dispersion`**

```rust
pub fn q_dispersion(
    a: &QRatPoly,
    b: &QRatPoly,
    q_val: &QRat,
) -> Vec<i64>
```

Find all non-negative integers j such that gcd(a(x), b(q^j*x)) is non-trivial (degree >= 1).

Algorithm:
1. If a.is_zero() or b.is_zero(), return empty vec.
2. Compute j_max = deg(a) * deg(b) as upper bound (safe bound from resultant theory). If either degree is None (constant/zero), return empty.
3. Iterate j = 0, 1, ..., j_max:
   - Compute b_shifted = b.q_shift_n(q_val, j).
   - Compute g = poly_gcd(a, &b_shifted).
   - If g has degree >= 1 (i.e., g.degree().unwrap_or(0) >= 1), push j into the result.
4. Return the sorted vector.

Also add a private helper `q_dispersion_positive` that is the same but starts from j=1 (skips j=0). This will be needed by the normal form decomposition in Plan 02.

**Tests (in `#[cfg(test)] mod tests`):**

For extract_term_ratio:
1. Test with a simple 2phi1 series: upper=[q^{-2}, q^2], lower=[q^3], z=q. Use q_val=2. Verify the ratio is the expected rational function by checking numerator and denominator degrees and evaluating at a specific point.
2. Test with a 1phi0 series (r=1, s=0, extra=1): upper=[q^{-3}], z=q. Verify the ratio has the correct form.
3. Test verification: for the q-Vandermonde _2phi1(a, q^{-n}; c; q, cq^n/a), extract the ratio and verify it matches the known formula by evaluating at specific x values.

For q_dispersion:
1. Test with coprime polynomials (no shifts produce common factors): q_dispersion should return empty.
2. Test with a(x) = (1-x), b(x) = (1-x): dispersion should include j=0 since gcd(1-x, 1-x) = 1-x.
3. Test with a(x) = (1-x), b(x) = (1-q*x) where q_val=2: b(q^1*x) = 1-q*q*x = 1-4x. Check gcd(1-x, 1-4x) = 1 (no common root), but gcd(1-x, b(q^0*x)) = gcd(1-x, 1-2x) = 1 also. So dispersion is empty.
4. Test with a(x) = (1-x)(1-2x), b(x) = (1-x)(1-3x), q_val=1: should find j=0 since gcd is nontrivial at j=0. (Note: q_val=1 is degenerate but tests the mechanism.)
5. Test with polynomials where a and b share a root under q-shift: e.g., a(x) = (1-2x), b(x) = (1-x), q_val=2. Then b(q^1*x) = 1-2x = a(x), so j=1 should be in the dispersion set.

For q_dispersion_positive:
1. Test that it excludes j=0: same setup as test 2 above but using q_dispersion_positive returns empty.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core gosper` -- all tests pass. Also run `cargo test -p qsym-core` to confirm no regressions.
  </verify>
  <done>
- gosper.rs exists with QGosperResult, GosperNormalForm types, extract_term_ratio and q_dispersion functions
- mod.rs updated with `pub mod gosper;` and re-exports
- All tests pass for term ratio extraction and q-dispersion
- extract_term_ratio correctly converts HypergeometricSeries params to QRatRationalFunc
- q_dispersion correctly finds all j >= 0 where gcd is nontrivial
  </done>
</task>

</tasks>

<verification>
- `cargo test -p qsym-core gosper` passes all tests
- `cargo test -p qsym-core` passes (no regressions in existing 722 tests)
- Term ratio extraction produces correct rational functions matching known formulas
- q-dispersion finds the correct set of shifts for test cases with known answers
</verification>

<success_criteria>
- gosper.rs module exists and compiles
- extract_term_ratio converts HypergeometricSeries to QRatRationalFunc correctly
- q_dispersion finds all nontrivial GCD shifts within the degree-product bound
- All new tests pass alongside existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/14-q-gosper-algorithm/14-01-SUMMARY.md`
</output>
