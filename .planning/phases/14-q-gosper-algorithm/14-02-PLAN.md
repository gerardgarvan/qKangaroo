---
phase: 14-q-gosper-algorithm
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - crates/qsym-core/src/qseries/gosper.rs
autonomous: true

must_haves:
  truths:
    - "Gosper normal form decomposition produces sigma, tau, c satisfying r(x) = sigma(x)/tau(x) * c(qx)/c(x) and gcd(sigma(x), tau(q^j*x)) = 1 for all j >= 1"
    - "Key equation solver finds polynomial f satisfying sigma(x)*f(qx) - tau(x)*f(x) = c(x) when one exists, and returns None when no solution exists"
  artifacts:
    - path: "crates/qsym-core/src/qseries/gosper.rs"
      provides: "Gosper normal form and key equation solver"
      exports: ["gosper_normal_form", "solve_key_equation"]
  key_links:
    - from: "gosper_normal_form"
      to: "q_dispersion_positive"
      via: "iterative GCD loop using dispersion to find shifts"
      pattern: "q_dispersion_positive"
    - from: "solve_key_equation"
      to: "crates/qsym-core/src/qseries/linalg.rs"
      via: "linear system solving via RREF"
      pattern: "rational_null_space|rref"
---

<objective>
Implement the Gosper normal form decomposition (GOSP-03) and key equation solver (GOSP-04).

Purpose: The normal form decomposition converts the term ratio into a form where the key equation can be solved as a linear system. The key equation solver determines whether a polynomial antidifference certificate exists. Together, these are the algorithmic heart of q-Gosper.

Output: Two new public functions in gosper.rs: `gosper_normal_form` and `solve_key_equation`.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-q-gosper-algorithm/14-RESEARCH.md
@.planning/phases/14-q-gosper-algorithm/14-01-SUMMARY.md
@crates/qsym-core/src/qseries/gosper.rs
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/gcd.rs
@crates/qsym-core/src/qseries/linalg.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Gosper normal form decomposition</name>
  <files>crates/qsym-core/src/qseries/gosper.rs</files>
  <action>
Add the `gosper_normal_form` function to gosper.rs:

```rust
pub fn gosper_normal_form(
    numer: &QRatPoly,
    denom: &QRatPoly,
    q_val: &QRat,
) -> GosperNormalForm
```

**Algorithm:**
1. Start with sigma = numer.clone(), tau = denom.clone(), c = QRatPoly::one().
2. Enter loop:
   a. Compute disp = q_dispersion_positive(&sigma, &tau, q_val) (j >= 1 only).
   b. If disp is empty, break.
   c. Take j_max = *disp.last().unwrap() (largest dispersion value).
   d. Compute tau_shifted = tau.q_shift_n(q_val, j_max).
   e. Compute g = poly_gcd(&sigma, &tau_shifted). Make g monic for consistency.
   f. Update sigma = sigma.exact_div(&g).
   g. Compute g_unshifted = g.q_shift_n(q_val, -j_max). Update tau = tau.exact_div(&g_unshifted).
   h. Accumulate into c: for i in 0..j_max, compute g_back = g.q_shift_n(q_val, -i) and multiply c = &c * &g_back.
   i. Continue loop.
3. Return GosperNormalForm { sigma, tau, c }.

**Verification step (debug_assert):** After the loop, verify the decomposition:
- Compute c_shifted = c.q_shift(q_val).
- Build reconstructed = QRatRationalFunc::new(&sigma * &c_shifted, &tau * &c).
- Build original = QRatRationalFunc::new(numer.clone(), denom.clone()).
- debug_assert_eq!(reconstructed, original, "Normal form decomposition failed").

**Edge cases:**
- If numer or denom is constant, the dispersion is empty and the loop never executes.
- If numer and denom are already q-coprime (no dispersion >= 1), return immediately with c = 1.

**Tests for gosper_normal_form:**

1. **Already q-coprime:** a(x) = 1-x, b(x) = 1-3x, q_val=2. These should have no positive dispersion. Result: sigma=a, tau=b, c=1.

2. **Simple dispersion j=1:** Construct a(x) and b(x) such that gcd(a(x), b(q*x)) is nontrivial. For example, with q_val=2:
   - a(x) = (1-x)(1-4x) (roots at x=1 and x=1/4)
   - b(x) = (1-2x)(1-6x) (roots at x=1/2 and x=1/6)
   - b(q*x) = b(2x) = (1-4x)(1-12x)
   - gcd(a, b(2x)) = (1-4x), so j=1 is in the dispersion set.
   - After decomposition: sigma = (1-x), tau should be adjusted, c should capture the common factor.
   - Verify: sigma/tau * c(qx)/c(x) == a/b.

3. **Verification identity:** For any test case, verify sigma(x)/tau(x) * c(q*x)/c(x) = numer(x)/denom(x) as rational functions.

4. **q-coprimality check:** After decomposition, verify that q_dispersion_positive(&sigma, &tau, q_val) is empty.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core gosper::tests::test_gosper_normal` -- all normal form tests pass.
  </verify>
  <done>
- gosper_normal_form decomposes a/b into sigma/tau * c(qx)/c(x)
- After decomposition, gcd(sigma(x), tau(q^j*x)) = 1 for all j >= 1
- Reconstruction identity verified: sigma/tau * c(qx)/c(x) = original ratio
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement key equation solver</name>
  <files>crates/qsym-core/src/qseries/gosper.rs</files>
  <action>
Add the `solve_key_equation` function to gosper.rs:

```rust
pub fn solve_key_equation(
    sigma: &QRatPoly,
    tau: &QRatPoly,
    c_poly: &QRatPoly,
    q_val: &QRat,
) -> Option<QRatPoly>
```

The key equation is: sigma(x) * f(q*x) - tau(x) * f(x) = c_poly(x).

**Step 1: Compute degree bound for f.**

Let d_sigma = sigma.degree(), d_tau = tau.degree(), d_c = c_poly.degree(). If any is None (zero polynomial), handle edge cases:
- If c_poly is zero, f = 0 is a solution (return Some(QRatPoly::zero())).
- If sigma is zero and tau is zero but c is nonzero, no solution (return None).
- If only sigma is zero: -tau(x)*f(x) = c(x), so f = -c/tau if divisible (use exact_div, catching panic with div_rem check).
- If only tau is zero: sigma(x)*f(qx) = c(x). Degree: d_sigma + deg_f = d_c, so deg_f = d_c - d_sigma. Solve by coefficient matching.

For the normal case (both nonzero):

Candidate degree computation:
- If d_sigma != d_tau: deg_f = d_c - max(d_sigma, d_tau). If this is negative, no solution.
- If d_sigma == d_tau:
  - Let lc_sigma = sigma.leading_coeff().unwrap(), lc_tau = tau.leading_coeff().unwrap().
  - The leading terms must cancel: lc_sigma * q_val^{deg_f} * f_D = lc_tau * f_D.
  - So q_val^{deg_f} = lc_tau / lc_sigma.
  - Compute the ratio = lc_tau / lc_sigma.
  - Try to find deg_f such that q_val^{deg_f} = ratio. Iterate deg_f from 0 up to d_c: if qrat_pow_i64(q_val, deg_f) == ratio, use that deg_f.
  - If no match found, try deg_f = d_c - d_sigma as a fallback (the "non-cancellation" case where the leading term of c determines the degree).

**Strategy:** Try the primary degree bound first. If the linear system has no solution, try deg_f + 1 as a fallback (per research recommendation). If both fail, return None.

**Step 2: Set up the linear system.**

Assume f(x) = f_0 + f_1*x + ... + f_D*x^D with D = deg_f.

The equation sigma(x)*f(qx) - tau(x)*f(x) = c_poly(x) must hold coefficient-by-coefficient.

Note: f(qx) = f_0 + f_1*q*x + f_2*q^2*x^2 + ... + f_D*q^D*x^D. So the coefficient of x^i in f(qx) is f_i * q_val^i.

Compute the polynomial sigma(x)*f(qx) by:
- For each coefficient x^k on the LHS, sigma(x)*f(qx) contributes: sum_{i+j=k} sigma_coeff(i) * f_j * q_val^j.
- Similarly, tau(x)*f(x) contributes: sum_{i+j=k} tau_coeff(i) * f_j.

The equation becomes: for each power k of x (from 0 to max degree of LHS):
  sum_j [sigma_coeff(k-j) * q_val^j - tau_coeff(k-j) * 1] * f_j = c_poly_coeff(k)

This is a linear system A * [f_0, ..., f_D]^T = b where:
- A is a matrix with rows indexed by power k, columns by unknown f_j.
- A[k][j] = sigma.coeff(k-j) * q_val^j - tau.coeff(k-j) for valid indices.
- b[k] = c_poly.coeff(k).

The number of equations = max(d_sigma + D, d_tau + D, d_c) + 1.
The number of unknowns = D + 1.

**Step 3: Solve via Gaussian elimination (RREF).**

Build an augmented matrix [A | b] and row-reduce. Use the RREF logic from linalg.rs directly (copy the pivot/elimination logic or build a simple solve_linear_system helper). Do NOT use rational_null_space -- we need to solve Ax=b, not find the null space.

Implement a private helper:
```rust
fn solve_linear_system(matrix: &[Vec<QRat>], rhs: &[QRat]) -> Option<Vec<QRat>>
```
That builds the augmented matrix, row-reduces to RREF, and extracts the unique solution if one exists (the system is square or overdetermined). Return None if the system is inconsistent.

**Step 4: Construct f from solution.**

If the system has a solution, construct f = QRatPoly::from_vec(solution_coeffs). Return Some(f).

**Tests for solve_key_equation:**

1. **Known solvable case:** sigma = 1-x, tau = 1, c = x (trivially constructed). The equation (1-x)*f(qx) - f(x) = x. Try with q_val=2 and verify the solution f satisfies the equation.

2. **Unsolvable case:** Construct sigma, tau, c where no polynomial f exists. For example, sigma = 1, tau = 1 (so f(qx) - f(x) = c(x)). For c(x) = x and q_val=2, try: f(2x) - f(x) = x. If f = ax+b, then 2ax+b - ax - b = ax = x, so a=1. f = x+b for any b. This is solvable! Instead, use c(x) = 1 (constant nonzero): f(2x) - f(x) = 1. If f = constant k, then k - k = 0 != 1. If f = ax + b, then 2ax + b - ax - b = ax = 1, impossible (1 is not a polynomial in x of degree >= 1 with zero constant). Actually ax = 1 has no polynomial solution. So this should return None.

3. **Verification:** For any returned solution f, verify sigma(x)*f(qx) - tau(x)*f(x) = c(x) by polynomial arithmetic (substitute, expand, compare).

4. **Degree bound edge case:** Test the d_sigma == d_tau case where the leading coefficient ratio is a q-power.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core gosper::tests::test_solve_key` -- all key equation tests pass. Also run `cargo test -p qsym-core gosper` to confirm all gosper tests pass together.
  </verify>
  <done>
- solve_key_equation finds polynomial f for solvable cases
- solve_key_equation returns None for unsolvable cases
- Degree bound handles both d_sigma != d_tau and d_sigma == d_tau cases
- Solution verification: sigma(x)*f(qx) - tau(x)*f(x) = c(x) holds for all returned solutions
  </done>
</task>

</tasks>

<verification>
- `cargo test -p qsym-core gosper` passes all tests (both Plan 01 and Plan 02)
- `cargo test -p qsym-core` passes (no regressions)
- Normal form decomposition verified: sigma/tau * c(qx)/c(x) = original ratio
- Key equation solutions verified: sigma*f(qx) - tau*f(x) = c
- Unsolvable cases correctly return None
</verification>

<success_criteria>
- gosper_normal_form correctly decomposes ratios and produces q-coprime sigma, tau
- solve_key_equation finds solutions when they exist and returns None otherwise
- Both functions handle edge cases (constant polynomials, zero polynomials)
- All new tests pass alongside the full test suite
</success_criteria>

<output>
After completion, create `.planning/phases/14-q-gosper-algorithm/14-02-SUMMARY.md`
</output>
