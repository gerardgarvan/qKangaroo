---
phase: 14-q-gosper-algorithm
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - crates/qsym-core/src/qseries/gosper.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "The complete q-Gosper algorithm returns Summable(certificate) for known summable series like q-Vandermonde"
    - "The complete q-Gosper algorithm returns NotSummable for series with no q-hypergeometric antidifference"
    - "The antidifference certificate is verified: evaluating s_{k+1} - s_k at concrete k values reproduces t_k"
  artifacts:
    - path: "crates/qsym-core/src/qseries/gosper.rs"
      provides: "Complete q-Gosper algorithm"
      exports: ["q_gosper"]
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "Re-export of q_gosper"
      contains: "q_gosper"
  key_links:
    - from: "q_gosper"
      to: "extract_term_ratio"
      via: "first step: extract term ratio from HypergeometricSeries"
      pattern: "extract_term_ratio"
    - from: "q_gosper"
      to: "gosper_normal_form"
      via: "second step: decompose ratio into normal form"
      pattern: "gosper_normal_form"
    - from: "q_gosper"
      to: "solve_key_equation"
      via: "third step: solve for polynomial certificate"
      pattern: "solve_key_equation"
---

<objective>
Implement the complete q-Gosper algorithm (GOSP-05) and comprehensive integration tests.

Purpose: This ties together all components (term ratio extraction, normal form, key equation) into a single public function that takes a HypergeometricSeries and returns Summable or NotSummable. Integration tests verify the algorithm against known summable and non-summable series from the q-hypergeometric literature.

Output: Public function `q_gosper` in gosper.rs, re-exported from mod.rs, with comprehensive integration tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-q-gosper-algorithm/14-RESEARCH.md
@.planning/phases/14-q-gosper-algorithm/14-01-SUMMARY.md
@.planning/phases/14-q-gosper-algorithm/14-02-SUMMARY.md
@crates/qsym-core/src/qseries/gosper.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement the complete q_gosper function</name>
  <files>crates/qsym-core/src/qseries/gosper.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Add the main public function to gosper.rs:

```rust
/// Run the complete q-Gosper algorithm on a q-hypergeometric series.
///
/// Given a HypergeometricSeries and a concrete q value, determines whether
/// the series has a q-hypergeometric antidifference (indefinite sum).
///
/// Returns:
/// - `QGosperResult::Summable { certificate }` if an antidifference exists.
///   The certificate is a rational function R(x) such that the antidifference
///   at step k is s_k = R(q^k) * t_k, where t_k is the k-th term.
/// - `QGosperResult::NotSummable` if no q-hypergeometric antidifference exists.
///
/// The q_val parameter must not be zero or a root of unity.
pub fn q_gosper(
    series: &HypergeometricSeries,
    q_val: &QRat,
) -> QGosperResult
```

**Algorithm:**
1. Extract the term ratio: `let ratio = extract_term_ratio(series, q_val);`
2. Get coprime numerator and denominator: `let a = ratio.numer.clone(); let b = ratio.denom.clone();` (QRatRationalFunc already ensures gcd = 1).
3. Compute Gosper normal form: `let gnf = gosper_normal_form(&a, &b, q_val);`
4. Solve key equation: `let f = solve_key_equation(&gnf.sigma, &gnf.tau, &gnf.c, q_val);`
5. If f is None, return QGosperResult::NotSummable.
6. If f is Some(f_poly):
   - Construct the certificate rational function: R(x) = tau(x) * f(x) / c(x).
     This is the rational function such that s_k = R(q^k) * t_k is the antidifference.
   - Build: `let certificate = QRatRationalFunc::new(&gnf.tau * &f_poly, gnf.c.clone());`
   - Return QGosperResult::Summable { certificate }.

**Update mod.rs re-exports:** Add `q_gosper` to the `pub use gosper::...` line. The full re-export line should include: `QGosperResult, GosperNormalForm, extract_term_ratio, q_dispersion, gosper_normal_form, solve_key_equation, q_gosper`.

**Verification helper (private, for tests):**

Add a private helper function for verifying the antidifference:

```rust
/// Verify the q-Gosper certificate by checking s_{k+1} - s_k = t_k
/// for k = 0, 1, ..., max_k, where s_k = R(q^k) * t_k.
///
/// Returns true if the identity holds for all tested k.
fn verify_certificate(
    series: &HypergeometricSeries,
    certificate: &QRatRationalFunc,
    q_val: &QRat,
    max_k: usize,
) -> bool
```

This function:
1. Computes the first max_k+2 terms t_0, t_1, ..., t_{max_k+1} of the series using concrete evaluation:
   - t_0 = 1 (the initial term of any _r phi_s).
   - t_{k+1} = t_k * r(q^k) where r is the term ratio evaluated at x = q^k.
2. For each k = 0, ..., max_k:
   - Compute s_k = certificate.eval(q_val^k) * t_k. If the eval returns None (pole), skip this k.
   - Compute s_{k+1} = certificate.eval(q_val^{k+1}) * t_{k+1}.
   - Check s_{k+1} - s_k == t_k (within exact rational arithmetic).
3. Return true if all checks pass.

To compute t_k from t_{k-1}: use the term ratio r(x) = extract_term_ratio(series, q_val), then t_k = t_{k-1} * r.eval(q_val^{k-1}). Handle the eval returning None (skip that k).

**Integration tests:**

1. **q-Vandermonde (summable):** _2phi1(q^{-3}, q^2; q^3; q, q^4/q^2 = q^2). This is the q-Vandermonde with n=3, a=q^2, c=q^3. Use q_val = QRat::from((2,1)) (or another small integer). The algorithm should return Summable. Verify the certificate using verify_certificate with max_k = 5.

2. **Geometric series (summable):** _1phi0(a; -; q, z) with a = q^{-n} (terminating). The term ratio is (1-a*x)/(1-q*x) * (-z). For a = q^{-2}, z = q, q_val = 2: this is a finite geometric-like sum. Should be summable.

3. **Simple non-summable:** _2phi1(q^{-n}, b; c; q, q) where the parameters don't satisfy any known summation formula conditions. For example, _2phi1(q^{-3}, q; q^2; q, q) -- this is a q-Vandermonde only if z = cq^n/a = q^2*q^3/q = q^4, but z = q != q^4, so it may or may not be Gosper-summable. Choose parameters carefully: a non-balanced, non-Vandermonde 2phi1 with z=q^2 that is known to be NOT Gosper-summable. A good test: _2phi1(q^{-3}, q; q^5; q, q) -- the series truncates at n=3 terms, and the key equation should have no polynomial solution.

4. **Certificate verification round-trip:** For each Summable result, verify that s_{k+1} - s_k = t_k holds for k = 0, 1, ..., N where N is the termination order minus 1.

5. **Trivially terminating:** _2phi1(q^0, b; c; q, z) where q^0 = 1. The termination order is 0, so the sum is just the k=0 term (which is 1). This edge case should be handled (the ratio may be degenerate).

6. **Balanced 3phi2 (may or may not be summable via Gosper):** _3phi2(q^{-2}, q, q; q^2, q^2; q, q). q-Saalschutz applies here, but q-Gosper should also find it summable (Gosper can sum any series that has a hypergeometric antidifference, which balanced terminating sums do).
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core gosper` -- all tests pass, including integration tests. Also run the full test suite: `cargo test -p qsym-core` to confirm no regressions.
  </verify>
  <done>
- q_gosper returns Summable with valid certificate for known summable series
- q_gosper returns NotSummable for non-summable series
- Certificate verification passes: s_{k+1} - s_k = t_k for all tested k values
- mod.rs re-exports q_gosper and all gosper types/functions
- Full test suite passes (existing 722+ tests plus all new gosper tests)
  </done>
</task>

</tasks>

<verification>
- `cargo test -p qsym-core gosper` passes all tests (unit + integration)
- `cargo test -p qsym-core` passes (no regressions, total test count increased)
- q-Vandermonde correctly identified as Summable
- Non-summable series correctly identified as NotSummable
- Antidifference certificate verified via s_{k+1} - s_k = t_k identity
- All public types and functions properly re-exported from mod.rs
</verification>

<success_criteria>
- q_gosper function exists, compiles, and returns correct results
- Known summable series (q-Vandermonde, geometric) produce Summable with valid certificates
- Known non-summable series produce NotSummable
- Certificate verification helper confirms antidifference identity
- Complete test coverage: 6+ integration tests spanning summable, non-summable, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/14-q-gosper-algorithm/14-03-SUMMARY.md`
</output>
