---
phase: 15-q-zeilberger-wz-certificates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/zeilberger.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "N-direction shift ratio F(n+j,k)/F(n,k) is correctly computed as a QRatRationalFunc of x=q^k"
    - "Extended key equation with c_j unknowns is set up and solved for the q-Vandermonde case at order d=1"
    - "Creative telescoping loop finds a valid solution (non-trivial c_j and polynomial f) for q-Vandermonde"
  artifacts:
    - path: "crates/qsym-core/src/qseries/zeilberger.rs"
      provides: "n_shift_ratio, solve_extended_key_equation, creative telescoping loop core"
      min_lines: 200
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "pub mod zeilberger declaration"
      contains: "pub mod zeilberger"
  key_links:
    - from: "crates/qsym-core/src/qseries/zeilberger.rs"
      to: "crates/qsym-core/src/qseries/gosper.rs"
      via: "extract_term_ratio, gosper_normal_form"
      pattern: "use super::gosper"
    - from: "crates/qsym-core/src/qseries/zeilberger.rs"
      to: "crates/qsym-core/src/poly"
      via: "QRatPoly, QRatRationalFunc, poly_gcd"
      pattern: "use crate::poly"
---

<objective>
Create the zeilberger.rs module with n-direction shift ratio computation and the extended key equation solver that forms the core of the creative telescoping algorithm.

Purpose: The creative telescoping loop is the heart of q-Zeilberger. It wraps q-Gosper's key equation with additional unknowns (the recurrence coefficients c_j). This plan implements the mathematical machinery -- the next plan will wrap it into the user-facing API.

Output: zeilberger.rs with data types, n_shift_ratio, extended key equation solver, and tests proving the q-Vandermonde case succeeds at order d=1.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-RESEARCH.md
@.planning/phases/14-q-gosper-algorithm/14-01-SUMMARY.md
@.planning/phases/14-q-gosper-algorithm/14-02-SUMMARY.md
@.planning/phases/14-q-gosper-algorithm/14-03-SUMMARY.md
@crates/qsym-core/src/qseries/gosper.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/ratfunc.rs
@crates/qsym-core/src/poly/gcd.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create zeilberger.rs with data types, n-shift ratios, and extended key equation solver</name>
  <files>crates/qsym-core/src/qseries/zeilberger.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Create `crates/qsym-core/src/qseries/zeilberger.rs` with the following components:

**Imports and module doc:**
- Import from gosper: `extract_term_ratio`, `gosper_normal_form`, `GosperNormalForm`
- Import from super: `QMonomial`, `HypergeometricSeries`
- Import from crate::poly: `QRatPoly`, `QRatRationalFunc`, `poly_gcd`
- Import from crate::number: `QRat`

**Data types:**

```rust
/// Result of the q-Zeilberger algorithm.
#[derive(Clone, Debug)]
pub struct ZeilbergerResult {
    /// The recurrence order d.
    pub order: usize,
    /// The recurrence coefficients c_0, ..., c_d.
    /// c_j is the coefficient of S(n+j) in: c_0*S(n) + ... + c_d*S(n+d) = 0.
    pub coefficients: Vec<QRat>,
    /// The WZ proof certificate as a rational function of x = q^k.
    /// G(n,k) = R(q^k) * F(n,k) is the antidifference companion.
    pub certificate: QRatRationalFunc,
}

/// Result enum for q-Zeilberger.
#[derive(Clone, Debug)]
pub enum QZeilbergerResult {
    /// A recurrence was found.
    Recurrence(ZeilbergerResult),
    /// No recurrence found up to the given max_order.
    NoRecurrence,
}
```

**Private helper: qrat_pow_i64** -- Duplicate the same helper from gosper.rs (it is private there). Same implementation: repeated squaring for positive exponents, inversion for negative.

**Private helper: eval_qmonomial** -- Same duplicate from gosper.rs (also private). Returns coeff * q_val^power.

**N-direction shift ratio (pub(crate)):**

```rust
/// Compute F(n+j, k) / F(n, k) as a rational function of x = q^k.
///
/// For a HypergeometricSeries, shifting n -> n+j changes parameters that
/// depend on n. This function constructs the shifted series and computes
/// the ratio of k-th terms as a rational function.
///
/// The ratio is computed term-by-term: for each upper/lower param and
/// the argument, compute how the shift affects the k-th term.
pub(crate) fn n_shift_ratio(
    series: &HypergeometricSeries,
    j: i64,
    n_val: i64,
    q_val: &QRat,
    n_param_indices: &[usize],  // which upper params depend on n
    n_is_in_argument: bool,     // whether the argument z depends on n
) -> QRatRationalFunc
```

Implementation approach -- the concrete approach:
1. Build the "shifted" HypergeometricSeries by modifying parameters that depend on n. For each index in `n_param_indices`, the upper param q^{-n} becomes q^{-(n+j)} (multiply coeff by q^{-j} and keep power same, OR adjust power by -j). For the argument, if it depends on n (e.g., z = c*q^n/a), shift its power by +j.
2. Use `extract_term_ratio` on both the original (at n_val) and shifted (at n_val+j) series to get their k-direction ratios r_0(x) and r_j(x).
3. The ratio F(n+j,k)/F(n,k) = product_{i=0}^{k-1} r_j(q^i) / product_{i=0}^{k-1} r_0(q^i) -- but this gives a numeric value, not a rational function.

BETTER approach: Compute the ratio DIRECTLY from the Pochhammer quotients. For each upper param a_i that depends on n:
- Original k-th term factor: (a_i(n); q)_k = prod_{m=0}^{k-1} (1 - a_i(n) * q^m)
- Shifted k-th term factor: (a_i(n+j); q)_k = prod_{m=0}^{k-1} (1 - a_i(n+j) * q^m)
- Ratio = prod_{m=0}^{k-1} (1 - a_i(n+j)*q^m) / (1 - a_i(n)*q^m)

With a_i(n) evaluated at concrete q_val and n_val, each factor in the product is a ratio of linear polynomials in x = q^k... WAIT, that's not right either. The product over m=0..k-1 depends on k itself, so it's NOT a simple rational function of x = q^k.

CORRECT approach: The ratio F(n+j,k)/F(n,k) is NOT a standard rational function of x = q^k for arbitrary k. However, for the purpose of the extended key equation, what we actually need is:

The modified summand divided by F(n,k) gives: c_0 + c_1*R_1(x_k) + ... + c_d*R_d(x_k), where each R_j involves a PRODUCT of k-dependent linear factors. This product IS a polynomial in x_k.

SIMPLEST correct approach: Build the shifted series, extract both term ratios (original and shifted), compute their ratio. The ratio of consecutive term ratios gives:

r_j(x) / r_0(x) = [F(n+j, k+1)/F(n+j, k)] / [F(n, k+1)/F(n, k)]

This ratio IS a rational function of x = q^k. Then:

R_j(x) = F(n+j, k)/F(n, k) satisfies R_j(x) at k+1 / R_j(x) at k = r_j(x)/r_0(x).

But we need R_j(x) itself, not its ratio. For the Zeilberger extended key equation, we need R_j evaluated at x = q^k for specific k values.

FINAL PRAGMATIC approach (matching research recommendation): Since we work with concrete q_val and n_val:

1. Build the shifted HypergeometricSeries for n+j.
2. Extract both term ratios: r_original = extract_term_ratio(series_n, q_val) and r_shifted = extract_term_ratio(series_n_plus_j, q_val).
3. The ratio r_shifted(x) / r_original(x) is a rational function of x = q^k. This gives the TERM-RATIO of R_j in the k-direction.
4. For the extended key equation, we DON'T need R_j itself as a rational function. Instead, the Zeilberger key equation (from the research) is:

   sigma(x)*f(qx) - tau(x)*f(x) = tau(x)*c(x) * [c_0 + c_1*R_1(x) + ... + c_d*R_d(x)]

   where R_j is evaluated at x = q^k. Since R_j is a PRODUCT of k linear factors (not a simple rational function), we need a different formulation.

**ACTUAL implementation (Paule-Riese approach from research):**

For each order d, the modified summand is sum_{j=0}^d c_j * F(n+j, k). Each F(n+j, k) is q-hypergeometric in k with its own term ratio r_j(x). The key insight: instead of working with the combined modified summand's term ratio (which involves the c_j), work with the EXTENDED KEY EQUATION directly.

The telescoping equation divided by F(n,k) is:
  y(k+1)*t_k - y(k) = sum_j c_j * R_j(k)

where t_k = r_original(x) = sigma/tau * c_poly(qx)/c_poly(x) (Gosper normal form) and R_j(k) = F(n+j,k)/F(n,k).

Setting y(k) = f(x)/c_poly(x) as in standard Gosper, multiply by tau(x)*c_poly(x):
  sigma(x)*f(qx) - tau(x)*f(x) = tau(x)*c_poly(x) * sum_j c_j * R_j(k)

BUT R_j(k) is not a polynomial/rational function of x for general k. It's a product of k factors.

**KEY RESOLUTION:** For the standard Zeilberger algorithm, one does NOT compute R_j as a symbolic rational function. Instead, one constructs the COMBINED modified summand, which IS q-hypergeometric in k (it's a sum of q-hypergeometric terms with the SAME support, weighted by c_j). The trick is:

For each shifted series F(n+j, k), it has k-direction term ratio r_j(x). The modified summand H(k) = sum_j c_j * F(n+j, k) is NOT q-hypergeometric in general, but we can still apply Gosper's approach if we set up the system as follows:

At each value of k, the Gosper key equation must hold with the RHS being a specific polynomial. This gives us equations at k = 0, 1, 2, ... which determine both f and the c_j.

**SIMPLEST IMPLEMENTATION THAT WORKS:**

Evaluate R_j(k) = F(n+j, k) / F(n, k) NUMERICALLY at k = 0, 1, 2, ... up to the termination order. Then the extended key equation becomes a system of linear equations in the unknowns {f_0, ..., f_D, c_0, ..., c_{d-1}} (with c_d = 1).

BUT WAIT -- the key equation is about POLYNOMIALS, not evaluations. We need f to be a polynomial in x.

**FINAL CORRECT IMPLEMENTATION:**

The approach from the research that actually works: treat the problem as finding a common antidifference.

For each j = 0, ..., d, the j-th shifted summand F(n+j, k) has k-term ratio r_j(x). Apply Gosper normal form to the ORIGINAL ratio r_0(x) to get sigma, tau, c_poly. Then the ratio r_j(x)/r_0(x) IS a rational function of x = q^k (it's a finite product of ratios of linear factors that are the same for each k). Specifically:

r_j(x) = F(n+j, k+1) / F(n+j, k)

is the k-direction term ratio evaluated with the j-shifted parameters. Since both r_j and r_0 are rational functions of x = q^k (they come from extract_term_ratio), their ratio rho_j(x) = r_j(x) / r_0(x) is also a rational function.

The relationship between R_j(k) and rho_j is: R_j(k+1) = R_j(k) * rho_j(q^k), with R_j(0) = 1. This means R_j is NOT a rational function of x -- it's a PRODUCT of rho_j evaluated at successive q-powers.

**THE ACTUAL ALGORITHM (found by careful analysis):**

For the Zeilberger approach, we need to turn the problem into an extended Gosper-type key equation. The way to do this is:

The combined sum has G(n,k) = y(k) * F(n,k), and we want:
  sum_j c_j * F(n+j,k) = G(n,k+1) - G(n,k) = y(k+1)*F(n,k+1) - y(k)*F(n,k)

Dividing by F(n,k):
  sum_j c_j * R_j(k) = y(k+1) * t_k - y(k)

where t_k = F(n,k+1)/F(n,k) = r_0(q^k).

For k = 0, 1, ..., N (where N is the termination order), evaluate R_j(k) numerically. The unknowns are the polynomial coefficients of y(x) = f(x)/c(x) and the c_j values. At each k, substitute x = q^k into y(x) = f(x)/c(x) and get a linear equation.

This is the EVALUATION-BASED approach: set up a large linear system from evaluating the key equation at x = q^0, q^1, ..., q^N.

**Implement this concrete approach:**

1. For the original series at n_val, extract the k-direction term ratio r_0(x).
2. For each shift j=1..d, build the shifted series (replace params that depend on n), extract r_j(x).
3. Compute the Gosper normal form for r_0(x): sigma, tau, c_poly.
4. Evaluate R_j(k) = F(n+j,k)/F(n,k) numerically for k = 0, 1, ..., N by computing cumulative products of term ratios. Specifically:
   - R_j(0) = 1 (the 0th term ratio is always 1 for normalized series)
   - Wait, we need to be more careful. F(n,k) is the k-th term of the series at n. Both F(n,0) and F(n+j,0) equal 1 (the initial term). So R_j(0) = F(n+j,0)/F(n,0) = 1.
   - R_j(k+1) = R_j(k) * [F(n+j,k+1)/F(n+j,k)] / [F(n,k+1)/F(n,k)]
              = R_j(k) * r_j(q^k) / r_0(q^k)
   - Compute iteratively.
5. The key equation y(k+1)*t_k - y(k) = sum_j c_j*R_j(k) at x = q^k means:
   [f(q^{k+1})/c(q^{k+1})] * [sigma(q^k)/tau(q^k)] * [c(q^{k+1})/c(q^k)] - f(q^k)/c(q^k) = sum_j c_j * R_j(k)

   Multiplying by tau(q^k)*c(q^k):
   sigma(q^k)*f(q^{k+1}) - tau(q^k)*f(q^k) = tau(q^k)*c(q^k) * sum_j c_j*R_j(k)

   This must hold for all k. Since f is a polynomial of degree D, f(q^k) = sum_{i=0}^D f_i * (q^k)^i. So the LHS is a known linear combination of f_i. The RHS involves c_j * R_j(k) (known numerics times unknown c_j). This gives one linear equation per k value.

6. Set up the linear system with unknowns [f_0, ..., f_D, c_0, ..., c_{d-1}] (normalize c_d = 1). For each k = 0, 1, ..., N:
   - LHS coeff of f_i: sigma_eval * (q^{k+1})^i - tau_eval * (q^k)^i
   - RHS contribution from c_j: tau_eval * c_eval * R_j(k)
   - Move everything to one side: sum_i A_{k,i} * f_i - sum_{j<d} B_{k,j} * c_j = tau_eval * c_eval * R_d(k) (the c_d=1 term)

7. Solve via RREF. If the system has a solution with not all c_j zero, we have a recurrence.

WAIT -- this approach loses the polynomial structure of f. The f_i are coefficients of the polynomial f(x) = sum f_i * x^i. When we evaluate f at q^k, we get sum f_i * q^{ik}. This is correct.

For the degree bound D of f: use the same analysis as standard Gosper. After the Gosper normal form, D = max degree of RHS / max(deg sigma, deg tau). But with the R_j terms, the RHS at each k is a numeric value, not a polynomial. We need to estimate D.

Try D = deg(c_poly) + max(deg(sigma), deg(tau)) as an upper bound, with fallbacks D+1, D+2.

**Implementation steps:**

a) `build_shifted_series(series, j, n_val, n_param_indices, n_is_in_argument, q_val)` -- returns a new HypergeometricSeries with params shifted by j.

b) `compute_rj_values(r_0, r_j, q_val, max_k)` -- compute R_j(k) for k=0..max_k iteratively from the term ratio quotient.

c) `solve_extended_key_equation(gnf, r_j_values_per_j, q_val, deg_f_candidates, d)` -- set up and solve the linear system.

d) `try_creative_telescoping(series, n_val, q_val, d, n_param_indices, n_is_in_argument)` -- attempt order-d creative telescoping. Returns Option<(Vec<QRat>, QRatPoly)> (coefficients c_j, polynomial f).

**N-parameter detection:**

Provide a helper `detect_n_params(series, n_val, q_val) -> (Vec<usize>, bool)` that examines which upper parameters look like q^{-n} (i.e., have value q^{-n_val} when evaluated). Check each upper param: if eval_qmonomial(param, q_val) == q^{-n_val}, it's an n-dependent param. For the argument, check if its power involves n (heuristic: if argument has a nonzero power component, check if shifting n changes the argument value).

Actually, for cleanliness, accept `n_param_indices` and `n_is_in_argument` as explicit parameters rather than auto-detecting. The caller (q_zeilberger in Plan 15-02) will provide these based on the series structure. For Plan 15-01 tests, construct them explicitly.

**Duplicate solve_linear_system from gosper.rs** (it's private there). Copy the exact same RREF solver into zeilberger.rs as a private function. This avoids modifying Phase 14 code.

Also add a **null_space_1d** helper: for a homogeneous system, find a 1-dimensional null space vector (for the case where we want to find c_j without normalizing c_d = 1). Or, more pragmatically, first try c_d = 1 normalization (inhomogeneous solve), and if that fails, try c_{d-1} = 1, etc.

**Termination order detection:**

For the linear system, we need N equations where N > number of unknowns. The number of unknowns is (D+1) + d. The termination order of the series (the highest k where F(n,k) != 0) gives a natural bound. Use series.termination_order() if available, otherwise use a default like 20.

**Update mod.rs:**

Add `pub mod zeilberger;` to the module list. For now, only re-export the data types (ZeilbergerResult, QZeilbergerResult). The public API functions come in Plan 15-02.

**Tests (8-12 tests):**

1. `test_build_shifted_series_q_vandermonde` -- shifting n->n+1 for 2phi1(q^{-n}, a; c; q, z) changes q^{-n} to q^{-n-1} and z = cq^n/a to cq^{n+1}/a.
2. `test_rj_values_trivial` -- R_0(k) = 1 for all k.
3. `test_rj_values_vandermonde` -- R_1(k) values for q-Vandermonde match manual computation.
4. `test_extended_key_equation_vandermonde_d1` -- Extended key equation for q-Vandermonde at d=1 yields a solution.
5. `test_extended_key_equation_coefficients` -- The c_j coefficients from the q-Vandermonde solution are nonzero.
6. `test_creative_telescoping_vandermonde` -- Full creative telescoping for q-Vandermonde finds solution at d=1 (SUCCESS CRITERION 1).
7. `test_creative_telescoping_1phi0` -- 1phi0(q^{-n}; ; q, z) finds recurrence at d=1.
8. `test_creative_telescoping_no_recurrence` -- A non-summable case returns None at d=1.
9. `test_detect_n_params` -- Correctly identifies which params depend on n.
10. `test_rj_values_consistency` -- R_j(k) * F(n,k) == F(n+j,k) for several k values (sanity check).

Build and run with:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::zeilberger -- --nocapture
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::zeilberger` and confirm all tests pass. Specifically verify test_creative_telescoping_vandermonde passes, confirming the q-Vandermonde sum finds a recurrence at order d=1.
  </verify>
  <done>
zeilberger.rs exists with: ZeilbergerResult and QZeilbergerResult types, n-direction shift ratio computation via build_shifted_series + compute_rj_values, extended key equation solver, creative telescoping loop (try_creative_telescoping), and at least 8 passing tests including q-Vandermonde at d=1. Module declared in mod.rs.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::zeilberger` passes all tests
- `cargo test --lib` passes all existing tests (no regressions)
- q-Vandermonde creative telescoping succeeds at d=1 (ROADMAP success criterion 1)
</verification>

<success_criteria>
1. Creative telescoping finds a recurrence for q-Vandermonde at order d=1
2. Extended key equation solver correctly handles the c_j unknowns alongside f polynomial coefficients
3. N-direction shift ratios are computed correctly for series with q^{-n} upper parameters
4. All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/15-q-zeilberger-wz-certificates/15-01-SUMMARY.md`
</output>
