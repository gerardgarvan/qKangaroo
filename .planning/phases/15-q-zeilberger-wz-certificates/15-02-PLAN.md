---
phase: 15-q-zeilberger-wz-certificates
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - crates/qsym-core/src/qseries/zeilberger.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "q_zeilberger returns a ZeilbergerResult with inspectable polynomial coefficients c_0, ..., c_d for q-Vandermonde"
    - "The WZ proof certificate is extracted as a QRatRationalFunc from the extended key equation solution"
    - "The recurrence coefficients satisfy c_0*S(n) + ... + c_d*S(n+d) = 0 when verified numerically"
  artifacts:
    - path: "crates/qsym-core/src/qseries/zeilberger.rs"
      provides: "q_zeilberger public function, ZeilbergerResult with certificate"
      exports: ["q_zeilberger", "ZeilbergerResult", "QZeilbergerResult"]
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "Re-export of q_zeilberger, ZeilbergerResult, QZeilbergerResult"
      contains: "pub use zeilberger"
  key_links:
    - from: "crates/qsym-core/src/qseries/zeilberger.rs"
      to: "try_creative_telescoping (from Plan 15-01)"
      via: "q_zeilberger calls try_creative_telescoping for each order d"
      pattern: "try_creative_telescoping"
    - from: "crates/qsym-core/src/qseries/mod.rs"
      to: "crates/qsym-core/src/qseries/zeilberger.rs"
      via: "pub use re-exports"
      pattern: "pub use zeilberger"
---

<objective>
Implement the public q_zeilberger function and WZ certificate extraction, completing the user-facing API for creative telescoping.

Purpose: Plan 15-01 built the internal machinery (extended key equation solver, n-shift ratios). This plan wraps it into the public q_zeilberger function that accepts a HypergeometricSeries and returns a ZeilbergerResult with recurrence coefficients and WZ certificate. This satisfies ZEIL-02 (recurrence output) and ZEIL-03 (WZ certificate extraction).

Output: Public q_zeilberger function, WZ certificate construction from extended key equation solution, re-exports in mod.rs, tests verifying recurrence output and certificate structure.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-RESEARCH.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-01-SUMMARY.md
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/gosper.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement q_zeilberger public function with WZ certificate extraction</name>
  <files>crates/qsym-core/src/qseries/zeilberger.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Add the following to zeilberger.rs:

**N-parameter auto-detection:**

```rust
/// Detect which upper parameters depend on n.
///
/// Examines upper params to find those matching q^{-n_val} (i.e., the param
/// is q^{-n} for the given n_val). Also checks if the argument depends on n
/// by testing whether shifting n changes the argument value.
///
/// Returns (n_param_indices, n_is_in_argument).
pub(crate) fn detect_n_params(
    series: &HypergeometricSeries,
    n_val: i64,
    q_val: &QRat,
) -> (Vec<usize>, bool)
```

Implementation: For each upper param a_i, evaluate it at q_val. If the result equals q_val^{-n_val}, it's an n-dependent parameter (index i goes into the list). For the argument: evaluate the argument at q_val. Then hypothetically shift n to n+1 (multiply by q_val or divide, depending on sign). If the argument QMonomial has nonzero power, the argument likely depends on n. Specifically: if argument = c * q^p where p != 0, then shifting n->n+1 would change the evaluated value. A simple heuristic: check if the argument power is nonzero. If so, set n_is_in_argument = true.

A more robust approach: the argument's n-dependence is determined by whether shifting n would change the argument. For a terminating _r phi_s with parameter q^{-n}, the standard form often has z = c*q^{n+1}/a (q-Vandermonde) or z = q (q-binomial). Check: evaluate the argument as c*q^p. If p > 0 or there's a q^n in the argument, it depends on n. Since we work at concrete n_val, compare the argument power modulo n_val considerations. Pragmatically: if argument.power != 0, return true (it likely involves q^n).

Actually, the cleaner approach: accept that the argument's n-dependence is encoded in its QMonomial. For q-Vandermonde, the argument is QMonomial::new(c*q/a, n) where the power=n explicitly. Since we can inspect argument.power, check if it matches n_val or some function of it.

SIMPLEST: The argument is c * q^power. If power == 0, it doesn't depend on n. If power != 0, it might depend on n. Since we can't distinguish q^3 (constant) from q^n at n=3, accept an explicit flag OR use the convention that if the argument power equals n_val, it depends on n. This is fragile. Better: accept `n_is_in_argument` as an explicit parameter to q_zeilberger.

DECISION: q_zeilberger accepts explicit parameters `n_param_indices` and `n_is_in_argument`, PLUS provide a convenience function `detect_n_params_heuristic` that uses the heuristic (upper param eval == q^{-n_val}, argument power == n_val). Document that for non-standard series, users should provide indices explicitly.

**Public q_zeilberger function:**

```rust
/// Run the q-Zeilberger algorithm for creative telescoping.
///
/// Given a q-hypergeometric summand F(n,k) (represented as a HypergeometricSeries
/// parameterized by n), finds a linear recurrence
///   c_0 * S(n) + c_1 * S(n+1) + ... + c_d * S(n+d) = 0
/// for the definite sum S(n) = sum_k F(n,k), together with a WZ proof certificate.
///
/// # Arguments
/// * `series` - The HypergeometricSeries at the specific n_val.
/// * `n_val` - The specific value of n for the computation.
/// * `q_val` - Concrete q parameter.
/// * `max_order` - Maximum recurrence order to try (d = 1, 2, ..., max_order).
/// * `n_param_indices` - Indices of upper parameters that depend on n (e.g., q^{-n}).
/// * `n_is_in_argument` - Whether the argument z depends on n.
///
/// # Returns
/// * `QZeilbergerResult::Recurrence(result)` if a recurrence is found.
/// * `QZeilbergerResult::NoRecurrence` if no recurrence exists up to max_order.
pub fn q_zeilberger(
    series: &HypergeometricSeries,
    n_val: i64,
    q_val: &QRat,
    max_order: usize,
    n_param_indices: &[usize],
    n_is_in_argument: bool,
) -> QZeilbergerResult
```

Implementation:
1. For d = 1, 2, ..., max_order:
   a. Call try_creative_telescoping(series, n_val, q_val, d, n_param_indices, n_is_in_argument).
   b. If it returns Some((coefficients, f_poly, gnf)):
      - Construct the WZ certificate: R(x) = f(x) / gnf.c(x) as QRatRationalFunc.
      - Return QZeilbergerResult::Recurrence(ZeilbergerResult { order: d, coefficients, certificate }).
2. Return QZeilbergerResult::NoRecurrence.

**WZ Certificate extraction:**

The certificate comes directly from the Gosper solution: R(x) = f(x) / c_poly(x), exactly as in q-Gosper (Phase 14). The f polynomial is the solution of the extended key equation, and c_poly is from the Gosper normal form of the original k-direction term ratio.

Ensure try_creative_telescoping returns enough information to construct the certificate: (Vec<QRat>, QRatPoly, GosperNormalForm) -- the c_j values, the f polynomial, and the normal form.

**Update mod.rs re-exports:**

Add to the `pub use zeilberger::` line:
```rust
pub use zeilberger::{ZeilbergerResult, QZeilbergerResult, q_zeilberger};
```

Update the module doc comment to include q-Zeilberger in the list.

**Tests (6-8 tests):**

1. `test_q_zeilberger_vandermonde_finds_recurrence` -- q-Vandermonde sum _2phi1(q^{-n}, a; c; q, cq^n/a) with n_val=5, q=1/3 returns Recurrence at order 1 (SUCCESS CRITERION 1).
2. `test_q_zeilberger_vandermonde_coefficients_inspectable` -- The returned coefficients c_0, c_1 are nonzero QRat values that can be inspected (SUCCESS CRITERION 2).
3. `test_q_zeilberger_vandermonde_certificate_is_rational_func` -- The certificate is a well-formed QRatRationalFunc (non-zero numerator, non-zero denominator).
4. `test_q_zeilberger_1phi0_recurrence` -- 1phi0(q^{-n}; ; q, z) finds recurrence.
5. `test_q_zeilberger_no_recurrence_max_order` -- When max_order=1 and the series needs d=2, returns NoRecurrence.
6. `test_q_zeilberger_certificate_verifies_at_k_values` -- For q-Vandermonde, manually check that sum_j c_j * F(n+j, k) == G(n,k+1) - G(n,k) for k = 0, 1, 2 where G(n,k) = R(q^k)*F(n,k) (SUCCESS CRITERION 3).
7. `test_q_zeilberger_multiple_n_values` -- Run at n_val=3, 5, 7 for q-Vandermonde and verify all return recurrences with consistent structure.
8. `test_detect_n_params_vandermonde` -- Correctly identifies the first upper param q^{-n} and the argument dependence.

Build and run:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::zeilberger -- --nocapture
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::zeilberger` and confirm all tests pass. Verify test_q_zeilberger_vandermonde_finds_recurrence passes (SUCCESS CRITERION 1), test_q_zeilberger_vandermonde_coefficients_inspectable passes (SUCCESS CRITERION 2), and test_q_zeilberger_certificate_verifies_at_k_values passes (SUCCESS CRITERION 3).
  </verify>
  <done>
Public q_zeilberger function exists and is re-exported from mod.rs. q-Vandermonde returns a ZeilbergerResult with: order=1, inspectable c_0/c_1 coefficients, and a QRatRationalFunc certificate that verifies the telescoping identity at concrete k values. At least 6 tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::zeilberger` passes all tests including new ones
- `cargo test --lib` passes all existing tests (no regressions)
- q_zeilberger returns inspectable polynomial coefficients (ROADMAP success criterion 2)
- WZ certificate is extracted and verifiable (ROADMAP success criterion 3)
</verification>

<success_criteria>
1. q_zeilberger is a public function accessible via `use qsym_core::qseries::q_zeilberger`
2. ZeilbergerResult contains inspectable coefficients and a QRatRationalFunc certificate
3. q-Vandermonde at n_val=5 returns Recurrence with order=1
4. Certificate verifies the telescoping identity at specific k values
5. No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/15-q-zeilberger-wz-certificates/15-02-SUMMARY.md`
</output>
