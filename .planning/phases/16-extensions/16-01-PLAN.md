---
phase: 16-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/petkovsek.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "q-Petkovsek finds q-hypergeometric solution ratio for order-1 constant-coefficient recurrences from q-Zeilberger"
    - "q-Petkovsek finds solutions for order-2 constant-coefficient recurrences via systematic candidate enumeration"
    - "Closed-form output expresses solutions as products of q-Pochhammer symbols and q-powers when decomposition succeeds"
    - "Non-solvable recurrences return empty solution vector"
  artifacts:
    - path: "crates/qsym-core/src/qseries/petkovsek.rs"
      provides: "q_petkovsek algorithm, QPetkovsekResult, ClosedForm, closed-form decomposition"
      min_lines: 250
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "pub mod petkovsek and re-exports"
      contains: "pub mod petkovsek"
  key_links:
    - from: "crates/qsym-core/src/qseries/petkovsek.rs"
      to: "crates/qsym-core/src/qseries/zeilberger.rs"
      via: "Consumes ZeilbergerResult.coefficients as input recurrence"
      pattern: "ZeilbergerResult|coefficients"
    - from: "crates/qsym-core/src/qseries/petkovsek.rs"
      to: "crates/qsym-core/src/qseries/factoring.rs"
      via: "qfactor for Pochhammer decomposition"
      pattern: "qfactor"
---

<objective>
Implement the q-Petkovsek algorithm for finding q-hypergeometric solutions of constant-coefficient linear recurrences, with closed-form output as q-Pochhammer products.

Purpose: q-Zeilberger (Phase 15) produces recurrences c_0*S(n) + ... + c_d*S(n+d) = 0 with constant QRat coefficients. q-Petkovsek closes the loop by solving these recurrences for explicit closed forms, completing the identity-proving pipeline.

Output: petkovsek.rs with QPetkovsekResult, ClosedForm types, q_petkovsek() solver, closed-form Pochhammer decomposition, and tests against known q-Zeilberger outputs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-extensions/16-RESEARCH.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-02-SUMMARY.md
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/factoring.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement q-Petkovsek solver for constant-coefficient recurrences</name>
  <files>crates/qsym-core/src/qseries/petkovsek.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Create `crates/qsym-core/src/qseries/petkovsek.rs` with the following components:

**Module doc:** q-Petkovsek algorithm for solving constant-coefficient q-difference equations produced by q-Zeilberger. Finds q-hypergeometric solutions and expresses them as q-Pochhammer products when possible.

**Imports:**
- `crate::number::QRat` (and rug Integer/Rational as needed)
- `crate::series::FormalPowerSeries`
- `super::factoring::{qfactor, QFactorization}`
- `super::QMonomial`
- `std::collections::BTreeMap`

**Private helper: qrat_pow_i64** -- Duplicate from gosper.rs/zeilberger.rs (same repeated-squaring implementation). Also qrat_pow_u32.

**Data types:**

```rust
/// Closed-form representation of a q-hypergeometric solution.
///
/// Represents: scalar * q^{q_power_coeff * n*(n-1)/2} * prod_i (numer_factors_i; q)_n / prod_j (denom_factors_j; q)_n
///
/// The q_power_coeff uses the n*(n-1)/2 convention, matching the natural normalization
/// of q-Pochhammer products. For example, (a;q)_n contains a factor with q-power
/// proportional to n*(n-1)/2. This convention does NOT cover simple geometric sequences
/// like r^n = q^{mn}; such geometric behavior is captured entirely by
/// QPetkovsekResult.ratio, and ClosedForm is only produced when the ratio genuinely
/// factors into Pochhammer terms.
#[derive(Clone, Debug)]
pub struct ClosedForm {
    /// Scalar prefactor (from S(0) normalization).
    pub scalar: QRat,
    /// Coefficient for q-power: the solution includes factor q^{q_power_coeff * n*(n-1)/2}.
    /// Uses n*(n-1)/2 convention (matching q-Pochhammer natural normalization).
    pub q_power_coeff: i64,
    /// Pochhammer numerator factors: each (a_i; q)_n in the product.
    pub numer_factors: Vec<QMonomial>,
    /// Pochhammer denominator factors: each (b_j; q)_n in the product.
    pub denom_factors: Vec<QMonomial>,
}

/// Result of the q-Petkovsek algorithm for a single solution.
#[derive(Clone, Debug)]
pub struct QPetkovsekResult {
    /// The ratio y(n+1)/y(n) as a QRat constant (for constant-coefficient recurrences).
    /// This always holds the exact solution ratio, even when closed_form is None.
    pub ratio: QRat,
    /// Closed-form representation as q-Pochhammer factors, if decomposition succeeded.
    /// None when the ratio cannot be cleanly decomposed into Pochhammer terms
    /// (the ratio itself is still the valid solution).
    pub closed_form: Option<ClosedForm>,
}
```

**Core algorithm: q_petkovsek**

```rust
/// Solve a constant-coefficient q-recurrence for q-hypergeometric solutions.
///
/// Given recurrence c_0*S(n) + c_1*S(n+1) + ... + c_d*S(n+d) = 0
/// where all c_j are QRat constants (as produced by q-Zeilberger at concrete q),
/// find all q-hypergeometric solutions.
///
/// The key simplification: since coefficients are constants (not polynomials in q^n),
/// a q-hypergeometric solution y(n+1)/y(n) = r must satisfy the characteristic
/// equation c_0 + c_1*r + c_2*r^2 + ... + c_d*r^d = 0.
///
/// For order 1: r = -c_0/c_1 (unique solution).
/// For order 2+: solve the polynomial c_0 + c_1*r + ... + c_d*r^d = 0 for rational roots.
pub fn q_petkovsek(
    coefficients: &[QRat],
    q_val: &QRat,
) -> Vec<QPetkovsekResult>
```

**Implementation details:**

1. **Input validation:** coefficients must have length >= 2, leading coefficient (c_d) must be nonzero.

2. **Order 1 (d=1):** ratio = -c_0/c_1. Always exactly one solution. Attempt closed-form decomposition.

3. **Order 2+ (d>=2):** The characteristic equation c_0 + c_1*r + ... + c_d*r^d = 0 must be solved for RATIONAL roots. Use the Rational Root Theorem: any rational root p/s has p dividing c_0 (the constant term) and s dividing c_d (the leading coefficient). Enumerate all candidate p/s values and test each.

   - Extract integer numerator and denominator of c_0 and c_d.
   - Since c_0 and c_d are QRat, the characteristic polynomial has QRat coefficients. To use the rational root theorem properly, multiply through by lcm of all denominators to get integer coefficients, THEN apply the theorem.
   - For each candidate rational root r, substitute into the characteristic equation. If it evaluates to zero, r is a solution.
   - Cap the number of divisor candidates to avoid explosion (e.g., if c_0 or c_d have > 1000 divisors, return results without the higher-order solutions).

4. **For each rational root r found:** Create QPetkovsekResult with that ratio, then attempt closed-form decomposition.

**Closed-form decomposition: try_decompose_ratio**

```rust
/// Attempt to express the ratio S(n+1)/S(n) = r as q-Pochhammer factors.
///
/// Strategy (single concrete approach):
/// 1. Check if ratio = q^m for integer m in range -20..=20.
///    If so, this is a pure q-power geometric sequence. Return None -- geometric
///    behavior is fully captured by QPetkovsekResult.ratio, not ClosedForm.
///    (ClosedForm is reserved for genuine Pochhammer factorizations.)
/// 2. If ratio is not a q-power, compute (1 - ratio) as a 2-term polynomial
///    FPS and apply qfactor. If qfactor gives an exact decomposition
///    (1 - ratio) = product of (1 - q^i) factors, then each factor corresponds
///    to one step of a Pochhammer (a;q)_n. Build ClosedForm from the factors.
/// 3. If qfactor does not give an exact decomposition, return None.
fn try_decompose_ratio(ratio: &QRat, q_val: &QRat) -> Option<ClosedForm>
```

Implementation:
- Step 1: For m in -20..=20, compute q^m. If ratio == q^m, return None (geometric, captured by QPetkovsekResult.ratio).
- Step 2: Build a 2-term FPS with coefficients {0: 1, 1: -ratio} representing the polynomial (1 - ratio*x). Actually, since ratio is a QRat constant (not a polynomial in x), we need to think of (1 - r) as a NUMBER. The question is whether r = (1-q^a)/(1-q^b). Equivalently, (1-r) = (q^a - q^b)/(1-q^b). Try: for a,b in -10..=10, check if ratio == (1 - q^a)/(1 - q^b). If found, the ratio step in the Pochhammer product corresponds to the n-th term ratio (q^a * q^n - 1)/(q^b * q^n - 1) -- but since our ratio is CONSTANT (not n-dependent), it means ratio = (1-q^a)/(1-q^b) where a,b encode the Pochhammer parameters. Build ClosedForm with numer_factors=[QMonomial(q^a)] and denom_factors=[QMonomial(q^b)].
- Step 3: If no (a,b) pair works, try product of two such ratios: ratio = (1-q^a1)(1-q^a2)/((1-q^b1)(1-q^b2)). Enumerate small combinations.
- Step 4: If nothing works, return None. The QPetkovsekResult still has the valid ratio.

**Update mod.rs:**

Add `pub mod petkovsek;` to the module list.
Add re-exports: `pub use petkovsek::{q_petkovsek, QPetkovsekResult, ClosedForm};`

**Tests (10+ tests):**

1. `test_order1_simple` -- c_0=1, c_1=-2 (at arbitrary q). Ratio = 1/2.
2. `test_order1_q_vandermonde` -- Feed the q-Vandermonde recurrence coefficients from q-Zeilberger (use specific q=1/3, n=5). Verify the ratio matches expected value.
3. `test_order1_1phi0` -- Feed 1phi0 recurrence. Verify ratio.
4. `test_order2_two_roots` -- c_0, c_1, c_2 chosen so characteristic polynomial has two rational roots. Verify both found.
5. `test_order2_no_rational_roots` -- c_0=1, c_1=0, c_2=1 (roots are +/-i). Returns empty vec.
6. `test_order2_one_rational_root` -- Characteristic poly with one rational and one irrational root. Returns 1 result.
7. `test_order2_repeated_root` -- (r-a)^2 = 0. Returns one result with multiplicity (or two identical).
8. `test_closed_form_q_power` -- Ratio = q^m for specific m. closed_form is None (geometric captured by ratio field).
9. `test_closed_form_none` -- Ratio is an arbitrary rational (not decomposable). closed_form is None.
10. `test_roundtrip_zeilberger` -- Construct a q-Vandermonde series, run q_zeilberger to get recurrence, feed to q_petkovsek, verify solution ratio. This is the end-to-end pipeline test. Use q=1/3, n=5.
11. `test_empty_coefficients_panics` -- Zero or one coefficient panics.
12. `test_leading_zero_panics` -- Leading coefficient zero panics.

**Integer divisor helper:**

```rust
/// Find all positive divisors of an integer.
fn positive_divisors(n: &rug::Integer) -> Vec<rug::Integer>
```

For the rational root theorem. Take absolute value, find divisors by trial division up to sqrt(n). Cap at a reasonable limit (e.g., if n > 10^12, use only small prime factors to bound candidates).

Build and test:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::petkovsek -- --nocapture
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::petkovsek` and confirm all tests pass. Run `cargo test --lib` to confirm no regressions. Verify the roundtrip test (q-Zeilberger -> q-Petkovsek) passes successfully.
  </verify>
  <done>
petkovsek.rs exists with: QPetkovsekResult and ClosedForm types, q_petkovsek() function handling order-1 and order-2+ recurrences, rational root finding via Rational Root Theorem, try_decompose_ratio for Pochhammer decomposition, at least 10 passing tests including a q-Zeilberger roundtrip test. Module declared and re-exported in mod.rs. All existing tests pass (no regressions). Requirements SOLV-01 and SOLV-02 satisfied.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::petkovsek` passes all tests
- `cargo test --lib` passes all existing tests (no regressions)
- q-Petkovsek solves order-1 recurrences from q-Zeilberger (SOLV-01)
- Closed-form Pochhammer decomposition attempted for all solutions (SOLV-02)
- Roundtrip test: q_zeilberger -> q_petkovsek produces valid solution ratio
</verification>

<success_criteria>
1. q-Petkovsek finds the correct solution ratio for order-1 constant-coefficient recurrences
2. Order-2+ recurrences are solved via rational root theorem on the characteristic polynomial
3. Closed-form output attempts Pochhammer decomposition (succeeds for q-power ratios, returns None gracefully for non-decomposable ratios)
4. End-to-end pipeline: q-Zeilberger recurrence -> q-Petkovsek solution verified
5. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-extensions/16-01-SUMMARY.md`
</output>
