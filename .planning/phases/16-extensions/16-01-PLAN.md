---
phase: 16-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/petkovsek.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "q-Petkovsek finds q-hypergeometric solution ratio for order-1 constant-coefficient recurrences from q-Zeilberger"
    - "q-Petkovsek finds solutions for order-2 constant-coefficient recurrences via systematic candidate enumeration"
    - "Closed-form output expresses solutions as products of q-Pochhammer symbols and q-powers when decomposition succeeds"
    - "Non-solvable recurrences return empty solution vector"
  artifacts:
    - path: "crates/qsym-core/src/qseries/petkovsek.rs"
      provides: "q_petkovsek algorithm, QPetkovsekResult, ClosedForm, closed-form decomposition"
      min_lines: 250
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "pub mod petkovsek and re-exports"
      contains: "pub mod petkovsek"
  key_links:
    - from: "crates/qsym-core/src/qseries/petkovsek.rs"
      to: "crates/qsym-core/src/qseries/zeilberger.rs"
      via: "Consumes ZeilbergerResult.coefficients as input recurrence"
      pattern: "ZeilbergerResult|coefficients"
    - from: "crates/qsym-core/src/qseries/petkovsek.rs"
      to: "crates/qsym-core/src/qseries/factoring.rs"
      via: "qfactor for Pochhammer decomposition"
      pattern: "qfactor"
---

<objective>
Implement the q-Petkovsek algorithm for finding q-hypergeometric solutions of constant-coefficient linear recurrences, with closed-form output as q-Pochhammer products.

Purpose: q-Zeilberger (Phase 15) produces recurrences c_0*S(n) + ... + c_d*S(n+d) = 0 with constant QRat coefficients. q-Petkovsek closes the loop by solving these recurrences for explicit closed forms, completing the identity-proving pipeline.

Output: petkovsek.rs with QPetkovsekResult, ClosedForm types, q_petkovsek() solver, closed-form Pochhammer decomposition, and tests against known q-Zeilberger outputs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-extensions/16-RESEARCH.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-02-SUMMARY.md
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/mod.rs
@crates/qsym-core/src/qseries/factoring.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement q-Petkovsek solver for constant-coefficient recurrences</name>
  <files>crates/qsym-core/src/qseries/petkovsek.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Create `crates/qsym-core/src/qseries/petkovsek.rs` with the following components:

**Module doc:** q-Petkovsek algorithm for solving constant-coefficient q-difference equations produced by q-Zeilberger. Finds q-hypergeometric solutions and expresses them as q-Pochhammer products when possible.

**Imports:**
- `crate::number::QRat` (and rug Integer/Rational as needed)
- `crate::series::FormalPowerSeries`
- `super::factoring::{qfactor, QFactorization}`
- `super::QMonomial`
- `std::collections::BTreeMap`

**Private helper: qrat_pow_i64** -- Duplicate from gosper.rs/zeilberger.rs (same repeated-squaring implementation). Also qrat_pow_u32.

**Data types:**

```rust
/// Closed-form representation of a q-hypergeometric solution.
///
/// Represents: scalar * q^{q_power_coeff * n*(n-1)/2} * prod_i (numer_factors_i; q)_n / prod_j (denom_factors_j; q)_n
#[derive(Clone, Debug)]
pub struct ClosedForm {
    /// Scalar prefactor (from S(0) normalization).
    pub scalar: QRat,
    /// Coefficient for q-power: the solution includes factor q^{q_power_coeff * n*(n-1)/2}.
    pub q_power_coeff: i64,
    /// Pochhammer numerator factors: each (a_i; q)_n in the product.
    pub numer_factors: Vec<QMonomial>,
    /// Pochhammer denominator factors: each (b_j; q)_n in the product.
    pub denom_factors: Vec<QMonomial>,
}

/// Result of the q-Petkovsek algorithm for a single solution.
#[derive(Clone, Debug)]
pub struct QPetkovsekResult {
    /// The ratio y(n+1)/y(n) as a QRat constant (for constant-coefficient recurrences).
    pub ratio: QRat,
    /// Closed-form representation as q-Pochhammer factors, if decomposition succeeded.
    pub closed_form: Option<ClosedForm>,
}
```

**Core algorithm: q_petkovsek**

```rust
/// Solve a constant-coefficient q-recurrence for q-hypergeometric solutions.
///
/// Given recurrence c_0*S(n) + c_1*S(n+1) + ... + c_d*S(n+d) = 0
/// where all c_j are QRat constants (as produced by q-Zeilberger at concrete q),
/// find all q-hypergeometric solutions.
///
/// The key simplification: since coefficients are constants (not polynomials in q^n),
/// a q-hypergeometric solution y(n+1)/y(n) = r must satisfy the characteristic
/// equation c_0 + c_1*r + c_2*r^2 + ... + c_d*r^d = 0.
///
/// For order 1: r = -c_0/c_1 (unique solution).
/// For order 2+: solve the polynomial c_0 + c_1*r + ... + c_d*r^d = 0 for rational roots.
pub fn q_petkovsek(
    coefficients: &[QRat],
    q_val: &QRat,
) -> Vec<QPetkovsekResult>
```

**Implementation details:**

1. **Input validation:** coefficients must have length >= 2, leading coefficient (c_d) must be nonzero.

2. **Order 1 (d=1):** ratio = -c_0/c_1. Always exactly one solution. Attempt closed-form decomposition.

3. **Order 2+ (d>=2):** The characteristic equation c_0 + c_1*r + ... + c_d*r^d = 0 must be solved for RATIONAL roots. Use the Rational Root Theorem: any rational root p/s has p dividing c_0 (the constant term) and s dividing c_d (the leading coefficient). Enumerate all candidate p/s values and test each.

   - Extract integer numerator and denominator of c_0 and c_d.
   - Find all divisors of |numer(c_0)| and |numer(c_d)| (for p-candidates from c_0, s-candidates from c_d). Actually, since c_0 and c_d are QRat, the characteristic polynomial has QRat coefficients. To use the rational root theorem properly, multiply through by lcm of all denominators to get integer coefficients, THEN apply the theorem.
   - For each candidate rational root r, substitute into the characteristic equation. If it evaluates to zero, r is a solution.
   - Cap the number of divisor candidates to avoid explosion (e.g., if c_0 or c_d have > 1000 divisors, return results without the higher-order solutions).

4. **For each rational root r found:** Create QPetkovsekResult with that ratio, then attempt closed-form decomposition.

**Closed-form decomposition: try_decompose_ratio**

```rust
/// Attempt to express S(n) = S(0) * r^n as a product of q-Pochhammer symbols.
///
/// Strategy:
/// 1. If r = q^m for some integer m, then S(n) = q^{m*n} (pure q-power).
/// 2. If r = (1-q^a)/(1-q^b) for some integers a, b, then S(n) involves (q^a;q)_n/(q^b;q)_n.
/// 3. Use qfactor on the FPS representations of numerator/denominator of r
///    to find (1-q^i) factor decompositions.
/// 4. If decomposition fails, return None (the ratio is still valid, just not expressible
///    in simple Pochhammer form).
fn try_decompose_ratio(ratio: &QRat, q_val: &QRat) -> Option<ClosedForm>
```

Implementation of decomposition:
- First check if ratio is a q-power: compute log_q(ratio) by checking if ratio == q^m for m = -20..20.
- If ratio is a q-power m, the closed form is scalar=1, q_power_coeff=m, no Pochhammer factors. Note: S(n) = r^n = q^{m*n}, not q^{m*n*(n-1)/2}. So represent as q_power_coeff=0 with a note that it's r^n. Actually, express the SEQUENCE S(n) as: if r = q^m, then S(n) = q^{mn}, which is a simple geometric sequence. Set q_power_coeff = 0 (since the n(n-1)/2 form doesn't apply here) and record as scalar=1 with a special "geometric" flag. Simpler: just store the ratio in QPetkovsekResult.ratio and try to express it.
- If ratio is NOT a pure q-power, write ratio = p/s where p, s are integers (from numerator/denominator). Try to factor (1-p*q)/(1-s*q)-style decomposition. Build the FPS for numerator (1 - ratio_numer_as_polynomial) and denominator and apply qfactor.
- PRACTICAL approach: Build a 2-term FPS representing (1 - r) and try qfactor. If r = (1-q^a)*(1-q^b)/((1-q^c)*(1-q^d)), then 1-r has a specific q-polynomial structure that qfactor can decompose. Construct the FPS for the ratio "1 - ratio" and "ratio - 1" and see if qfactor gives an exact decomposition.
- If no clean decomposition is found, return None. The QPetkovsekResult still has the valid ratio.

**Update mod.rs:**

Add `pub mod petkovsek;` to the module list.
Add re-exports: `pub use petkovsek::{q_petkovsek, QPetkovsekResult, ClosedForm};`

**Tests (10+ tests):**

1. `test_order1_simple` -- c_0=1, c_1=-2 (at arbitrary q). Ratio = 1/2.
2. `test_order1_q_vandermonde` -- Feed the q-Vandermonde recurrence coefficients from q-Zeilberger (use specific q=1/3, n=5). Verify the ratio matches expected value.
3. `test_order1_1phi0` -- Feed 1phi0 recurrence. Verify ratio.
4. `test_order2_two_roots` -- c_0, c_1, c_2 chosen so characteristic polynomial has two rational roots. Verify both found.
5. `test_order2_no_rational_roots` -- c_0=1, c_1=0, c_2=1 (roots are +/-i). Returns empty vec.
6. `test_order2_one_rational_root` -- Characteristic poly with one rational and one irrational root. Returns 1 result.
7. `test_order2_repeated_root` -- (r-a)^2 = 0. Returns one result with multiplicity (or two identical).
8. `test_closed_form_q_power` -- Ratio = q^m for specific m. Closed form should detect q-power.
9. `test_closed_form_none` -- Ratio is an arbitrary rational (not decomposable). closed_form is None.
10. `test_roundtrip_zeilberger` -- Construct a q-Vandermonde series, run q_zeilberger to get recurrence, feed to q_petkovsek, verify solution ratio. This is the end-to-end pipeline test. Use q=1/3, n=5.
11. `test_empty_coefficients_panics` -- Zero or one coefficient panics.
12. `test_leading_zero_panics` -- Leading coefficient zero panics.

**Integer divisor helper:**

```rust
/// Find all positive divisors of an integer.
fn positive_divisors(n: &rug::Integer) -> Vec<rug::Integer>
```

For the rational root theorem. Take absolute value, find divisors by trial division up to sqrt(n). Cap at a reasonable limit (e.g., if n > 10^12, use only small prime factors to bound candidates).

Build and test:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::petkovsek -- --nocapture
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::petkovsek` and confirm all tests pass. Run `cargo test --lib` to confirm no regressions. Verify the roundtrip test (q-Zeilberger -> q-Petkovsek) passes successfully.
  </verify>
  <done>
petkovsek.rs exists with: QPetkovsekResult and ClosedForm types, q_petkovsek() function handling order-1 and order-2+ recurrences, rational root finding via Rational Root Theorem, try_decompose_ratio for Pochhammer decomposition, at least 10 passing tests including a q-Zeilberger roundtrip test. Module declared and re-exported in mod.rs. All existing tests pass (no regressions). Requirements SOLV-01 and SOLV-02 satisfied.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::petkovsek` passes all tests
- `cargo test --lib` passes all existing tests (no regressions)
- q-Petkovsek solves order-1 recurrences from q-Zeilberger (SOLV-01)
- Closed-form Pochhammer decomposition attempted for all solutions (SOLV-02)
- Roundtrip test: q_zeilberger -> q_petkovsek produces valid solution ratio
</verification>

<success_criteria>
1. q-Petkovsek finds the correct solution ratio for order-1 constant-coefficient recurrences
2. Order-2+ recurrences are solved via rational root theorem on the characteristic polynomial
3. Closed-form output attempts Pochhammer decomposition (succeeds for q-power ratios, returns None gracefully for non-decomposable ratios)
4. End-to-end pipeline: q-Zeilberger recurrence -> q-Petkovsek solution verified
5. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-extensions/16-01-SUMMARY.md`
</output>
