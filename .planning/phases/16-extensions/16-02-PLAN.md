---
phase: 16-extensions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/nonterminating.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "Nonterminating identity LHS(x) = RHS(x) is proved by showing both sides satisfy the same recurrence with matching initial conditions"
    - "Parameter specialization correctly builds terminating series from nonterminating ones by substituting x -> x*q^n"
    - "Initial condition verification checks FPS agreement at n = 0, 1, ..., d where d is recurrence order"
    - "Proof fails gracefully when recurrences differ or initial conditions don't match"
  artifacts:
    - path: "crates/qsym-core/src/qseries/nonterminating.rs"
      provides: "prove_nonterminating, NonterminatingProofResult, parameter specialization logic"
      min_lines: 200
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "pub mod nonterminating and re-exports"
      contains: "pub mod nonterminating"
  key_links:
    - from: "crates/qsym-core/src/qseries/nonterminating.rs"
      to: "crates/qsym-core/src/qseries/zeilberger.rs"
      via: "q_zeilberger for finding recurrences of parametrized terminating series"
      pattern: "q_zeilberger"
    - from: "crates/qsym-core/src/qseries/nonterminating.rs"
      to: "crates/qsym-core/src/qseries/hypergeometric.rs"
      via: "eval_phi for FPS comparison of initial conditions"
      pattern: "eval_phi"
---

<objective>
Implement the Chen-Hou-Mu parameter specialization method for proving nonterminating q-hypergeometric identities by reducing them to terminating q-Zeilberger problems.

Purpose: Many important q-hypergeometric identities (q-Gauss, q-Kummer, Heine transforms) involve nonterminating (infinite) sums that q-Zeilberger cannot directly handle. The Chen-Hou-Mu method replaces a parameter with x*q^n to produce terminating versions, proves both sides satisfy the same recurrence, then verifies initial conditions.

Output: nonterminating.rs with NonterminatingProofResult, prove_nonterminating() function, and tests proving known nonterminating identities (q-Gauss sum).
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-extensions/16-RESEARCH.md
@.planning/phases/15-q-zeilberger-wz-certificates/15-02-SUMMARY.md
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Chen-Hou-Mu nonterminating identity proofs</name>
  <files>crates/qsym-core/src/qseries/nonterminating.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Create `crates/qsym-core/src/qseries/nonterminating.rs` with the following components:

**Module doc:** Chen-Hou-Mu parameter specialization for proving nonterminating q-hypergeometric identities. Reduces nonterminating identities to terminating cases solvable by q-Zeilberger.

**Imports:**
- `crate::number::QRat`
- `crate::series::{FormalPowerSeries, arithmetic}`
- `crate::symbol::SymbolId`
- `super::hypergeometric::{HypergeometricSeries, eval_phi, TransformationResult}`
- `super::zeilberger::{q_zeilberger, QZeilbergerResult, ZeilbergerResult, detect_n_params}`
- `super::{QMonomial, PochhammerOrder, aqprod}`

**Private helper: qrat_pow_i64** -- Same duplicate as other modules.

**Data types:**

```rust
/// Result of a nonterminating identity proof via Chen-Hou-Mu method.
#[derive(Clone, Debug)]
pub enum NonterminatingProofResult {
    /// Identity proved: both sides satisfy the same recurrence with matching initial conditions.
    Proved {
        /// The shared recurrence order.
        recurrence_order: usize,
        /// The shared recurrence coefficients (from the LHS, normalized).
        recurrence_coefficients: Vec<QRat>,
        /// Number of initial conditions verified (= recurrence_order + 1).
        initial_conditions_checked: usize,
    },
    /// Proof failed.
    Failed {
        /// Description of why the proof failed.
        reason: String,
    },
}
```

**Core function: prove_nonterminating**

```rust
/// Prove a nonterminating identity using the Chen-Hou-Mu parameter specialization method.
///
/// The method works as follows:
/// 1. The user provides a `lhs_builder` that, given n, returns a terminating
///    HypergeometricSeries (the LHS with a parameter specialized to q^{-n}).
/// 2. The user provides a `rhs_builder` that, given n, returns an FPS representing
///    the RHS evaluated at the same parameter specialization.
/// 3. For a test value of n, apply q-Zeilberger to the LHS to find a recurrence.
/// 4. Verify the RHS satisfies the same recurrence by direct FPS evaluation.
/// 5. Verify initial conditions (n = 0, 1, ..., d) by FPS comparison.
///
/// # Arguments
/// - `lhs_builder`: Given n, returns a terminating HypergeometricSeries for the LHS.
///   The series must be terminating (have an upper param q^{-n} or similar).
/// - `rhs_builder`: Given n, returns an FPS representing the RHS at that n.
/// - `q_val`: The concrete value of q.
/// - `n_test`: The test value of n for finding the recurrence (should be >= 5).
/// - `max_order`: Maximum recurrence order to try.
/// - `variable`: The FPS variable (SymbolId).
/// - `truncation_order`: FPS truncation order.
pub fn prove_nonterminating(
    lhs_builder: &dyn Fn(i64) -> HypergeometricSeries,
    rhs_builder: &dyn Fn(i64) -> FormalPowerSeries,
    q_val: &QRat,
    n_test: i64,
    max_order: usize,
    variable: SymbolId,
    truncation_order: i64,
) -> NonterminatingProofResult
```

**Implementation details:**

1. **Build LHS at n_test.** Call `lhs_builder(n_test)` to get the terminating series. Verify it IS terminating (call `termination_order()` on it; if None, return Failed with "LHS at n_test is not terminating").

2. **Find LHS recurrence.** First call `detect_n_params` to identify which parameters depend on n:
   ```rust
   let lhs_series = lhs_builder(n_test);
   let (n_indices, n_in_arg) = detect_n_params(&lhs_series, n_test, q_val);
   ```
   Then call `q_zeilberger` with the CORRECT signature (see zeilberger.rs line 668):
   ```rust
   let zeil_result = q_zeilberger(&lhs_series, n_test, q_val, max_order, &n_indices, n_in_arg);
   ```
   Note the parameter order: `(series, n_val, q_val, max_order, n_param_indices, n_is_in_argument)` where `n_param_indices` is `&[usize]` (output of detect_n_params) and `n_is_in_argument` is `bool`. Do NOT pass `variable` or `truncation_order` to q_zeilberger -- those are FPS parameters, not Zeilberger parameters. If result is `QZeilbergerResult::NoRecurrence`, return Failed.

3. **Extract recurrence.** Get ZeilbergerResult with order d and coefficients c_0, ..., c_d.

4. **Verify RHS satisfies the same recurrence.** For a verification value n_verify (use n_test as the base):
   - Compute RHS FPS at n_verify, n_verify+1, ..., n_verify+d via `rhs_builder`.
   - Check: c_0 * RHS(n_verify) + c_1 * RHS(n_verify+1) + ... + c_d * RHS(n_verify+d) == 0 (as FPS).
   - This means: form the linear combination of FPS and check it equals zero.
   - Do this for multiple n_verify values (e.g., n_test-2, n_test-1, n_test) for robustness.
   - If ANY check fails, return Failed("RHS does not satisfy LHS recurrence").

5. **Verify initial conditions.** For n = 0, 1, ..., d:
   - Compute LHS FPS: `eval_phi(&lhs_builder(n), variable, truncation_order)`.
   - Compute RHS FPS: `rhs_builder(n)`.
   - Compare: if LHS != RHS, return Failed("Initial condition mismatch at n={n}").

6. **If all checks pass:** Return Proved { recurrence_order: d, recurrence_coefficients, initial_conditions_checked: d+1 }.

**Helper for RHS recurrence check:**

```rust
/// Check if an FPS sequence satisfies a recurrence c_0*f(n) + ... + c_d*f(n+d) = 0.
fn check_recurrence_on_fps(
    fps_values: &[FormalPowerSeries],  // f(n), f(n+1), ..., f(n+d)
    coefficients: &[QRat],             // c_0, ..., c_d
) -> bool
```

Implementation: compute sum_j c_j * fps_values[j] using FPS scalar multiplication and addition. Check if result is zero (all coefficients zero).

**Update mod.rs:**

Add `pub mod nonterminating;` to the module list.
Add re-exports: `pub use nonterminating::{prove_nonterminating, NonterminatingProofResult};`

**Tests (8+ tests):**

1. `test_prove_q_gauss` -- The q-Gauss summation formula: 2phi1(a, b; c; q, c/(ab)) = (c/a;q)_inf*(c/b;q)_inf / ((c;q)_inf*(c/(ab);q)_inf). Specialize a -> q^{-n} to make it terminating. Use concrete q=1/2, b=q^2, c=q^3.

   LHS builder (given n): Construct 2phi1(q^{-n}, b; c; q, z_n) where z_n = c*q^n/b (the argument c/(ab) with a=q^{-n} becomes c*q^n/b). Return this as a terminating HypergeometricSeries.

   RHS builder (given n): Evaluate the product formula at a=q^{-n}. Concretely:
   - Compute c_over_a = c * q^n (since a=q^{-n}, c/a = c*q^n).
   - Compute c_over_b = c / b (constant, does not depend on n).
   - Compute c_over_ab = c * q^n / b (since a=q^{-n}).
   - The RHS is (c_over_a; q)_inf * (c_over_b; q)_inf / ((c; q)_inf * (c_over_ab; q)_inf).
   - BUT with a=q^{-n}, the infinite products simplify: (c*q^n; q)_inf and (c; q)_inf share a telescoping relationship. Specifically, (c; q)_inf = (c; q)_n * (c*q^n; q)_inf, so (c*q^n; q)_inf / (c; q)_inf = 1/(c; q)_n.
   - Similarly (c*q^n/b; q)_inf / (c/b; q)_inf = 1/(c/b; q)_n, but we have the INVERSE ratio.
   - After simplification the RHS at a=q^{-n} becomes: (c/b; q)_n / (c; q)_n (a finite product ratio).
   - Compute each as FPS: use `aqprod` with `PochhammerOrder::Finite(n)` for both (c/b; q)_n and (c; q)_n. Divide by computing the FPS for (c; q)_n, inverting it (series inversion), and multiplying. Or more directly: compute numerator = product_{k=0}^{n-1} (1 - c/b * q^k) and denominator = product_{k=0}^{n-1} (1 - c * q^k) as FPS via aqprod, then use arithmetic::div.
   - Return the resulting FPS.

   Prove the identity with n_test=8, max_order=2.

2. `test_prove_q_vandermonde` -- q-Vandermonde sum as nonterminating proof (even though it's already terminating, the method should still work). 2phi1(q^{-n}, a; c; q, q) = (c/a;q)_n / (c;q)_n.

3. `test_prove_fails_wrong_rhs` -- Provide correct LHS but wrong RHS (e.g., multiply RHS by 2). Should return Failed.

4. `test_prove_fails_non_terminating_lhs` -- Provide an lhs_builder that returns a non-terminating series. Should return Failed.

5. `test_recurrence_check_on_fps` -- Unit test for check_recurrence_on_fps with known recurrence.

6. `test_initial_condition_mismatch` -- LHS and RHS satisfy same recurrence but different initial conditions. Should return Failed.

7. `test_prove_1phi0_identity` -- 1phi0(q^{-n};;q,z) = (z;q)_n * (-1)^n * q^{n(n-1)/2} * z^{-n}... Actually, for 1phi0 the RHS involves z^n which is simpler. Build the RHS as: product_{k=0}^{n-1} (1 - z*q^k) = (z;q)_n. Compute as FPS.

8. `test_prove_with_different_n_test` -- Same identity as test 1 but with different n_test values (e.g., 5, 8, 10). All should succeed.

Build and test:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::nonterminating -- --nocapture
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::nonterminating` and confirm all tests pass. Run `cargo test --lib` to confirm no regressions. Verify the q-Gauss nonterminating proof test passes.
  </verify>
  <done>
nonterminating.rs exists with: NonterminatingProofResult enum, prove_nonterminating() function implementing Chen-Hou-Mu method (parameter specialization -> q-Zeilberger -> RHS recurrence check -> initial condition verification), at least 8 passing tests including a q-Gauss nonterminating proof. Module declared and re-exported in mod.rs. All existing tests pass (no regressions). Requirements NTPR-01 and NTPR-02 satisfied.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::nonterminating` passes all tests
- `cargo test --lib` passes all existing tests (no regressions)
- q-Gauss nonterminating identity proved via Chen-Hou-Mu method (NTPR-01)
- Initial conditions verified by FPS comparison (NTPR-02)
- Failed proofs produce clear error messages
</verification>

<success_criteria>
1. prove_nonterminating correctly proves the q-Gauss summation formula via parameter specialization
2. The method correctly detects when RHS does not satisfy the LHS recurrence
3. Initial condition mismatches are caught and reported
4. Non-terminating LHS (no q^{-n} parameter) is rejected gracefully
5. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-extensions/16-02-SUMMARY.md`
</output>
