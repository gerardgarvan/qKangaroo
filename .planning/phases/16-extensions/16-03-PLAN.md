---
phase: 16-extensions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/hypergeometric.rs
  - crates/qsym-core/src/qseries/mod.rs
autonomous: true

must_haves:
  truths:
    - "Transformation chain search finds a known single-step path (e.g., Heine 1) between source and target 2phi1 series"
    - "Multi-step chains (e.g., Heine 1 followed by Heine 2) are discovered within depth bound"
    - "Search returns NotFound when no chain exists within the depth bound"
    - "Visited set prevents revisiting the same series parameters, avoiding exponential blowup"
    - "Returned chain includes transformation names, intermediate series, and cumulative prefactor"
  artifacts:
    - path: "crates/qsym-core/src/qseries/hypergeometric.rs"
      provides: "find_transformation_chain, TransformationChainResult, TransformationStep"
      min_lines: 100
    - path: "crates/qsym-core/src/qseries/mod.rs"
      provides: "re-exports for chain search types"
      contains: "find_transformation_chain"
  key_links:
    - from: "crates/qsym-core/src/qseries/hypergeometric.rs find_transformation_chain"
      to: "crates/qsym-core/src/qseries/hypergeometric.rs heine_transform_1/2/3, sears_transform, watson_transform"
      via: "Applies each transformation as a BFS edge"
      pattern: "heine_transform_1|heine_transform_2|heine_transform_3|sears_transform|watson_transform"
    - from: "crates/qsym-core/src/qseries/hypergeometric.rs find_transformation_chain"
      to: "crates/qsym-core/src/qseries/hypergeometric.rs eval_phi"
      via: "FPS comparison for target matching"
      pattern: "eval_phi"
---

<objective>
Implement BFS transformation chain search over the existing Heine/Sears/Watson transformation catalog to find paths between two hypergeometric series.

Purpose: Researchers often need to relate two hypergeometric series that are connected by a sequence of known transformations but the exact sequence is not obvious. This search automates the discovery of transformation chains within a configurable depth bound.

Output: TransformationStep, TransformationChainResult types, find_transformation_chain() function, and tests finding known single-step and multi-step chains.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-extensions/16-RESEARCH.md
@crates/qsym-core/src/qseries/hypergeometric.rs
@crates/qsym-core/src/qseries/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BFS transformation chain search</name>
  <files>crates/qsym-core/src/qseries/hypergeometric.rs, crates/qsym-core/src/qseries/mod.rs</files>
  <action>
Add the following to `crates/qsym-core/src/qseries/hypergeometric.rs`:

**New imports at top of file:**
- `use std::collections::{VecDeque, HashSet};`

**New data types (add after TransformationResult):**

```rust
/// A single step in a transformation chain.
#[derive(Clone, Debug)]
pub struct TransformationStep {
    /// Name of the transformation applied (e.g., "heine_1", "sears").
    pub name: String,
    /// The resulting series after this transformation.
    pub result_series: HypergeometricSeries,
    /// The prefactor from this single transformation step.
    pub step_prefactor: FormalPowerSeries,
}

/// Result of a transformation chain search.
#[derive(Clone, Debug)]
pub enum TransformationChainResult {
    /// A chain of transformations was found connecting source to target.
    Found {
        /// The sequence of transformation steps.
        steps: Vec<TransformationStep>,
        /// The cumulative prefactor (product of all step prefactors).
        total_prefactor: FormalPowerSeries,
    },
    /// No chain found within the depth bound.
    NotFound {
        /// The depth bound used.
        max_depth: usize,
    },
}
```

**Series normalization for visited set:**

```rust
/// Normalize a HypergeometricSeries into a canonical String key for visited-set deduplication.
///
/// Returns a single String built by:
/// 1. For each upper param QMonomial, produce string "{power}:{coeff_numer}/{coeff_denom}"
///    from coeff.numer().to_string(), coeff.denom().to_string(), and power.
/// 2. Sort the upper param strings lexicographically.
/// 3. Do the same for lower params.
/// 4. Produce the argument string in the same format.
/// 5. Concatenate: "U[{sorted_upper_joined_by_comma}]L[{sorted_lower_joined_by_comma}]A[{argument}]"
///
/// This gives a deterministic, order-independent key so that series with the same
/// parameter multisets (regardless of ordering) produce the same key.
fn normalize_series_key(series: &HypergeometricSeries) -> String
```

Implementation: For each QMonomial param, format as `"{power}:{numer}/{denom}"` where numer and denom come from `coeff.numer().to_string()` and `coeff.denom().to_string()`, and power is `power`. Sort the resulting Vec<String> for upper and lower params separately. Format the argument QMonomial the same way. Join into: `"U[a,b,c]L[d,e]A[f]"`. Return this String. Use `HashSet<String>` for visited.

**Target matching:**

```rust
/// Check if a series matches the target by FPS comparison.
/// Evaluates both series to FPS and checks if they are equal (up to a scalar/product prefactor).
fn series_matches_target(
    candidate: &HypergeometricSeries,
    candidate_prefactor: &FormalPowerSeries,
    target: &HypergeometricSeries,
    variable: SymbolId,
    truncation_order: i64,
) -> bool
```

Implementation: Compute eval_phi(candidate) * candidate_prefactor and compare to eval_phi(target). Return true if they are equal as FPS.

**Core function: find_transformation_chain**

```rust
/// Search for a transformation chain between two hypergeometric series.
///
/// Uses BFS over the transformation catalog {heine_1, heine_2, heine_3, sears, watson}
/// to find a sequence of transformations that transforms source into target
/// (modulo a prefactor).
///
/// # Arguments
/// - `source`: Starting hypergeometric series.
/// - `target`: Target hypergeometric series to reach.
/// - `max_depth`: Maximum number of transformation steps to try.
/// - `variable`: FPS variable for evaluation.
/// - `truncation_order`: FPS truncation order for comparison.
///
/// # Returns
/// - `Found { steps, total_prefactor }` if a chain exists within max_depth.
/// - `NotFound { max_depth }` if no chain was found.
pub fn find_transformation_chain(
    source: &HypergeometricSeries,
    target: &HypergeometricSeries,
    max_depth: usize,
    variable: SymbolId,
    truncation_order: i64,
) -> TransformationChainResult
```

**BFS implementation:**

1. **Initialize:** Create a VecDeque with initial state: (source.clone(), vec![], FPS::one(variable, truncation_order)). Create a HashSet<String> for visited states. Add normalize_series_key(source) to visited.

2. **Check source == target:** Before BFS, check if source already matches target (trivial chain with 0 steps). Compare via eval_phi(source) == eval_phi(target).

3. **BFS loop:** While queue is not empty:
   a. Dequeue (current_series, chain_so_far, cumulative_prefactor).
   b. If chain_so_far.len() >= max_depth: skip (don't expand further).
   c. Define the transformation catalog as a Vec of (name, fn pointer):
      ```
      let transforms: Vec<(&str, fn(&HypergeometricSeries, SymbolId, i64) -> Option<TransformationResult>)> = vec![
          ("heine_1", heine_transform_1),
          ("heine_2", heine_transform_2),
          ("heine_3", heine_transform_3),
          ("sears", sears_transform),
          ("watson", watson_transform),
      ];
      ```
   d. For each (name, transform_fn) in transforms:
      - Call transform_fn(&current_series, variable, truncation_order).
      - If Some(result):
        - Compute new_prefactor = arithmetic::mul(&cumulative_prefactor, &result.prefactor).
        - Build new_step = TransformationStep { name, result_series: result.transformed.clone(), step_prefactor: result.prefactor }.
        - Build new_chain = chain_so_far + [new_step].
        - Check if result.transformed matches target:
          Each transformation gives result.transformed and result.prefactor such that eval_phi(input) == result.prefactor * eval_phi(result.transformed). So after a chain of transformations: eval_phi(source) == total_prefactor * eval_phi(chain_end). We want chain_end to MATCH target. The match condition is: eval_phi(chain_end) == eval_phi(target). This means eval_phi(source) == total_prefactor * eval_phi(target).

          So check: does eval_phi(&result.transformed) == eval_phi(target)?
        - If match: return Found { steps: new_chain, total_prefactor: new_prefactor }.
        - Compute key = normalize_series_key(&result.transformed).
        - If key is NOT in visited: add to visited, enqueue (result.transformed, new_chain, new_prefactor).

4. **If queue exhausted:** Return NotFound { max_depth }.

**Performance note:** The BFS with visited set and depth bound is sufficient. For depth <= 4, the search space is at most 5^4 = 625 nodes (minus visited pruning). Each node requires eval_phi which is O(truncation_order) work. Total is very fast.

**Update mod.rs re-exports:**

Add to the existing hypergeometric re-export line: `TransformationStep, TransformationChainResult, find_transformation_chain`.

**Tests (8+ tests):**

1. `test_chain_identity` -- Source == target. Should return Found with 0 steps and prefactor 1.

2. `test_chain_single_heine1` -- Source is 2phi1(a,b;c;q,z). Target is the Heine-1 transformed series. Should find a 1-step chain via heine_1. Use concrete q=1/2, a=q, b=q^2, c=q^3, z=c/(ab)=q^3/(q*q^2)=1.

3. `test_chain_single_heine2` -- Similar but target is Heine-2 transform. 1-step chain.

4. `test_chain_two_step` -- Apply heine_1 then heine_2 to a source series. Use the doubly-transformed series as target. BFS should find a 2-step chain. (The exact 2-step path may or may not be heine_1+heine_2; BFS finds the shortest.)

5. `test_chain_not_found_depth0` -- max_depth=0, source != target. Returns NotFound.

6. `test_chain_not_found_different_rs` -- Source is 2phi1, target is 4phi3. No transformation can change (r,s). Returns NotFound.

7. `test_chain_visited_dedup` -- Create a scenario where naive BFS would loop but visited set prevents it. Verify BFS terminates quickly.

8. `test_chain_with_prefactor` -- Verify the total_prefactor in the Found result is correct by checking: total_prefactor * eval_phi(final_series) == eval_phi(source).

9. `test_chain_heine3_involution` -- Heine 3 applied twice relates back. Verify BFS handles this without infinite loop.

Build and test:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib qseries::hypergeometric::tests -- --nocapture
```

Note: Since we're adding to an existing file, run the full hypergeometric test suite, not just new tests.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test --lib qseries::hypergeometric` and confirm all tests pass (both existing and new). Run `cargo test --lib` to confirm no regressions. Verify chain search finds a known single-step Heine transformation.
  </verify>
  <done>
hypergeometric.rs extended with: TransformationStep and TransformationChainResult types, normalize_series_key for visited dedup, find_transformation_chain() BFS function over 5 transformations, at least 8 passing tests including single-step chains, multi-step chains, not-found cases, and prefactor verification. Types re-exported in mod.rs. All existing tests pass (no regressions). Requirements TRNS-01 and TRNS-02 satisfied.
  </done>
</task>

</tasks>

<verification>
- `cargo test --lib qseries::hypergeometric` passes all tests (existing + new)
- `cargo test --lib` passes all existing tests (no regressions)
- Single-step transformation chain found correctly (TRNS-01)
- Multi-step chain discovered within depth bound (TRNS-01)
- NotFound returned when no chain exists (TRNS-02)
- Chain includes transformation names, intermediate forms, and prefactor (TRNS-02)
</verification>

<success_criteria>
1. BFS finds single-step Heine/Sears/Watson chains between series
2. Multi-step chains are discovered (depth 2+)
3. Depth bound correctly limits search
4. Visited set prevents revisiting and ensures termination
5. Total prefactor satisfies: prefactor * eval_phi(chain_end) == eval_phi(source)
6. All existing hypergeometric tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-extensions/16-03-SUMMARY.md`
</output>
