---
phase: 17-python-api-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/python/q_kangaroo/__init__.py
  - crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
  - crates/qsym-python/python/q_kangaroo/__init__.pyi
autonomous: true

must_haves:
  truths:
    - "q_zeilberger returns recurrence order, coefficients, and certificate string for q-Vandermonde"
    - "verify_wz independently verifies a WZ certificate by re-deriving it and checking the telescoping identity"
    - "q_petkovsek returns closed-form Pochhammer solutions for recurrences from q_zeilberger"
    - "q_gosper has type stubs in both .pyi files (fixing existing gap)"
  artifacts:
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "q_zeilberger_fn, verify_wz_fn, q_petkovsek_fn with NumPy-style docstrings"
      contains: "pub fn q_zeilberger_fn"
    - path: "crates/qsym-python/src/lib.rs"
      provides: "Module registration for 3 new functions"
      contains: "wrap_pyfunction!(dsl::q_zeilberger_fn"
    - path: "crates/qsym-python/python/q_kangaroo/__init__.py"
      provides: "Re-exports for q_zeilberger, verify_wz, q_petkovsek"
      contains: "q_zeilberger"
    - path: "crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi"
      provides: "Type stubs for q_gosper, q_zeilberger, verify_wz, q_petkovsek"
      contains: "def q_zeilberger"
    - path: "crates/qsym-python/python/q_kangaroo/__init__.pyi"
      provides: "Re-export stubs for q_gosper, q_zeilberger, verify_wz, q_petkovsek"
      contains: "q_zeilberger as q_zeilberger"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "qsym_core::qseries::q_zeilberger"
      via: "use import + function call"
      pattern: "q_zeilberger\\("
    - from: "crates/qsym-python/src/lib.rs"
      to: "crates/qsym-python/src/dsl.rs"
      via: "wrap_pyfunction! registration"
      pattern: "wrap_pyfunction!"
    - from: "crates/qsym-python/python/q_kangaroo/__init__.py"
      to: "crates/qsym-python/src/dsl.rs"
      via: "from _q_kangaroo import"
      pattern: "q_zeilberger_fn as q_zeilberger"
---

<objective>
Add Python DSL functions for the core algorithmic summation tools: q_zeilberger, verify_wz, and q_petkovsek (API-01 requirements). Also fix the missing q_gosper type stubs (existing gap from Phase 14).

Purpose: These are the straightforward function wrappers that follow established patterns (result-as-dict, parse_qmonomials). They form Group 12 (Algorithmic Summation) in the DSL.
Output: 3 new pyfunction entries in dsl.rs, registrations in lib.rs, re-exports in __init__.py, type stubs in both .pyi files.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-python-api-docs/17-RESEARCH.md
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/python/q_kangaroo/__init__.py
@crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
@crates/qsym-python/python/q_kangaroo/__init__.pyi
@crates/qsym-core/src/qseries/zeilberger.rs
@crates/qsym-core/src/qseries/petkovsek.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add q_zeilberger_fn, verify_wz_fn, q_petkovsek_fn to dsl.rs</name>
  <files>crates/qsym-python/src/dsl.rs</files>
  <action>
Add new imports at the top of dsl.rs to the existing `use qsym_core::qseries::{...}` block:
- `q_zeilberger, QZeilbergerResult, ZeilbergerResult, detect_n_params`
- `verify_wz_certificate`
- `q_petkovsek, QPetkovsekResult, ClosedForm`

Also add: `use qsym_core::poly::QRatRationalFunc;`

After the Group 11 (q-Gosper) section at end of file, add:

**Group 12: Algorithmic Summation** with 3 functions:

1. **q_zeilberger_fn** -- `#[pyfunction] #[pyo3(name = "q_zeilberger", signature = (upper, lower, z_num, z_den, z_pow, n_val, q_num, q_den, max_order, n_param_indices=None, n_is_in_argument=None))]`
   - Takes upper/lower as Vec<(i64,i64,i64)>, z params, n_val, q params, max_order
   - Optional n_param_indices: Option<Vec<usize>> and n_is_in_argument: Option<bool> for manual override
   - Build HypergeometricSeries from parse_qmonomials + QMonomial::new
   - Build q_val from QRat::from((q_num, q_den))
   - Auto-detect via detect_n_params when overrides are None; use provided values otherwise
   - Call q_zeilberger(...) from qsym_core
   - Return dict: on Recurrence variant, set "found"=true, "order"=zr.order, "coefficients"=qrat_vec_to_pylist(py, &zr.coefficients), "certificate"=format!("{}", zr.certificate), "numer"=format!("{}", zr.certificate.numer), "denom"=format!("{}", zr.certificate.denom)
   - On NoRecurrence, set "found"=false
   - Full NumPy-style docstring: Parameters section with all 11 params, Returns section describing both dict shapes, Examples section showing q-Vandermonde ([(1,1,-5),(1,1,2)], [(1,1,3)], 1,1,4, 5, 2,1, 3), See Also referencing q_gosper/verify_wz/q_petkovsek

2. **verify_wz_fn** -- `#[pyfunction] #[pyo3(name = "verify_wz", signature = (upper, lower, z_num, z_den, z_pow, n_val, q_num, q_den, max_order, max_k, n_param_indices=None, n_is_in_argument=None))]`
   - Same series/q construction as q_zeilberger_fn
   - Internally call q_zeilberger first to get the certificate (since QRatRationalFunc can't come from Python)
   - If q_zeilberger returns NoRecurrence, return dict with "verified"=false, "reason"="no recurrence found"
   - If recurrence found, call verify_wz_certificate(series, n_val, q_val, &zr.coefficients, &zr.certificate, &indices, in_arg, max_k)
   - Return dict: "verified"=bool result, "order"=zr.order, "coefficients"=qrat_vec_to_pylist, "certificate"=format string
   - NumPy-style docstring explaining this independently verifies the WZ telescoping identity

3. **q_petkovsek_fn** -- `#[pyfunction] #[pyo3(name = "q_petkovsek", signature = (coefficients, q_num, q_den))]`
   - Takes coefficients: Vec<(i64, i64)> as (numer, denom) pairs representing QRat values
   - Build Vec<QRat> from the tuples
   - Build q_val from QRat::from((q_num, q_den))
   - Call q_petkovsek(&coeffs, &q_val) which returns Vec<QPetkovsekResult>
   - Convert to Python list of dicts. Each dict has:
     - "ratio" = qrat_to_python(py, &r.ratio)
     - "has_closed_form" = bool
     - If closed_form is Some: "scalar" = qrat_to_python, "q_power_coeff" = i64, "numer_factors" = list of (String, i64) tuples from QMonomial coeff Display + power, "denom_factors" same
   - Use PyList::new(py, &items) for the outer list (match PyO3 0.23 API -- check existing pattern in dsl.rs for list construction)
   - NumPy-style docstring with Parameters, Returns, Examples (using output from q_zeilberger as input), See Also

Pattern references: Follow q_gosper_fn (line 3253) for series construction, prove_eta_id (line ~2156) for dict result pattern, phi (line ~2090) for parse_qmonomials usage.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo check -p qsym-python 2>&1 | tail -5` -- should compile without errors.
  </verify>
  <done>Three new #[pyfunction] entries exist in dsl.rs with full NumPy-style docstrings, compiling successfully against qsym-core types.</done>
</task>

<task type="auto">
  <name>Task 2: Register functions and update all Python-side files</name>
  <files>crates/qsym-python/src/lib.rs, crates/qsym-python/python/q_kangaroo/__init__.py, crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi, crates/qsym-python/python/q_kangaroo/__init__.pyi</files>
  <action>
**lib.rs** -- After the Group 11 section (line 125), add:
```
    // Group 12: Algorithmic Summation
    m.add_function(wrap_pyfunction!(dsl::q_zeilberger_fn, m)?)?;
    m.add_function(wrap_pyfunction!(dsl::verify_wz_fn, m)?)?;
    m.add_function(wrap_pyfunction!(dsl::q_petkovsek_fn, m)?)?;
```

**__init__.py** -- In the import block (after Group 11 q_gosper line), add:
```python
    # Group 12: Algorithmic Summation
    q_zeilberger_fn as q_zeilberger,
    verify_wz_fn as verify_wz,
    q_petkovsek_fn as q_petkovsek,
```
In __all__, after "q_gosper" entry, add: "q_zeilberger", "verify_wz", "q_petkovsek"

**_q_kangaroo.pyi** -- After Group 10c Bailey section (end of file), add:

Group 11 stub for q_gosper (MISSING -- existing gap fix):
```python
# ===========================================================================
# Group 11: q-Gosper Algorithm
# ===========================================================================

def q_gosper(upper: list[tuple[int, int, int]], lower: list[tuple[int, int, int]], z_num: int, z_den: int, z_pow: int, q_num: int, q_den: int) -> dict[str, object]:
    """Run the q-Gosper algorithm for indefinite q-hypergeometric summation."""
    ...
```

Then Group 12:
```python
# ===========================================================================
# Group 12: Algorithmic Summation
# ===========================================================================

def q_zeilberger(upper: list[tuple[int, int, int]], lower: list[tuple[int, int, int]], z_num: int, z_den: int, z_pow: int, n_val: int, q_num: int, q_den: int, max_order: int, n_param_indices: Optional[list[int]] = None, n_is_in_argument: Optional[bool] = None) -> dict[str, object]:
    """Run the q-Zeilberger creative telescoping algorithm."""
    ...

def verify_wz(upper: list[tuple[int, int, int]], lower: list[tuple[int, int, int]], z_num: int, z_den: int, z_pow: int, n_val: int, q_num: int, q_den: int, max_order: int, max_k: int, n_param_indices: Optional[list[int]] = None, n_is_in_argument: Optional[bool] = None) -> dict[str, object]:
    """Verify a WZ certificate for a q-hypergeometric identity."""
    ...

def q_petkovsek(coefficients: list[tuple[int, int]], q_num: int, q_den: int) -> list[dict[str, object]]:
    """Solve a q-hypergeometric recurrence for closed-form solutions."""
    ...
```

**__init__.pyi** -- After Group 10 section, add:

Group 11 (q_gosper -- MISSING gap fix):
```python
# Group 11: q-Gosper Algorithm
from q_kangaroo._q_kangaroo import q_gosper as q_gosper
```

Group 12:
```python
# Group 12: Algorithmic Summation
from q_kangaroo._q_kangaroo import q_zeilberger as q_zeilberger
from q_kangaroo._q_kangaroo import verify_wz as verify_wz
from q_kangaroo._q_kangaroo import q_petkovsek as q_petkovsek
```
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-python 2>&1 | tail -10` -- all tests pass. Also verify: `python -c "from q_kangaroo._q_kangaroo import q_zeilberger; print('OK')"` after maturin develop (if time permits, otherwise cargo test is sufficient).
  </verify>
  <done>All 4 Python-side files updated: lib.rs registers 3 new functions, __init__.py re-exports them, both .pyi files have type stubs for q_gosper (gap fix) + 3 new functions. cargo test passes.</done>
</task>

</tasks>

<verification>
- `cargo check -p qsym-python` compiles without errors
- `cargo test -p qsym-python` passes all existing tests
- _q_kangaroo.pyi contains stubs for q_gosper, q_zeilberger, verify_wz, q_petkovsek
- __init__.pyi contains re-export stubs for all 4 functions
- __init__.py __all__ includes q_zeilberger, verify_wz, q_petkovsek
- lib.rs has wrap_pyfunction! for all 3 new functions
</verification>

<success_criteria>
- q_zeilberger_fn, verify_wz_fn, q_petkovsek_fn compile and are registered in the Python module
- q_gosper type stubs added to both .pyi files (gap fix)
- All functions follow the established dict-return pattern with NumPy-style docstrings
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-python-api-docs/17-01-SUMMARY.md`
</output>
