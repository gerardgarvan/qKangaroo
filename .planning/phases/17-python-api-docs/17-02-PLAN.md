---
phase: 17-python-api-docs
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - crates/qsym-python/src/dsl.rs
  - crates/qsym-python/src/lib.rs
  - crates/qsym-python/python/q_kangaroo/__init__.py
  - crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
  - crates/qsym-python/python/q_kangaroo/__init__.pyi
  - docs/api/summation.rst
  - docs/api/index.rst
  - docs/index.rst
autonomous: true

must_haves:
  truths:
    - "prove_nonterminating works from Python using declarative template parameters (no closures)"
    - "find_transformation_chain works from Python with source/target series and session"
    - "All 6 new functions have NumPy-style docstrings visible via help()"
    - "Sphinx docs site has a summation.rst page with autofunction directives for all 6 functions"
    - "docs/index.rst and docs/api/index.rst reflect updated function and group counts"
  artifacts:
    - path: "crates/qsym-python/src/dsl.rs"
      provides: "prove_nonterminating_fn, find_transformation_chain_fn with docstrings"
      contains: "pub fn prove_nonterminating_fn"
    - path: "docs/api/summation.rst"
      provides: "Sphinx API page for all algorithmic summation functions"
      contains: "autofunction:: q_kangaroo.q_zeilberger"
    - path: "docs/api/index.rst"
      provides: "Updated toctree including summation page, updated counts"
      contains: "summation"
    - path: "docs/index.rst"
      provides: "Updated function count"
      contains: "79 functions"
  key_links:
    - from: "crates/qsym-python/src/dsl.rs"
      to: "qsym_core::qseries::prove_nonterminating"
      via: "closure construction from declarative params"
      pattern: "prove_nonterminating\\("
    - from: "crates/qsym-python/src/dsl.rs"
      to: "qsym_core::qseries::find_transformation_chain"
      via: "session symbol lookup + function call"
      pattern: "find_transformation_chain\\("
    - from: "docs/api/summation.rst"
      to: "crates/qsym-python/src/dsl.rs"
      via: "sphinx autofunction directives"
      pattern: "autofunction:: q_kangaroo"
---

<objective>
Add Python DSL functions for prove_nonterminating (API-02, closure template design) and find_transformation_chain (API-02), then create Sphinx documentation pages for all new functions (API-03, API-04).

Purpose: prove_nonterminating is the most complex wrapper (requires Rust-side closure construction from declarative Python parameters). find_transformation_chain needs QSession for variable lookup. The Sphinx page completes the documentation requirement.
Output: 2 new pyfunction entries in dsl.rs, all Python-side registrations, new summation.rst Sphinx page, updated counts in index files.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-python-api-docs/17-RESEARCH.md
@.planning/phases/17-python-api-docs/17-01-SUMMARY.md
@crates/qsym-python/src/dsl.rs
@crates/qsym-python/src/lib.rs
@crates/qsym-python/python/q_kangaroo/__init__.py
@crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi
@crates/qsym-python/python/q_kangaroo/__init__.pyi
@crates/qsym-core/src/qseries/nonterminating.rs
@crates/qsym-core/src/qseries/hypergeometric.rs
@docs/api/index.rst
@docs/api/hypergeometric.rst
@docs/index.rst
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prove_nonterminating_fn and find_transformation_chain_fn to dsl.rs</name>
  <files>crates/qsym-python/src/dsl.rs</files>
  <action>
Add new imports to the existing use block (if not already added by 17-01):
- `prove_nonterminating, NonterminatingProofResult`
- `find_transformation_chain, TransformationChainResult, TransformationStep`

After the Group 12 section added by 17-01, add:

**Group 13: Identity Proving Extensions** with 2 functions:

1. **prove_nonterminating_fn** -- HIGH complexity, closure template design.
   `#[pyfunction] #[pyo3(name = "prove_nonterminating", signature = (upper_fixed, n_param_offset, lower, z_pow_offset, rhs_numer_bases, rhs_denom_bases, q_num, q_den, n_test, max_order))]`

   Parameters:
   - upper_fixed: Vec<(i64, i64, i64)> -- n-independent upper params
   - n_param_offset: i64 -- the n-dependent upper param is q^{offset - n}
   - lower: Vec<(i64, i64, i64)> -- lower params
   - z_pow_offset: i64 -- argument is q^{offset + n}
   - rhs_numer_bases: Vec<i64> -- each base b means (q^b; q)_n in RHS numerator
   - rhs_denom_bases: Vec<i64> -- each base b means (q^b; q)_n in RHS denominator
   - q_num, q_den: i64 -- concrete q
   - n_test: i64 -- test value for n (>= 5 recommended)
   - max_order: usize -- max recurrence order to search

   Implementation:
   - Parse upper_fixed and lower via parse_qmonomials into local variables
   - Create a private helper `pochhammer_scalar_val(q_val: &QRat, base_power: i64, n: i64) -> QRat` that computes (q^base; q)_n at concrete q by iterating k=0..n and multiplying (1 - q^base * q^k). Uses qrat_pow_i64 (already duplicated in zeilberger.rs -- duplicate again locally in dsl.rs, or reference it via the public re-export path).
   - NOTE: qrat_pow_i64 is private in gosper.rs and zeilberger.rs. Duplicate a minimal version in dsl.rs as a private helper (just repeated squaring for positive, invert for negative, one for zero). This matches established pattern of duplication across modules.
   - Build lhs_builder closure: `|n: i64| -> HypergeometricSeries { let mut upper = upper_fixed_qm.clone(); upper.push(QMonomial::q_power(n_param_offset - n)); HypergeometricSeries { upper, lower: lower_qm.clone(), argument: QMonomial::q_power(z_pow_offset + n) } }`
   - Build rhs_builder closure: `|n: i64| -> QRat { if n == 0 { return QRat::one(); } let mut numer = QRat::one(); for &base in &rhs_numer_bases { numer = &numer * &pochhammer_scalar_val(&q_val, base, n); } let mut denom = QRat::one(); for &base in &rhs_denom_bases { denom = &denom * &pochhammer_scalar_val(&q_val, base, n); } &numer / &denom }`
   - Call prove_nonterminating(&lhs_builder, &rhs_builder, &q_val, n_test, max_order)
   - Return dict: on Proved, set "proved"=true, "recurrence_order", "coefficients"=qrat_vec_to_pylist, "initial_conditions_checked"
   - On Failed, set "proved"=false, "reason"=reason string

   QMonomial::q_power(p) is shorthand for QMonomial::new(QRat::one(), p). Check if this method exists on QMonomial. If not, use QMonomial { coeff: QRat::one(), power: p } directly or QMonomial::new(QRat::from((1i64, 1i64)), p).

   Full NumPy-style docstring: explain the template approach, all 10 parameters with types, Returns section with both dict shapes, Examples section showing q-Gauss nonterminating proof, See Also referencing q_zeilberger.

2. **find_transformation_chain_fn** -- `#[pyfunction] #[pyo3(name = "find_transformation_chain", signature = (session, source_upper, source_lower, source_z_num, source_z_den, source_z_pow, target_upper, target_lower, target_z_num, target_z_den, target_z_pow, max_depth, order))]`
   - Takes QSession reference + source/target series params + max_depth + order
   - Lock session to get_or_create_symbol_id("q") -> SymbolId, then drop the lock
   - Build source and target HypergeometricSeries from parse_qmonomials
   - Call find_transformation_chain(&source, &target, max_depth, variable, order)
   - Return dict: on Found, set "found"=true, "steps"=list of dicts with "name" and "prefactor" (as QSeries), "total_prefactor" as QSeries
   - For each step, the result_series can be represented as a dict with "upper", "lower", "argument" where each is a list of (String, i64) tuples for the QMonomials
   - On NotFound, set "found"=false, "max_depth"=max_depth

   Full NumPy-style docstring explaining BFS chain search, all 13 params, Returns, Examples, See Also.

Important: The `series` module in qsym-python has `QSeries { fps: FormalPowerSeries }` -- use this to wrap prefactors. Check if QSeries fields are pub or if there is a constructor. Look at series.rs in qsym-python for how QSeries is constructed from FPS.

For PyList construction with PyO3 0.23, use `PyList::new(py, &vec_of_py_objects)?` -- check existing dsl.rs patterns for correct API (some versions use `PyList::new_bound`).
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo check -p qsym-python 2>&1 | tail -5` -- compiles without errors.
  </verify>
  <done>prove_nonterminating_fn and find_transformation_chain_fn exist in dsl.rs with closure-from-template design and full docstrings, compiling successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Register functions, update Python files, create Sphinx docs</name>
  <files>crates/qsym-python/src/lib.rs, crates/qsym-python/python/q_kangaroo/__init__.py, crates/qsym-python/python/q_kangaroo/_q_kangaroo.pyi, crates/qsym-python/python/q_kangaroo/__init__.pyi, docs/api/summation.rst, docs/api/index.rst, docs/index.rst</files>
  <action>
**lib.rs** -- After Group 12 section, add:
```
    // Group 13: Identity Proving Extensions
    m.add_function(wrap_pyfunction!(dsl::prove_nonterminating_fn, m)?)?;
    m.add_function(wrap_pyfunction!(dsl::find_transformation_chain_fn, m)?)?;
```

**__init__.py** -- In import block after Group 12, add:
```python
    # Group 13: Identity Proving Extensions
    prove_nonterminating_fn as prove_nonterminating,
    find_transformation_chain_fn as find_transformation_chain,
```
In __all__, add: "prove_nonterminating", "find_transformation_chain"

**_q_kangaroo.pyi** -- After Group 12 section, add Group 13 stubs:
```python
# ===========================================================================
# Group 13: Identity Proving Extensions
# ===========================================================================

def prove_nonterminating(upper_fixed: list[tuple[int, int, int]], n_param_offset: int, lower: list[tuple[int, int, int]], z_pow_offset: int, rhs_numer_bases: list[int], rhs_denom_bases: list[int], q_num: int, q_den: int, n_test: int, max_order: int) -> dict[str, object]:
    """Prove a nonterminating q-hypergeometric identity via Chen-Hou-Mu method."""
    ...

def find_transformation_chain(session: QSession, source_upper: list[tuple[int, int, int]], source_lower: list[tuple[int, int, int]], source_z_num: int, source_z_den: int, source_z_pow: int, target_upper: list[tuple[int, int, int]], target_lower: list[tuple[int, int, int]], target_z_num: int, target_z_den: int, target_z_pow: int, max_depth: int, order: int) -> dict[str, object]:
    """Search for a chain of transformations between two hypergeometric series."""
    ...
```

**__init__.pyi** -- After Group 12 section, add:
```python
# Group 13: Identity Proving Extensions
from q_kangaroo._q_kangaroo import prove_nonterminating as prove_nonterminating
from q_kangaroo._q_kangaroo import find_transformation_chain as find_transformation_chain
```

**docs/api/summation.rst** -- Create NEW file:
```rst
Algorithmic Summation & Identity Proving
=========================================

The q-Gosper algorithm performs indefinite q-hypergeometric summation.
The q-Zeilberger algorithm extends this via creative telescoping to find
recurrences for definite sums $S(n) = \sum_k F(n,k)$. The q-Petkovsek
algorithm solves the resulting recurrences for closed-form solutions.
The WZ (Wilf-Zeilberger) certificate provides a proof certificate that
can be independently verified. The Chen-Hou-Mu method proves nonterminating
identities by parameter specialization, and the transformation chain search
discovers sequences of Heine/Sears/Watson transformations connecting two
hypergeometric series.

.. autofunction:: q_kangaroo.q_gosper

.. autofunction:: q_kangaroo.q_zeilberger

.. autofunction:: q_kangaroo.verify_wz

.. autofunction:: q_kangaroo.q_petkovsek

.. autofunction:: q_kangaroo.prove_nonterminating

.. autofunction:: q_kangaroo.find_transformation_chain
```

**docs/api/index.rst** -- Update:
- Change "73 functions organized in 10 functional groups" to "79 functions organized in 12 functional groups"
- Add `summation` to the toctree (after `mock_theta`)

**docs/index.rst** -- Change "**73 functions** organized in 10 functional groups" to "**79 functions** organized in 12 functional groups"
  </action>
  <verify>
1. `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-python 2>&1 | tail -10` -- all tests pass.
2. Verify docs/api/summation.rst exists and has 6 autofunction directives.
3. Verify docs/api/index.rst toctree includes "summation".
4. Verify docs/index.rst says "79 functions".
  </verify>
  <done>All Python-side files updated for 2 new functions, summation.rst Sphinx page exists with all 6 autofunction directives, index pages reflect 79 functions in 12 groups, all tests pass.</done>
</task>

</tasks>

<verification>
- `cargo check -p qsym-python` compiles without errors
- `cargo test -p qsym-python` passes all tests
- prove_nonterminating_fn constructs closures from declarative template params (no Python Callable)
- find_transformation_chain_fn correctly locks session for symbol lookup
- docs/api/summation.rst has 6 autofunction directives (q_gosper through find_transformation_chain)
- docs/api/index.rst toctree includes summation, says "79 functions" and "12 functional groups"
- docs/index.rst says "79 functions"
- All 5 new + 1 fixed functions have complete type stubs in both .pyi files
- __init__.py __all__ includes all 5 new function names
</verification>

<success_criteria>
- Python functions prove_nonterminating and find_transformation_chain work from `import q_kangaroo` (API-02)
- All new functions have NumPy-style docstrings with LaTeX mathematical notation (API-03)
- Sphinx API reference page for new functions integrated into existing docs site (API-04)
- Function and group counts updated across all documentation files
</success_criteria>

<output>
After completion, create `.planning/phases/17-python-api-docs/17-02-SUMMARY.md`
</output>
