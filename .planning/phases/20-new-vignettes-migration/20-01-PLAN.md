---
phase: 20-new-vignettes-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/examples/getting_started.ipynb
  - docs/examples/series_analysis.ipynb
autonomous: true
requirements: [DOC-09, DOC-10]

must_haves:
  truths:
    - "getting_started.ipynb walks a newcomer from import to first identity verification"
    - "getting_started.ipynb shows QSession creation, aqprod, partition_gf, and findcong"
    - "getting_started.ipynb demonstrates etaq and jacprod named products"
    - "getting_started.ipynb ends with a prove_eta_id verification"
    - "series_analysis.ipynb demonstrates the full prodmake -> etamake -> sift pipeline"
    - "series_analysis.ipynb shows findlincombo, findhom, and findpoly for relation discovery"
    - "series_analysis.ipynb demonstrates findcong for congruence discovery"
    - "series_analysis.ipynb covers jacprodmake and mprodmake"
  artifacts:
    - path: "docs/examples/getting_started.ipynb"
      provides: "Newcomer onboarding tutorial notebook"
      contains: "partition_gf"
    - path: "docs/examples/series_analysis.ipynb"
      provides: "Series analysis workflow tutorial notebook"
      contains: "findlincombo"
  key_links:
    - from: "docs/examples/getting_started.ipynb"
      to: "q_kangaroo API"
      via: "import QSession, aqprod, partition_gf, etaq, jacprod, findcong, prove_eta_id"
      pattern: "QSession|aqprod|partition_gf|etaq|jacprod|findcong|prove_eta_id"
    - from: "docs/examples/series_analysis.ipynb"
      to: "q_kangaroo API"
      via: "import prodmake, etamake, sift, findlincombo, findhom, findpoly, findcong"
      pattern: "prodmake|etamake|sift|findlincombo|findhom|findpoly|findcong"
---

<objective>
Create two new tutorial notebooks: getting_started.ipynb for newcomer onboarding (DOC-09) and series_analysis.ipynb for the series analysis workflow (DOC-10).

Purpose: These fill the two most critical gaps in the documentation -- there is no beginner tutorial and no notebook showing the core analysis pipeline (prodmake/etamake/relation discovery). Newcomers need a zero-to-first-identity path, and researchers need to see the full analytical workflow demonstrated.

Output: Two new .ipynb files with pre-computed outputs, ready for Sphinx integration.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/examples/partition_congruences.ipynb
@crates/qsym-python/src/dsl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getting_started.ipynb -- zero to first identity for newcomers</name>
  <files>docs/examples/getting_started.ipynb</files>
  <action>
Create a new Jupyter notebook `docs/examples/getting_started.ipynb` with approximately 20-24 cells that walks a complete newcomer from installation to verifying their first q-series identity. Use the same .ipynb JSON format as existing notebooks: `nbformat: 4`, `nbformat_minor: 5`, `metadata.kernelspec` with `python3`, and `"metadata": {"nbsphinx_execute": "never"}` at cell level for code cells.

**Notebook structure (sections):**

**1. Title and Introduction** (2 cells)
- Markdown cell: "# Getting Started with q-Kangaroo" -- brief intro explaining q-Kangaroo is a symbolic computation engine for q-series that replaces Garvan's Maple packages. Target audience: researchers in number theory, combinatorics, partition theory.
- Markdown cell: Installation instructions: `pip install q-kangaroo` then `from q_kangaroo import *`

**2. Creating a Session** (2 cells)
- Markdown cell: Every computation starts with a `QSession` that manages the symbolic computation context.
- Code cell: `from q_kangaroo import QSession` then `s = QSession()` and `print(s)`. Pre-computed output: `QSession(symbols: 0, expressions: 0)` (or similar -- check the actual repr from the code).

**3. Your First q-Pochhammer Symbol** (3 cells)
- Markdown cell: The q-Pochhammer symbol $(a;q)_n = \prod_{k=0}^{n-1}(1-aq^k)$ is the fundamental building block. Explain the `aqprod` function.
- Code cell: `from q_kangaroo import aqprod` then `result = aqprod(s, 1, 1, 0, 3, 10)` (computes $(1;q)_3$ to order 10, which is $(1-q)(1-q^2)(1-q^3)$). Pre-computed output: `1 - q - q^2 + q^5 + O(q^10)`. Wait -- $(1;q)_3 = (1-q)(1-q^2)(1-q^3) = 1 - q - q^2 + q^3 + q^3 - q^4 - q^5 + q^6$. Let me compute: $(1-q)(1-q^2) = 1 - q - q^2 + q^3$. Then $\times (1-q^3) = 1 - q - q^2 + q^3 - q^3 + q^4 + q^5 - q^6 = 1 - q - q^2 + q^4 + q^5 - q^6$. So output is `1 - q - q^2 + q^4 + q^5 - q^6 + O(q^10)`.
- Markdown cell: Explain the parameters: `aqprod(session, coeff_num, coeff_den, power, n, order)` where `a = (coeff_num/coeff_den) * q^power` and `n` is the product length.

**4. Infinite Products** (3 cells)
- Markdown cell: Use `n=None` for $(a;q)_\infty$. This is central to q-series -- Euler's function $(q;q)_\infty = \prod_{k=1}^\infty(1-q^k)$.
- Code cell: `euler = aqprod(s, 1, 1, 1, None, 20)` (computes $(q;q)_\infty$ to order 20). Pre-computed output: Euler function coefficients from pentagonal theorem: `1 - q - q^2 + q^5 + q^7 - q^12 - q^15 + O(q^20)`.
- Markdown cell: The sparse pattern $1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15} + \ldots$ reflects Euler's pentagonal number theorem.

**5. Partition Generating Function** (3 cells)
- Markdown cell: The partition function $p(n)$ counts partitions of $n$. Its generating function is $\sum p(n)q^n = 1/(q;q)_\infty$.
- Code cell: `from q_kangaroo import partition_gf` then `pgf = partition_gf(s, 15)` then `pgf`. Pre-computed output: `1 + q + 2*q^2 + 3*q^3 + 5*q^4 + 7*q^5 + 11*q^6 + 15*q^7 + 22*q^8 + 30*q^9 + 42*q^10 + 56*q^11 + 77*q^12 + 101*q^13 + 135*q^14 + O(q^15)`.
- Code cell: `from q_kangaroo import partition_count` then print `partition_count(n)` for n=0..10 in a loop. Output: `p(0)=1, p(1)=1, p(2)=2, p(3)=3, p(4)=5, p(5)=7, p(6)=11, p(7)=15, p(8)=22, p(9)=30, p(10)=42`.

**6. Named Products -- Eta and Jacobi** (3 cells)
- Markdown cell: q-Kangaroo provides named products from the literature. `etaq(s, d, t, order)` computes $\prod_{n \ge 0}(1-q^{dn+t})$ and `jacprod(s, a, b, order)` computes the Jacobi triple product $J(a,b)$.
- Code cell: `from q_kangaroo import etaq, jacprod` then compute `eta1 = etaq(s, 1, 1, 15)` (this is $(q;q)_\infty$) and `jp = jacprod(s, 1, 2, 20)` (this is $J(1,2) = \theta_4(q)$). Pre-computed output for eta1: same as Euler function above (to order 15). For jp: `1 - 2*q + 2*q^4 - 2*q^9 + 2*q^16 + O(q^20)` (theta4).
- Markdown cell: Explain that $J(1,2) = \theta_4(q)$ is a Jacobi theta function.

**7. Discovering Congruences** (3 cells)
- Markdown cell: Ramanujan discovered $p(5n+4) \equiv 0 \pmod{5}$. The `findcong` function discovers such congruences automatically.
- Code cell: `from q_kangaroo import findcong` then `pgf100 = partition_gf(s, 100)` then `congs = findcong(pgf100, [5, 7, 11])` then print each. Pre-computed output: `p(5n + 4) == 0 (mod 5)`, `p(7n + 5) == 0 (mod 7)`, `p(11n + 6) == 0 (mod 11)`.
- Markdown cell: All three Ramanujan congruences rediscovered automatically!

**8. Your First Identity Verification** (3 cells)
- Markdown cell: q-Kangaroo can prove eta-quotient identities via the valence formula. Let's verify a simple identity involving eta functions. We'll prove $\eta(\tau)^{24} = \Delta(\tau)$, which is the discriminant modular form. Actually, let's prove a simpler self-equality as a first test: $\eta(\tau)^2 / \eta(2\tau) = \eta(\tau)^2 / \eta(2\tau)$, which is trivially true. For a real identity, we need two different eta-quotient expressions that are equal. A classic one is: at level 6, $\eta(\tau)\eta(2\tau)\eta(3\tau)\eta(6\tau)$ has specific properties. Actually the simplest genuine identity to demonstrate is a self-consistency check.

  Better approach: Use `prove_eta_id` with a genuine eta identity. A good example: $\eta(2\tau)^5 / (\eta(\tau)^2 \eta(4\tau)^2) = \phi(q)$ at level 4. Or simpler: prove a trivial identity where LHS = RHS to show the function works, then state that real identities from DLMF can be verified the same way.

  Use: `prove_eta_id(s, [(1, 2), (2, -1)], [(1, 2), (2, -1)], 2)` which proves $\eta(\tau)^2 / \eta(2\tau) = \eta(\tau)^2 / \eta(2\tau)$ at level 2 (self-equality, always works). Output: `{"status": "proved", "sturm_bound": ..., "cusp_orders": ...}`. This is a trivially true identity but demonstrates the API workflow.

  Actually for a more interesting demo: prove the identity $\eta(\tau)^{-1}\eta(2\tau)^2 = \sum q^{n(n+1)/2}$... but this needs specific LHS/RHS factors. Let me just use the self-equality example and note that researchers would use this for genuine identities from the literature.

- Code cell: `from q_kangaroo import prove_eta_id` then `result = prove_eta_id(s, [(1, 2), (2, -1)], [(1, 2), (2, -1)], 2)` then `print(result["status"])`. Pre-computed output: `proved`.
- Markdown cell: Summary table of functions learned + "Next Steps" pointing to the other notebooks. Mention partition_congruences.ipynb for deeper partition analysis, series_analysis.ipynb for research workflows, etc.

**CRITICAL FORMAT NOTES:**
- Use the exact same JSON structure as existing notebooks (see partition_congruences.ipynb for reference).
- Every code cell: `"cell_type": "code"`, `"execution_count": null`, `"metadata": {"nbsphinx_execute": "never"}`, `"outputs": [{"output_type": "stream", "name": "stdout", "text": [...]}]` for print outputs, or `"outputs": [{"output_type": "execute_result", "data": {"text/plain": [...]}, "metadata": {}, "execution_count": null}]` for expression outputs.
- Every markdown cell: `"cell_type": "markdown"`, `"metadata": {}`, `"source": [...]`.
- Source is an array of strings, one per line, with `\n` at end of each line except the last.

To compute pre-computed outputs accurately, use the mathematical definitions:
- $(1;q)_3 = (1-q)(1-q^2)(1-q^3) = 1 - q - q^2 + q^4 + q^5 - q^6$
- $(q;q)_\infty$ pentagonal: $1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15} + q^{22} + q^{26} - \ldots$ (exponents are pentagonal numbers $k(3k-1)/2$)
- partition_gf = $1/(q;q)_\infty$: coefficients are $p(n)$
- theta4 = $\sum_{n=-\infty}^{\infty} (-1)^n q^{n^2} = 1 - 2q + 2q^4 - 2q^9 + 2q^{16} - 2q^{25} + \ldots$

Where exact outputs are uncertain, use a Rust test harness to verify before hardcoding in the notebook. Write a temporary test in `crates/qsym-core/src/` that prints the exact FPS output, run with cargo test, and use the output.
  </action>
  <verify>
Read docs/examples/getting_started.ipynb and verify:
1. Valid JSON structure with nbformat 4
2. Sections present: session creation, aqprod, infinite products, partition_gf, partition_count, etaq, jacprod, findcong, prove_eta_id
3. All code cells have pre-computed outputs
4. All imports use `from q_kangaroo import ...`
5. Total cell count is 20-24
6. Notebook metadata includes kernelspec
  </verify>
  <done>
getting_started.ipynb exists with ~20-24 cells walking newcomers from installation through session creation, q-Pochhammer symbols, partition functions, named products, congruence discovery, and identity verification, with all outputs pre-computed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create series_analysis.ipynb -- prodmake/etamake/sift/relation discovery pipeline</name>
  <files>docs/examples/series_analysis.ipynb</files>
  <action>
Create a new Jupyter notebook `docs/examples/series_analysis.ipynb` with approximately 25-30 cells demonstrating the complete series analysis workflow. Use the same .ipynb JSON format as existing notebooks.

**Notebook structure (sections):**

**1. Title** (1 cell)
- Markdown: "# Series Analysis Workflows" -- analyzing q-series to discover product representations, eta-quotient structure, and linear/polynomial relations.

**2. Starting Point: A Mystery Series** (2 cells)
- Markdown: Start with a q-series and show how q-Kangaroo's analysis tools reverse-engineer its structure. Use the partition generating function as the first example (well-known, easy to verify).
- Code cell: Create session, compute `partition_gf(s, 50)` and display.

**3. Prodmake: Recovering Infinite Product Structure** (3 cells)
- Markdown: Andrews' `prodmake` algorithm determines exponents $a_n$ such that $f(q) = \prod(1-q^n)^{-a_n}$.
- Code cell: `prodmake(partition_gf(s, 50), 20)` showing all factors are 1 (confirming $\prod 1/(1-q^n)$). Output: `{'factors': {1: 1, 2: 1, ..., 20: 1}, 'terms_used': 50}`.
- Markdown: Interpret the result -- uniform exponents $a_n = 1$ confirm the Euler product.

**4. Etamake: Eta-Quotient Representation** (3 cells)
- Markdown: `etamake` groups `prodmake` output by divisor, recovering the Dedekind eta-quotient $\prod_d \eta(d\tau)^{r_d}$.
- Code cell: `etamake(partition_gf(s, 50), 20)` showing factors `{1: -1}` and q_shift `-1/24`.
- Markdown: Interpret: $f = q^{-1/24} \eta(\tau)^{-1}$, i.e., $\sum p(n)q^n = 1/\eta(\tau)$.

**5. Jacprodmake: Jacobi Product Representation** (3 cells)
- Markdown: `jacprodmake` searches for a Jacobi product representation $\prod J(a_i, b_i)^{e_i}$.
- Code cell: Demonstrate with theta4: `from q_kangaroo import theta4, jacprodmake` then `t4 = theta4(s, 50)` then `jacprodmake(t4, 50)`. The result should show `J(1,2)` (or equivalent). Output: dict with `factors` and `is_exact`.
- Markdown: Interpret the result -- theta4 is identified as a single Jacobi product.

**6. Mprodmake: Modified Product Representation** (2 cells)
- Markdown: `mprodmake` extracts $(1+q^n)$ factors iteratively, useful for series that are products of $(1+q^n)$ terms.
- Code cell: `from q_kangaroo import distinct_parts_gf, mprodmake` then `dpgf = distinct_parts_gf(s, 50)` then `mprodmake(dpgf, 20)`. Output: factors showing all exponents 1, confirming $\prod(1+q^n)$.

**7. Sift: Extracting Subsequences** (3 cells)
- Markdown: `sift(f, m, j)` extracts the subsequence $\{a_{mn+j}\}$ from a series $f = \sum a_n q^n$. Critical for studying congruences and dissections.
- Code cell: `from q_kangaroo import sift` then sift `partition_gf(s, 100)` with `sift(pgf, 5, 4)` to extract $p(5n+4)$. Output: `5 + 30*q + 135*q^2 + 490*q^3 + 1575*q^4 + ...` (all divisible by 5).
- Code cell: Also sift with `sift(pgf, 7, 5)` showing $p(7n+5)$ (all divisible by 7). Output: `7 + 77*q + 490*q^2 + 2436*q^3 + ...`.

**8. Qfactor: Polynomial Factoring** (2 cells)
- Markdown: `qfactor` factors a polynomial into $(1-q^i)$ factors.
- Code cell: `from q_kangaroo import qfactor` then factor $(1;q)_3 = (1-q)(1-q^2)(1-q^3)$: `poly = aqprod(s, 1, 1, 0, 3, 10)` then `qfactor(poly, 10)`. Output: dict showing factors `{1: 1, 2: 1, 3: 1}`.

**9. Findlincombo: Linear Relations** (3 cells)
- Markdown: `findlincombo` searches for linear combinations $\sum c_i f_i = 0$ among a set of series. This is the workhorse for discovering relations between q-series.
- Code cell: Create three related series -- e.g., partition_gf, `odd_parts_gf`, `distinct_parts_gf` -- and search for relations. Since `odd_parts_gf == distinct_parts_gf` (Euler's theorem), `findlincombo` with these plus partition_gf should find the relation `odd_parts - distinct_parts = 0`. Code: `from q_kangaroo import findlincombo, odd_parts_gf, distinct_parts_gf` then `series = [odd_parts_gf(s, 30), distinct_parts_gf(s, 30)]` then `findlincombo(series, 30)`. Output: coefficients `[1, -1]` (or `[-1, 1]`), confirming equality.
- Markdown: Interpret: coefficient vector $[1, -1]$ means $f_1 - f_2 = 0$, i.e., the two series are equal.

**10. Findhom: Homogeneous Polynomial Relations** (3 cells)
- Markdown: `findhom` searches for homogeneous polynomial relations of degree $d$ among series: $\sum c_{ij} f_i f_j = 0$ (for degree 2).
- Code cell: Use `findhom` with theta functions. Example: `from q_kangaroo import theta3, theta4, findhom` then create basis series and search for degree-2 relation. Since we can't multiply QSeries in Python, use `findhom` directly with a list of series and degree. The function handles the multiplication internally. Code: `t3 = theta3(s, 50)` then `t4 = theta4(s, 50)` then `findhom([t3, t4], 2, 50)`. This searches for a degree-2 relation. Output depends on whether theta3 and theta4 satisfy a degree-2 relation -- they don't in general without a third series. Better example: use `findhom` with `[partition_gf(s,30), etaq(s,1,1,30)]` at degree 1 to find that `partition_gf * etaq = 1` (or similar). Actually `findhom` with degree 1 is just `findlincombo`. Use degree 2 with a genuine relation.

  Better approach: Use `findhom` on the eta/theta series where we know there's a degree-2 identity. For example, with $f = (q;q)_\infty$ and $g = (q^2;q^2)_\infty$, $h = (q;q^2)_\infty$: we know $f = g \cdot h$, i.e., $f - g \cdot h = 0$, which is a degree-2 relation among $\{f, g, h\}$.

  Code: `e1 = etaq(s, 1, 1, 30)` ($(q;q)_\infty$), `e2 = etaq(s, 2, 2, 30)` ($(q^2;q^2)_\infty$), `e12 = aqprod(s, 1, 1, 1, None, 30)` ($(q;q^2)_\infty$ -- wait, that's $(q;q)_\infty$ again). Actually $(q;q^2)_\infty = \prod(1-q^{2k+1})$. To compute this: `aqprod(s, 1, 1, 1, None, 30)` with base period... hmm, aqprod only does $(a;q)_\infty$ with step 1. For $(q;q^2)_\infty$ we need `etaq(s, 2, 1, 30)` which is $\prod_{n \ge 0}(1 - q^{2n+1})$. So: `e_odd = etaq(s, 2, 1, 30)` for $(q;q^2)_\infty$. Then `findhom([e1, e2, e_odd], 2, 30)` should find the relation $e1 - e2 \cdot e_odd = 0$.

  Output: a coefficient vector for the degree-2 monomials. With 3 series and degree 2, monomials are $\{f_1^2, f_1 f_2, f_1 f_3, f_2^2, f_2 f_3, f_3^2\}$ (6 monomials). The relation $f_1 - f_2 f_3 = 0$ involves a degree-1 term ($f_1$) and degree-2 term ($f_2 f_3$). This might need `findnonhom` instead since it mixes degrees.

  Simpler approach: Just demonstrate `findhom` with a known quadratic identity. Use $\theta_3(q)^2 = 1 + 4\sum_{n=1}^{\infty} \frac{(-1)^{n+1}}{1-q^{2n-1}} q^{2n-1}$... this is too complex.

  Simplest approach: Show `findhom` searching for a relation among partition_gf and other partition-type series, and note whether it finds one or not. A "not found" result is also informative. Or demonstrate with series that have a known product relation.

  Actually, let me use `findpoly` instead of `findhom` for the more general case.

- Code cell: `from q_kangaroo import findhom` then demonstrate with a small example. Use `findhom([theta3(s, 40), theta4(s, 40), aqprod(s, 1, 1, 1, None, 40)], 2, 40)`. If a relation exists, show it. If not, show the empty result.
- Markdown: Explain what the output means and how homogeneous relations arise in modular forms.

**11. Findpoly: General Polynomial Relations** (2 cells)
- Markdown: `findpoly` searches for general polynomial relations (not necessarily homogeneous) up to a given degree.
- Code cell: `from q_kangaroo import findpoly` then demonstrate. Example: `findpoly([theta3(s, 40), theta4(s, 40)], 2, 40)` to search for a degree-2 relation between theta3 and theta4.

**12. Findcong: Automated Congruence Discovery** (2 cells)
- Markdown: `findcong` systematically searches for arithmetic subsequence congruences.
- Code cell: Show `findcong(partition_gf(s, 100), [5, 7, 11, 13, 17, 19, 23])` and display results. Output: the three Ramanujan congruences (mod 5, 7, 11). Note that no congruences are found for primes 13, 17, 19, 23.

**13. Summary** (1 cell)
- Markdown: Table of all analysis functions demonstrated and their purposes. Point to other notebooks for related workflows.

**CRITICAL FORMAT NOTES:**
Same .ipynb JSON format as existing notebooks. All code cells need pre-computed outputs.

To compute outputs, use temporary Rust test harness where needed. Key known outputs:
- partition_gf coefficients: 1,1,2,3,5,7,11,15,22,30,42,...
- prodmake(partition_gf, 20): factors {1:1, 2:1, ..., 20:1} (convention: f = prod(1-q^n)^{-a_n})
- etamake(partition_gf, 20): factors {1: -1}, q_shift -1/24
- sift(partition_gf(100), 5, 4): 5, 30, 135, 490, 1575, 4565, ...
- sift(partition_gf(100), 7, 5): 7, 77, 490, 2436, 10143, ...
- findcong result: [(5,4,5), (7,5,7), (11,6,11)]
- theta4(q): 1 - 2q + 2q^4 - 2q^9 + 2q^16 - ...
- Euler function: 1 - q - q^2 + q^5 + q^7 - q^12 - q^15 + ...
  </action>
  <verify>
Read docs/examples/series_analysis.ipynb and verify:
1. Valid JSON structure with nbformat 4
2. Sections present: prodmake, etamake, jacprodmake, mprodmake, sift, qfactor, findlincombo, findhom, findpoly, findcong
3. All code cells have pre-computed outputs
4. All imports use `from q_kangaroo import ...`
5. Total cell count is 25-30
  </verify>
  <done>
series_analysis.ipynb exists with ~25-30 cells demonstrating the complete analysis pipeline: prodmake -> etamake -> jacprodmake -> mprodmake for product analysis, sift + qfactor for dissection, and findlincombo/findhom/findpoly/findcong for relation discovery, with all outputs pre-computed.
  </done>
</task>

</tasks>

<verification>
1. Both notebooks are valid JSON (.ipynb format)
2. getting_started.ipynb covers DOC-09: install, session, aqprod, partition_gf, etaq, jacprod, findcong, prove_eta_id
3. series_analysis.ipynb covers DOC-10: prodmake, etamake, jacprodmake, mprodmake, sift, qfactor, findlincombo, findhom, findpoly, findcong
4. All code cells have pre-computed outputs matching actual Rust engine behavior
5. No broken imports -- all functions exist in q_kangaroo
</verification>

<success_criteria>
- getting_started.ipynb walks a newcomer from zero to first identity verification (DOC-09)
- series_analysis.ipynb demonstrates the full analysis pipeline: product decomposition, subsequence extraction, and relation discovery (DOC-10)
- Both notebooks have ~20-30 cells with mathematical context and pre-computed outputs
</success_criteria>

<output>
After completion, create `.planning/phases/20-new-vignettes-migration/20-01-SUMMARY.md`
</output>
