---
phase: 20-new-vignettes-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/examples/identity_proving.ipynb
autonomous: true
requirements: [DOC-11]

must_haves:
  truths:
    - "identity_proving.ipynb demonstrates q-Zeilberger creative telescoping to find recurrences"
    - "identity_proving.ipynb shows WZ certificate extraction and independent verification"
    - "identity_proving.ipynb demonstrates q-Petkovsek recurrence solving for closed forms"
    - "identity_proving.ipynb shows prove_nonterminating for infinite series identities"
    - "identity_proving.ipynb demonstrates find_transformation_chain for connecting equivalent series"
    - "identity_proving.ipynb shows q-Gosper for indefinite summation"
  artifacts:
    - path: "docs/examples/identity_proving.ipynb"
      provides: "Identity proving workflow tutorial notebook"
      contains: "q_zeilberger"
  key_links:
    - from: "docs/examples/identity_proving.ipynb"
      to: "q_kangaroo API"
      via: "import q_gosper, q_zeilberger, verify_wz, q_petkovsek, prove_nonterminating, find_transformation_chain"
      pattern: "q_gosper|q_zeilberger|verify_wz|q_petkovsek|prove_nonterminating|find_transformation_chain"
---

<objective>
Create the identity_proving.ipynb tutorial notebook demonstrating the full algorithmic identity proving pipeline from v1.2 (DOC-11).

Purpose: The v1.2 algorithms (q-Gosper, q-Zeilberger, WZ certificates, q-Petkovsek, prove_nonterminating, find_transformation_chain) are the most sophisticated features of q-Kangaroo. Researchers need a guided workflow showing how to combine these tools for machine-assisted proof of q-hypergeometric identities.

Output: One new .ipynb file with pre-computed outputs demonstrating the complete proof pipeline.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/examples/hypergeometric_summation.ipynb
@crates/qsym-python/src/dsl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create identity_proving.ipynb -- q-Zeilberger/WZ/q-Petkovsek/prove_nonterminating workflow</name>
  <files>docs/examples/identity_proving.ipynb</files>
  <action>
Create a new Jupyter notebook `docs/examples/identity_proving.ipynb` with approximately 28-34 cells demonstrating the complete algorithmic identity proving pipeline. Use the same .ipynb JSON format as existing notebooks.

**Notebook structure (sections):**

**1. Title and Introduction** (2 cells)
- Markdown: "# Machine-Assisted Identity Proving" -- overview of the algorithmic pipeline for proving q-hypergeometric identities. Mention the three stages: (1) indefinite summation (q-Gosper), (2) definite summation (q-Zeilberger + WZ), (3) closed-form recovery (q-Petkovsek). Plus extensions for nonterminating identities and transformation discovery.
- Markdown: All algorithms work with concrete q values (rational numbers), not symbolic q. This is because polynomial arithmetic over Q[x] is needed for the algorithms.

**2. q-Gosper: Indefinite Summation** (4 cells)
- Markdown: The q-Gosper algorithm (Paule, 1995) determines whether a q-hypergeometric term $t_k$ has a q-hypergeometric antidifference. This is the q-analog of Gosper's algorithm. If successful, $\sum_{k=0}^n t_k$ can be evaluated in closed form.
- Code cell: Summable example. `from q_kangaroo import q_gosper` then `result = q_gosper([(1,1,-3), (1,1,2)], [(1,1,3)], 1, 1, 4, 2, 1)`. This is ${}_{2}\phi_{1}(q^{-3}, q^2; q^3; q, q^4)$ at $q=2$. Pre-computed output: `{"summable": True, "certificate": "...", "numer": "...", "denom": "..."}`. The exact certificate strings depend on the polynomial output format -- derive from Rust test harness.
  Print `result["summable"]` (True) and `result["certificate"]`.
- Code cell: Non-summable example. `result = q_gosper([(1,1,1), (1,1,2)], [(1,1,5)], 1, 1, 1, 2, 1)`. Print `result["summable"]` (False). This demonstrates that not every q-hypergeometric sum has a closed form.
- Markdown: When q-Gosper fails, the sum may still satisfy a recurrence -- this is where q-Zeilberger takes over.

**3. q-Zeilberger: Creative Telescoping** (5 cells)
- Markdown: The q-Zeilberger algorithm (Koornwinder, 1993) finds a linear recurrence $c_0 S(n) + c_1 S(n+1) + \ldots + c_d S(n+d) = 0$ for the definite sum $S(n) = \sum_k F(n,k)$ where $F$ is q-hypergeometric in both $n$ and $k$. It also produces a WZ proof certificate.
- Code cell: Demonstrate with the q-Vandermonde identity. `from q_kangaroo import q_zeilberger` then `result = q_zeilberger([(1,1,-5), (1,1,2)], [(1,1,3)], 1, 1, 4, 5, 2, 1, 3)`. This is ${}_{2}\phi_{1}(q^{-5}, q^2; q^3; q, q^4)$ at $n=5$, $q=2$. Pre-computed output: `{"found": True, "order": 1, "coefficients": [...], "certificate": "..."}`.
  Print `result["found"]` (True), `result["order"]` (1), and the coefficients.
- Markdown: A first-order recurrence $c_0 S(n) + c_1 S(n+1) = 0$ means $S(n+1)/S(n) = -c_0/c_1$, giving the ratio of consecutive sums directly.
- Code cell: Show another example with higher order. `result2 = q_zeilberger([(1,1,-5), (1,1,1), (1,1,2)], [(1,1,3), (1,1,4)], 1, 1, 3, 5, 2, 1, 3)`. This is ${}_{3}\phi_{2}(q^{-5}, q, q^2; q^3, q^4; q, q^3)$ at $n=5$, $q=2$. Print the result.
- Markdown: The `max_order` parameter controls how high the algorithm searches. If no recurrence is found within `max_order`, try increasing it.

**4. WZ Certificates: Computer-Verified Proofs** (4 cells)
- Markdown: The WZ (Wilf-Zeilberger) certificate $R(n,k)$ is a rational function that provides a computer-verifiable proof of the summation identity. The telescoping identity $F(n+1,k) - F(n,k) = G(n,k+1) - G(n,k)$ where $G = R \cdot F$ is checked at multiple evaluation points.
- Code cell: `from q_kangaroo import verify_wz` then `result = verify_wz([(1,1,-5), (1,1,2)], [(1,1,3)], 1, 1, 4, 5, 2, 1, 3, 20)`. Check 20 evaluation points. Pre-computed output: `{"verified": True, "order": 1, "coefficients": [...], "certificate": "..."}`.
  Print `result["verified"]` (True) and the certificate.
- Markdown: Explain that `verify_wz` re-derives the recurrence independently and verifies the telescoping identity at `max_k` concrete points. This provides a rigorous proof, not a numerical approximation -- all arithmetic is exact rational.
- Code cell: Show the verification is independent -- even if we only had the certificate from a paper, we could verify it. Demonstrate by printing the verification details.

**5. q-Petkovsek: Solving Recurrences for Closed Forms** (4 cells)
- Markdown: Once q-Zeilberger finds a recurrence, q-Petkovsek (Petkovsek, 1992; Abramov-Paule-Petkovsek, 1998) solves it to recover a closed-form solution as a ratio of q-Pochhammer products. This completes the pipeline: series -> recurrence -> closed form.
- Code cell: Full pipeline. First get recurrence from q-Zeilberger, then solve with q-Petkovsek. `from q_kangaroo import q_petkovsek` then use the coefficients from the q-Zeilberger result. Code:
  ```
  zeil = q_zeilberger([(1,1,-5), (1,1,2)], [(1,1,3)], 1, 1, 4, 5, 2, 1, 3)
  coeffs = [(c.numerator, c.denominator) for c in zeil["coefficients"]]
  solutions = q_petkovsek(coeffs, 2, 1)
  ```
  Print `len(solutions)`, and for each solution print `ratio`, `has_closed_form`, and if closed form exists, the Pochhammer factors.
- Markdown: Interpret the closed form. If `has_closed_form` is True, the solution is $y(n) = s \cdot q^{c\binom{n}{2}} \cdot \prod(q^{a_i};q)_n / \prod(q^{b_j};q)_n$ with explicit numerical factors.
- Code cell: Show the complete pipeline in one block for clarity -- from q-hypergeometric parameters to closed-form solution.

**6. Proving Nonterminating Identities** (4 cells)
- Markdown: The Chen-Hou-Mu (2010) method proves nonterminating q-hypergeometric identities by specializing a parameter $a \to q^{-n}$ to create a family of terminating identities, then showing both sides satisfy the same recurrence with matching initial conditions.
- Code cell: Prove the q-Gauss summation in nonterminating form. `from q_kangaroo import prove_nonterminating` then:
  ```
  result = prove_nonterminating(
      [(1, 1, 1)],  # upper_fixed: a = q
      2,             # n_param_offset: b = q^{2-n}
      [(1, 1, 3)],   # lower: c = q^3
      2,             # z_pow_offset: z = q^{2+n}
      [2, 1],        # rhs numerator bases: (q^2;q)_n * (q;q)_n
      [3, 0],        # rhs denominator bases: (q^3;q)_n * (1;q)_n
      2, 1,          # q = 2/1 = 2
      5,             # n_test = 5
      3              # max_order = 3
  )
  ```
  Pre-computed output: `{"proved": True, "recurrence_order": 1, "initial_conditions_checked": 1, "coefficients": [...]}`.
  Print `result["proved"]` (True) and `result["recurrence_order"]`.
- Markdown: This proves ${}_{2}\phi_{1}(q, q^{-n}; q^3; q, q^{n+2}) = \frac{(q^2;q)_n (q;q)_n}{(q^3;q)_n (1;q)_n}$ for all $n$, which by analytic continuation implies the nonterminating q-Gauss formula.
- Code cell: Show a failed attempt -- an incorrect RHS. Change the rhs bases to something wrong and show `proved: False`. This demonstrates the algorithm correctly detects inconsistencies.

**7. Transformation Chain Discovery** (4 cells)
- Markdown: `find_transformation_chain` uses BFS over a catalog of known transformations (Heine 1/2/3, Sears, Watson) to connect two equivalent ${}_{2}\phi_{1}$ forms. This answers: "Are these two hypergeometric series related by a sequence of known transformations?"
- Code cell: `from q_kangaroo import QSession, find_transformation_chain` then search for a chain connecting two related series:
  ```
  s = QSession()
  result = find_transformation_chain(
      s,
      [(1,1,1), (1,1,2)], [(1,1,3)], 1, 1, 1,  # source: 2phi1(q, q^2; q^3; q, q)
      [(1,1,3), (1,1,1)], [(1,1,2)], 1, 1, 1,   # target: 2phi1(q^3, q; q^2; q, q)
      3, 20                                       # max_depth=3, order=20
  )
  ```
  Print `result["found"]` and if found, print each step's `name`.
- Markdown: If a chain is found, each step names a transformation (e.g., "heine1", "heine2") and provides the accumulated prefactor. This automates the process of navigating the web of hypergeometric transformation formulas.
- Code cell: Show a case where no chain exists within the search depth. Use two unrelated series.

**8. Summary: The Complete Pipeline** (2 cells)
- Markdown: Summarize the full pipeline in a table:

  | Step | Tool | Purpose |
  |------|------|---------|
  | 1 | `q_gosper` | Check for indefinite sum (antidifference) |
  | 2 | `q_zeilberger` | Find linear recurrence for definite sum |
  | 3 | `verify_wz` | Independently verify the WZ proof certificate |
  | 4 | `q_petkovsek` | Solve recurrence for closed-form product |
  | 5 | `prove_nonterminating` | Extend to nonterminating identities |
  | 6 | `find_transformation_chain` | Connect equivalent series via known transforms |

- Markdown: "Next steps" pointing to hypergeometric_summation.ipynb for classical summation formulas and maple_migration.ipynb for side-by-side Maple comparison.

**CRITICAL FORMAT NOTES:**
Same .ipynb JSON format as existing notebooks. All code cells need pre-computed outputs.

To compute outputs:
- Use the Rust test harness to get exact outputs for q-Zeilberger, verify_wz, q-Petkovsek, prove_nonterminating, and find_transformation_chain calls.
- The q-Vandermonde example at n=5, q=2 is well-tested (used in Phase 15 and 17 development).
- q-Gosper summable case: 2phi1(q^{-3}, q^2; q^3; q, q^4) at q=2 (from docstring examples).
- prove_nonterminating with the q-Gauss example (from docstring).
- For find_transformation_chain, the source/target pair may or may not have a chain -- verify with test harness.
  </action>
  <verify>
Read docs/examples/identity_proving.ipynb and verify:
1. Valid JSON structure with nbformat 4
2. Sections present: q-Gosper (summable + non-summable), q-Zeilberger (recurrence finding), WZ verification, q-Petkovsek (closed form), prove_nonterminating, find_transformation_chain
3. All code cells have pre-computed outputs
4. All imports use `from q_kangaroo import ...`
5. Total cell count is 28-34
6. The full pipeline is demonstrated end-to-end
  </verify>
  <done>
identity_proving.ipynb exists with ~28-34 cells demonstrating: q-Gosper (summable and non-summable), q-Zeilberger creative telescoping, WZ certificate verification, q-Petkovsek recurrence solving, prove_nonterminating for infinite series, and find_transformation_chain for connecting equivalent series, with all outputs pre-computed.
  </done>
</task>

</tasks>

<verification>
1. identity_proving.ipynb is valid JSON (.ipynb format)
2. All 6 v1.2 algorithmic functions demonstrated: q_gosper, q_zeilberger, verify_wz, q_petkovsek, prove_nonterminating, find_transformation_chain
3. Full pipeline shown end-to-end (series -> recurrence -> closed form)
4. All code cells have pre-computed outputs matching Rust engine
5. Mathematical context explains each step of the pipeline
</verification>

<success_criteria>
- identity_proving.ipynb covers DOC-11: q-Zeilberger recurrence, WZ certificate extraction and verification, q-Petkovsek closed forms, prove_nonterminating for infinite series, find_transformation_chain
- Notebook demonstrates the complete proving pipeline with concrete examples
- Both success cases and failure cases shown for each tool
</success_criteria>

<output>
After completion, create `.planning/phases/20-new-vignettes-migration/20-02-SUMMARY.md`
</output>
