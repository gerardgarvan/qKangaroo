---
phase: 20-new-vignettes-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/examples/maple_migration.ipynb
  - docs/examples/index.rst
autonomous: true
requirements: [DOC-12, DOC-13]

must_haves:
  truths:
    - "maple_migration.ipynb covers all 13 function groups with Maple -> Python mappings"
    - "maple_migration.ipynb shows at least 30 common operations with side-by-side code"
    - "maple_migration.ipynb covers Pochhammer, Named Products, Theta, Partitions, Utilities, Relation Discovery (exact + modular), Hypergeometric, Identity Proving, Mock Theta/Bailey, q-Gosper, Algorithmic Summation, and Extensions"
    - "index.rst lists all 9 notebooks with descriptions"
  artifacts:
    - path: "docs/examples/maple_migration.ipynb"
      provides: "Maple to q-Kangaroo migration guide"
      contains: "Maple"
    - path: "docs/examples/index.rst"
      provides: "Updated example gallery with all 9 notebooks"
      contains: "getting_started"
  key_links:
    - from: "docs/examples/maple_migration.ipynb"
      to: "q_kangaroo API"
      via: "imports covering all 13 function groups"
      pattern: "aqprod|etaq|theta|partition|prodmake|findlincombo|phi|prove|mock_theta|q_gosper|q_zeilberger|q_petkovsek|prove_nonterminating"
    - from: "docs/examples/index.rst"
      to: "docs/examples/*.ipynb"
      via: "toctree entries"
      pattern: "getting_started|series_analysis|identity_proving|maple_migration"
---

<objective>
Create the maple_migration.ipynb notebook (DOC-12, DOC-13) providing side-by-side Maple-to-Python translation for all 13 function groups with 30+ operations, and update index.rst to list all 9 notebooks.

Purpose: The primary value proposition of q-Kangaroo is replacing Garvan's Maple packages. Researchers switching from Maple need a concrete translation guide showing exactly how to convert their existing Maple code. This is the single most important documentation for adoption.

Output: maple_migration.ipynb (large notebook, ~50-60 cells) + updated index.rst.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/examples/index.rst
@crates/qsym-python/src/dsl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create maple_migration.ipynb -- side-by-side Maple->Python for all 13 groups</name>
  <files>docs/examples/maple_migration.ipynb</files>
  <action>
Create a new Jupyter notebook `docs/examples/maple_migration.ipynb` with approximately 50-60 cells providing a comprehensive migration guide from Garvan's Maple packages (`qseries`, `thetaids`, `ETA`) to q-Kangaroo. Use the same .ipynb JSON format as existing notebooks.

The notebook should use a consistent pattern for each group: a markdown cell with a comparison table showing Maple syntax vs Python syntax, followed by code cells demonstrating the Python equivalents.

**IMPORTANT: Use exact Python function names as exported by q_kangaroo.** Verified names from `__init__.py`:
- Modular relation: `findlincombomodp`, `findhommodp` (no underscores before "modp")
- Mock theta (third-order): `mock_theta_f3`, `mock_theta_phi3`, `mock_theta_psi3`, `mock_theta_chi3`, `mock_theta_omega3`, `mock_theta_nu3`, `mock_theta_rho3`
- Mock theta (fifth-order): `mock_theta_f0_5`, `mock_theta_f1_5`, `mock_theta_cap_f0_5`, `mock_theta_cap_f1_5`, `mock_theta_phi0_5`, `mock_theta_phi1_5`, `mock_theta_psi0_5`, `mock_theta_psi1_5`, `mock_theta_chi0_5`, `mock_theta_chi1_5`
- Mock theta (seventh-order): `mock_theta_cap_f0_7`, `mock_theta_cap_f1_7`, `mock_theta_cap_f2_7`
- Appell-Lerch: `appell_lerch_m`, `universal_mock_theta_g2`, `universal_mock_theta_g3`
- Bailey: `bailey_apply_lemma`, `bailey_chain`, `bailey_discover` (NOT `bailey_pair`)
- `batch_generate` is a method on `QSession`, called as `s.batch_generate(...)`, NOT a standalone function

**Notebook structure:**

**1. Title and Introduction** (3 cells)
- Markdown: "# Migrating from Maple to q-Kangaroo" -- this guide maps functions from Frank Garvan's Maple packages to their q-Kangaroo equivalents.
- Markdown: Quick setup: `pip install q-kangaroo` then `from q_kangaroo import *`. All q-Kangaroo functions take a `QSession` as the first argument.
- Code cell: `from q_kangaroo import *` then `s = QSession()`. Output: None (just setup).

**2. Group 1: Pochhammer and q-Binomial** (3 cells, 3 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `aqprod(a, q, n)` | `aqprod(s, num, den, pow, n, order)` | Monomial params: a = (num/den)*q^pow |
  | `aqprod(a, q, infinity)` | `aqprod(s, num, den, pow, None, order)` | n=None for infinite product |
  | `qbin(n, k, q)` | `qbin(s, n, k, order)` | q-binomial coefficient |
- Code cell: Demonstrate `aqprod(s, 1, 1, 0, 3, 10)` for $(1;q)_3$ and `aqprod(s, 1, 1, 1, None, 15)` for $(q;q)_\infty$. Show outputs.
- Code cell: `qbin(s, 5, 2, 15)` for $\binom{5}{2}_q$. Output: the q-binomial coefficient polynomial.

**3. Group 2: Named Products** (3 cells, 5 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `etaq(d, t, q, N)` | `etaq(s, d, t, order)` | $\prod_{n \ge 0}(1 - q^{dn+t})$ |
  | `jacprod(a, b, q, N)` | `jacprod(s, a, b, order)` | Jacobi triple product $J(a,b)$ |
  | `tripleprod(z, b, t, q, N)` | `tripleprod(s, z_num, z_den, z_pow, b, t, order)` | Triple product with $z$ parameter |
  | `quinprod(z, q, N)` | `quinprod(s, z_num, z_den, z_pow, order)` | Quintuple product |
  | `winquist(a, b, q, N)` | `winquist(s, a_num, a_den, a_pow, b_num, b_den, b_pow, order)` | Winquist's 10-factor product |
- Code cell: `etaq(s, 1, 1, 15)` and `jacprod(s, 1, 2, 20)`. Show outputs.
- Code cell: `tripleprod(s, -1, 1, 0, 2, 1, 20)` (theta3 via triple product). Show output.

**4. Group 3: Theta Functions** (3 cells, 3 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `theta2(q, N)` | `theta2(s, order)` | $\theta_2(q)$ in $q^{1/4}$ convention |
  | `theta3(q, N)` | `theta3(s, order)` | $\theta_3(q) = \sum_{n=-\infty}^{\infty} q^{n^2}$ |
  | `theta4(q, N)` | `theta4(s, order)` | $\theta_4(q) = \sum_{n=-\infty}^{\infty} (-1)^n q^{n^2}$ |
- Code cell: `theta2(s, 30)`, `theta3(s, 20)`, `theta4(s, 20)`. Show all three outputs.
- Markdown: Note that theta2 uses the $q^{1/4}$ convention where exponents in the output represent powers of $q^{1/4}$.

**5. Group 4: Partition Functions** (4 cells, 6 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `numbpart(n)` | `partition_count(n)` | Exact $p(n)$ |
  | `seq(numbpart(n), n=0..N)` | `partition_gf(s, order)` | Generating function |
  | `rankgf(z, q, N)` | `rank_gf(s, z_num, z_den, order)` | Dyson rank GF |
  | `crankgf(z, q, N)` | `crank_gf(s, z_num, z_den, order)` | Andrews-Garvan crank GF |
  | *no Maple equiv* | `distinct_parts_gf(s, order)` | $\prod(1+q^k)$ |
  | *no Maple equiv* | `odd_parts_gf(s, order)` | $\prod 1/(1-q^{2k+1})$ |
- Code cell: `partition_count(100)` and `partition_gf(s, 10)`. Show outputs. Note: `partition_count(100) = 190569292`.
- Code cell: `rank_gf(s, 1, 1, 15)` and `crank_gf(s, 1, 1, 15)`. Show both equal partition_gf.
- Code cell: `distinct_parts_gf(s, 15)` and `odd_parts_gf(s, 15)`. Show equal (Euler's theorem).

**6. Group 5: Utilities and Prodmake** (4 cells, 7 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `sift(f, m, j)` | `sift(series, m, j)` | Extract $a_{mn+j}$ subsequence |
  | `qfactor(f, q, N)` | `qfactor(series, max_factor)` | Factor into $(1-q^i)$ |
  | `prodmake(f, q, N)` | `prodmake(series, n)` | Andrews' product algorithm |
  | `etamake(f, q, N)` | `etamake(series, n)` | Eta-quotient representation |
  | `jacprodmake(f, q, N)` | `jacprodmake(series, n)` | Jacobi product representation |
  | `mprodmake(f, q, N)` | `mprodmake(series, n)` | Modified product $(1+q^n)$ |
  | *batch processing* | `s.batch_generate(func_name, params, order)` | Generate multiple series (QSession method) |
- Code cell: `sift(partition_gf(s, 50), 5, 4)` showing p(5n+4). Output: `5 + 30*q + 135*q^2 + ...`
- Code cell: `prodmake(partition_gf(s, 50), 10)` and `etamake(partition_gf(s, 50), 10)`. Show outputs.
- Code cell: `qfactor(aqprod(s, 1, 1, 0, 4, 20), 10)` -- factor $(1;q)_4$. Show factors dict.

**7. Group 6: Relation Discovery (Exact)** (4 cells, 6 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `findlincombo(series_list, q, N)` | `findlincombo(series_list, order)` | $\sum c_i f_i = 0$ |
  | `findhom(series_list, d, q, N)` | `findhom(series_list, degree, order)` | Homogeneous poly relations |
  | `findpoly(series_list, d, q, N)` | `findpoly(series_list, degree, order)` | General poly relations |
  | `findnonhom(series_list, d, q, N)` | `findnonhom(series_list, degree, order)` | Non-homogeneous relations |
  | `findprod(series, bases, q, N)` | `findprod(series, base_series, max_coeff)` | Product representation |
  | `findmaxind(series_list, q, N)` | `findmaxind(series_list, order)` | Maximal independent subset |
- Code cell: `findlincombo([odd_parts_gf(s, 30), distinct_parts_gf(s, 30)], 30)` -- discover Euler's theorem. Output: `[1, -1]` (or `[-1, 1]`).
- Code cell: `findmaxind([partition_gf(s, 30), odd_parts_gf(s, 30), distinct_parts_gf(s, 30)], 30)` -- find maximal independent subset. Output: indices of a maximal linearly independent subset (e.g., `[0, 1]` since odd_parts = distinct_parts).
- Markdown: Note: `findprod` searches for a product representation using brute-force enumeration and is computationally expensive for large bases.

**8. Group 7: Relation Discovery (Modular)** (3 cells, 3 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `findcong(f, moduli, q, N)` | `findcong(series, moduli)` | Discover $a_{mn+j} \equiv 0 \pmod{d}$ |
  | `findlincombo_modp(...)` | `findlincombomodp(series_list, prime, order)` | Linear relations mod p |
  | `findhom_modp(...)` | `findhommodp(series_list, degree, prime, order)` | Poly relations mod p |
- Code cell: `findcong(partition_gf(s, 100), [5, 7, 11])` -- Ramanujan congruences. Output: the three congruences.
- Code cell: `findlincombomodp([partition_gf(s, 50), odd_parts_gf(s, 50)], 5, 50)` -- search for a relation mod 5. Show result.

**9. Group 8: Hypergeometric Series** (4 cells, 6 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `qphihyper([a1,a2], [b1], q, z, N)` | `phi(s, [(n,d,p),...], [(n,d,p),...], z_n, z_d, z_p, order)` | ${}_{r}\phi_{s}$ |
  | `qpsihyper([a1], [b1], q, z, N)` | `psi(s, [(n,d,p),...], [(n,d,p),...], z_n, z_d, z_p, order)` | ${}_{r}\psi_{s}$ bilateral |
  | `qgauss(...)` | `try_summation(s, upper, lower, z_n, z_d, z_p)` | Try classical summation |
  | `heine1(...)` | `heine1(s, upper, lower, z_n, z_d, z_p, order)` | Heine transform I |
  | `heine2(...)` | `heine2(s, upper, lower, z_n, z_d, z_p, order)` | Heine transform II |
  | `heine3(...)` | `heine3(s, upper, lower, z_n, z_d, z_p, order)` | Heine transform III |
- Code cell: `phi(s, [(1,1,1), (1,1,2)], [(1,1,4)], 1, 1, 1, 15)` -- evaluate ${}_{2}\phi_{1}(q, q^2; q^4; q, q)$. Show output.
- Code cell: `try_summation(s, [(1,1,1), (1,1,2)], [(1,1,4)], 1, 1, 1)` -- try closed-form evaluation. Show result dict.
- Code cell: `heine1(s, [(1,1,1), (1,1,2)], [(1,1,4)], 1, 1, 1, 15)` -- Heine transform I. Show output (dict with prefactor and transformed series).

**10. Group 9: Identity Proving (Eta)** (2 cells, 2 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `proveid(lhs, rhs, level)` | `prove_eta_id(s, lhs_factors, rhs_factors, level)` | Valence formula proof |
  | `search_id(...)` | `search_identities(s, ...)` | Search identity database |
- Code cell: `prove_eta_id(s, [(1, 2), (2, -1)], [(1, 2), (2, -1)], 2)` -- prove self-equality. Output: `{"status": "proved", ...}`. Note: for genuine identities, supply different LHS and RHS eta-quotient factors.

**11. Group 10: Mock Theta, Appell-Lerch, and Bailey** (5 cells, 27 operations summary)
- Markdown: Table of mock theta functions (use exact Python names):
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | *third order* | `mock_theta_f3(s, N)`, `mock_theta_phi3(s, N)`, `mock_theta_psi3(s, N)`, `mock_theta_chi3(s, N)`, `mock_theta_omega3(s, N)`, `mock_theta_nu3(s, N)`, `mock_theta_rho3(s, N)` | 7 third-order |
  | *fifth order* | `mock_theta_f0_5(s, N)`, `mock_theta_phi0_5(s, N)`, `mock_theta_psi0_5(s, N)`, `mock_theta_chi0_5(s, N)`, `mock_theta_cap_f0_5(s, N)`, `mock_theta_f1_5(s, N)`, `mock_theta_phi1_5(s, N)`, `mock_theta_psi1_5(s, N)`, `mock_theta_chi1_5(s, N)`, `mock_theta_cap_f1_5(s, N)` | 10 fifth-order |
  | *seventh order* | `mock_theta_cap_f0_7(s, N)`, `mock_theta_cap_f1_7(s, N)`, `mock_theta_cap_f2_7(s, N)` | 3 seventh-order |
  | Appell-Lerch | `appell_lerch_m(s, a_pow, z_pow, order)`, `universal_mock_theta_g2(s, a_pow, order)`, `universal_mock_theta_g3(s, a_pow, order)` | Bilateral sum and Zwegers g-functions |
  | Bailey lemma | `bailey_apply_lemma(s, pair, a_num, a_den, a_pow, order)` | Apply Bailey's lemma |
  | Bailey chain | `bailey_chain(s, pair, a, depth, order)` | Iterate lemma |
  | Bailey discover | `bailey_discover(s, alpha_series, beta_series, order)` | Find pair match |
- Code cell: `mock_theta_f3(s, 20)` -- third-order mock theta $f(q)$. Output: `1 + q + q^2 + q^3 + 2*q^4 + ...`. Also `mock_theta_cap_f0_7(s, 15)` for seventh-order.
- Code cell: `appell_lerch_m(s, 1, 1, 20)` -- Appell-Lerch bilateral sum. Show output.
- Code cell: `bailey_chain(s, "rogers_ramanujan", 1, 1, 1, 1, 0, 2, 20)` -- one step of Bailey chain from R-R pair.
- Markdown: Note: The 20 classical mock theta functions are named by order and variant with `mock_theta_` prefix. Garvan's Maple packages do not include mock theta functions -- this is a q-Kangaroo extension.

**12. Group 11: q-Gosper Algorithm** (2 cells, 1 operation)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | *no direct equiv* | `q_gosper(upper, lower, z_n, z_d, z_p, q_n, q_d)` | Indefinite q-hypergeometric sum |
- Code cell: `q_gosper([(1,1,-3), (1,1,2)], [(1,1,3)], 1, 1, 4, 2, 1)` -- summable example. Output: `{"summable": True, "certificate": "..."}`.

**13. Group 12: Algorithmic Summation** (3 cells, 3 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | `qZeil(...)` | `q_zeilberger(upper, lower, z, n, q, max_order)` | Creative telescoping |
  | *WZ verify* | `verify_wz(upper, lower, z, n, q, max_order, max_k)` | Certificate verification |
  | `qPetkovsek(...)` | `q_petkovsek(coefficients, q_num, q_den)` | Solve recurrence |
- Code cell: Full pipeline: `q_zeilberger` then `q_petkovsek` on q-Vandermonde. Show recurrence and closed form.
- Code cell: `verify_wz` on same example showing verification passes.

**14. Group 13: Extensions** (3 cells, 2 operations)
- Markdown: Table:
  | Maple | q-Kangaroo | Notes |
  |-------|------------|-------|
  | *no equiv* | `prove_nonterminating(upper_fixed, n_offset, lower, z_offset, rhs_n, rhs_d, q, n_test, max)` | Chen-Hou-Mu proof |
  | *no equiv* | `find_transformation_chain(s, source, target, max_depth, order)` | BFS transformation search |
- Code cell: `prove_nonterminating([(1,1,1)], 2, [(1,1,3)], 2, [2,1], [3,0], 2, 1, 5, 3)` -- prove q-Gauss nonterminating. Output: `{"proved": True, ...}`.
- Code cell: `find_transformation_chain(s, ...)` with the Heine example from Group 8.

**15. Quick Reference Summary** (2 cells)
- Markdown: A condensed reference table listing ALL Maple -> Python mappings in one place (all 13 groups, all operations). This serves as a "cheat sheet" for researchers.
- Markdown: Common patterns: (1) All functions take `QSession` as first arg, (2) Monomials are `(num, den, power)` tuples, (3) `None` for infinity in Pochhammer, (4) Results are QSeries or dicts, (5) `batch_generate` is a QSession method (`s.batch_generate(...)`).

**CRITICAL FORMAT NOTES:**
Same .ipynb JSON format as existing notebooks. All code cells need pre-computed outputs.

**Operation count:** The notebook must demonstrate at least 30 distinct operations. Current count by group:
1. Pochhammer: 3 (aqprod finite, aqprod infinite, qbin)
2. Named Products: 5 (etaq, jacprod, tripleprod, quinprod, winquist)
3. Theta: 3 (theta2, theta3, theta4)
4. Partitions: 4 (partition_count, partition_gf, rank_gf, crank_gf)
5. Utilities: 5 (sift, qfactor, prodmake, etamake, mprodmake)
6. Relation exact: 2 (findlincombo, findmaxind)
7. Relation modular: 2 (findcong, findlincombomodp)
8. Hypergeometric: 3 (phi, try_summation, heine1)
9. Identity: 1 (prove_eta_id)
10. Mock/Bailey: 3 (mock_theta_f3, appell_lerch_m, bailey_chain)
11. q-Gosper: 1
12. Algorithmic: 2 (q_zeilberger, verify_wz)
13. Extensions: 2 (prove_nonterminating, find_transformation_chain)
Total: 36 operations -- exceeds the 30 minimum. (Note: reduced from prior draft which incorrectly listed prove_identity_qratio.)

To compute outputs, use Rust test harness for any values that cannot be derived from mathematical knowledge alone.
  </action>
  <verify>
Read docs/examples/maple_migration.ipynb and verify:
1. Valid JSON structure with nbformat 4
2. All 13 function groups have sections with comparison tables
3. At least 30 distinct operations demonstrated
4. All code cells have pre-computed outputs
5. All imports use `from q_kangaroo import ...`
6. Total cell count is 50-60
7. Maple syntax shown alongside Python equivalent in tables
8. Mock theta functions use `mock_theta_` prefix (e.g., `mock_theta_f3`, NOT `f3`)
9. Modular relations use `findlincombomodp` and `findhommodp` (no underscores before "modp")
10. Appell-Lerch uses `appell_lerch_m`, `universal_mock_theta_g2`, `universal_mock_theta_g3`
11. Bailey uses `bailey_apply_lemma`, `bailey_chain`, `bailey_discover` (NOT `bailey_pair`)
12. No reference to `prove_identity_qratio` (does not exist)
  </verify>
  <done>
maple_migration.ipynb exists with ~50-60 cells covering all 13 function groups with Maple -> Python translation tables, at least 30 operations demonstrated with pre-computed outputs, and the "no Maple equivalent" extensions (mock theta, q-Gosper, algorithmic proving) clearly marked. All Python function names match actual exports from q_kangaroo.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update docs/examples/index.rst with all 9 notebooks</name>
  <files>docs/examples/index.rst</files>
  <action>
Update `docs/examples/index.rst` to include all 9 notebooks (5 existing + 4 new). Organize with brief descriptions and audience tags.

The current index.rst has:
```
Example Gallery
===============

These notebooks demonstrate key features of q-Kangaroo with mathematical context.

.. toctree::
   :maxdepth: 1

   partition_congruences
   theta_identities
   hypergeometric_summation
   mock_theta_functions
   bailey_chains
```

Replace with:
```
Example Gallery
===============

Tutorials and guides demonstrating q-Kangaroo's features with mathematical context.

**New to q-series?** Start with :doc:`getting_started`.

**Switching from Maple?** See the :doc:`maple_migration` guide.

.. toctree::
   :maxdepth: 1
   :caption: Tutorials

   getting_started
   series_analysis
   identity_proving

.. toctree::
   :maxdepth: 1
   :caption: Topic Guides

   partition_congruences
   theta_identities
   hypergeometric_summation
   mock_theta_functions
   bailey_chains

.. toctree::
   :maxdepth: 1
   :caption: Reference

   maple_migration
```

This organizes notebooks into three categories:
1. Tutorials (workflow-oriented, for learning)
2. Topic Guides (deep dives into specific mathematical areas)
3. Reference (migration guide for switching from Maple)
  </action>
  <verify>
Read docs/examples/index.rst and verify:
1. All 9 notebooks listed: getting_started, series_analysis, identity_proving, partition_congruences, theta_identities, hypergeometric_summation, mock_theta_functions, bailey_chains, maple_migration
2. Organized into 3 toctree sections (Tutorials, Topic Guides, Reference)
3. Navigation hints for newcomers and Maple users
4. Valid RST syntax
  </verify>
  <done>
index.rst updated with all 9 notebooks organized into Tutorials, Topic Guides, and Reference sections, with audience-directed navigation hints.
  </done>
</task>

</tasks>

<verification>
1. maple_migration.ipynb is valid JSON with all 13 function groups
2. maple_migration.ipynb demonstrates at least 30 operations (target: 36)
3. Each function group has a Maple vs Python comparison table
4. index.rst lists all 9 notebooks in organized sections
5. All code cells have pre-computed outputs
6. Functions marked "no Maple equiv" for q-Kangaroo extensions (mock theta, q-Gosper, algorithmic proving, nonterminating proofs)
7. All Python function names match actual q_kangaroo exports (verified against __init__.py)
</verification>

<success_criteria>
- maple_migration.ipynb covers DOC-12: side-by-side Maple -> Python mapping with code comparison
- maple_migration.ipynb covers DOC-13: all 13 function groups with 30+ operations
- index.rst updated to list all 9 notebooks with organized navigation
- Migration guide clearly distinguishes Garvan-equivalent functions from q-Kangaroo extensions
- All function names are correct per q_kangaroo __init__.py exports
</success_criteria>

<output>
After completion, create `.planning/phases/20-new-vignettes-migration/20-03-SUMMARY.md`
</output>
