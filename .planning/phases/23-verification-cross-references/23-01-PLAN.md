---
phase: 23-verification-cross-references
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [check_install.py]
autonomous: true
requirements: [VRFY-01, VRFY-02]

must_haves:
  truths:
    - "Running python check_install.py prints pass/fail for Python version, import q_kangaroo, GMP loading, and basic computation"
    - "Running python check_install.py --dev additionally checks Rust, cargo, maturin, GMP headers, and C compiler availability"
    - "Exit code is 0 when all checks pass, non-zero when any check fails"
  artifacts:
    - path: "check_install.py"
      provides: "Installation verification script with end-user and --dev modes"
      min_lines: 80
  key_links:
    - from: "check_install.py"
      to: "q_kangaroo"
      via: "import and partition_count call"
      pattern: "from q_kangaroo import"
---

<objective>
Create check_install.py at the project root that verifies a q-Kangaroo installation is working correctly.

Purpose: Users and contributors can run a single script to confirm their setup is functional, rather than manually testing individual components.
Output: check_install.py with end-user checks (default) and developer checks (--dev flag).
</objective>

<context>
@.planning/ROADMAP.md
@INSTALL.md
@crates/qsym-python/python/q_kangaroo/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check_install.py with end-user verification checks</name>
  <files>check_install.py</files>
  <action>
Create check_install.py at the project root. The script uses only the Python standard library (no third-party imports). It uses argparse for the --dev flag.

Define a helper function that prints a colored pass/fail line for each check:
- PASS: green "[PASS]" prefix (using ANSI codes, with fallback for Windows terminals that don't support them)
- FAIL: red "[FAIL]" prefix with brief error description

End-user checks (always run, in this order):

1. **Python version**: Check sys.version_info >= (3, 9). Print the detected version. FAIL if too old.

2. **Import q_kangaroo**: Try `from q_kangaroo import partition_count, QSession, etaq`. PASS if import succeeds. FAIL with the ImportError message if it fails.

3. **GMP loading**: Try `QSession()` to trigger the native extension load (which requires GMP). PASS if no DLL/SO loading error. FAIL with the error message. This is separate from the import check because the import may succeed but the native extension may fail to load its GMP dependency.

4. **Basic computation**: Call `partition_count(50)` and assert the result equals 204226. PASS if correct. FAIL if wrong value or exception.

After all checks, print a summary line: "X/Y checks passed". Set exit code to 0 if all passed, 1 if any failed.
  </action>
  <verify>Run `python check_install.py` in the project venv. All 4 checks should print [PASS] and exit code should be 0.</verify>
  <done>check_install.py exists, runs without --dev, prints pass/fail for 4 checks (Python version, import, GMP loading, computation), exits 0 on success.</done>
</task>

<task type="auto">
  <name>Task 2: Add --dev flag with build-from-source prerequisite checks</name>
  <files>check_install.py</files>
  <action>
Extend check_install.py to accept a --dev flag via argparse. When --dev is passed, run the 4 end-user checks FIRST, then run these additional developer checks:

5. **Rust toolchain**: Run `rustc --version` via subprocess. PASS if exits 0 and output contains "rustc". FAIL if command not found or non-zero exit. Print the detected version string.

6. **Cargo**: Run `cargo --version` via subprocess. PASS if exits 0. FAIL if not found. Print version.

7. **Maturin**: Try `python -m maturin --version` via subprocess. PASS if exits 0. FAIL if not installed. Print version.

8. **GMP headers**: Check if the file `gmp.h` is findable. Strategy: check C_INCLUDE_PATH env var paths, then check common locations (/usr/include, /usr/local/include on Linux; C:/mingw64-gcc/mingw64/include on Windows). PASS if gmp.h found (print location). FAIL if not found.

9. **C compiler**: Run `gcc --version` via subprocess. PASS if exits 0. FAIL if not found. On Windows, also try `cc --version` as fallback.

Update the summary line to show total checks (9 with --dev, 4 without). Exit code remains 0 only if all relevant checks pass.

Add a brief usage docstring at the top of the file:
```
Usage:
    python check_install.py          # End-user checks
    python check_install.py --dev    # + build-from-source checks
```
  </action>
  <verify>Run `python check_install.py --dev` in the project environment (where Rust, cargo, maturin are available). Should print pass/fail for all 9 checks. Also run without --dev to confirm it still shows only 4 checks.</verify>
  <done>check_install.py --dev prints pass/fail for 9 checks (4 end-user + 5 developer). Without --dev, only 4 checks. Exit code reflects pass/fail status.</done>
</task>

</tasks>

<verification>
- `python check_install.py` exits 0 with 4 [PASS] lines in a working environment
- `python check_install.py --dev` exits 0 with 9 [PASS] lines when all dev tools are installed
- `python check_install.py` from a fresh Python (no q_kangaroo) exits 1 with [FAIL] on import check
- Script uses only standard library (no pip install required to run it)
</verification>

<success_criteria>
check_install.py exists at project root. Running it without flags verifies end-user installation (4 checks). Running with --dev adds 5 build prerequisite checks (9 total). Clear pass/fail output with informative error messages. Exit code 0 on all-pass, 1 on any failure.
</success_criteria>

<output>
After completion, create `.planning/phases/23-verification-cross-references/23-01-SUMMARY.md`
</output>
