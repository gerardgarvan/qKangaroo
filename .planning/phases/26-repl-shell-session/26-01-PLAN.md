---
phase: 26-repl-shell-session
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/Cargo.toml
  - crates/qsym-cli/src/main.rs
  - crates/qsym-cli/src/lib.rs
  - crates/qsym-cli/src/environment.rs
  - crates/qsym-cli/src/commands.rs
autonomous: true
requirements: [REPL-01, REPL-04, SESS-02, SESS-03]

must_haves:
  truths:
    - "User launches the binary and sees an ASCII kangaroo banner with version and hint"
    - "User types expressions and sees output; up/down arrows recall previous commands"
    - "History persists in .q_kangaroo_history next to the executable after restart"
    - "Malformed expressions print descriptive parse errors without crashing the session"
    - "Caught panics from qsym-core print descriptive messages without crashing"
    - "set precision 50 changes default truncation order for subsequent computations"
    - "clear resets all variables, last result, and precision back to 20"
    - "quit, exit, and Ctrl-D all exit cleanly; Ctrl-C cancels current line"
  artifacts:
    - path: "crates/qsym-cli/Cargo.toml"
      provides: "rustyline dependency"
      contains: "rustyline"
    - path: "crates/qsym-cli/src/commands.rs"
      provides: "Command enum, parse_command, execute_command"
      exports: ["Command", "CommandResult", "parse_command", "execute_command"]
    - path: "crates/qsym-cli/src/main.rs"
      provides: "REPL loop with rustyline Editor, history, error handling"
      min_lines: 80
    - path: "crates/qsym-cli/src/environment.rs"
      provides: "reset() method for clear command"
      contains: "fn reset"
  key_links:
    - from: "crates/qsym-cli/src/main.rs"
      to: "rustyline::Editor"
      via: "readline loop"
      pattern: "rl\\.readline"
    - from: "crates/qsym-cli/src/main.rs"
      to: "crates/qsym-cli/src/commands.rs"
      via: "command dispatch before parser"
      pattern: "parse_command"
    - from: "crates/qsym-cli/src/commands.rs"
      to: "crates/qsym-cli/src/environment.rs"
      via: "clear resets env, set precision modifies default_order"
      pattern: "env\\.reset\\(\\)|env\\.default_order"
---

<objective>
Wire up the interactive REPL loop with rustyline for line editing, persistent history, session commands (set precision, clear, quit/exit), multi-line paren-counting, and robust error recovery. This plan creates the core interactive experience -- the user can launch the binary, type expressions, get results, manage session state, and exit cleanly.

Purpose: Transform the placeholder main.rs into a fully interactive terminal session that a researcher can use productively. This is the foundation that Plan 02 layers tab completion and help onto.

Output: Working REPL binary with line editing, history persistence, session commands, and error resilience.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-repl-shell-session/26-CONTEXT.md
@.planning/phases/26-repl-shell-session/26-RESEARCH.md
@crates/qsym-cli/src/main.rs
@crates/qsym-cli/src/lib.rs
@crates/qsym-cli/src/environment.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-cli/src/error.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rustyline dependency, commands module, and Environment.reset()</name>
  <files>
    crates/qsym-cli/Cargo.toml
    crates/qsym-cli/src/lib.rs
    crates/qsym-cli/src/environment.rs
    crates/qsym-cli/src/commands.rs
  </files>
  <action>
**Cargo.toml:** Add rustyline dependency:
```toml
rustyline = { version = "17.0", features = ["derive"] }
```

**lib.rs:** Add `pub mod commands;` to the module list.

**environment.rs:** Add a `reset()` method to `Environment`:
```rust
/// Reset the environment to its initial state.
/// Clears all variables, resets last_result to None, and restores default_order to 20.
/// Does NOT reset the symbol registry (sym_q must remain valid).
pub fn reset(&mut self) {
    self.variables.clear();
    self.last_result = None;
    self.default_order = 20;
}
```
Add tests for `reset()`: verify variables cleared, last_result is None, default_order is 20, sym_q still valid.

**commands.rs:** Create a new module with:

1. `Command` enum with variants: `Help(Option<String>)`, `SetPrecision(i64)`, `Clear`, `Quit`.

2. `CommandResult` enum with variants: `Continue`, `Quit`, `Output(String)`.

3. `parse_command(line: &str) -> Option<Command>` function:
   - Split on whitespace. Match first word (case-insensitive).
   - `"quit"` | `"exit"` => `Command::Quit`
   - `"clear"` => `Command::Clear` (only if the line is exactly "clear" -- no `:=` or `(` in line)
   - `"help"` => `Command::Help(optional second word)` (only bare "help" or "help topic" pattern -- if line contains `:=` or `(` after "help", pass to parser)
   - `"set"` with second word `"precision"` and third word parseable as i64 => `Command::SetPrecision(n)`
   - Invalid `set precision` (no number or non-integer) => return `Some(Command::SetPrecision(-1))` so execute_command can print a helpful error. Actually, better: return None for truly unrecognizable patterns (pass to parser), but for `set precision foo` where the intent is clear, print an error message. Implement this as: if starts with "set" and second word is "precision", return a specific error variant or handle it directly. Simplest: add a `CommandError(String)` variant to CommandResult, or just have parse_command return `Some(Command::SetPrecision(-1))` and have execute_command check for invalid values.
   - Anything else => `None` (pass to expression parser).
   - **Important anti-pattern avoidance:** Only intercept bare command patterns. If the line contains `:=` anywhere, return None (user is assigning, e.g., `help := 42`). If the line contains `(` and the first word matches a function name, return None (user is calling it as a function).

4. `execute_command(cmd: Command, env: &mut Environment) -> CommandResult` function:
   - `Quit` => return `CommandResult::Quit`
   - `Clear` => call `env.reset()`, return `CommandResult::Output("Session cleared.".to_string())`
   - `SetPrecision(n)` if n > 0 => set `env.default_order = n`, return `CommandResult::Output(format!("Truncation order set to {}.", n))`
   - `SetPrecision(n)` if n <= 0 => return `CommandResult::Output("Error: precision must be a positive integer. Usage: set precision N".to_string())`
   - `Help(_)` => for now return `CommandResult::Output("Help system not yet available.".to_string())` (Plan 02 wires up the real help)

Add comprehensive tests in commands.rs:
- parse_command("quit") => Some(Command::Quit)
- parse_command("exit") => Some(Command::Quit)
- parse_command("QUIT") => Some(Command::Quit) (case insensitive)
- parse_command("clear") => Some(Command::Clear)
- parse_command("clear := 5") => None (assignment, not command)
- parse_command("help") => Some(Command::Help(None))
- parse_command("help aqprod") => Some(Command::Help(Some("aqprod")))
- parse_command("help := 42") => None (assignment)
- parse_command("set precision 50") => Some(Command::SetPrecision(50))
- parse_command("set precision foo") => appropriate error
- parse_command("aqprod(q,q,5,20)") => None
- parse_command("f := 42") => None
- execute_command Clear resets environment
- execute_command SetPrecision changes env.default_order
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- commands && cargo test -p qsym-cli -- environment::tests::reset`

All new tests pass. Existing tests still pass.
  </verify>
  <done>
commands.rs module exists with Command/CommandResult enums, parse_command correctly distinguishes commands from expressions, execute_command handles clear/set precision/quit. Environment.reset() clears state. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: REPL loop with rustyline, history, banner, multi-line, and error recovery</name>
  <files>
    crates/qsym-cli/src/main.rs
  </files>
  <action>
Replace the placeholder main.rs with a complete REPL implementation.

**1. Welcome banner function (`print_banner`):**
Print an ASCII kangaroo art (compact, 6-8 lines), the version from `env!("CARGO_PKG_VERSION")`, and the hint line. Per user decision: include ASCII art kangaroo, version number, and "Type 'help' for commands, 'quit' to exit". Example kangaroo (adjust as needed for aesthetics):
```
    __
   /  \    q-Kangaroo v0.1.0
  | q> |   Symbolic q-series computation
  |    |
  /|  |\   Type 'help' for commands, 'quit' to exit
 (_|  |_)
```
Keep it compact (no more than ~8 lines total). The exact ASCII art is discretionary but must clearly be a kangaroo.

**2. History file path function (`history_file_path`):**
```rust
fn history_file_path() -> std::path::PathBuf {
    std::env::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|d| d.to_path_buf()))
        .unwrap_or_else(|| std::path::PathBuf::from("."))
        .join(".q_kangaroo_history")
}
```

**3. ReplHelper struct (minimal for now -- Plan 02 adds Completer):**
Create a minimal struct that implements the rustyline Helper traits. For now it only needs Validator for multi-line support. Use derive macros for Highlighter, Hinter, Completer (default no-ops). Implement Validator manually with paren/bracket counting:
- Count unmatched `(` and `[` in input
- If depth > 0, return `ValidationResult::Incomplete`
- Otherwise return `ValidationResult::Valid(None)`

The continuation prompt should be `.. ` (the Editor config supports `set_secondary_prompt` or similar -- check rustyline 17 API; if not directly available, the Validator returning Incomplete triggers rustyline's continuation behavior with the default continuation prompt).

**4. Main function:**
```rust
fn main() {
    print_banner();

    let config = Config::builder()
        .completion_type(CompletionType::Circular)  // zsh-style Tab cycling
        .edit_mode(EditMode::Emacs)
        .auto_add_history(true)
        .max_history_size(10_000)
        .expect("valid max_history_size")
        .build();

    let helper = ReplHelper::new();
    let mut rl: Editor<ReplHelper, DefaultHistory> = Editor::with_config(config)
        .expect("failed to create editor");
    rl.set_helper(Some(helper));

    let history_path = history_file_path();
    let _ = rl.load_history(&history_path);

    let mut env = Environment::new();

    loop {
        match rl.readline("q> ") {
            Ok(line) => {
                let trimmed = line.trim();
                if trimmed.is_empty() {
                    continue;
                }

                // Command dispatch (before parser)
                if let Some(cmd) = parse_command(trimmed) {
                    match execute_command(cmd, &mut env) {
                        CommandResult::Continue => continue,
                        CommandResult::Quit => break,
                        CommandResult::Output(text) => {
                            println!("{}", text);
                            continue;
                        }
                    }
                }

                // Parse and evaluate
                match qsym_cli::parser::parse(trimmed) {
                    Ok(stmts) => {
                        for stmt in &stmts {
                            match qsym_cli::eval::eval_stmt_safe(stmt, &mut env) {
                                Ok(Some(val)) => {
                                    println!("{}", qsym_cli::format::format_value(&val));
                                }
                                Ok(None) => {} // semicolon-suppressed
                                Err(e) => eprintln!("{}", e),
                            }
                        }
                    }
                    Err(e) => eprintln!("{}", e.render(trimmed)),
                }

                // After eval: update variable names in helper for completion (Plan 02 will use this)
            }
            Err(ReadlineError::Interrupted) => {
                // Ctrl-C: cancel current line, print hint
                continue;
            }
            Err(ReadlineError::Eof) => {
                // Ctrl-D: exit per user decision
                break;
            }
            Err(err) => {
                eprintln!("Error: {:?}", err);
                break;
            }
        }
    }

    // Save history on exit
    let _ = rl.save_history(&history_path);
}
```

**Important implementation details:**
- Use `use qsym_cli::commands::{parse_command, execute_command, CommandResult};`
- Use `use qsym_cli::environment::Environment;`
- Import rustyline types: `Config`, `CompletionType`, `EditMode`, `Editor`, `DefaultHistory`, `ReadlineError`
- The ReplHelper struct lives in main.rs for now (Plan 02 moves it to repl.rs with full Completer)
- For the multi-line Validator: use `use rustyline::validate::{ValidationResult, Validator, ValidationContext};`
- For derive macros: `use rustyline::{Completer, Helper, Highlighter, Hinter};` from rustyline_derive (the `derive` feature of rustyline re-exports these)

**5. Ensure robust error handling:**
- Parse errors: rendered with caret via `e.render(trimmed)`, printed to stderr
- Eval errors: printed via Display impl to stderr
- Panics: caught by eval_stmt_safe, printed as "Error: computation failed: ..."
- None of these crash the REPL -- the loop continues

**Note on multi-line with the Validator:** When paren-counting returns Incomplete, rustyline automatically prompts for continuation. When the user finishes the expression and parens balance, the full multi-line input is returned as a single string from readline(). The parser handles this correctly since it already processes whitespace/newlines.
  </action>
  <verify>
Run:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo build -p qsym-cli
```

Build succeeds with no errors. Then verify existing tests still pass:
```bash
cargo test -p qsym-cli
```

All tests pass (existing + new). The binary should be buildable. Manual verification of the REPL is not required (that is Phase 26 checkpoint territory), but the build must succeed.
  </verify>
  <done>
main.rs contains a complete rustyline REPL loop with: ASCII kangaroo banner + version + hint, `q> ` prompt, readline loop dispatching commands before parser, paren-counting multi-line Validator, history file next to executable (load on start, save on exit), Ctrl-C continues / Ctrl-D exits, parse errors render with caret, eval errors display descriptively, panics caught without crash. cargo build -p qsym-cli succeeds. All cargo test -p qsym-cli pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-cli` succeeds with no warnings related to new code
2. `cargo test -p qsym-cli` -- all existing tests pass plus new tests for commands.rs and environment reset
3. The built binary (`target/debug/q-kangaroo.exe`) exists
4. Code inspection confirms: banner with kangaroo art, `q> ` prompt, history path alongside exe, paren-counting Validator, command dispatch before parser, error recovery without crash
</verification>

<success_criteria>
- rustyline 17.0 is in Cargo.toml with derive feature
- commands.rs exists with Command/CommandResult/parse_command/execute_command
- environment.rs has reset() method
- main.rs has full REPL loop with banner, history, multi-line, error handling
- All existing and new tests pass
- Binary builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/26-repl-shell-session/26-01-SUMMARY.md`
</output>
