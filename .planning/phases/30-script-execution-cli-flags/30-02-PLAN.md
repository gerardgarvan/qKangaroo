---
phase: 30-script-execution-cli-flags
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - crates/qsym-cli/src/main.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/commands.rs
autonomous: true
requirements: [CLI-01, CLI-02, CLI-03, CLI-04, CLI-05, CLI-06, EXEC-01, EXEC-04, EXEC-05, EXEC-06]

must_haves:
  truths:
    - "q-kangaroo --help prints usage summary listing all flags and exits with code 0"
    - "q-kangaroo -q suppresses the banner in interactive mode"
    - "q-kangaroo -c 'expr' evaluates the expression, prints the result, and exits"
    - "q-kangaroo -v shows per-statement timing on stderr"
    - "q-kangaroo -- -file.qk treats -file.qk as a filename, not a flag"
    - "q-kangaroo --badopt prints error with --help suggestion and exits with code 2"
    - "q-kangaroo script.qk executes the file and exits"
    - "echo '1+1' piped to q-kangaroo prints result with no banner or prompt"
    - "q-kangaroo -c and script mode suppress banner and prompt"
    - "read('file.qk') in the REPL executes the file in the current session"
  artifacts:
    - path: "crates/qsym-cli/src/main.rs"
      provides: "CliMode enum, parse_args(), mode dispatch, print_usage()"
      contains: "CliMode"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "read() function dispatch"
      contains: "\"read\""
    - path: "crates/qsym-cli/src/commands.rs"
      provides: "read session command parsing and execution"
      contains: "Command::Read"
  key_links:
    - from: "crates/qsym-cli/src/main.rs"
      to: "crates/qsym-cli/src/script.rs"
      via: "execute_source() and execute_file() calls in mode runners"
      pattern: "script::execute"
    - from: "crates/qsym-cli/src/main.rs"
      to: "std::io::IsTerminal"
      via: "TTY detection for piped mode"
      pattern: "is_terminal"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/script.rs"
      via: "read() function calls execute_file()"
      pattern: "script::execute_file"
    - from: "crates/qsym-cli/src/commands.rs"
      to: "crates/qsym-cli/src/script.rs"
      via: "read command calls execute_file()"
      pattern: "script::execute_file"
---

<objective>
Refactor main.rs with argument parsing and mode dispatch; add read() function and command.

Purpose: This plan wires together the script execution engine (from Plan 01) with all the CLI entry points: --help, -q, -c, -v, --, unknown flag errors, script file execution, piped stdin, and the read() function/command for loading scripts within the REPL. After this plan, all 12 requirements are functionally complete.

Output: Fully refactored main.rs with CliMode enum, parse_args(), print_usage(), and mode runners. read() function in eval dispatch. read session command in commands.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-script-execution-cli-flags/30-RESEARCH.md
@.planning/phases/30-script-execution-cli-flags/30-01-SUMMARY.md
@crates/qsym-cli/src/main.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/commands.rs
@crates/qsym-cli/src/script.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor main.rs with argument parsing and all CLI modes</name>
  <files>
    crates/qsym-cli/src/main.rs
  </files>
  <action>
Completely rewrite `main.rs`. The new structure:

**1. Imports:** Add `use std::process::ExitCode;` and `use std::io::{self, BufRead, IsTerminal};`. Keep existing rustyline imports. Add `use qsym_cli::script::{self, ScriptResult};`.

**2. CliMode enum** (before main):
```rust
/// Parsed CLI mode of operation.
enum CliMode {
    Interactive { quiet: bool, verbose: bool },
    Script { path: String, verbose: bool },
    Expression { expr: String, verbose: bool },
    Piped { verbose: bool },
    Help,
    Version,
}
```

**3. parse_args() function** implementing the exact state machine from the research (Pattern 1):
- Iterate `std::env::args().skip(1)` collected into Vec
- `--help`/`-h` -> `CliMode::Help`
- `--version`/`-V` -> `CliMode::Version`
- `--quiet`/`-q` -> set quiet flag
- `--verbose`/`-v` -> set verbose flag
- `-c` -> consume next arg as expression (error if missing: `"option '-c' requires an argument"`)
- `--` -> set dashdash flag, next arg is filename
- Unknown flag (starts with `-`) -> `Err(format!("unknown option '{}'\nTry 'q-kangaroo --help' for more information.", arg))`
- Non-flag arg -> filename, break
- After loop: if expr set -> Expression, if file set -> Script, else check stdin.is_terminal() -> Interactive or Piped

**4. print_usage() function** -- exact text from research Pattern 6 (Help Text Format section).

**5. main() -> ExitCode** -- dispatch on parse_args():
```rust
fn main() -> ExitCode {
    match parse_args() {
        Err(msg) => {
            eprintln!("q-kangaroo: {}", msg);
            ExitCode::from(script::EXIT_USAGE)
        }
        Ok(CliMode::Help) => {
            print_usage();
            ExitCode::SUCCESS
        }
        Ok(CliMode::Version) => {
            println!("q-kangaroo {}", env!("CARGO_PKG_VERSION"));
            ExitCode::SUCCESS
        }
        Ok(CliMode::Expression { expr, verbose }) => {
            run_expression(&expr, verbose)
        }
        Ok(CliMode::Script { path, verbose }) => {
            run_script(&path, verbose)
        }
        Ok(CliMode::Piped { verbose }) => {
            run_piped(verbose)
        }
        Ok(CliMode::Interactive { quiet, verbose }) => {
            run_interactive(quiet, verbose);
            ExitCode::SUCCESS
        }
    }
}
```

**6. run_expression():**
```rust
fn run_expression(expr: &str, verbose: bool) -> ExitCode {
    let mut env = Environment::new();
    let result = script::execute_source(expr, &mut env, verbose);
    if let Some(msg) = result.error_message() {
        eprintln!("{}", msg);
    }
    ExitCode::from(result.exit_code())
}
```

**7. run_script():**
```rust
fn run_script(path: &str, verbose: bool) -> ExitCode {
    let mut env = Environment::new();
    let result = script::execute_file(path, &mut env, verbose);
    if let Some(msg) = result.error_message() {
        eprintln!("{}", msg);
    }
    ExitCode::from(result.exit_code())
}
```

**8. run_piped():**
```rust
fn run_piped(verbose: bool) -> ExitCode {
    let stdin = io::stdin();
    let source: String = stdin.lock().lines()
        .map(|l| l.unwrap_or_default())
        .collect::<Vec<_>>()
        .join("\n");

    let mut env = Environment::new();
    let result = script::execute_source(&source, &mut env, verbose);
    if let Some(msg) = result.error_message() {
        eprintln!("{}", msg);
    }
    ExitCode::from(result.exit_code())
}
```

**9. run_interactive(quiet, verbose):** Refactor the existing REPL loop into this function. Key changes:
- Accept `quiet: bool` parameter; only call `print_banner()` if `!quiet`
- Accept `verbose: bool` parameter; wrap each eval in timing if verbose (same pattern as script.rs but printing to stderr)
- The rest of the REPL loop (rustyline setup, history, command dispatch, parse/eval, var completer update) stays the same
- Keep `print_banner()` and `history_file_path()` as module-level functions

**IMPORTANT for run_interactive verbose:** In the existing eval loop inside run_interactive, if verbose is true, wrap the eval_stmt_safe call:
```rust
let start = if verbose { Some(std::time::Instant::now()) } else { None };
match qsym_cli::eval::eval_stmt_safe(stmt, &mut env) {
    Ok(Some(val)) => {
        println!("{}", qsym_cli::format::format_value(&val));
        if let Some(t) = start {
            eprintln!("  [{:.3}s]", t.elapsed().as_secs_f64());
        }
    }
    Ok(None) => {
        if let Some(t) = start {
            eprintln!("  [{:.3}s]", t.elapsed().as_secs_f64());
        }
    }
    Err(e) => eprintln!("{}", e),
}
```

The `run_interactive` function should also handle `Command::Read` from the command dispatch (see Task 2 which adds this to commands.rs). When a `CommandResult::ReadFile(path)` is returned, call `script::execute_file(&path, &mut env, verbose)` and print any error.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build -p qsym-cli 2>&1 | tail -5`

Binary builds without errors. Then manually test:
- `./target/debug/q-kangaroo --version` prints version
- `./target/debug/q-kangaroo --help` prints usage
- `./target/debug/q-kangaroo -c "1 + 1"` prints `2`
- `./target/debug/q-kangaroo --unknown` prints error with exit code 2
  </verify>
  <done>
main.rs is fully refactored with CliMode enum, parse_args() handling all 6 flags (--help, --version, -q, -v, -c, --), unknown flag errors with --help suggestion, and mode dispatch to run_expression, run_script, run_piped, and run_interactive. main() returns ExitCode. Banner is suppressed in all non-interactive modes and when -q is passed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add read() function dispatch and read session command</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/commands.rs
    crates/qsym-cli/src/main.rs
  </files>
  <action>
**eval.rs:** In the `dispatch()` function, add a new match arm for `"read"` BEFORE the catch-all unknown function error at the bottom of the match. Place it in a logical position (e.g., after the last function group, before the catch-all):

```rust
// =================================================================
// Script loading (EXEC-06)
// =================================================================

"read" => {
    expect_args(name, args, 1)?;
    match &args[0] {
        Value::String(path) => {
            match crate::script::execute_file(path, env, false) {
                crate::script::ScriptResult::Success => Ok(Value::None),
                crate::script::ScriptResult::ParseError(msg) => {
                    Err(EvalError::Panic(msg))
                }
                crate::script::ScriptResult::EvalError(msg) => {
                    Err(EvalError::Panic(msg))
                }
                crate::script::ScriptResult::Panic(msg) => {
                    Err(EvalError::Panic(msg))
                }
            }
        }
        _ => Err(EvalError::ArgType {
            function: name.to_string(),
            arg_index: 0,
            expected: "string",
            got: args[0].type_name().to_string(),
        }),
    }
}
```

Also add `"read"` to the `get_signature()` function:
```rust
"read" => "read(filename)".to_string(),
```

And add `"read"` to the `FUNCTION_NAMES` array (used for tab completion and fuzzy matching) -- find the array and add `"read"` in alphabetical order.

**commands.rs:** Two changes:

1. Add `Read(String)` variant to the `Command` enum:
```rust
/// Load and execute a script file.
Read(String),
```

2. In `parse_command()`, add a `"read"` arm in the match after `"save"`:
```rust
"read" => {
    // read("file") is a function call, pass to parser
    if trimmed.contains('(') {
        return None;
    }
    if words.len() == 2 {
        Some(Command::Read(words[1].to_string()))
    } else if words.len() == 1 {
        Some(Command::Read(String::new()))
    } else {
        None
    }
}
```

3. In `execute_command()`, add handling for `Command::Read`:
```rust
Command::Read(path) => {
    if path.is_empty() {
        return CommandResult::Output("Usage: read filename.qk".to_string());
    }
    CommandResult::ReadFile(path)
}
```

4. Add `ReadFile(String)` variant to `CommandResult`:
```rust
/// Load and execute a script file (handled by main loop).
ReadFile(String),
```

**main.rs:** In `run_interactive()`, add handling for `CommandResult::ReadFile` in the command dispatch:
```rust
CommandResult::ReadFile(path) => {
    let result = script::execute_file(&path, &mut env, verbose);
    if let Some(msg) = result.error_message() {
        eprintln!("{}", msg);
    }
    // Update var names after script execution (script may define vars)
    let var_names: Vec<String> = env.variables.keys().cloned().collect();
    if let Some(helper) = rl.helper_mut() {
        helper.update_var_names(var_names);
    }
    continue;
}
```

Add tests to commands.rs:
```rust
#[test]
fn parse_read_command() {
    assert_eq!(
        parse_command("read file.qk"),
        Some(Command::Read("file.qk".into()))
    );
}

#[test]
fn parse_read_no_file() {
    assert_eq!(parse_command("read"), Some(Command::Read("".into())));
}

#[test]
fn parse_read_function_passthrough() {
    // read("file.qk") should go to parser, not command
    assert_eq!(parse_command(r#"read("file.qk")"#), None);
}

#[test]
fn execute_read_no_path() {
    let mut env = Environment::new();
    let result = execute_command(Command::Read("".into()), &mut env);
    assert!(matches!(result, CommandResult::Output(ref s) if s.contains("Usage")));
}
```
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib 2>&1 | tail -5 && cargo build -p qsym-cli 2>&1 | tail -3`

All tests pass. Binary builds. Then:
- Create a test script: `echo 'x := 42; x' > /tmp/test.qk`
- `./target/debug/q-kangaroo /tmp/test.qk` prints `42`
- `echo "1 + 1" | ./target/debug/q-kangaroo` prints `2` (no banner)
- `./target/debug/q-kangaroo -c "etaq(1,1,10)"` prints the series and exits
  </verify>
  <done>
read() function works both as `read("file.qk")` function call (via eval dispatch) and as `read file.qk` session command (via commands.rs). CommandResult::ReadFile signals main.rs to execute the file in the current environment. Variables defined in the read file persist in the REPL session. All CLI modes work: --help, --version, -q, -v, -c, --, script file, piped stdin, interactive. All 12 requirements are functionally implemented.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli --lib` -- all tests pass
2. `cargo build -p qsym-cli` -- binary builds without warnings
3. `q-kangaroo --help` prints usage with all flags documented
4. `q-kangaroo -c "1 + 1"` outputs `2` and exits
5. `q-kangaroo script.qk` executes script with comments and multi-line statements
6. `echo "1 + 1" | q-kangaroo` outputs `2` with no banner
7. `q-kangaroo --badopt` exits with code 2 and prints --help suggestion
8. `q-kangaroo -q` starts REPL without banner
</verification>

<success_criteria>
- main.rs uses ExitCode, CliMode enum, parse_args() for all flag handling
- All 6 flags work: --help, --version, -q, -v, -c, --
- Unknown flags error with exit code 2 and --help suggestion
- Script file execution reads, parses, evaluates, exits
- Piped stdin detected via IsTerminal, evaluated without banner/prompt
- read() works as function call and session command
- Verbose mode shows per-statement timing on stderr
</success_criteria>

<output>
After completion, create `.planning/phases/30-script-execution-cli-flags/30-02-SUMMARY.md`
</output>
