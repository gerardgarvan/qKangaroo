---
phase: 31-error-hardening-exit-codes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/script.rs
  - crates/qsym-cli/src/error.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/main.rs
autonomous: true
requirements: [EXIT-05, EXIT-07, ERR-01, ERR-02, ERR-03, ERR-04, ERR-05]

must_haves:
  truths:
    - "q-kangaroo nonexistent.qk prints 'file not found' with OS error and exits 66"
    - "q-kangaroo script.qk with syntax error on line 5 shows 'script.qk:5:col' in error"
    - "A qsym-core panic like 'Cannot invert series with zero constant term' is translated to a human-friendly message"
    - "I/O errors (permission denied, etc.) exit with code 74 and show the OS error message"
    - "In scripts, the first error stops execution; in REPL, errors print but the session continues"
    - "read() errors in REPL print a message but the session continues"
  artifacts:
    - path: "crates/qsym-cli/src/script.rs"
      provides: "FileNotFound and IoError ScriptResult variants, EXIT_IO_ERROR constant, execute_source_with_context, execute_file with ErrorKind dispatch"
      contains: "ScriptResult::FileNotFound"
    - path: "crates/qsym-cli/src/error.rs"
      provides: "render_for_file() multiline-aware error rendering, byte_offset_to_line_col helper"
      contains: "render_for_file"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "translate_panic_message() helper applied in eval_stmt_safe, read() uses EvalError::Other not Panic for file errors"
      contains: "translate_panic_message"
    - path: "crates/qsym-cli/src/main.rs"
      provides: "REPL handles --help/-h/--version at prompt, run_script passes filename context"
      contains: "--help"
  key_links:
    - from: "crates/qsym-cli/src/script.rs"
      to: "std::io::ErrorKind"
      via: "match on ErrorKind::NotFound vs other in execute_file"
      pattern: "ErrorKind::NotFound"
    - from: "crates/qsym-cli/src/script.rs"
      to: "crates/qsym-cli/src/error.rs"
      via: "execute_source_with_context calls render_for_file for parse errors"
      pattern: "render_for_file"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "translate_panic_message"
      via: "eval_stmt_safe passes panic message through translation before wrapping in EvalError::Panic"
      pattern: "translate_panic_message"
---

<objective>
Implement all error hardening infrastructure for the q-Kangaroo CLI: distinct exit codes for file-not-found (66) and I/O errors (74), filename:line:col context in script error messages, panic message translation to human-friendly text, and REPL graceful handling of --help/--version at the prompt.

Purpose: Users get clear, actionable error messages instead of cryptic internal messages, and scripts/tools can rely on distinct exit codes for every failure mode.
Output: Updated script.rs, error.rs, eval.rs, main.rs with full error hardening.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-error-hardening-exit-codes/31-RESEARCH.md
@crates/qsym-cli/src/script.rs
@crates/qsym-cli/src/error.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/main.rs
@crates/qsym-cli/src/commands.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ScriptResult variants, exit codes, execute_file dispatch, and filename-threaded execute_source</name>
  <files>
    crates/qsym-cli/src/script.rs
    crates/qsym-cli/src/error.rs
  </files>
  <action>
**In `crates/qsym-cli/src/script.rs`:**

1. Add `pub const EXIT_IO_ERROR: u8 = 74;` after the existing EXIT_PANIC constant.

2. Add two new variants to `ScriptResult`:
   - `FileNotFound(String)` -- for exit code 66
   - `IoError(String)` -- for exit code 74

3. Update `exit_code()` to map `FileNotFound` -> `EXIT_FILE_NOT_FOUND` (66) and `IoError` -> `EXIT_IO_ERROR` (74).

4. Update `error_message()` to return `Some(msg)` for both new variants.

5. Rewrite `execute_file()` to match on `std::io::ErrorKind`:
   ```rust
   pub fn execute_file(path: &str, env: &mut Environment, verbose: bool) -> ScriptResult {
       match std::fs::read_to_string(path) {
           Ok(source) => execute_source_with_context(&source, env, verbose, Some(path)),
           Err(e) => match e.kind() {
               std::io::ErrorKind::NotFound => {
                   ScriptResult::FileNotFound(format!("file not found: '{}': {}", path, e))
               }
               _ => {
                   ScriptResult::IoError(format!("cannot read '{}': {}", path, e))
               }
           },
       }
   }
   ```
   Note: `execute_file` now calls `execute_source_with_context` with `Some(path)` for filename context.

6. Add `execute_source_with_context()` function that takes an optional `filename: Option<&str>` parameter:
   ```rust
   pub fn execute_source_with_context(
       source: &str,
       env: &mut Environment,
       verbose: bool,
       filename: Option<&str>,
   ) -> ScriptResult {
       let stmts = match crate::parser::parse(source) {
           Ok(stmts) => stmts,
           Err(e) => {
               let msg = match filename {
                   Some(f) => e.render_for_file(source, f),
                   None => e.render(source),
               };
               return ScriptResult::ParseError(msg);
           }
       };

       for (stmt_idx, stmt) in stmts.iter().enumerate() {
           // ... same timing logic as before ...
           match eval::eval_stmt_safe(stmt, env) {
               Ok(Some(val)) => { /* same print + timing */ }
               Ok(None) => { /* same timing */ }
               Err(e) => {
                   let base_msg = format!("{}", e);
                   let msg = match filename {
                       Some(f) => {
                           // Compute line number from statement index.
                           // We track which source line each statement starts on
                           // by counting newlines before the statement.
                           let line = compute_stmt_line(source, &stmts, stmt_idx);
                           format!("{}:{}: {}", f, line, base_msg)
                       }
                       None => base_msg,
                   };
                   return if matches!(e, eval::EvalError::Panic(_)) {
                       ScriptResult::Panic(msg)
                   } else {
                       ScriptResult::EvalError(msg)
                   };
               }
           }
       }
       ScriptResult::Success
   }
   ```

7. Add a helper `compute_stmt_line()` that determines which line a statement starts on. Since the parser produces statements sequentially from the source, and we don't have spans on Stmt, use a heuristic: re-parse to count how many statements appear before `stmt_idx`, and count newlines in the source up to the approximate position. A simpler approach: after parsing, split the source by statement terminators (`;`, `:`, or end-of-input) and count newlines in the consumed portion up to statement N. The simplest correct approach:
   - After parsing the stmts, walk through source line by line, re-parsing each prefix to determine boundaries. BUT this is expensive.
   - Better approach: Use the parser's knowledge. The parser produces stmts in order. We need to know where each stmt starts in the source. Since `AstNode` has no spans, we need another way.
   - Pragmatic approach: Count newlines in the entire source up to an estimated byte offset. Since stmts are executed in order, assign each stmt a "source segment" by splitting source on `;` and `:` terminators (outside strings/parens). For the initial implementation, use a simpler heuristic: track a `current_line` counter. Before parsing, split the source into lines. Map statement indices to line numbers by scanning source for the statement count. SIMPLEST correct approach: use the lexer to find the byte offset of each statement separator, then compute line numbers from those offsets.
   - **ACTUALLY SIMPLEST:** Since we have the source and the parser, and statements are delimited by `;` `:` or newline-at-end, scan the source for statement boundary positions. Use `crate::lexer::lex()` to get all tokens with spans. Walk through SpannedTokens, track statement boundaries (Semi, Colon tokens), and record the byte offset of the first token after each boundary. Then `compute_stmt_line` maps stmt_idx to byte offset to line number.
   - Implement as: lex the source once, find the start byte offset of each statement (token after each Semi/Colon, or the first token), store as `Vec<usize>`. Then use `byte_offset_to_line_col` from error.rs to get the line number.

   ```rust
   fn compute_stmt_starts(source: &str) -> Vec<usize> {
       use crate::lexer::lex;
       let tokens = match lex(source) {
           Ok(t) => t,
           Err(_) => return vec![0],
       };
       let mut starts = Vec::new();
       let mut expect_start = true;
       for st in &tokens {
           if expect_start {
               starts.push(st.span.start);
               expect_start = false;
           }
           if matches!(st.token, crate::token::Token::Semi | crate::token::Token::Colon) {
               expect_start = true;
           }
       }
       if starts.is_empty() {
           starts.push(0);
       }
       starts
   }

   fn compute_stmt_line(source: &str, _stmts: &[crate::ast::Stmt], stmt_idx: usize) -> usize {
       let starts = compute_stmt_starts(source);
       let offset = starts.get(stmt_idx).copied().unwrap_or(0);
       crate::error::byte_offset_to_line_col(source, offset).0
   }
   ```

8. Keep the original `execute_source()` as a thin wrapper for backward compatibility (used by `-c` and piped modes which don't have a filename):
   ```rust
   pub fn execute_source(source: &str, env: &mut Environment, verbose: bool) -> ScriptResult {
       execute_source_with_context(source, env, verbose, None)
   }
   ```

9. Update unit tests:
   - Change `test_execute_file_not_found` to assert `ScriptResult::FileNotFound(_)` instead of `ScriptResult::EvalError(_)`, and verify message contains "file not found".
   - Add `test_exit_code_file_not_found` asserting exit code 66.
   - Add `test_exit_code_io_error` asserting `ScriptResult::IoError("x".into()).exit_code() == 74`.

**In `crates/qsym-cli/src/error.rs`:**

1. Add a public `byte_offset_to_line_col()` function (module-level, not method):
   ```rust
   /// Convert a byte offset to 1-indexed (line, col).
   pub fn byte_offset_to_line_col(source: &str, offset: usize) -> (usize, usize) {
       let mut line = 1;
       let mut col = 1;
       for (i, ch) in source.char_indices() {
           if i >= offset {
               break;
           }
           if ch == '\n' {
               line += 1;
               col = 1;
           } else {
               col += 1;
           }
       }
       (line, col)
   }
   ```

2. Add `render_for_file()` method to `ParseError`:
   ```rust
   /// Render for a script file: shows filename:line:col prefix with caret.
   ///
   /// For multiline sources, extracts just the offending line and computes
   /// the column within that line.
   pub fn render_for_file(&self, source: &str, filename: &str) -> String {
       let (line, col) = byte_offset_to_line_col(source, self.span.start);
       let source_line = source.lines().nth(line - 1).unwrap_or("");
       let spaces = " ".repeat(col - 1 + 2); // 2 for "  " prefix
       format!(
           "{}:{}:{}: parse error: {}\n  {}\n{}^",
           filename, line, col, self.message, source_line, spaces
       )
   }
   ```

3. Add tests for `byte_offset_to_line_col` and `render_for_file`:
   - `byte_offset_to_line_col("abc\ndef", 0)` == `(1, 1)`
   - `byte_offset_to_line_col("abc\ndef", 4)` == `(2, 1)`
   - `byte_offset_to_line_col("abc\ndef", 5)` == `(2, 2)`
   - `render_for_file` with multiline source pointing at line 2 error.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib -- script:: error:: 2>&1 | tail -20`. All existing and new unit tests pass.
  </verify>
  <done>
ScriptResult has FileNotFound (exit 66) and IoError (exit 74) variants. execute_file dispatches on ErrorKind::NotFound. execute_source_with_context threads filename through parse error rendering (via render_for_file) and eval error messages (via line number computation). byte_offset_to_line_col is public and tested. All script.rs and error.rs unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Panic translation, read() error improvement, REPL --help handling, and updated main.rs</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/main.rs
  </files>
  <action>
**In `crates/qsym-cli/src/eval.rs`:**

1. Add a `translate_panic_message()` function near `eval_stmt_safe()`:
   ```rust
   /// Translate common qsym-core panic messages to human-readable text.
   ///
   /// Uses `contains()` for robustness against minor wording changes.
   /// Falls back to the raw message if no translation matches.
   fn translate_panic_message(raw: &str) -> String {
       if raw.contains("Cannot invert series with zero constant term") {
           return "cannot invert a series whose constant term is zero (the series \
                   starts at q^k with k > 0; try shifting or extracting the leading \
                   power first)".to_string();
       }
       if raw.contains("division by zero") || raw.contains("Division by zero") {
           return "division by zero".to_string();
       }
       if raw.contains("Cannot invert zero") {
           return "cannot invert zero".to_string();
       }
       if raw.contains("index out of bounds") {
           return "index out of bounds".to_string();
       }
       // Strip "thread 'main' panicked at" prefix if present (shouldn't happen
       // with catch_unwind, but defensive)
       if let Some(stripped) = raw.strip_prefix("thread '") {
           if let Some(pos) = stripped.find("': ") {
               return stripped[pos + 3..].to_string();
           }
       }
       raw.to_string()
   }
   ```

2. Update `eval_stmt_safe()` to apply translation:
   ```rust
   Err(panic_payload) => {
       let msg = if let Some(s) = panic_payload.downcast_ref::<&str>() {
           s.to_string()
       } else if let Some(s) = panic_payload.downcast_ref::<String>() {
           s.clone()
       } else {
           "internal computation error".to_string()
       };
       Err(EvalError::Panic(translate_panic_message(&msg)))
   }
   ```

3. Update the `read` function dispatch (around line 1756) to use `EvalError::Other` instead of `EvalError::Panic` for non-panic errors from read():
   ```rust
   "read" => {
       expect_args(name, args, 1)?;
       match &args[0] {
           Value::String(path) => {
               match crate::script::execute_file(path, env, false) {
                   crate::script::ScriptResult::Success => Ok(Value::None),
                   crate::script::ScriptResult::ParseError(msg) => {
                       Err(EvalError::Other(msg))
                   }
                   crate::script::ScriptResult::EvalError(msg) => {
                       Err(EvalError::Other(msg))
                   }
                   crate::script::ScriptResult::Panic(msg) => {
                       Err(EvalError::Panic(msg))
                   }
                   crate::script::ScriptResult::FileNotFound(msg) => {
                       Err(EvalError::Other(msg))
                   }
                   crate::script::ScriptResult::IoError(msg) => {
                       Err(EvalError::Other(msg))
                   }
               }
           }
           _ => Err(EvalError::ArgType {
               function: name.to_string(),
               arg_index: 0,
               expected: "string",
               got: args[0].type_name().to_string(),
           }),
       }
   }
   ```
   This ensures: read() file-not-found shows "file not found" not "computation failed", and only actual panics use EvalError::Panic.

4. Add unit tests for `translate_panic_message`:
   - Input containing "Cannot invert series with zero constant term" -> friendly message
   - Input containing "QRat division by zero" -> "division by zero"
   - Input containing "Cannot invert zero" -> "cannot invert zero"
   - Unknown message passes through unchanged

**In `crates/qsym-cli/src/main.rs`:**

1. In `run_interactive()`, right after the `if trimmed.is_empty() { continue; }` check (around line 263), add REPL-level handling for --help/--version typed at the prompt:
   ```rust
   // Handle --help / --version typed at REPL prompt
   match trimmed {
       "--help" | "-h" | "help" => {
           // "help" already handled by parse_command below, but --help/-h are not
       }
       "--version" | "-V" => {
           println!("q-kangaroo {}", env!("CARGO_PKG_VERSION"));
           continue;
       }
       _ => {}
   }
   // For --help/-h at the REPL, show help and continue
   if trimmed == "--help" || trimmed == "-h" {
       print_usage();
       continue;
   }
   ```
   Actually, cleaner approach -- add a single block before the command dispatch:
   ```rust
   // Handle CLI-style flags typed at REPL prompt (UAT feedback)
   if trimmed == "--help" || trimmed == "-h" {
       print_usage();
       continue;
   }
   if trimmed == "--version" || trimmed == "-V" {
       println!("q-kangaroo {}", env!("CARGO_PKG_VERSION"));
       continue;
   }
   ```

2. No changes needed to `run_script()` or `run_expression()` -- they already call into `script::execute_file` and `script::execute_source` which now handle everything correctly.

3. Verify that the REPL error continuation path is intact: in the REPL loop, `Err(e) => eprintln!("{}", e)` for eval errors and `Err(e) => eprintln!("{}", e.render(trimmed))` for parse errors both just print and continue the loop. The `CommandResult::ReadFile` path also just prints errors and continues. This satisfies ERR-04 and ERR-05.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib 2>&1 | tail -20`. All tests pass (including new translate_panic_message tests).
  </verify>
  <done>
Panic messages from qsym-core are translated to human-friendly text before display. read() uses EvalError::Other for file/parse errors (not Panic). REPL handles --help/-h/--version at prompt gracefully. REPL continues after errors in all paths (eval, parse, read).
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo test -p qsym-cli --lib` -- all unit tests pass
2. `cargo test -p qsym-cli --test cli_integration` -- all existing integration tests pass (some may need adjustment if assertions check for specific ScriptResult variants)
3. Quick manual smoke test: `cargo run -p qsym-cli -- nonexistent.qk` exits 66 with "file not found" message
4. `cargo run -p qsym-cli -- -c "1/0"` shows translated "division by zero" not raw panic text
</verification>

<success_criteria>
- ScriptResult::FileNotFound returns exit code 66
- ScriptResult::IoError returns exit code 74
- Parse errors in scripts show filename:line:col format
- Eval errors in scripts show filename:line format
- Common panic messages translated to user-friendly text
- read() errors use EvalError::Other (not Panic) for non-panic failures
- REPL handles --help and --version typed at prompt
- All existing tests pass (with updated assertions where ScriptResult variant changed)
</success_criteria>

<output>
After completion, create `.planning/phases/31-error-hardening-exit-codes/31-01-SUMMARY.md`
</output>
