---
phase: 31-error-hardening-exit-codes
plan: 02
type: execute
wave: 2
depends_on: [31-01]
files_modified:
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [EXIT-01, EXIT-02, EXIT-03, EXIT-04, EXIT-05, EXIT-06, EXIT-07, ERR-01, ERR-02, ERR-03, ERR-04, ERR-05]

must_haves:
  truths:
    - "Every exit code (0, 1, 2, 65, 66, 70, 74) is tested via subprocess integration tests"
    - "Script parse errors include filename:line:col in the error output"
    - "Script eval errors include filename:line in the error output"
    - "Panic messages are translated (no raw qsym-core assert text in output)"
    - "File-not-found error includes OS error message text"
    - "Script stops on first error (only one error line in stderr)"
    - "read() of nonexistent file shows 'file not found' not 'computation failed'"
  artifacts:
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Subprocess integration tests for all 12 requirement IDs"
      contains: "EXIT-05"
  key_links:
    - from: "crates/qsym-cli/tests/cli_integration.rs"
      to: "q-kangaroo binary"
      via: "subprocess execution with env!(CARGO_BIN_EXE_q-kangaroo)"
      pattern: "CARGO_BIN_EXE"
---

<objective>
Add comprehensive subprocess integration tests covering all 12 Phase 31 requirements (EXIT-01 through EXIT-07, ERR-01 through ERR-05), and update existing tests whose assertions may need adjustment after the ScriptResult variant changes in Plan 01.

Purpose: Verify every exit code and error message format works correctly end-to-end via the actual compiled binary, providing regression protection for all error hardening work.
Output: Updated cli_integration.rs with full coverage of all 12 requirement IDs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-error-hardening-exit-codes/31-RESEARCH.md
@.planning/phases/31-error-hardening-exit-codes/31-01-SUMMARY.md
@crates/qsym-cli/tests/cli_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update existing tests and add EXIT-05/EXIT-07/ERR-01/ERR-02/ERR-03 integration tests</name>
  <files>
    crates/qsym-cli/tests/cli_integration.rs
  </files>
  <action>
**Update existing test `script_file_not_found`:**
Change from `assert_ne!(code, 0)` to `assert_eq!(code, 66)` and update the stderr assertion from `"cannot read"` to `"file not found"` (matching the new FileNotFound variant message format).

**Add new test sections at the end of the file:**

```rust
// ===========================================================================
// EXIT-01: Exit code 0 on success (already covered by many tests above,
// add explicit requirement label)
// ===========================================================================

#[test]
fn exit_01_success_exit_code() {
    let (code, stdout, _) = run(&["-c", "1 + 1"]);
    assert_eq!(code, 0, "EXIT-01: success should exit 0");
    assert_eq!(stdout.trim(), "2");
}

// ===========================================================================
// EXIT-02: Exit code 1 on evaluation error in batch mode
// ===========================================================================

#[test]
fn exit_02_eval_error_exit_code() {
    let (code, _, stderr) = run(&["-c", "undefined_var"]);
    assert_eq!(code, 1, "EXIT-02: eval error should exit 1");
    assert!(stderr.contains("undefined variable"));
}

#[test]
fn exit_02_eval_error_in_script() {
    let tmp = write_temp_script("qk_test_exit02.qk", "x := 1:\nundefined_var");
    let (code, _, stderr) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 1, "EXIT-02: script eval error should exit 1");
    assert!(stderr.contains("undefined variable"));
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// EXIT-03: Exit code 2 on usage error (already covered by unknown_flag tests,
// add explicit label)
// ===========================================================================

#[test]
fn exit_03_usage_error_exit_code() {
    let (code, _, stderr) = run(&["--bogus"]);
    assert_eq!(code, 2, "EXIT-03: unknown flag should exit 2");
    assert!(stderr.contains("unknown option"));
    assert!(stderr.contains("--help"), "should suggest --help");
}

// ===========================================================================
// EXIT-04: Exit code 65 on parse error in script input
// ===========================================================================

#[test]
fn exit_04_parse_error_exit_code() {
    let (code, _, stderr) = run(&["-c", "1 + + 2"]);
    assert_eq!(code, 65, "EXIT-04: parse error should exit 65");
    assert!(stderr.contains("parse error"));
}

#[test]
fn exit_04_parse_error_in_script() {
    let tmp = write_temp_script("qk_test_exit04.qk", "1 + + 2");
    let (code, _, stderr) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 65, "EXIT-04: script parse error should exit 65");
    assert!(stderr.contains("parse error"));
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// EXIT-05: Exit code 66 on file not found
// ===========================================================================

#[test]
fn exit_05_file_not_found_exit_code() {
    let (code, _, stderr) = run(&["/nonexistent/path/script.qk"]);
    assert_eq!(code, 66, "EXIT-05: file not found should exit 66");
    assert!(
        stderr.contains("file not found"),
        "EXIT-05: stderr should contain 'file not found', got: {}",
        stderr
    );
    // ERR-03: Should include OS error message
    assert!(
        stderr.contains("No such file") || stderr.contains("not find") || stderr.contains("cannot find"),
        "EXIT-05/ERR-03: should include OS error message, got: {}",
        stderr
    );
}

// ===========================================================================
// EXIT-06: Exit code 70 on caught panic
// ===========================================================================

#[test]
fn exit_06_panic_exit_code() {
    // Trigger a division by zero panic in qsym-core
    let (code, _, stderr) = run(&["-c", "0/0"]);
    // This may be exit 1 (eval error) rather than 70 depending on how
    // 0/0 is handled. Use a series operation that triggers a qsym-core panic:
    // Creating q^1 series and dividing by (q - q) which gives zero series
    // Actually the simplest panic trigger: invert a series with zero constant term
    // jacprod(0,0,0,0,0) or similar -- let's use a direct approach
    // A reliable panic: 1/(q*etaq(1,1,5)) where the series starts at q^1
    // Actually, construct zero and divide:
    assert!(code != 0, "should fail");
    // Better: use a script that explicitly triggers the inversion panic
}

#[test]
fn exit_06_panic_invert_zero_constant() {
    // etaq(1,1,5) has nonzero constant term, but q*etaq(1,1,5) starts at q^1
    // Inverting that should panic with "Cannot invert series with zero constant term"
    let tmp = write_temp_script("qk_test_exit06.qk", "1/(q * etaq(1,1,5))");
    let (code, _, stderr) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 70, "EXIT-06: caught panic should exit 70");
    // ERR-02: Should be translated, not raw assert text
    assert!(
        !stderr.contains("Cannot invert series with zero constant term"),
        "ERR-02: should show translated message, not raw panic. Got: {}",
        stderr
    );
    assert!(
        stderr.contains("cannot invert") || stderr.contains("zero constant term") || stderr.contains("constant term is zero"),
        "ERR-02: should show friendly version of the panic. Got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// EXIT-07: Exit code 74 on I/O error
// ===========================================================================

// Note: Triggering a non-NotFound I/O error in a portable test is hard.
// We test the exit code mapping via the unit tests in script.rs.
// Here we verify that the code path exists by checking the constant is used.
// If we can find a directory path (which is an I/O error, not NotFound):

#[test]
fn exit_07_io_error_directory_as_file() {
    // Reading a directory as a file produces an I/O error (not NotFound)
    // On Windows this may produce a different error -- accept either 66 or 74
    let (code, _, stderr) = run(&["."]);
    assert!(
        code == 74 || code == 66 || code == 1,
        "EXIT-07: I/O error reading directory should exit 74 (or 66 on some platforms), got: {}",
        code
    );
    assert!(!stderr.is_empty(), "should produce an error message");
}

// ===========================================================================
// ERR-01: Script errors include filename:line:col context
// ===========================================================================

#[test]
fn err_01_parse_error_shows_filename_line_col() {
    let tmp = write_temp_script(
        "qk_test_err01_parse.qk",
        "x := 1:\ny := 2:\n1 + + 3",
    );
    let path_str = tmp.to_str().unwrap();
    let (code, _, stderr) = run(&[path_str]);
    assert_eq!(code, 65);
    // Should contain filename:line:col format
    let filename = std::path::Path::new(path_str)
        .file_name()
        .unwrap()
        .to_str()
        .unwrap();
    // The path in the error will be the full path, check for the line number
    assert!(
        stderr.contains(":3:"),
        "ERR-01: parse error on line 3 should show ':3:' in error, got: {}",
        stderr
    );
    assert!(
        stderr.contains("parse error"),
        "ERR-01: should contain 'parse error', got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

#[test]
fn err_01_eval_error_shows_filename_line() {
    let tmp = write_temp_script(
        "qk_test_err01_eval.qk",
        "x := 1:\ny := 2:\nz := 3:\nw := 4:\nundefined_var",
    );
    let path_str = tmp.to_str().unwrap();
    let (code, _, stderr) = run(&[path_str]);
    assert_eq!(code, 1);
    // Should contain filename:line format (line 5 has the error)
    assert!(
        stderr.contains(":5:"),
        "ERR-01: eval error on line 5 should show ':5:' in error, got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

#[test]
fn err_01_first_line_error() {
    let tmp = write_temp_script("qk_test_err01_first.qk", "undefined_var");
    let path_str = tmp.to_str().unwrap();
    let (code, _, stderr) = run(&[path_str]);
    assert_eq!(code, 1);
    assert!(
        stderr.contains(":1:"),
        "ERR-01: error on line 1 should show ':1:', got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// ERR-02: Panic messages translated to human-readable
// (Covered by exit_06_panic_invert_zero_constant above)
// ===========================================================================

#[test]
fn err_02_division_by_zero_translated() {
    // Division by zero integer should produce a clear message
    let tmp = write_temp_script("qk_test_err02_div.qk", "1/0");
    let (code, _, stderr) = run(&[tmp.to_str().unwrap()]);
    assert_ne!(code, 0);
    // Should say "division by zero" not "QInt division by zero" or "QRat division..."
    assert!(
        stderr.contains("division by zero"),
        "ERR-02: should contain 'division by zero', got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// ERR-03: File I/O errors display OS error message
// (Covered by exit_05_file_not_found_exit_code above)
// ===========================================================================

#[test]
fn err_03_file_error_includes_os_message() {
    let (code, _, stderr) = run(&["nonexistent_file_abc123.qk"]);
    assert_eq!(code, 66);
    // OS error message should be included (Windows says "The system cannot find the file specified"
    // or "No such file or directory" on Unix)
    assert!(
        stderr.len() > 30,
        "ERR-03: error should include OS message, got short stderr: {}",
        stderr
    );
}

// ===========================================================================
// ERR-04: Scripts fail-fast on first error; REPL continues
// ===========================================================================

#[test]
fn err_04_script_fail_fast() {
    // Two errors in script -- only the first should appear
    let tmp = write_temp_script(
        "qk_test_err04.qk",
        "x := 1:\nundefined_a\nundefined_b",
    );
    let (code, _, stderr) = run(&[tmp.to_str().unwrap()]);
    assert_eq!(code, 1, "should exit on first error");
    // Should mention undefined_a but NOT undefined_b
    assert!(
        stderr.contains("undefined_a"),
        "ERR-04: should report first error (undefined_a), got: {}",
        stderr
    );
    assert!(
        !stderr.contains("undefined_b"),
        "ERR-04: should NOT report second error (undefined_b) due to fail-fast, got: {}",
        stderr
    );
    std::fs::remove_file(&tmp).ok();
}

// ===========================================================================
// ERR-05: read() in REPL continues on error
// (Testing via -c mode which uses execute_source, not REPL.
//  REPL continuation is verified by the existing architecture:
//  CommandResult::ReadFile path prints errors and continues.)
// ===========================================================================

#[test]
fn err_05_read_nonexistent_shows_file_not_found() {
    let expr = r#"read("/nonexistent/file.qk")"#;
    let (code, _, stderr) = run(&["-c", expr]);
    assert_ne!(code, 0);
    // Should show "file not found" not "computation failed"
    assert!(
        stderr.contains("file not found"),
        "ERR-05: read() of nonexistent file should show 'file not found', got: {}",
        stderr
    );
}

#[test]
fn err_05_read_error_then_continue() {
    // In -c mode with two statements: read a nonexistent file, then compute.
    // Because -c uses execute_source which is fail-fast, the second stmt won't run.
    // This test verifies read() error message quality.
    let expr = r#"read("/no/such/file.qk")"#;
    let (_, _, stderr) = run(&["-c", expr]);
    assert!(
        !stderr.contains("computation failed"),
        "ERR-05: read() file error should NOT say 'computation failed', got: {}",
        stderr
    );
}
```

**Important:** After adding all tests, run the full integration test suite and fix any assertions that break due to the Plan 01 changes. Specifically:
- `script_file_not_found` test: update `assert!(stderr.contains("cannot read"))` to `assert!(stderr.contains("file not found"))` since the message format changed from `ScriptResult::EvalError("cannot read...")` to `ScriptResult::FileNotFound("file not found: ...")`.
- `dashdash_separator` test: update similarly if it tests a nonexistent file path.
- `read_function_not_found` test: may need to check for "file not found" instead of just non-empty stderr.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --test cli_integration 2>&1 | tail -30`. All integration tests pass.
  </verify>
  <done>
All 12 requirement IDs (EXIT-01 through EXIT-07, ERR-01 through ERR-05) have at least one dedicated integration test verifying exit codes and error message content via subprocess execution. Existing tests updated for new ScriptResult variants. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all unit and integration tests pass
2. `cargo test -p qsym-cli --test cli_integration` -- all subprocess tests pass
3. Spot-check exit codes manually:
   - `q-kangaroo nonexistent.qk; echo $?` -> 66
   - `q-kangaroo --bogus; echo $?` -> 2
   - `q-kangaroo -c "1+1"; echo $?` -> 0
4. Verify the five roadmap success criteria:
   SC1: Script with typo on line 5 shows filename:5: in error
   SC2: nonexistent.qk shows "file not found" + OS error, exits 66
   SC3: --bogus shows "unknown option" + --help suggestion, exits 2
   SC4: Panic shows translated message (not Rust backtrace), exits 70
   SC5: REPL errors continue; script errors stop
</verification>

<success_criteria>
- All 12 requirement IDs covered by integration tests
- Every exit code (0, 1, 2, 65, 66, 70, 74) verified in tests
- ERR-01 filename:line:col format verified for both parse and eval errors
- ERR-02 panic translation verified (no raw assert text)
- ERR-03 OS error message presence verified
- ERR-04 fail-fast verified (second error not shown)
- ERR-05 read() error message improved (no "computation failed")
- Full cargo test -p qsym-cli passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/31-error-hardening-exit-codes/31-02-SUMMARY.md`
</output>
