---
phase: 32-pdf-reference-manual
plan: 05
type: execute
wave: 2
depends_on: [32-01]
files_modified:
  - manual/chapters/13-worked-examples.typ
  - manual/chapters/14-maple-migration.typ
  - manual/chapters/15-index.typ
autonomous: true
requirements: [DOC-03]

must_haves:
  truths:
    - "Worked examples chapter contains 5-6 complete examples spanning identity verification and research workflows"
    - "Each worked example cites source papers for identities"
    - "Maple migration chapter contains a complete side-by-side mapping table for all 15+ Maple aliases"
    - "Index chapter generates back-of-book index via in-dexter"
  artifacts:
    - path: "manual/chapters/13-worked-examples.typ"
      provides: "5-6 worked examples with REPL transcripts and mathematical context"
      contains: "repl"
    - path: "manual/chapters/14-maple-migration.typ"
      provides: "Maple-to-q-Kangaroo mapping table"
      contains: "numbpart"
    - path: "manual/chapters/15-index.typ"
      provides: "Back-of-book index via make-index"
      contains: "make-index"
  key_links:
    - from: "manual/chapters/14-maple-migration.typ"
      to: "crates/qsym-cli/src/eval.rs"
      via: "Maple alias data"
      pattern: "resolve_alias"
---

<objective>
Write the closing chapters: Worked Examples (5-6 extended examples), Maple Migration table, and Index page.

Purpose: Provide researchers with end-to-end usage examples spanning multiple function groups, a quick Maple migration reference, and a comprehensive back-of-book index.

Output: manual/chapters/13-worked-examples.typ, 14-maple-migration.typ, 15-index.typ
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-pdf-reference-manual/32-RESEARCH.md
@.planning/phases/32-pdf-reference-manual/32-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
@docs/examples/maple_migration.ipynb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Worked Examples chapter (13)</name>
  <files>manual/chapters/13-worked-examples.typ</files>
  <action>
**chapters/13-worked-examples.typ** -- "Worked Examples" chapter (5-6 examples, ~8-12 pages):

Chapter introduction: This chapter demonstrates q-Kangaroo through extended examples that span multiple function groups. Each example shows a complete research workflow from problem statement through solution.

**Example 1: Euler's Pentagonal Theorem** (Identity Verification, introductory)
- Mathematical context: Euler's pentagonal number theorem states $(q;q)_oo = sum_(n=-oo)^oo (-1)^n q^(n(3n-1)/2)$. This is the generating function identity for partitions with distinct odd parts.
- Citation: "Euler (1750); see Andrews, *The Theory of Partitions*, Chapter 1"
- REPL workflow (use repl template for each step):
  1. Compute $(q;q)_oo$: `aqprod(1, 1, 1, infinity, 20)`
  2. Observe the pentagonal numbers in exponents: 0, 1, 2, 5, 7, 12, 15, ...
  3. Verify with prodmake: `prodmake(%, 10)` showing {1: 1} (single factor)
  4. Use etamake to confirm eta quotient form
- Takeaway: The signs and exponents encode pentagonal numbers

**Example 2: Ramanujan's Partition Congruences** (Research Workflow)
- Mathematical context: $p(5n+4) equiv 0 (mod 5)$, $p(7n+5) equiv 0 (mod 7)$, $p(11n+6) equiv 0 (mod 11)$
- Citation: "Ramanujan (1919); see Berndt, *Ramanujan's Notebooks*, Vol. III"
- REPL workflow:
  1. Generate partition function: `f := partition_gf(200)`
  2. Use findcong to discover congruences: `findcong(f, [5, 7, 11])`
  3. Verify manually with sift: `sift(f, 5, 4)` and check all coefficients divisible by 5
  4. Check higher moduli: `findcong(f, [13, 17, 19])` to show these do NOT yield simple congruences
- Takeaway: Demonstrates the findcong research tool and manual verification with sift

**Example 3: Jacobi Triple Product Identity** (Identity Proving)
- Mathematical context: $sum_(n=-oo)^oo z^n q^(n^2) = product_(k>=1) (1-q^(2k))(1+z q^(2k-1))(1+z^(-1) q^(2k-1))$
- At z=1: $theta_3(q) = (q^2;q^2)_oo (-q;q^2)_oo^2$
- Citation: "Jacobi (1829); see Andrews & Berndt, *Ramanujan's Lost Notebook*, Part I"
- REPL workflow:
  1. Compute theta3 directly: `a := theta3(50)`
  2. Build the product side: `b := aqprod(1,1,0,infinity,50)^2 * ...` (construct the triple product)
  3. Verify equality: subtract and check zero
  4. Use prove_eta_id or findlincombo to verify algebraically
- Takeaway: Multiple verification strategies available

**Example 4: Rogers-Ramanujan via Bailey Chains** (Advanced)
- Mathematical context: The Rogers-Ramanujan identities relate certain infinite products to infinite sums
- Citation: "Rogers (1894), Ramanujan (1913); see Andrews, *q-Series: Their Development and Application in Analysis, Number Theory, Combinatorics, Physics and Computer Algebra*"
- REPL workflow:
  1. Start with Rogers-Ramanujan Bailey pair: `bailey_weak_lemma(1, 1, 1, 0, 10, 30)`
  2. Apply Bailey's lemma: `bailey_apply_lemma(1, 1,1,0, 1,1,1, 1,1,2, 10, 30)`
  3. Iterate chain: `bailey_chain(1, 1,1,0, 1,1,1, 1,1,2, 2, 10, 30)`
  4. Use bailey_discover to find the proof automatically
- Takeaway: Bailey chains generate infinite families of identities from a single seed

**Example 5: Hypergeometric Exploration** (Transformation Chain)
- Mathematical context: Connecting two ${}_2 phi_1$ representations via Heine's transformations
- Citation: "Heine (1847); see Gasper & Rahman, *Basic Hypergeometric Series*, Chapter 1"
- REPL workflow:
  1. Define a ${}_2 phi_1$ series via phi()
  2. Apply heine1 to transform
  3. Apply heine2 to the result
  4. Use find_transformation_chain to discover the path automatically
- Takeaway: Demonstrates the BFS transformation search as a research tool

**Example 6 (optional -- include if space/context allows): Mock Theta Function Relations**
- Mathematical context: Relations among Ramanujan's third-order mock theta functions
- Citation: "Watson (1936); Zwegers (2002)"
- REPL workflow:
  1. Compute several mock theta functions
  2. Use findlincombo to discover a linear relation
  3. Verify with appell_lerch_m
- Takeaway: Modern mock theta theory via computational tools

For ALL examples: Use realistic REPL transcripts with actual q-Kangaroo syntax. Show both input and (abbreviated) output. Include mathematical context before the computation. Cite sources.
  </action>
  <verify>
Verify 13-worked-examples.typ contains at least 5 distinct examples with:
- Mathematical context paragraphs
- Citation strings
- Multiple repl() calls showing complete workflows
- Takeaway summaries
  </verify>
  <done>
Worked Examples chapter complete with 5-6 extended examples spanning identity verification (Euler, Jacobi), research workflows (Ramanujan congruences), Bailey chains, and hypergeometric transformations. All examples cite source papers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Maple Migration and Index chapters (14-15)</name>
  <files>
    manual/chapters/14-maple-migration.typ
    manual/chapters/15-index.typ
  </files>
  <action>
**chapters/14-maple-migration.typ** -- "Maple Migration Quick Reference" chapter:

Chapter introduction (1 paragraph): Users familiar with Garvan's Maple packages (qseries, thetaids) can use q-Kangaroo as a drop-in replacement for most operations. The table below maps Maple function names to their q-Kangaroo equivalents. q-Kangaroo also accepts most Maple names as aliases.

**Side-by-side mapping table**: Three columns: Maple Name, q-Kangaroo Name, Notes.

Extract ALL 17 aliases from eval.rs resolve_alias() function (lines 2382-2400):

| Maple Name | q-Kangaroo Name | Notes |
|------------|-----------------|-------|
| numbpart | partition_count | Integer output (not series) |
| rankgf | rank_gf | |
| crankgf | crank_gf | |
| qphihyper | phi | Basic hypergeometric r_phi_s |
| qpsihyper | psi | Bilateral r_psi_s |
| qgauss | try_summation | Tries multiple summation formulas |
| proveid | prove_eta_id | Eta-quotient identity prover |
| qzeil | q_zeilberger | Creative telescoping |
| qzeilberger | q_zeilberger | Alternative spelling |
| qpetkovsek | q_petkovsek | Recurrence solver |
| qgosper | q_gosper | Indefinite summation |
| findlincombo_modp | findlincombomodp | Underscore removed |
| findhom_modp | findhommodp | Underscore removed |
| findhomcombo_modp | findhomcombomodp | Underscore removed |
| search_id | search_identities | Expanded name |
| g2 | universal_mock_theta_g2 | Short alias |
| g3 | universal_mock_theta_g3 | Short alias |

Add a note below the table: "All aliases are case-insensitive. You can type `numbpart(100)` or `NUMBPART(100)` in the REPL."

**Key differences section** (brief bullet list):
- Parameter encoding: Maple uses symbolic parameters; q-Kangaroo encodes parameters as (num, den, pow) integer triples
- Series display: q-Kangaroo shows q as the indeterminate (not x); truncation shown as O(q^N)
- Assignment: q-Kangaroo uses `:=` (same as Maple)
- No symbolic parameters: q-Kangaroo works with concrete q-series, not formal symbols

Index entries: "Maple migration", "aliases", and each Maple function name as a sub-entry under "Maple functions" (e.g., `#index("Maple functions", "numbpart")`).

---

**chapters/15-index.typ** -- Index page:

This file is minimal -- it just triggers index generation:

```typst
= Index

#make-index(title: none)
```

Note: The `= Index` heading provides the chapter heading. `make-index(title: none)` generates the index without a redundant sub-title since we already have the heading. OR use `#make-index(title: [Index])` without a separate heading -- pick whichever renders cleaner. The index entries themselves are distributed throughout all other chapters via `#index[]` and `#index-main[]` calls.
  </action>
  <verify>
Verify:
- 14-maple-migration.typ contains a table with all 17 Maple aliases from eval.rs resolve_alias()
- 14-maple-migration.typ contains #index entries for Maple function names
- 15-index.typ contains #make-index call
  </verify>
  <done>
Maple Migration chapter contains complete side-by-side mapping table with all 17 aliases and key differences section. Index chapter generates back-of-book index via in-dexter make-index.
  </done>
</task>

</tasks>

<verification>
- Worked examples cover both identity verification AND research workflows (per user decision)
- At least 5 examples with citations
- Maple migration table includes ALL aliases from eval.rs resolve_alias()
- No Maple content appears in function reference chapters (only in migration table)
- Index chapter triggers in-dexter make-index
</verification>

<success_criteria>
- 3 chapter files complete
- Worked examples demonstrate real research workflows with mathematical context and citations (DOC-03)
- Maple migration table is comprehensive with all aliases (DOC-03)
- Index chapter is functional
</success_criteria>

<output>
After completion, create `.planning/phases/32-pdf-reference-manual/32-05-SUMMARY.md`
</output>
