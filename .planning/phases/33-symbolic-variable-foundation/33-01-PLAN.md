---
phase: 33-symbolic-variable-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements:
  - SYM-01
  - SYM-04

must_haves:
  truths:
    - "Typing an undefined name like `f` at the REPL returns a Symbol value (no error)"
    - "Assignment `x := 42` followed by `x` returns 42 (assigned values take precedence over symbol fallback)"
    - "`q` is no longer a keyword -- it becomes a bare symbol like any other undefined name"
    - "All existing tests compile and pass (with updated assertions where needed)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::Symbol(String) variant; symbol fallback in Variable eval"
      contains: "Value::Symbol"
    - path: "crates/qsym-cli/src/token.rs"
      provides: "Token enum without Token::Q variant"
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode enum without AstNode::Q variant"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Parser without Token::Q -> AstNode::Q path"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Lexer where 'q' produces Token::Ident, not Token::Q"
  key_links:
    - from: "crates/qsym-cli/src/lexer.rs"
      to: "crates/qsym-cli/src/token.rs"
      via: "q produces Token::Ident('q') instead of Token::Q"
      pattern: "Token::Ident"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/environment.rs"
      via: "Variable eval: env.get_var returns Some -> use it, None -> Value::Symbol(name)"
      pattern: "Value::Symbol"
---

<objective>
Add the `Value::Symbol` variant to the evaluator's Value enum, remove `Token::Q` and `AstNode::Q` (demoting `q` to a regular identifier), and change the evaluator so undefined variable names return `Value::Symbol(name)` instead of `EvalError::UnknownVariable`. Update all existing tests that reference `Token::Q`, `AstNode::Q`, or `EvalError::UnknownVariable` (for variables) to work with the new behavior.

Purpose: This is the foundation for all Phase 33 work. Without `Value::Symbol` and the q demotion, symbols cannot be passed to functions or participate in arithmetic. SYM-01 (bare symbols) and SYM-04 (assignment precedence) are both satisfied by this plan.

Output: Modified token.rs, lexer.rs, ast.rs, parser.rs, eval.rs with all existing tests passing.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-symbolic-variable-foundation/33-CONTEXT.md
@.planning/phases/33-symbolic-variable-foundation/33-RESEARCH.md

Key source files:
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/environment.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Value::Symbol, remove Token::Q/AstNode::Q, implement symbol fallback</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/ast.rs
    crates/qsym-cli/src/parser.rs
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
    **Step 1: Add `Value::Symbol(String)` variant to eval.rs**

    In the `Value` enum (line 28-49), add a new variant:
    ```rust
    /// A symbolic variable name (undefined name fallback, Maple-like).
    Symbol(String),
    ```

    In `Value::type_name()` (line 53-66), add:
    ```rust
    Value::Symbol(_) => "symbol",
    ```

    **Step 2: Remove `Token::Q` from token.rs**

    Delete the `Q` variant from the Token enum (line 16). This is the line:
    ```rust
    /// The `q` keyword (reserved indeterminate, not a variable).
    Q,
    ```

    Update the doc comment on the module to note that `q` is now a regular identifier.

    Update token.rs tests:
    - `token_variants_distinct`: Remove `assert_ne!(Token::Q, Token::Infinity)`. Replace with another meaningful assertion, e.g., `assert_ne!(Token::Ident("q".to_string()), Token::Infinity)`.

    **Step 3: Remove `"q" => Token::Q` from lexer.rs**

    In the keyword match block (line 143-147), remove the `"q" => Token::Q` arm. The match becomes:
    ```rust
    let token = match word {
        "infinity" => Token::Infinity,
        _ => Token::Ident(word.to_string()),
    };
    ```

    Update lexer.rs tests: Search for any test that asserts `Token::Q` and change to `Token::Ident("q".to_string())`. Specifically check `test_simple_tokens` and any test tokenizing expressions with `q`.

    **Step 4: Remove `AstNode::Q` from ast.rs**

    Delete the `Q` variant (line 32-33):
    ```rust
    /// The `q` indeterminate.
    Q,
    ```

    Update ast.rs tests:
    - `ast_q_and_infinity`: Remove `assert_ne!(AstNode::Q, AstNode::Infinity)` and `assert_eq!(AstNode::Q, AstNode::Q)`. Replace with tests for `AstNode::Variable("q".to_string())`.
    - `ast_func_call`: Change `AstNode::Q` in args to `AstNode::Variable("q".to_string())`.
    - `stmt_with_terminator`: Change `AstNode::Q` to `AstNode::Variable("q".to_string())`.

    **Step 5: Remove `Token::Q => AstNode::Q` from parser.rs**

    Delete the arm in `expr_bp` (lines 148-151):
    ```rust
    Token::Q => {
        self.advance();
        AstNode::Q
    }
    ```

    Now `q` falls through to the `Token::Ident` arm and produces `AstNode::Variable("q")` -- exactly what we want.

    Also, check the `token_name()` helper function at the bottom of parser.rs. If it has a `Token::Q => "q"` arm, remove it. The `Token::Ident("q")` case is handled by the generic `Token::Ident` arm.

    Update parser.rs tests: Any test asserting `AstNode::Q` should be changed to `AstNode::Variable("q".to_string())`.

    **Step 6: Change Variable eval from error to symbol fallback in eval.rs**

    Change the `AstNode::Variable` arm (lines 642-647) from:
    ```rust
    AstNode::Variable(name) => match env.get_var(name) {
        Some(val) => Ok(val.clone()),
        None => Err(EvalError::UnknownVariable {
            name: name.clone(),
        }),
    },
    ```
    To:
    ```rust
    AstNode::Variable(name) => match env.get_var(name) {
        Some(val) => Ok(val.clone()),
        None => Ok(Value::Symbol(name.clone())),
    },
    ```

    **Step 7: Remove `AstNode::Q` eval arm in eval.rs**

    Delete the `AstNode::Q` arm (lines 622-631). After the demotion, `q` flows through `AstNode::Variable("q")` -> symbol fallback -> `Value::Symbol("q")`. The monomial creation now happens in arithmetic (Plan 33-02), not in the variable evaluator.

    **Important note on `env.sym_q`:** Do NOT remove `env.sym_q` from Environment. Keep it as a cached SymbolId for "q". Functions that don't receive an explicit variable symbol should continue using `env.sym_q`. This will be refined in Plan 33-03.
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo build -p qsym-cli 2>&1 | tail -5`

    Expect: No compilation errors. The build may have warnings about unused imports (e.g., EvalError::UnknownVariable for variables) -- that's acceptable.
  </verify>
  <done>
    `Value::Symbol(String)` variant exists in the Value enum. `Token::Q` and `AstNode::Q` are removed. The lexer produces `Token::Ident("q")` for `q`. The parser produces `AstNode::Variable("q")` for `q`. Evaluating an undefined variable name returns `Value::Symbol(name)` instead of an error. The code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all existing tests for the new symbol behavior</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/format.rs
    crates/qsym-cli/src/script.rs
    crates/qsym-cli/tests/cli_integration.rs
  </files>
  <action>
    **Step 1: Update eval.rs unit tests**

    Search for all tests referencing `AstNode::Q` and change to `AstNode::Variable("q".to_string())`. Key tests:
    - `eval_q_creates_series`: This currently evaluates `AstNode::Q` and expects `Value::Series`. After demotion, evaluating `AstNode::Variable("q")` returns `Value::Symbol("q")`, NOT a series. Update this test to assert `Value::Symbol("q")` is returned. (Series creation from `q` will happen via arithmetic in Plan 33-02.)
    - `eval_series_add` (q + q): If this test constructs `AstNode::Q` directly, change to `AstNode::Variable("q")`. This test will likely fail until Plan 33-02 adds symbol arithmetic, so if it uses direct `q` AST nodes, either skip it temporarily with `#[ignore]` and a comment "Re-enable after Plan 33-02 adds symbol arithmetic", or restructure to construct FPS values directly for the add test.
    - `eval_scalar_mul_series` (3 * q): Same approach -- if it depends on `AstNode::Q` producing a series, restructure or mark `#[ignore]`.
    - `eval_variable_not_found`: Now expects `Value::Symbol("unknown")` not `EvalError::UnknownVariable`. Update assertion.
    - `eval_error_display_unknown_var`: If this test constructs `EvalError::UnknownVariable` directly (not through eval), keep it -- the error type still exists for function dispatch. If it tests eval of an undefined variable, update to expect success with Symbol value.

    **Step 2: Update format.rs for Value::Symbol**

    In `format_value()` (line 30-43), add a match arm:
    ```rust
    Value::Symbol(name) => name.clone(),
    ```

    In `format_latex()` (line 97-140), add a match arm:
    ```rust
    Value::Symbol(name) => name.clone(),
    ```

    These are minimal -- just display the symbol name as-is. (Variable-aware series formatting is in Plan 33-02.)

    **Step 3: Update script.rs tests**

    The test `test_execute_source_eval_error` (line 273-277) evaluates `"undefined_var"` and expects `ScriptResult::EvalError(_)`. After the symbol fallback, this now succeeds (prints "undefined_var" as a symbol). Update to expect `ScriptResult::Success`. Add a NEW test that triggers an actual eval error (e.g., wrong arg count: `"etaq(1)"` expects 3 args).

    **Step 4: Update integration tests (cli_integration.rs)**

    The following integration tests need updating because `undefined_var` no longer errors:

    - `c_flag_eval_error` (line 143-151): Currently runs `-c "undefined_var"` and expects exit code != 0 + stderr containing "undefined variable". After Phase 33, this prints "undefined_var" to stdout and exits 0. Update to test a real eval error instead, e.g., `-c "etaq(1)"` (wrong arg count). Keep the test name but change the input and assertions.

    - `exit_02_eval_error_exit_code` (line 503-507): Same issue -- `undefined_var` now succeeds. Change to use `-c "nonexistent_function(1)"` which will produce `UnknownFunction` error.

    - `exit_02_eval_error_in_script` (line 510-516): The script has `undefined_var` on line 2. This now succeeds. Change the script content to have a real error, e.g., `"x := 1:\netaq(1)"`.

    - `err_01_eval_error_shows_filename_line` (line 660-675): Tests error at line 5 with `undefined_var`. Change to a real error, e.g., `"etaq(1)"` on line 5.

    - `err_01_first_line_error` (line 677-689): `undefined_var` on line 1. Change to real error.

    - `err_04_script_fail_fast` (line 745-766): Uses `undefined_a` and `undefined_b`. These now produce Symbol values (success). Change to real errors, e.g., `"etaq(1);\netaq(2)"` (wrong arg count errors). Update assertions to check for the first error but not the second.

    **Step 5: Add new tests for symbol behavior**

    Add integration tests:
    - `symbol_bare_variable`: `-c "f"` -> exit 0, stdout "f"
    - `symbol_q_bare`: `-c "q"` -> exit 0, stdout "q"
    - `symbol_assignment_precedence`: `-c "x := 42:\nx"` -> exit 0, stdout "42"
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -20`

    Expect: All tests pass (with possible `#[ignore]` for tests needing Plan 33-02 symbol arithmetic). Zero test failures.
  </verify>
  <done>
    All existing tests compile and pass or are appropriately marked `#[ignore]` with comments explaining they need Plan 33-02 for symbol arithmetic. `format_value` and `format_latex` handle `Value::Symbol`. Integration tests use real eval errors instead of `undefined_var`. New integration tests verify bare symbols and assignment precedence work.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p qsym-cli` compiles without errors
2. `cargo test -p qsym-cli` passes all tests (minus any `#[ignore]` for symbol arithmetic)
3. `cargo test -p qsym-cli --test cli_integration` passes all integration tests
4. Running `q-kangaroo -c "f"` prints `f` and exits 0
5. Running `q-kangaroo -c "q"` prints `q` and exits 0
6. Running `q-kangaroo -c "x := 42:\nx"` prints `42` and exits 0
</verification>

<success_criteria>
- `Value::Symbol(String)` variant exists in the Value enum with type_name "symbol"
- `Token::Q` and `AstNode::Q` are completely removed from the codebase
- `q` tokenizes as `Token::Ident("q")` and parses as `AstNode::Variable("q")`
- Undefined variable names produce `Value::Symbol(name)` (no error)
- Assigned variables still return their assigned value (SYM-04)
- format_value and format_latex handle Value::Symbol
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-symbolic-variable-foundation/33-01-SUMMARY.md`
</output>
