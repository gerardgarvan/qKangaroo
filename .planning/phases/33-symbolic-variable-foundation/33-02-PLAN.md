---
phase: 33-symbolic-variable-foundation
plan: 02
type: execute
wave: 2
depends_on: [33-01]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-core/src/series/display.rs
autonomous: true
requirements:
  - SYM-03

must_haves:
  truths:
    - "`q^2` evaluates to a monomial series with one term at power 2"
    - "`2*q^3` evaluates to a monomial with coefficient 2 at power 3"
    - "`(q^2 + 1) * (q + 1)` evaluates to the polynomial `1 + q + q^2 + q^3` (no O(...) suffix)"
    - "Series produced by functions like `etaq(1,1,10)` display with `O(q^N)` truncation"
    - "Standalone polynomial arithmetic works at the REPL without truncation artifacts"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Symbol arithmetic: pow, mul, add, sub with Value::Symbol promotion to FPS"
      contains: "Value::Symbol"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "Variable-aware series formatting using SymbolRegistry; polynomial display without O(...)"
      contains: "format_series"
    - path: "crates/qsym-core/src/series/display.rs"
      provides: "Optional suppression of O(...) for polynomial sentinel truncation order"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/series/mod.rs"
      via: "symbol_to_series promotes Value::Symbol to FormalPowerSeries monomial"
      pattern: "symbol_to_series"
    - from: "crates/qsym-cli/src/format.rs"
      to: "crates/qsym-core/src/symbol.rs"
      via: "format_series uses SymbolRegistry to resolve variable names"
      pattern: "symbols.name"
---

<objective>
Implement symbol arithmetic (so expressions like `q^2`, `2*q`, `q^2 + q + 1` work), variable-aware series display (so series in variable `t` display with `t` not `q`), and polynomial display (finite polynomials display without `O(q^N)` truncation).

Purpose: This enables SYM-03 (monomial/polynomial expressions as function arguments) and the user decisions about polynomial arithmetic and display. Without this, `q^2` produces a TypeError because `Value::Symbol` cannot participate in `^` with `Value::Integer`. The variable-aware display is needed so `etaq(t, 1, 20)` (Phase 33-03) shows terms in `t`.

Output: Modified eval.rs (symbol arithmetic), format.rs (variable-aware formatting), display.rs (polynomial sentinel).
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-symbolic-variable-foundation/33-CONTEXT.md
@.planning/phases/33-symbolic-variable-foundation/33-RESEARCH.md
@.planning/phases/33-symbolic-variable-foundation/33-01-SUMMARY.md

Key source files:
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-core/src/series/display.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/symbol.rs
@crates/qsym-cli/src/environment.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement symbol arithmetic in eval.rs</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
    **Polynomial sentinel constant:**

    Add a module-level constant for polynomial truncation order:
    ```rust
    /// Sentinel truncation order for exact polynomials (no O(...) in display).
    /// Chosen to be large enough to never interfere with real truncation orders,
    /// but small enough to avoid overflow in min() comparisons.
    const POLYNOMIAL_ORDER: i64 = 1_000_000_000;
    ```

    **Helper function: symbol_to_series**

    Add a helper that promotes a `Value::Symbol` to a monomial `FormalPowerSeries` (var^1):
    ```rust
    /// Promote a symbol to a FPS monomial (var^1) with polynomial truncation order.
    fn symbol_to_series(name: &str, env: &mut Environment) -> FormalPowerSeries {
        let sym_id = env.symbols.intern(name);
        FormalPowerSeries::monomial(sym_id, QRat::one(), 1, POLYNOMIAL_ORDER)
    }
    ```

    Note: Uses `POLYNOMIAL_ORDER` (not `env.default_order`) because symbol arithmetic creates polynomials, not truncated series. When a polynomial interacts with a truncated series later, `min(POLYNOMIAL_ORDER, 20)` = 20, giving correct behavior.

    **Helper function: value_to_series**

    Add a helper that promotes `Value::Symbol`, `Value::Integer`, or `Value::Rational` to a series for mixed arithmetic:
    ```rust
    /// Try to promote a value to a FPS for mixed arithmetic with series.
    /// Symbols become var^1 monomials; integers/rationals become constants.
    fn value_to_series(val: &Value, env: &mut Environment) -> Option<FormalPowerSeries> {
        match val {
            Value::Symbol(name) => Some(symbol_to_series(name, env)),
            Value::Integer(n) => {
                let sym_q = env.sym_q;
                Some(FormalPowerSeries::monomial(sym_q, QRat::from(n.clone()), 0, POLYNOMIAL_ORDER))
            }
            Value::Rational(r) => {
                let sym_q = env.sym_q;
                Some(FormalPowerSeries::monomial(sym_q, r.clone(), 0, POLYNOMIAL_ORDER))
            }
            _ => None,
        }
    }
    ```

    **Step 1: Update eval_pow for Symbol ^ Integer**

    In `eval_pow()`, add a new match arm BEFORE the error fallback:
    ```rust
    (Value::Symbol(name), Value::Integer(n)) => {
        let exp = n.0.to_i64().ok_or_else(|| EvalError::Other(
            "exponent too large".to_string(),
        ))?;
        let sym_id = env.symbols.intern(name);
        let fps = FormalPowerSeries::monomial(sym_id, QRat::one(), exp, POLYNOMIAL_ORDER);
        Ok(Value::Series(fps))
    }
    ```

    This handles `q^2`, `q^(-1)`, `t^3`, etc.

    **IMPORTANT:** `eval_pow` currently takes `(left: Value, right: Value)` without `env`. It needs `env` for symbol interning. Change the signature to:
    ```rust
    fn eval_pow(left: Value, right: Value, env: &mut Environment) -> Result<Value, EvalError>
    ```
    And update the call site in `eval_binop` accordingly. Note: `eval_binop` currently takes `env: &Environment` (immutable). Change it to `env: &mut Environment` so it can pass `&mut` to eval_pow. Then trace the call chain: `eval_expr` -> `eval_binop` -> `eval_pow`. The `eval_expr` already has `env: &mut Environment`, so passing `&mut` to eval_binop is fine. Also update the signatures of `eval_add`, `eval_sub`, `eval_mul`, `eval_div` to accept `&mut Environment` (needed for symbol promotion).

    **Step 2: Update eval_mul for Symbol * Integer and Integer * Symbol**

    In `eval_mul()`, add arms for symbol multiplication:
    ```rust
    // Symbol * Integer or Integer * Symbol -> monomial series
    (Value::Symbol(_), _) | (_, Value::Symbol(_)) => {
        let a = value_to_series(&left, env);
        let b = value_to_series(&right, env);
        if let (Some(fa), Some(fb)) = (a, b) {
            Ok(Value::Series(arithmetic::mul(&fa, &fb)))
        } else {
            Err(EvalError::TypeError {
                operation: "*".to_string(),
                left: left.type_name().to_string(),
                right: right.type_name().to_string(),
            })
        }
    }
    ```

    Place this BEFORE the existing TypeError fallback arm. This handles `2*q`, `q*3`, `q*q`, etc.

    Also add: Symbol * Series and Series * Symbol:
    ```rust
    (Value::Symbol(_), Value::Series(fps)) => {
        let sym_fps = value_to_series(&left, env).unwrap();
        Ok(Value::Series(arithmetic::mul(&sym_fps, fps)))
    }
    (Value::Series(fps), Value::Symbol(_)) => {
        let sym_fps = value_to_series(&right, env).unwrap();
        Ok(Value::Series(arithmetic::mul(fps, &sym_fps)))
    }
    ```

    **Step 3: Update eval_add for Symbol + anything and anything + Symbol**

    In `eval_add()`, add arms for symbol addition (before the error fallback):
    ```rust
    // Symbol involved: promote to series
    (Value::Symbol(_), _) | (_, Value::Symbol(_)) => {
        let a = value_to_series(&left, env);
        let b = value_to_series(&right, env);
        if let (Some(fa), Some(fb)) = (a, b) {
            Ok(Value::Series(arithmetic::add(&fa, &fb)))
        } else {
            Err(EvalError::TypeError {
                operation: "+".to_string(),
                left: left.type_name().to_string(),
                right: right.type_name().to_string(),
            })
        }
    }
    ```

    Also add Symbol + Series and Series + Symbol:
    ```rust
    (Value::Symbol(_), Value::Series(fps)) => {
        let sym_fps = value_to_series(&left, env).unwrap();
        Ok(Value::Series(arithmetic::add(&sym_fps, fps)))
    }
    (Value::Series(fps), Value::Symbol(_)) => {
        let sym_fps = value_to_series(&right, env).unwrap();
        Ok(Value::Series(arithmetic::add(fps, &sym_fps)))
    }
    ```

    **Step 4: Update eval_sub for Symbol - anything and anything - Symbol**

    Same pattern as eval_add but with `arithmetic::sub`.

    **Step 5: Update eval_negate for -Symbol**

    In `eval_negate()`, add:
    ```rust
    Value::Symbol(name) => {
        // -symbol -> negate the monomial: -(var^1)
        // We need env here, but eval_negate doesn't have it.
        // Instead, produce TypeError for now. The user can write -(q) which will
        // work when q is promoted to series in the enclosing expression.
        // OR: change eval_negate to accept &mut Environment.
    }
    ```

    **Decision:** Change `eval_negate` signature to `fn eval_negate(val: Value, env: &mut Environment)`. Add:
    ```rust
    Value::Symbol(name) => {
        let fps = symbol_to_series(&name, env);
        Ok(Value::Series(arithmetic::negate(&fps)))
    }
    ```

    Update the call site in `eval_expr` Neg arm.

    **Step 6: Update eval_div for Symbol / Integer**

    In `eval_div()`, add symbol handling:
    ```rust
    // Symbol / scalar -> series / scalar
    (Value::Symbol(_), _) if value_to_qrat(&right).is_some() => {
        let sym_fps = value_to_series(&left, env).unwrap();
        let s = value_to_qrat(&right).unwrap();
        let inv_s = QRat::one() / s;
        Ok(Value::Series(arithmetic::scalar_mul(&inv_s, &sym_fps)))
    }
    ```

    **Step 7: Re-enable any `#[ignore]` tests from Plan 33-01**

    If Plan 33-01 marked tests like `eval_series_add` or `eval_scalar_mul_series` as `#[ignore]`, remove the `#[ignore]` attribute now. Update them to construct expressions using `AstNode::Variable("q")` and verify that the symbol arithmetic produces the correct series output.

    **Step 8: Add new unit tests for symbol arithmetic**

    Add tests in eval.rs:
    - `eval_symbol_pow`: `q^2` -> Series with one term at power 2, coefficient 1
    - `eval_symbol_pow_negative`: `q^(-1)` -> Series with one term at power -1
    - `eval_symbol_mul_int`: `2*q^3` -> Series with one term at power 3, coefficient 2
    - `eval_symbol_add`: `q + 1` -> Series with two terms (constant 1, power 1 coefficient 1)
    - `eval_polynomial_arithmetic`: `(q+1)*(q+1)` -> Series with terms at 0,1,2 with coefficients 1,2,1
    - `eval_symbol_negate`: `-q` -> Series with one term at power 1, coefficient -1
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib -- eval::tests 2>&1 | tail -20`

    Expect: All eval tests pass including new symbol arithmetic tests.
  </verify>
  <done>
    Symbol arithmetic works: `q^2` produces a monomial, `2*q` produces a scaled monomial, `q^2 + q + 1` produces a polynomial (series with POLYNOMIAL_ORDER sentinel). All arithmetic operations handle Value::Symbol by promoting to FPS.
  </done>
</task>

<task type="auto">
  <name>Task 2: Variable-aware series formatting and polynomial display</name>
  <files>
    crates/qsym-cli/src/format.rs
    crates/qsym-cli/src/main.rs
    crates/qsym-cli/src/script.rs
    crates/qsym-cli/src/commands.rs
    crates/qsym-cli/src/repl.rs
    crates/qsym-core/src/series/display.rs
  </files>
  <action>
    **Step 1: Add SymbolRegistry parameter to format_value and format_latex**

    Change signatures in format.rs:
    ```rust
    pub fn format_value(val: &Value, symbols: &SymbolRegistry) -> String
    pub fn format_latex(val: &Value, symbols: &SymbolRegistry) -> String
    ```

    Add the `use qsym_core::symbol::SymbolRegistry;` import (it may already be imported in tests).

    For the `Value::Series(fps)` arm, replace `format!("{}", fps)` with a call to a new `format_series` function:
    ```rust
    Value::Series(fps) => format_series(fps, symbols),
    ```

    For recursive calls in `format_list`, `format_dict`, `format_pair` -- propagate `symbols`:
    ```rust
    fn format_list(items: &[Value], symbols: &SymbolRegistry) -> String { ... }
    fn format_dict(entries: &[(String, Value)], symbols: &SymbolRegistry) -> String { ... }
    ```

    Update all internal calls to pass `symbols`.

    **Step 2: Implement format_series with variable name lookup**

    Port the logic from `crates/qsym-core/src/series/display.rs` into a new `format_series` function in format.rs that uses `symbols.name(fps.variable())` instead of hardcoded `"q"`:

    ```rust
    fn format_series(fps: &FormalPowerSeries, symbols: &SymbolRegistry) -> String {
        let var = symbols.name(fps.variable());
        let trunc = fps.truncation_order();
        let is_polynomial = trunc >= POLYNOMIAL_ORDER;
        // ... same logic as Display impl, but using `var` from registry
        // and suppressing O(...) when is_polynomial is true
    }
    ```

    Import `POLYNOMIAL_ORDER` from eval.rs or define a shared constant. Since eval.rs is in the same crate, either make it `pub(crate) const POLYNOMIAL_ORDER` or define it in a common location (e.g., format.rs can define its own matching constant, or a small constants module).

    **Recommendation:** Make the constant `pub(crate)` in eval.rs and import it in format.rs:
    ```rust
    use crate::eval::POLYNOMIAL_ORDER;
    ```

    The format_series function logic:
    1. Get variable name from symbols registry
    2. Iterate over coefficients (same as Display impl)
    3. Use `var` instead of `"q"` in all output
    4. At the end, only append `O({var}^{trunc})` if `trunc < POLYNOMIAL_ORDER`

    **Step 3: Implement fps_to_latex with variable name**

    Update `fps_to_latex` to accept `symbols: &SymbolRegistry`:
    ```rust
    fn fps_to_latex(fps: &FormalPowerSeries, symbols: &SymbolRegistry) -> String
    ```

    Use `let var = symbols.name(fps.variable());` and replace hardcoded `"q"` with `var`. Also suppress `O(...)` for polynomial sentinel.

    Update `latex_term` to accept `var: &str` parameter instead of hardcoded `"q"`:
    ```rust
    fn latex_term(out: &mut String, first: bool, k: i64, c: &QRat, var: &str)
    ```

    **Step 4: Update all call sites of format_value and format_latex**

    Search the crate for all calls to `format_value` and `format_latex`. Each needs `&env.symbols` or `&symbols` passed as the second argument.

    Call sites to update:
    - `crates/qsym-cli/src/main.rs`: In `run_interactive`, line ~315: `format_value(&val)` -> `format_value(&val, &env.symbols)`
    - `crates/qsym-cli/src/script.rs`: In `execute_source_with_context`, line ~167: `format_value(&val)` -> `format_value(&val, &env.symbols)`
    - `crates/qsym-cli/src/commands.rs`: In `execute_command`, the `Latex` arms use `format_latex(val)` -> `format_latex(val, &env.symbols)`. The `save_to_file` uses `format_value(val)` -> needs symbols too. **BUT** these functions receive `&mut Environment`, not just `&SymbolRegistry`. That's fine: pass `&env.symbols`.

    **Important:** `execute_command` and `save_to_file` need access to `&SymbolRegistry`. Currently `execute_command` takes `env: &mut Environment`. Extract `&env.symbols` inside the function and pass it down. For `save_to_file`, change its signature to also accept `&SymbolRegistry`, OR accept `&Environment` (currently `&Environment`).

    Specifically in commands.rs:
    - `execute_command`: Add `let symbols = &env.symbols;` at the top, then pass `symbols` to `format_latex` and delegate to `save_to_file`.
    - `save_to_file`: Change to `fn save_to_file(filename: &str, env: &Environment) -> CommandResult` (already is this) and pass `&env.symbols` to `format_value`.

    **Step 5: Update format.rs tests**

    All existing format tests call `format_value(&val)` without symbols. Update to pass a `&SymbolRegistry`:
    ```rust
    let mut reg = SymbolRegistry::new();
    // For tests that don't involve series, an empty registry is fine
    assert_eq!(format_value(&val, &reg), "expected");
    ```

    For series tests, create a registry with "q" interned:
    ```rust
    let mut reg = SymbolRegistry::new();
    let sym_q = reg.intern("q");
    ```

    **Step 6: Update commands.rs tests**

    Tests in commands.rs that call `execute_command` should work without changes since `execute_command` already takes `&mut Environment` which has `symbols`. But check the import for `format_latex` and `format_value` in commands.rs -- they're imported at the top (`use crate::format::{format_latex, format_value};`). The signature change will require updates to these calls.

    **Step 7: Add tests for polynomial vs series display**

    Add format.rs tests:
    - `format_polynomial_no_truncation`: Create a FPS with `POLYNOMIAL_ORDER` truncation, verify output has no `O(...)`.
    - `format_series_with_truncation`: Create a FPS with truncation 20, verify output has `O(q^20)`.
    - `format_series_variable_name`: Create a FPS with variable "t" (intern "t" in registry), verify output uses `t` not `q`.

    **Step 8: Suppress O(...) in core Display for polynomial sentinel (optional)**

    In `crates/qsym-core/src/series/display.rs`, optionally add a check:
    ```rust
    // Suppress O(...) for polynomial sentinel truncation
    if self.truncation_order < 1_000_000_000 {
        write!(f, " + O({}^{})", var, self.truncation_order)?;
    }
    ```

    This affects the core Display (used in debug output, Python API, etc.). It's a good defense-in-depth change. The core Display will still use hardcoded "q" -- the CLI format_series uses the registry. This is fine per the research recommendation (Option B).
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -20`

    Also verify end-to-end:
    `cargo run -p qsym-cli -- -c "q^2 + q + 1" 2>&1`
    Expected output: `1 + q + q^2` (no O(...) since it's a polynomial)

    `cargo run -p qsym-cli -- -c "etaq(1,1,5)" 2>&1`
    Expected output: `1 - q - q^2 + ... + O(q^5)` (with O(...) since it's a truncated series)
  </verify>
  <done>
    Variable-aware series formatting works: series in variable "t" display with "t". Polynomials (created by symbol arithmetic) display without O(...) truncation. Series from functions display with O(q^N). All format_value/format_latex call sites updated with &SymbolRegistry parameter. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` passes all tests
2. `q-kangaroo -c "q^2"` prints a monomial (e.g., `q^2`) with no O(...)
3. `q-kangaroo -c "(q+1)*(q+1)"` prints `1 + 2*q + q^2` with no O(...)
4. `q-kangaroo -c "etaq(1,1,5)"` prints series with `O(q^5)`
5. `q-kangaroo -c "2*q^3 + q + 1"` prints `1 + q + 2*q^3` with no O(...)
</verification>

<success_criteria>
- Symbol ^ Integer produces a monomial series
- Integer * Symbol and Symbol * Integer produce scaled monomials
- Symbol + Symbol, Symbol + Integer, Symbol + Series all work via FPS promotion
- Polynomial display (sentinel truncation) shows no O(...) suffix
- Truncated series from functions still show O(q^N) suffix
- format_value and format_latex use SymbolRegistry for variable names
- Series in non-q variables display with the correct variable name
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-symbolic-variable-foundation/33-02-SUMMARY.md`
</output>
