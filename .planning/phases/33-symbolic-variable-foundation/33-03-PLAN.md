---
phase: 33-symbolic-variable-foundation
plan: 03
type: execute
wave: 2
depends_on: [33-01]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/commands.rs
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements:
  - SYM-02
  - SYM-03

must_haves:
  truths:
    - "`etaq(q, 1, 20)` works -- q is accepted as a function parameter and produces the correct q-series"
    - "`aqprod(q^2, q, 5)` works -- q-monomial is accepted as a function argument"
    - "Any symbol can be used as the base variable: `etaq(t, 1, 20)` works and displays in `t`"
    - "`restart` command clears all user-defined variables"
    - "`anames()` lists all currently defined variables"
    - "`x := 'x'` removes the variable binding for x (Maple unassign syntax)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Function dispatch recognizing Value::Symbol as variable parameter; anames function; unassign logic"
      contains: "extract_symbol_id"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Single-quote string literal support for unassign syntax"
      contains: "single quote"
    - path: "crates/qsym-cli/src/commands.rs"
      provides: "restart command"
      contains: "Command::Restart"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "End-to-end tests for all Phase 33 success criteria"
      contains: "etaq_with_symbol"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/qseries.rs"
      via: "Function dispatch extracts SymbolId from Value::Symbol and passes to qseries functions"
      pattern: "extract_symbol_id"
    - from: "crates/qsym-cli/src/lexer.rs"
      to: "crates/qsym-cli/src/eval.rs"
      via: "Single-quoted strings flow through parser to Assign handler for unassign"
      pattern: "StringLit"
---

<objective>
Make function dispatch accept `Value::Symbol` as a variable parameter (so `etaq(q, 1, 20)` and `aqprod(q^2, q, 5)` work), add single-quote lexer support for unassign syntax (`x := 'x'`), add `restart` command, add `anames()` function, and create integration tests for all Phase 33 success criteria.

Purpose: This plan completes SYM-02 (q accepted as function parameter) and SYM-03 (q-monomial args). It also delivers the three user-decided variable management features (restart, anames, unassign). Together with Plans 33-01 and 33-02, this completes the entire Phase 33.

Output: Modified eval.rs (function dispatch), lexer.rs (single quotes), commands.rs (restart), repl.rs (tab completion), integration tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-symbolic-variable-foundation/33-CONTEXT.md
@.planning/phases/33-symbolic-variable-foundation/33-RESEARCH.md
@.planning/phases/33-symbolic-variable-foundation/33-01-SUMMARY.md
@.planning/phases/33-symbolic-variable-foundation/33-02-SUMMARY.md

Key source files:
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/commands.rs
@crates/qsym-cli/src/repl.rs
@crates/qsym-cli/src/environment.rs
@crates/qsym-cli/tests/cli_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Function dispatch with symbol args + single-quote lexer + variable management</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/lexer.rs
    crates/qsym-cli/src/commands.rs
    crates/qsym-cli/src/repl.rs
  </files>
  <action>
    **Part A: Helper functions for function dispatch**

    Add to eval.rs:

    ```rust
    /// Extract a SymbolId from a Value::Symbol, interning it in the registry.
    fn extract_symbol_id(
        name: &str,
        args: &[Value],
        index: usize,
        env: &mut Environment,
    ) -> Result<SymbolId, EvalError> {
        match &args[index] {
            Value::Symbol(s) => Ok(env.symbols.intern(s)),
            other => Err(EvalError::ArgType {
                function: name.to_string(),
                arg_index: index,
                expected: "symbol (variable name)",
                got: other.type_name().to_string(),
            }),
        }
    }
    ```

    Add import for `SymbolId`:
    ```rust
    use qsym_core::symbol::SymbolId;
    ```

    **Part B: Update `etaq` dispatch for Maple-style signature**

    Current `etaq` accepts `etaq(b, t, order)` where b and t are integers.
    New: Also accept `etaq(q, b, order)` where first arg is a symbol (the variable).

    Replace the `"etaq"` arm with:
    ```rust
    "etaq" => {
        if args.len() >= 2 && matches!(&args[0], Value::Symbol(_)) {
            // Maple-style: etaq(var, delta_or_b, order)
            // etaq(q, 1, 20) -> etaq(b=1, t=1, sym=q, order=20)
            // For Phase 33: etaq(var, b, order) with t=1 default
            expect_args(name, args, 3)?;
            let sym = extract_symbol_id(name, args, 0, env)?;
            let b = extract_i64(name, args, 1)?;
            let order = extract_i64(name, args, 2)?;
            let result = qseries::etaq(b, 1, sym, order);
            Ok(Value::Series(result))
        } else {
            // Legacy: etaq(b, t, order)
            expect_args(name, args, 3)?;
            let b = extract_i64(name, args, 0)?;
            let t = extract_i64(name, args, 1)?;
            let order = extract_i64(name, args, 2)?;
            let result = qseries::etaq(b, t, env.sym_q, order);
            Ok(Value::Series(result))
        }
    }
    ```

    **Part C: Update `aqprod` dispatch for Maple-style signature**

    Current `aqprod` takes `aqprod(cn, cd, power, n_or_infinity, order)` with 5 integer/infinity args.
    New: Also accept `aqprod(monomial_series, symbol_var, order_or_n)` forms.

    When the first argument is a `Value::Series` (a monomial from `q^2`) or `Value::Symbol`:

    ```rust
    "aqprod" => {
        // Detect Maple-style: first arg is Series (monomial like q^2) or Symbol
        if !args.is_empty() && matches!(&args[0], Value::Series(_) | Value::Symbol(_)) {
            // aqprod(a, q, n) where a is a monomial/polynomial, q is the variable, n is finite order
            // or aqprod(a, q, infinity, order) for infinite product
            let monomial = extract_monomial_from_arg(name, args, 0)?;
            let sym = extract_symbol_id(name, args, 1, env)?;

            if args.len() == 3 {
                // aqprod(q^2, q, 5) -> finite product, n=args[2]
                let n = extract_i64(name, args, 2)?;
                let result = qseries::aqprod(&monomial, sym, PochhammerOrder::Finite(n), n);
                Ok(Value::Series(result))
            } else if args.len() == 4 {
                // aqprod(q^2, q, infinity, order) or aqprod(q^2, q, n, order)
                let poch_order = match &args[2] {
                    Value::Infinity => PochhammerOrder::Infinite,
                    _ => {
                        let n = extract_i64(name, args, 2)?;
                        PochhammerOrder::Finite(n)
                    }
                };
                let order = extract_i64(name, args, 3)?;
                let result = qseries::aqprod(&monomial, sym, poch_order, order);
                Ok(Value::Series(result))
            } else {
                Err(EvalError::WrongArgCount {
                    function: name.to_string(),
                    expected: "3 or 4 (Maple-style)".to_string(),
                    got: args.len(),
                    signature: "aqprod(monomial, q, n) or aqprod(monomial, q, n, order)".to_string(),
                })
            }
        } else {
            // Legacy: aqprod(cn, cd, power, n_or_infinity, order)
            expect_args(name, args, 5)?;
            let cn = extract_i64(name, args, 0)?;
            let cd = extract_i64(name, args, 1)?;
            let power = extract_i64(name, args, 2)?;
            let poch_order = match &args[3] {
                Value::Infinity => PochhammerOrder::Infinite,
                _ => {
                    let n = extract_i64(name, args, 3)?;
                    PochhammerOrder::Finite(n)
                }
            };
            let order = extract_i64(name, args, 4)?;
            let monomial = QMonomial::new(QRat::from((cn, cd)), power);
            let result = qseries::aqprod(&monomial, env.sym_q, poch_order, order);
            Ok(Value::Series(result))
        }
    }
    ```

    **Helper: extract_monomial_from_arg**

    Add a helper to extract a `QMonomial` from a `Value::Series` (monomial) or `Value::Symbol`:
    ```rust
    /// Extract a QMonomial from an argument that is a Symbol (var^1) or a Series monomial.
    fn extract_monomial_from_arg(
        func_name: &str,
        args: &[Value],
        index: usize,
    ) -> Result<QMonomial, EvalError> {
        match &args[index] {
            Value::Symbol(_) => {
                // Symbol = var^1, coefficient 1
                Ok(QMonomial::new(QRat::one(), 1))
            }
            Value::Series(fps) => {
                // Extract monomial from single-term series
                let terms: Vec<_> = fps.iter().collect();
                if terms.len() == 1 {
                    let (&power, coeff) = terms[0];
                    Ok(QMonomial::new(coeff.clone(), power))
                } else if terms.is_empty() {
                    Ok(QMonomial::new(QRat::zero(), 0))
                } else {
                    Err(EvalError::ArgType {
                        function: func_name.to_string(),
                        arg_index: index,
                        expected: "monomial (single-term series like q^2)",
                        got: format!("polynomial with {} terms", terms.len()),
                    })
                }
            }
            Value::Integer(n) => {
                Ok(QMonomial::new(QRat::from(n.clone()), 0))
            }
            other => Err(EvalError::ArgType {
                function: func_name.to_string(),
                arg_index: index,
                expected: "monomial expression (e.g., q^2) or symbol",
                got: other.type_name().to_string(),
            }),
        }
    }
    ```

    Import `QRat::zero` and `QRat::one` if not already imported.

    **Part D: Add `anames` function**

    In `dispatch()`, add a new arm:
    ```rust
    "anames" => {
        expect_args(name, args, 0)?;
        let mut names: Vec<String> = env.variables.keys().cloned().collect();
        names.sort();
        Ok(Value::List(names.into_iter().map(Value::String).collect()))
    }
    ```

    Add "anames" to `ALL_FUNCTION_NAMES` array in eval.rs and to the canonical function names list in repl.rs.

    **Part E: Add unassign logic (`x := 'x'`)**

    This requires single-quote string literal support in the lexer.

    In `lexer.rs`, add single-quote string handling right after the double-quote string handling block:

    ```rust
    // Single-quoted string literals (for Maple unassign syntax: x := 'x')
    if b == b'\'' {
        let start = pos;
        pos += 1; // skip opening quote
        let mut value = String::new();
        while pos < bytes.len() && bytes[pos] != b'\'' {
            value.push(bytes[pos] as char);
            pos += 1;
        }
        if pos >= bytes.len() {
            return Err(ParseError::new(
                "unterminated single-quoted string".to_string(),
                Span::new(start, pos),
            ));
        }
        pos += 1; // skip closing quote
        tokens.push(SpannedToken {
            token: Token::StringLit(value),
            span: Span::new(start, pos),
        });
        continue;
    }
    ```

    Note: Single-quoted strings produce the same `Token::StringLit` as double-quoted strings. No escape processing for single-quoted strings (simpler, matches Maple behavior where `'x'` is literally the name `x`).

    In `eval.rs`, update the `AstNode::Assign` arm to check for unassign:
    ```rust
    AstNode::Assign { name, value } => {
        // Check for Maple unassign syntax: x := 'x'
        // After parsing, 'x' becomes AstNode::StringLit("x")
        if let AstNode::StringLit(s) = value.as_ref() {
            if s == name {
                env.variables.remove(name);
                return Ok(Value::Symbol(name.clone()));
            }
        }
        let val = eval_expr(value, env)?;
        env.set_var(name, val.clone());
        Ok(val)
    }
    ```

    **Part F: Add `restart` command**

    In `commands.rs`, add `Restart` to the Command enum:
    ```rust
    /// Reset all session state (Maple-style restart).
    Restart,
    ```

    In `parse_command`, add:
    ```rust
    "restart" => {
        if words.len() == 1 && !trimmed.contains('(') {
            Some(Command::Restart)
        } else {
            None
        }
    }
    ```

    In `execute_command`, add:
    ```rust
    Command::Restart => {
        env.reset();
        CommandResult::Output("Restart.".to_string())
    }
    ```

    **Part G: Update tab completion**

    In `repl.rs`, add "restart" to the `command_names` vec in `ReplHelper::new()`:
    ```rust
    command_names: vec!["help", "quit", "exit", "clear", "restart", "set", "latex", "save"],
    ```

    Add "anames" to the `canonical_function_names()` list in repl.rs.

    **Part H: Add unit tests**

    In eval.rs, add tests:
    - `eval_etaq_with_symbol`: Build `AstNode::FuncCall { name: "etaq", args: [Variable("q"), Integer(1), Integer(5)] }`, verify result is `Value::Series` with correct terms.
    - `eval_anames_empty`: Call `anames()` with no vars, expect empty list.
    - `eval_anames_with_vars`: Set `x := 42` and `y := 7`, call `anames()`, expect `["x", "y"]`.
    - `eval_unassign`: Set `x := 42`, then eval `x := 'x'` (Assign with StringLit), then eval `x`, expect `Value::Symbol("x")`.

    In lexer.rs, add tests:
    - `test_single_quote_string`: tokenize `'hello'`, expect `Token::StringLit("hello")`.
    - `test_unassign_syntax`: tokenize `x := 'x'`, expect `[Ident("x"), Assign, StringLit("x"), Eof]`.

    In commands.rs, add tests:
    - `parse_restart`: `parse_command("restart")` -> `Some(Command::Restart)`.
    - `execute_restart_clears_vars`: Set some vars, execute Restart, verify variables cleared.
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib 2>&1 | tail -20`

    Expect: All unit tests pass.
  </verify>
  <done>
    Function dispatch accepts Value::Symbol as variable parameter for etaq and aqprod. Single-quote strings work in the lexer. `x := 'x'` unassigns x. `restart` command clears the session. `anames()` lists variables. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end integration tests for all Phase 33 success criteria</name>
  <files>
    crates/qsym-cli/tests/cli_integration.rs
  </files>
  <action>
    Add comprehensive integration tests to `cli_integration.rs` that verify all Phase 33 success criteria end-to-end.

    **Success Criterion 1: Bare symbol evaluation**

    ```rust
    #[test]
    fn sym_01_bare_symbol_returns_symbol() {
        let (code, stdout, _) = run(&["-c", "f"]);
        assert_eq!(code, 0, "SYM-01: bare symbol should succeed");
        assert_eq!(stdout.trim(), "f", "SYM-01: should print symbol name");
    }

    #[test]
    fn sym_01_bare_q_returns_symbol() {
        let (code, stdout, _) = run(&["-c", "q"]);
        assert_eq!(code, 0, "SYM-01: bare q should succeed");
        assert_eq!(stdout.trim(), "q", "SYM-01: should print q as symbol");
    }

    #[test]
    fn sym_01_long_name_symbol() {
        let (code, stdout, _) = run(&["-c", "myVariable"]);
        assert_eq!(code, 0, "SYM-01: long names should work");
        assert_eq!(stdout.trim(), "myVariable");
    }
    ```

    **Success Criterion 2: etaq(q, 1, 20) works**

    ```rust
    #[test]
    fn sym_02_etaq_with_q_symbol() {
        let (code, stdout, stderr) = run(&["-c", "etaq(q, 1, 20)"]);
        assert_eq!(code, 0, "SYM-02: etaq(q, 1, 20) should succeed. stderr: {}", stderr);
        assert!(stdout.contains("q"), "should contain q variable");
        assert!(stdout.contains("O(q^20)"), "should show truncation at order 20");
    }

    #[test]
    fn sym_02_etaq_with_t_symbol() {
        // Any symbol can be the base variable
        let (code, stdout, stderr) = run(&["-c", "etaq(t, 1, 10)"]);
        assert_eq!(code, 0, "SYM-02: etaq(t, 1, 10) should succeed. stderr: {}", stderr);
        assert!(stdout.contains("t"), "should display in variable t");
        assert!(stdout.contains("O(t^10)"), "should show truncation with t variable");
    }

    #[test]
    fn sym_02_etaq_legacy_still_works() {
        // Legacy syntax etaq(b, t, order) should still work
        let (code, stdout, _) = run(&["-c", "etaq(1, 1, 10)"]);
        assert_eq!(code, 0, "legacy etaq(1,1,10) should still work");
        assert!(stdout.contains("q"), "legacy output uses q");
    }
    ```

    **Success Criterion 3: aqprod(q^2, q, 5) works**

    ```rust
    #[test]
    fn sym_03_aqprod_with_monomial() {
        let (code, stdout, stderr) = run(&["-c", "aqprod(q^2, q, 5)"]);
        assert_eq!(code, 0, "SYM-03: aqprod(q^2, q, 5) should succeed. stderr: {}", stderr);
        // Should produce a polynomial (finite product)
        assert!(!stdout.trim().is_empty(), "should produce output");
    }

    #[test]
    fn sym_03_aqprod_legacy_still_works() {
        // Legacy: aqprod(1, 1, 1, infinity, 20)
        let (code, stdout, _) = run(&["-c", "aqprod(1, 1, 1, infinity, 20)"]);
        assert_eq!(code, 0, "legacy aqprod should still work");
        assert!(stdout.contains("q"), "should produce q-series");
    }
    ```

    **Success Criterion 4: Assignment precedence**

    ```rust
    #[test]
    fn sym_04_assignment_precedence() {
        let (code, stdout, _) = run(&["-c", "x := 42:\nx"]);
        assert_eq!(code, 0, "SYM-04: assignment should work");
        assert_eq!(stdout.trim(), "42", "SYM-04: assigned value takes precedence");
    }

    #[test]
    fn sym_04_q_reassignment() {
        // q is NOT protected from reassignment
        let (code, stdout, _) = run(&["-c", "q := 5:\nq"]);
        assert_eq!(code, 0, "q should be reassignable");
        assert_eq!(stdout.trim(), "5", "q should return assigned value");
    }
    ```

    **Polynomial arithmetic and display**

    ```rust
    #[test]
    fn polynomial_arithmetic() {
        let (code, stdout, _) = run(&["-c", "(q + 1) * (q + 1)"]);
        assert_eq!(code, 0, "polynomial multiplication should work");
        // Should be 1 + 2*q + q^2 with no O(...)
        assert!(stdout.contains("1"), "should have constant term");
        assert!(stdout.contains("q^2") || stdout.contains("q^2"), "should have q^2");
        assert!(!stdout.contains("O("), "polynomial should not have O(...) truncation");
    }

    #[test]
    fn polynomial_display_no_truncation() {
        let (code, stdout, _) = run(&["-c", "q^2 + q + 1"]);
        assert_eq!(code, 0);
        assert!(!stdout.contains("O("), "polynomial should not have O(...) truncation");
    }

    #[test]
    fn series_display_has_truncation() {
        let (code, stdout, _) = run(&["-c", "etaq(1, 1, 5)"]);
        assert_eq!(code, 0);
        assert!(stdout.contains("O(q^5)"), "series should have O(q^5) truncation");
    }
    ```

    **Variable management**

    ```rust
    #[test]
    fn restart_command_in_script() {
        let tmp = write_temp_script("qk_test_restart.qk", "x := 42:\nrestart:\nanames()");
        let (code, stdout, stderr) = run(&[tmp.to_str().unwrap()]);
        assert_eq!(code, 0, "restart in script should work. stderr: {}", stderr);
        // After restart, anames() should return empty list
        // Output should include "Restart." and "[]"
        assert!(stdout.contains("[]"), "anames() after restart should be empty. stdout: {}", stdout);
        std::fs::remove_file(&tmp).ok();
    }

    #[test]
    fn anames_function() {
        let (code, stdout, _) = run(&["-c", "x := 1:\ny := 2:\nanames()"]);
        assert_eq!(code, 0, "anames() should work");
        // Should list x and y
        assert!(stdout.contains("x"), "should list x");
        assert!(stdout.contains("y"), "should list y");
    }

    #[test]
    fn unassign_via_single_quote() {
        let tmp = write_temp_script("qk_test_unassign.qk", "x := 42:\nx := 'x':\nx");
        let (code, stdout, _) = run(&[tmp.to_str().unwrap()]);
        assert_eq!(code, 0, "unassign should work");
        // After unassign, x is a symbol again
        assert_eq!(stdout.trim(), "x", "after unassign, x should be a symbol");
    }
    ```
  </action>
  <verify>
    Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --test cli_integration 2>&1 | tail -30`

    Expect: All integration tests pass, including the new Phase 33 tests and all pre-existing tests.
  </verify>
  <done>
    All Phase 33 success criteria verified end-to-end:
    1. Bare symbols work (f, q, myVariable all return symbols)
    2. etaq(q, 1, 20) works and produces correct q-series
    3. aqprod(q^2, q, 5) works with monomial argument
    4. Assignment precedence works (x := 42; x returns 42)
    Plus: restart, anames, unassign all work. Legacy function signatures still work. Polynomial display has no O(...). Series display has O(...).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` passes ALL tests (unit + integration)
2. `q-kangaroo -c "etaq(q, 1, 20)"` produces the correct eta quotient series
3. `q-kangaroo -c "etaq(t, 1, 10)"` produces series displayed in variable `t`
4. `q-kangaroo -c "aqprod(q^2, q, 5)"` produces the correct finite product
5. `q-kangaroo -c "q := 5:\nq"` returns 5 (q is reassignable)
6. `q-kangaroo -c "x := 42:\nx := 'x':\nx"` returns `x` (unassign works)
7. `q-kangaroo -c "anames()"` returns `[]` (no variables defined)
8. All legacy function calls (etaq(1,1,20), aqprod(1,1,1,infinity,20)) still work
</verification>

<success_criteria>
- etaq(q, 1, 20) dispatches correctly and produces matching output
- aqprod(q^2, q, 5) dispatches correctly with monomial extraction
- etaq(t, 1, 10) uses variable t and displays in t
- All legacy function signatures continue working
- restart command clears all user-defined variables
- anames() lists all currently defined variables
- x := 'x' removes the variable binding (Maple unassign syntax)
- Single-quote strings tokenize correctly in the lexer
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-symbolic-variable-foundation/33-03-SUMMARY.md`
</output>
