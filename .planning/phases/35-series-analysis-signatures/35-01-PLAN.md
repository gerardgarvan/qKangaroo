---
phase: 35-series-analysis-signatures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/qseries/prodmake.rs
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements: [SIG-08, SIG-09, SIG-10, SIG-11, SIG-12, SIG-13, SIG-14]

must_haves:
  truths:
    - "sift(s, q, 5, 2, 30) extracts the residue-2-mod-5 subseries with correct truncation"
    - "prodmake(f, q, 20) returns the same product decomposition as old prodmake(f, 20) but via 3-arg Maple call"
    - "etamake(f, q, 10) returns eta quotient form via 3-arg Maple call"
    - "jacprodmake(f, q, 10) returns Jacobi product form via 3-arg Maple call"
    - "jacprodmake(f, q, 10, P) restricts period search to divisors of P"
    - "mprodmake(f, q, 10) returns (1+q^n) product form via 3-arg Maple call"
    - "qetamake(f, q, 10) returns combined eta/q-Pochhammer form via 3-arg Maple call"
    - "qfactor(f, q) and qfactor(f, q, T) factor a polynomial with explicit q"
    - "Old signatures (sift(s,5,0), prodmake(f,10), etc.) produce wrong-arg-count errors"
  artifacts:
    - path: "crates/qsym-core/src/qseries/prodmake.rs"
      provides: "jacprodmake with optional period_divisor filter"
      contains: "period_divisor"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Maple-style dispatch for all 7 series analysis functions"
      contains: "extract_symbol_id"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qseries::sift"
      via: "5-arg dispatch extracting q, n, k, T"
      pattern: "sift.*extract_symbol_id"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qseries::jacprodmake"
      via: "3-arg or 4-arg dispatch with optional PP"
      pattern: "jacprodmake"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qseries::qfactor"
      via: "2-arg or 3-arg dispatch with explicit q"
      pattern: "qfactor.*extract_symbol_id"
---

<objective>
Migrate all 7 series analysis functions (sift, prodmake, etamake, jacprodmake, mprodmake, qetamake, qfactor) from old compact signatures to Garvan's exact Maple calling conventions. Remove old signatures completely (no backward compat). Add jacprodmake PP period filter to core.

Purpose: Researchers can call these functions identically to Garvan's Maple package
Output: Working Maple-style dispatch for all 7 functions, updated unit tests
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-series-analysis-signatures/35-RESEARCH.md
@.planning/phases/34-product-theta-signatures/34-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-core/src/qseries/prodmake.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add optional period_divisor to core jacprodmake</name>
  <files>crates/qsym-core/src/qseries/prodmake.rs</files>
  <action>
Add a new public function `jacprodmake_with_periods` (or modify the existing `jacprodmake`) to accept an optional period filter parameter. The cleanest approach:

1. Rename the existing `jacprodmake` to `jacprodmake_impl` (private) with signature:
   `fn jacprodmake_impl(f: &FormalPowerSeries, max_n: i64, period_divisor: Option<i64>) -> JacobiProductForm`

2. Keep `pub fn jacprodmake(f: &FormalPowerSeries, max_n: i64) -> JacobiProductForm` as a thin wrapper calling `jacprodmake_impl(f, max_n, None)`.

3. Add `pub fn jacprodmake_with_period_filter(f: &FormalPowerSeries, max_n: i64, pp: i64) -> JacobiProductForm` calling `jacprodmake_impl(f, max_n, Some(pp))`.

4. In `jacprodmake_impl`, when `period_divisor` is `Some(pp)`:
   - Instead of iterating `for b in 1..=effective_max`, iterate only over divisors of `pp` that are > 1 (matching Garvan's `numtheory[divisors](PP) minus {1}`).
   - Compute divisors: iterate 1..=pp.isqrt(), collect divisors, filter out 1, sort.
   - When `period_divisor` is `None`, keep the existing `for b in 1..=effective_max` loop.

5. Add a unit test `test_jacprodmake_with_period_filter` that verifies the period-filtered version produces the same result as the unfiltered version when PP contains the correct period.
  </action>
  <verify>
Run `cd C:/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-core jacprodmake` -- all jacprodmake tests pass including the new one.
  </verify>
  <done>
`jacprodmake_with_period_filter(f, max_n, pp)` restricts period search to divisors of pp > 1. Existing `jacprodmake(f, max_n)` unchanged in behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite dispatch blocks and unit tests for all 7 functions</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Replace ALL 7 dispatch blocks in Group 4 (lines ~1492-1573) with Maple-style signatures. Also update `get_signature` entries (lines ~2674-2682). Also rewrite all 7 unit tests (lines ~4074-4219).

**No backward compat** -- old argument counts produce wrong-arg-count errors.

**1. sift (SIG-08):** Replace 3-arg `sift(series, m, j)` with 5-arg `sift(s, q, n, k, T)`:
```rust
"sift" => {
    expect_args(name, args, 5)?;
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let n = extract_i64(name, args, 2)?;
    let k = extract_i64(name, args, 3)?;
    let t = extract_i64(name, args, 4)?;
    if n <= 0 {
        return Err(EvalError::Other(format!(
            "sift: Argument 3 (n): modulus must be positive, got {}", n
        )));
    }
    if k < 0 || k >= n {
        return Err(EvalError::Other(format!(
            "sift: Argument 4 (k): residue must satisfy 0 <= k < n={}, got {}", n, k
        )));
    }
    // Cap T at series truncation order
    let effective_t = t.min(fps.truncation_order());
    // Sift with the full series (core sift uses truncation_order internally)
    // then compute output truncation: floor((effective_t - k) / n) + 1
    let result = qseries::sift(&fps, n, k);
    let output_trunc = (effective_t - k) / n + 1;
    // Truncate result to output_trunc terms
    let mut truncated = FormalPowerSeries::zero(result.symbol_id(), output_trunc);
    for (&exp, coeff) in result.coeffs() {
        if exp >= 0 && exp < output_trunc {
            truncated.set_coeff(exp, coeff.clone());
        }
    }
    Ok(Value::Series(truncated))
}
```
NOTE: If `FormalPowerSeries::zero(sym_id, order)` doesn't exist with that signature, construct via `FormalPowerSeries::new(BTreeMap::new(), sym_id, output_trunc)` or similar. Check existing patterns. The core `sift` already returns a series -- we just need to cap its truncation_order. Alternatively, if `result.truncation_order()` is already <= `output_trunc`, just use the result directly.

**2. prodmake (SIG-09):** Replace 2-arg with 3-arg:
```rust
"prodmake" => {
    expect_args(name, args, 3)?;
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let max_n = extract_i64(name, args, 2)?;
    let result = qseries::prodmake(&fps, max_n);
    Ok(infinite_product_form_to_value(&result))
}
```

**3. etamake (SIG-10):** Replace 2-arg with 3-arg (same pattern as prodmake):
```rust
"etamake" => {
    expect_args(name, args, 3)?;
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let max_n = extract_i64(name, args, 2)?;
    let result = qseries::etamake(&fps, max_n);
    Ok(eta_quotient_to_value(&result))
}
```

**4. jacprodmake (SIG-11):** Replace 2-arg with 3-arg or 4-arg:
```rust
"jacprodmake" => {
    if args.len() == 3 {
        let fps = extract_series(name, args, 0)?;
        let _sym = extract_symbol_id(name, args, 1, env)?;
        let max_n = extract_i64(name, args, 2)?;
        let result = qseries::jacprodmake(&fps, max_n);
        Ok(jacobi_product_form_to_value(&result))
    } else if args.len() == 4 {
        let fps = extract_series(name, args, 0)?;
        let _sym = extract_symbol_id(name, args, 1, env)?;
        let max_n = extract_i64(name, args, 2)?;
        let pp = extract_i64(name, args, 3)?;
        if pp <= 0 {
            return Err(EvalError::Other(format!(
                "jacprodmake: Argument 4 (P): period filter must be positive, got {}", pp
            )));
        }
        let result = qseries::jacprodmake_with_period_filter(&fps, max_n, pp);
        Ok(jacobi_product_form_to_value(&result))
    } else {
        Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "3 or 4".to_string(),
            got: args.len(),
            signature: get_signature(name),
        })
    }
}
```

**5. mprodmake (SIG-12):** Replace 2-arg with 3-arg (same pattern as prodmake):
```rust
"mprodmake" => {
    expect_args(name, args, 3)?;
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let max_n = extract_i64(name, args, 2)?;
    let result = qseries::mprodmake(&fps, max_n);
    Ok(btreemap_i64_to_value(&result))
}
```

**6. qetamake (SIG-13):** Replace 2-arg with 3-arg:
```rust
"qetamake" => {
    expect_args(name, args, 3)?;
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let max_n = extract_i64(name, args, 2)?;
    let result = qseries::qetamake(&fps, max_n);
    Ok(q_eta_form_to_value(&result))
}
```

**7. qfactor (SIG-14):** Replace 1-arg with 2-arg or 3-arg:
```rust
"qfactor" => {
    if args.len() == 2 {
        let fps = extract_series(name, args, 0)?;
        let _sym = extract_symbol_id(name, args, 1, env)?;
        let result = qseries::qfactor(&fps);
        Ok(q_factorization_to_value(&result))
    } else if args.len() == 3 {
        let fps = extract_series(name, args, 0)?;
        let _sym = extract_symbol_id(name, args, 1, env)?;
        let _t = extract_i64(name, args, 2)?;
        // T parameter accepted for Maple compat but our qfactor is already degree-bounded
        let result = qseries::qfactor(&fps);
        Ok(q_factorization_to_value(&result))
    } else {
        Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "2 or 3".to_string(),
            got: args.len(),
            signature: get_signature(name),
        })
    }
}
```

**8. Update get_signature entries** (lines ~2674-2682):
```rust
"sift" => "(s, q, n, k, T)".to_string(),
"prodmake" => "(f, q, T)".to_string(),
"etamake" => "(f, q, T)".to_string(),
"jacprodmake" => "(f, q, T) or (f, q, T, P)".to_string(),
"mprodmake" => "(f, q, T)".to_string(),
"qetamake" => "(f, q, T)".to_string(),
"qfactor" => "(f, q) or (f, q, T)".to_string(),
```

**9. Rewrite all 7 unit tests** to use Maple-style signatures. Every test must pass `Value::Symbol("q".to_string())` as the q argument. Pattern:
```rust
#[test]
fn dispatch_sift_returns_series() {
    let mut env = make_env();
    let pgf = dispatch("partition_gf", &[Value::Integer(QInt::from(30i64))], &mut env).unwrap();
    let sift_args = vec![
        pgf,
        Value::Symbol("q".to_string()),
        Value::Integer(QInt::from(5i64)),  // n
        Value::Integer(QInt::from(0i64)),  // k
        Value::Integer(QInt::from(30i64)), // T
    ];
    let val = dispatch("sift", &sift_args, &mut env).unwrap();
    assert!(matches!(val, Value::Series(_)));
}
```

For each test, add `Value::Symbol("q".to_string())` as arg 2, and move the old max_n/T param to position 3. For qfactor, add the q symbol as arg 2:
```rust
#[test]
fn dispatch_qfactor_returns_dict_with_is_exact() {
    let mut env = make_env();
    let qb = dispatch("qbin", &[...], &mut env).unwrap();
    let val = dispatch("qfactor", &[qb, Value::Symbol("q".to_string())], &mut env).unwrap();
    // ... same assertions
}
```

Add 2 additional tests:
- `dispatch_sift_invalid_residue_errors`: Call `sift(pgf, q, 5, 7, 30)` -- k=7 >= n=5, expect error containing "residue"
- `dispatch_jacprodmake_4arg_with_period`: Call `jacprodmake(series, q, 10, 10)` with 4-arg PP form, verify returns Dict with "factors" key

NOTE: For the qbin call inside qfactor test and jacprodmake test -- qbin may now require Maple-style args (4-arg form from Phase 34). Check the current qbin dispatch to determine the correct call signature. If qbin still has its legacy 3-arg form, use that. If not, use the 4-arg Maple form `qbin(n, k, q, T)`.
  </action>
  <verify>
Run `cd C:/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli -- dispatch_sift dispatch_prodmake dispatch_etamake dispatch_jacprodmake dispatch_mprodmake dispatch_qetamake dispatch_qfactor` -- all 9 tests pass (7 rewritten + 2 new).

Also run `cargo test -p qsym-cli` to verify zero regressions across all 378+ unit tests.
  </verify>
  <done>
All 7 series analysis functions use Maple-style signatures exclusively. Old 1-2-3 arg calls fail with WrongArgCount errors. 9 unit tests pass (7 rewritten + 2 new for sift validation and jacprodmake 4-arg). Zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-core` -- all core tests pass (jacprodmake period filter works)
2. `cargo test -p qsym-cli` -- all CLI tests pass (378+ unit tests, zero regressions)
3. Each function's old signature (sift with 3 args, prodmake with 2 args, etc.) returns WrongArgCount error
4. sift validates k range: k < 0 or k >= n returns descriptive error
</verification>

<success_criteria>
All 7 functions accept ONLY Maple-style argument lists. Unit tests rewritten and passing. Core jacprodmake accepts optional period filter. Zero regressions across the full test suite.
</success_criteria>

<output>
After completion, create `.planning/phases/35-series-analysis-signatures/35-01-SUMMARY.md`
</output>
