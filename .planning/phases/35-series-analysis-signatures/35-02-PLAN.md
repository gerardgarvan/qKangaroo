---
phase: 35-series-analysis-signatures
plan: 02
type: execute
wave: 2
depends_on: [35-01]
files_modified:
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [SIG-08, SIG-09, SIG-10, SIG-11, SIG-12, SIG-13, SIG-14]

must_haves:
  truths:
    - "help(sift) shows 5-arg Maple signature sift(s, q, n, k, T)"
    - "help(prodmake) shows 3-arg Maple signature prodmake(f, q, T)"
    - "help(qfactor) shows qfactor(f, q) or (f, q, T) signature"
    - "All 7 help entries show Maple-style examples with explicit q"
    - "Integration tests verify sift, prodmake, etamake, jacprodmake, mprodmake, qetamake, qfactor end-to-end via CLI"
    - "Integration tests verify old signatures produce errors"
  artifacts:
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated help text for all 7 series analysis functions"
      contains: "sift(s, q, n, k, T)"
    - path: "crates/qsym-cli/tests/cli_integration.rs"
      provides: "Integration tests for Maple-style series analysis signatures"
      contains: "sift_maple"
  key_links:
    - from: "crates/qsym-cli/src/help.rs"
      to: "eval.rs dispatch signatures"
      via: "signature strings match dispatch arg patterns"
      pattern: "sift\\(s, q, n, k, T\\)"
    - from: "crates/qsym-cli/tests/cli_integration.rs"
      to: "qsym-cli binary"
      via: "CLI -c flag integration tests"
      pattern: "run_cmd.*sift"
---

<objective>
Update help text for all 7 series analysis functions to show Maple-style signatures and examples. Add CLI integration tests verifying each function works end-to-end and that old signatures produce errors.

Purpose: Users see correct Maple-style help and the full dispatch pipeline is verified end-to-end
Output: Updated help entries, comprehensive integration test coverage
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-series-analysis-signatures/35-RESEARCH.md
@.planning/phases/35-series-analysis-signatures/35-01-SUMMARY.md
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/tests/cli_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update help text for all 7 series analysis functions</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
Update ALL 7 FuncHelp entries in Group 4 (Series Analysis) to show Maple-style signatures and examples. Also update the general_help() text for the Series Analysis section.

**1. Update general_help() Series Analysis section** (lines ~42-51):
Change the one-line descriptions to reflect Maple-style usage:
```
Series Analysis:
  sift           - extract arithmetic subsequence: sift(s, q, n, k, T)
  qdegree        - highest power of q with nonzero coefficient
  lqdegree       - lowest power of q with nonzero coefficient
  qfactor        - factor polynomial into (1-q^i) factors
  prodmake       - find infinite product form via log derivative
  etamake        - find eta quotient form
  jacprodmake    - find Jacobi product form
  mprodmake      - find (1+q^n) product form
  qetamake       - combined eta/q-Pochhammer product form
```

**2. Update 7 FuncHelp entries** (lines ~263-325). Replace each entry with Maple-style signature and example:

**sift:**
```rust
FuncHelp {
    name: "sift",
    signature: "sift(s, q, n, k, T)",
    description: "Extract the arithmetic subsequence of coefficients at residue k mod n.\n  Returns a new series whose i-th coefficient is the (n*i+k)-th coefficient of the input.\n  T controls the truncation: the input is used up to q^T.",
    example: "q> f := partition_gf(50)\nq> sift(f, q, 5, 4, 50)",
    example_output: "1 + q + 2*q^2 + 3*q^3 + ... (coefficients of q^(5i+4) from partition_gf)",
},
```

**qfactor:**
```rust
FuncHelp {
    name: "qfactor",
    signature: "qfactor(f, q) or qfactor(f, q, T)",
    description: "Factor a polynomial series into (1-q^i) factors by top-down division.\n  Returns a dictionary with scalar, factors, and is_exact flag.\n  Optional T limits the maximum factor index to search.",
    example: "q> f := aqprod(q, q, 5)\nq> qfactor(f, q)",
    example_output: "{scalar: 1, factors: {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}, is_exact: true}",
},
```

**prodmake:**
```rust
FuncHelp {
    name: "prodmake",
    signature: "prodmake(f, q, T)",
    description: "Find the infinite product representation of a series via the log derivative method.\n  Returns exponents a_n such that series = prod_{n>=1} (1-q^n)^{a_n}.\n  T is the maximum exponent to search.",
    example: "q> f := partition_gf(50)\nq> prodmake(f, q, 20)",
    example_output: "{exponents: {1: -1, 2: -1, 3: -1, ...}, terms_used: 20}",
},
```

**etamake:**
```rust
FuncHelp {
    name: "etamake",
    signature: "etamake(f, q, T)",
    description: "Find an eta-quotient representation of the series via Mobius inversion.\n  Returns divisor-grouped exponents for eta(d*tau) factors.\n  T is the maximum delta to search.",
    example: "q> f := partition_gf(50)\nq> etamake(f, q, 10)",
    example_output: "{factors: {1: -1}, q_shift: 0, is_exact: true}",
},
```

**jacprodmake:**
```rust
FuncHelp {
    name: "jacprodmake",
    signature: "jacprodmake(f, q, T) or jacprodmake(f, q, T, P)",
    description: "Find a Jacobi product representation with period search and residue grouping.\n  Returns JAC(a,b) factors. Optional P restricts the period search to divisors of P.\n  Includes an is_exact flag indicating whether the product matches exactly.",
    example: "q> f := jacprod(1, 5, q, 30)\nq> jacprodmake(f, q, 10)",
    example_output: "{factors: {(1,5): 1}, scalar: 1, is_exact: true}",
},
```

**mprodmake:**
```rust
FuncHelp {
    name: "mprodmake",
    signature: "mprodmake(f, q, T)",
    description: "Find a (1+q^n) product representation by iterative extraction.\n  Returns exponents for each (1+q^n) factor.\n  T is the maximum exponent to search.",
    example: "q> f := distinct_parts_gf(50)\nq> mprodmake(f, q, 10)",
    example_output: "{1: 1, 2: 1, 3: 1, ...}",
},
```

**qetamake:**
```rust
FuncHelp {
    name: "qetamake",
    signature: "qetamake(f, q, T)",
    description: "Find a combined eta/q-Pochhammer product representation.\n  Extends etamake with additional q-Pochhammer factors.\n  T is the maximum exponent to search.",
    example: "q> f := partition_gf(50)\nq> qetamake(f, q, 10)",
    example_output: "{factors: {...}, q_shift: 0, is_exact: true}",
},
```

**3. Update help unit tests** that reference old signatures. Search help.rs for any tests that check for old signature strings like `"sift(series, m, j)"` and update to match new signatures. The `every_canonical_function_has_help_entry` test should still pass since function names are unchanged.
  </action>
  <verify>
Run `cd C:/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli help` -- all help tests pass.

Also run `cargo test -p qsym-cli` -- full unit test suite passes.
  </verify>
  <done>
All 7 help entries show Maple-style signatures and examples. General help section updated. Help unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI integration tests for all 7 Maple-style signatures</name>
  <files>crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
Add integration tests that exercise each of the 7 functions end-to-end through the CLI binary using the `-c` flag. Follow the existing integration test patterns (look at how Phase 34 added tests like `jacprod_maple_4arg`, `qbin_garvan_3arg`, etc.).

Find the test helper functions (likely `run_cmd` or `run_piped`) and use them.

**Add these integration tests:**

1. `sift_maple_5arg` -- `"f := partition_gf(50); sift(f, q, 5, 4, 50)"` -- verify output contains series terms (e.g., "1 +" or "q")

2. `sift_maple_invalid_residue` -- `"f := partition_gf(50); sift(f, q, 5, 7, 50)"` -- verify exit code != 0 or output contains "residue" error

3. `prodmake_maple_3arg` -- `"f := partition_gf(30); prodmake(f, q, 15)"` -- verify output contains "exponents" or expected dict keys

4. `etamake_maple_3arg` -- `"f := partition_gf(30); etamake(f, q, 10)"` -- verify output contains "factors"

5. `jacprodmake_maple_3arg` -- `"f := jacprod(1, 5, q, 30); jacprodmake(f, q, 10)"` -- verify output contains "factors" and "is_exact"

6. `jacprodmake_maple_4arg_with_period` -- `"f := jacprod(1, 5, q, 30); jacprodmake(f, q, 10, 10)"` -- verify output contains "factors" (period filter working)

7. `mprodmake_maple_3arg` -- `"f := distinct_parts_gf(30); mprodmake(f, q, 10)"` -- verify output is a dict

8. `qetamake_maple_3arg` -- `"f := partition_gf(30); qetamake(f, q, 10)"` -- verify output contains "factors"

9. `qfactor_maple_2arg` -- `"f := aqprod(q, q, 5); qfactor(f, q)"` -- verify output contains "factors" and "is_exact"

10. `qfactor_maple_3arg` -- `"f := aqprod(q, q, 5); qfactor(f, q, 20)"` -- verify output contains "factors"

11. `sift_old_signature_errors` -- `"sift(partition_gf(30), 5, 0)"` -- verify exit code != 0 or output contains "expected 5 arguments" or similar wrong-arg-count message

12. `prodmake_old_signature_errors` -- `"prodmake(partition_gf(30), 10)"` -- verify exit code != 0 or output contains wrong-arg-count message

NOTE: For the `aqprod(q, q, 5)` call in qfactor tests -- aqprod currently takes the Maple-style form `aqprod(a, q, n)` from Phase 34. Verify the correct call form. If the old 5-arg form `aqprod(1, 1, 1, 5, 20)` still works (Phase 34 kept backward compat for aqprod), use whichever is available.

For error tests, the CLI process should exit with a nonzero status code (likely 65 = EX_DATAERR). Check stderr or stdout for the error message.
  </action>
  <verify>
Run `cd C:/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli --test cli_integration` -- all integration tests pass (existing 90 + new 12 = 102).
  </verify>
  <done>
12 new integration tests verify all 7 Maple-style series analysis signatures end-to-end through the CLI binary. Old-signature error tests confirm backward compat is removed. Total integration tests: 102+.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli help` -- all help tests pass with new signatures
2. `cargo test -p qsym-cli --test cli_integration` -- all integration tests pass (90 existing + 12 new)
3. `cargo test -p qsym-cli` -- full unit test suite passes (378+ tests, zero regressions)
4. help(sift) shows "sift(s, q, n, k, T)" not "sift(series, m, j)"
5. help(qfactor) shows "qfactor(f, q) or qfactor(f, q, T)" not "qfactor(series)"
</verification>

<success_criteria>
All 7 help entries show Maple-style signatures. 12 integration tests pass covering all 7 functions end-to-end plus error cases. Zero regressions in the full test suite.
</success_criteria>

<output>
After completion, create `.planning/phases/35-series-analysis-signatures/35-02-SUMMARY.md`
</output>
