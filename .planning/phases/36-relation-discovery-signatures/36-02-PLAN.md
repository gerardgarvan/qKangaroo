---
phase: 36-relation-discovery-signatures
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements:
  - SIG-15
  - SIG-16
  - SIG-17
  - SIG-18
  - SIG-19
  - SIG-20
  - SIG-21
  - SIG-22
  - SIG-23
  - SIG-24
  - SIG-25
  - OUT-01
  - OUT-02

must_haves:
  truths:
    - "findlincombo(f, L, SL, q, topshift) prints formatted 12*F1 + 13*F2 output using SL labels"
    - "findlincombomodp(f, L, SL, p, q, topshift) works with p before q and SL labels"
    - "findhomcombo(f, L, q, n, topshift) uses X[i] auto-labels (no SL per Garvan)"
    - "findnonhomcombo(f, L, q, n, topshift) uses X[i] auto-labels (no SL per Garvan)"
    - "findhomcombomodp(f, L, p, q, n, topshift) uses X[i] auto-labels, p before q"
    - "findhom(L, q, n, topshift) prints polynomial expressions in X[i] labels"
    - "findnonhom(L, q, n, topshift) prints polynomial expressions in X[i] labels"
    - "findhommodp(L, p, q, n, topshift) prints modular polynomial expressions, p before q"
    - "findmaxind(L, T) accepts 2 args with no q parameter"
    - "findpoly(x, y, q, dx, dy) or findpoly(x, y, q, dx, dy, check) matches Garvan 5-6 args"
    - "findcong(QS, T) auto-scans moduli and prints [B, A, R] triples"
    - "findcong(QS, T, LM) and findcong(QS, T, LM, XSET) overloads work"
    - "Duplicate SL labels produce an error"
    - "Non-prime p in modp functions produces an error"
    - "No-solution cases print a message and return Value::None (not error)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Maple-compatible dispatch for all 11 relation discovery functions + formatting helpers"
      contains: "findlincombo"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/qseries/relations.rs"
      via: "qseries::findlincombo, qseries::findcong_garvan, qseries::generate_monomials"
      pattern: "qseries::findlincombo|qseries::findcong_garvan|qseries::generate_monomials"
---

<objective>
Rewrite all 11 relation discovery function dispatch blocks in eval.rs to match Garvan's exact Maple signatures, add output formatting with symbolic labels, and update unit tests.

Purpose: Researchers can copy-paste relation discovery function calls from Maple worksheets and get correct, identically-formatted results in q-Kangaroo.

Output: Updated eval.rs with Garvan-compatible dispatch for findlincombo, findhomcombo, findnonhomcombo, findlincombomodp, findhomcombomodp, findhom, findnonhom, findhommodp, findmaxind, findpoly, findcong.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-relation-discovery-signatures/36-RESEARCH.md
@.planning/phases/36-relation-discovery-signatures/36-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-core/src/qseries/relations.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add formatting helpers and rewrite dispatch for all 11 functions</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
CRITICAL: Follow Garvan's ACTUAL signatures (from 36-RESEARCH.md), NOT the requirements as written. The requirements have several discrepancies.

**Part A: Add helper functions** (place near the other extract_* helpers or near congruence_to_value):

1. `extract_symbol_list(name: &str, args: &[Value], index: usize) -> Result<Vec<String>, EvalError>`:
   Extract a list of Symbol values as Vec<String>. Error if arg is not a list, or if any element is not Value::Symbol.

2. `validate_unique_labels(name: &str, labels: &[String]) -> Result<(), EvalError>`:
   Check for duplicate labels. Error: "{name}: duplicate label '{label}' in SL"

3. `is_prime(n: i64) -> bool`:
   Simple trial division primality test. n < 2 returns false. Check 2, 3, then 6k+-1 up to sqrt(n).

4. `format_linear_combo(coeffs: &[QRat], labels: &[String]) -> String`:
   Format as "12*F1 + 13*F2" string. Handle coefficient 1 (just label), -1 (just -label), 0 (skip). Join with " + " then replace "+ -" with "- ". Handle all-zero as "0".

5. `format_linear_combo_modp(coeffs: &[i64], labels: &[String], p: i64) -> String`:
   Same as above but i64 coefficients mod p. Coefficients in range [0, p-1].

6. `format_polynomial_expr(coeffs: &[QRat], monomials: &[Vec<i64>], labels: &[String]) -> String`:
   Format a polynomial expression from null-space vector. For each nonzero coefficient, build monomial string (X[1]^2*X[2] etc.), combine with coefficient. Join terms with " + ", replace "+ -" with "- ".

7. `format_polynomial_expr_modp(coeffs: &[i64], monomials: &[Vec<i64>], labels: &[String], p: i64) -> String`:
   Same as above but i64 coefficients.

8. `format_findpoly_result(rel: &qseries::PolynomialRelation) -> String`:
   Format as polynomial in X, Y variables. For each nonzero coeff in rel.coefficients[i][j], build term "coeff*X^i*Y^j". Join with " + ". Handle X^0, Y^0, X^1, Y^1 display.

9. `default_labels(k: usize) -> Vec<String>`:
   Generate ["X[1]", "X[2]", ..., "X[k]"] matching Garvan's convention.

**Part B: Rewrite dispatch blocks** (replace lines ~1647-1827):

All functions follow the Phase 35 pattern: no backward compatibility with old signatures -- old arg counts produce a WrongArgCount error. Each function both PRINTS formatted output to stdout AND returns a structured Value.

1. **findlincombo** -- Garvan: `proc(f, L, SL, q, topshift)` -- 5 args
   ```
   expect_args(name, args, 5)?;
   target = extract_series(name, args, 0)?;
   candidates = extract_series_list(name, args, 1)?;
   labels = extract_symbol_list(name, args, 2)?;
   _sym = extract_symbol_id(name, args, 3, env)?;  // q consumed but not used
   topshift = extract_i64(name, args, 4)?;
   // Validate: labels.len() == candidates.len(), unique labels
   match qseries::findlincombo(&target, &refs, topshift) {
       Some(coeffs) => { let s = format_linear_combo(&coeffs, &labels); println!("{}", s); Ok(Value::String(s)) }
       None => { println!("NOT A LINEAR COMBO."); Ok(Value::None) }
   }
   ```

2. **findhomcombo** -- Garvan: `proc(f, L, q, n, topshift)` -- 5 args, NO SL
   ```
   expect_args(name, args, 5)?;
   target = extract_series(name, args, 0)?;
   candidates = extract_series_list(name, args, 1)?;
   _sym = extract_symbol_id(name, args, 2, env)?;
   degree = extract_i64(name, args, 3)?;
   topshift = extract_i64(name, args, 4)?;
   let labels = default_labels(candidates.len());
   let monomials = qseries::generate_monomials(candidates.len(), degree);
   match qseries::findhomcombo(&target, &refs, degree, topshift) {
       Some(coeffs) => { let s = format_polynomial_expr(&coeffs, &monomials, &labels); println!("{}", s); Ok(Value::String(s)) }
       None => { println!("NOT A HOMOGENEOUS COMBO."); Ok(Value::None) }
   }
   ```

3. **findnonhomcombo** -- Garvan: `proc(f, L, q, n, topshift)` -- 5 args, NO SL
   Same pattern as findhomcombo but calls qseries::findnonhomcombo and uses qseries::generate_nonhom_monomials for monomial list. Print "NOT A NON-HOMOGENEOUS COMBO." on failure.

4. **findlincombomodp** -- Garvan: `proc(f, L, SL, p, q, topshift)` -- 6 args, p BEFORE q
   ```
   expect_args(name, args, 6)?;
   target = extract_series(name, args, 0)?;
   candidates = extract_series_list(name, args, 1)?;
   labels = extract_symbol_list(name, args, 2)?;
   p = extract_i64(name, args, 3)?;
   _sym = extract_symbol_id(name, args, 4, env)?;
   topshift = extract_i64(name, args, 5)?;
   // Validate prime, label count, unique labels
   if !is_prime(p) { return Err(EvalError::Other(format!("{}: {} is not prime", name, p))); }
   match qseries::findlincombomodp(&target, &refs, p, topshift) {
       Some(coeffs) => { let s = format_linear_combo_modp(&coeffs, &labels, p); println!("{}", s); Ok(Value::String(s)) }
       None => { println!("NOT A LINEAR COMBO MOD {}.", p); Ok(Value::None) }
   }
   ```

5. **findhomcombomodp** -- Garvan: `proc(f, L, p, q, n, topshift)` -- 6 args, NO SL, p before q
   ```
   expect_args(name, args, 6)?;
   target = extract_series(name, args, 0)?;
   candidates = extract_series_list(name, args, 1)?;
   p = extract_i64(name, args, 2)?;
   _sym = extract_symbol_id(name, args, 3, env)?;
   degree = extract_i64(name, args, 4)?;
   topshift = extract_i64(name, args, 5)?;
   if !is_prime(p) { error }
   labels = default_labels(candidates.len());
   monomials = qseries::generate_monomials(candidates.len(), degree);
   match qseries::findhomcombomodp(&target, &refs, p, degree, topshift) {
       Some(coeffs) => { let s = format_polynomial_expr_modp(&coeffs, &monomials, &labels, p); println!("{}", s); Ok(Value::String(s)) }
       None => { println!("NOT A HOMOGENEOUS COMBO MOD {}.", p); Ok(Value::None) }
   }
   ```

6. **findhom** -- Garvan: `proc(L, q, n, topshift)` -- 4 args
   ```
   expect_args(name, args, 4)?;
   series_list = extract_series_list(name, args, 0)?;
   _sym = extract_symbol_id(name, args, 1, env)?;
   degree = extract_i64(name, args, 2)?;
   topshift = extract_i64(name, args, 3)?;
   labels = default_labels(series_list.len());
   monomials = qseries::generate_monomials(series_list.len(), degree);
   let rows = qseries::findhom(&refs, degree, topshift);
   if rows.is_empty() { println!("NO HOMOGENEOUS RELATIONS FOUND."); return Ok(Value::List(vec![])); }
   let mut exprs = Vec::new();
   for row in &rows { let s = format_polynomial_expr(row, &monomials, &labels); println!("{}", s); exprs.push(Value::String(s)); }
   Ok(Value::List(exprs))
   ```

7. **findnonhom** -- Garvan: `proc(L, q, n, topshift)` -- 4 args
   Same pattern as findhom but calls qseries::findnonhom and uses qseries::generate_nonhom_monomials. Print "NO NON-HOMOGENEOUS RELATIONS FOUND." on empty.

8. **findhommodp** -- Garvan: `proc(L, p, q, n, topshift)` -- 5 args, p BEFORE q
   ```
   expect_args(name, args, 5)?;
   series_list = extract_series_list(name, args, 0)?;
   p = extract_i64(name, args, 1)?;
   _sym = extract_symbol_id(name, args, 2, env)?;
   degree = extract_i64(name, args, 3)?;
   topshift = extract_i64(name, args, 4)?;
   if !is_prime(p) { error }
   labels = default_labels(series_list.len());
   monomials = qseries::generate_monomials(series_list.len(), degree);
   let rows = qseries::findhommodp(&refs, p, degree, topshift);
   // Format each row as polynomial mod p, print and collect
   ```

9. **findmaxind** -- Garvan docs: `findmaxind(XFL, T)` -- 2 args, NO q
   ```
   expect_args(name, args, 2)?;
   series_list = extract_series_list(name, args, 0)?;
   topshift = extract_i64(name, args, 1)?;
   let indices = qseries::findmaxind(&refs, topshift);
   // Return [P, NXFL] pair per Garvan:
   // P = list of independent series (filtered by indices)
   // NXFL = list of 1-based index integers
   let nxfl: Vec<Value> = indices.iter().map(|&i| Value::Integer(QInt::from((i + 1) as i64))).collect();
   let p_list: Vec<Value> = indices.iter().map(|&i| args_series_list[i].clone()).collect();
   // Actually just return the indices as 1-based list for now (simplest match to Garvan)
   // Garvan returns [P, NXFL] but P is the series themselves -- return list of 1-based indices
   println!("{:?}", nxfl_display);
   Ok(Value::List(nxfl))
   ```
   NOTE: findmaxind keeps its 2-arg signature. The return format changes to a list of 1-based indices. Print the indices.

10. **findpoly** -- Garvan: `proc(x, y, q, deg1, deg2, [check])` -- 5 or 6 args
    ```
    expect_args_range(name, args, 5, 6)?;
    x = extract_series(name, args, 0)?;
    y = extract_series(name, args, 1)?;
    _sym = extract_symbol_id(name, args, 2, env)?;
    deg_x = extract_i64(name, args, 3)?;
    deg_y = extract_i64(name, args, 4)?;
    let check = if args.len() == 6 { Some(extract_i64(name, args, 5)?) } else { None };
    // Use fixed topshift=10 matching Garvan's dim2 := dim1 + 10
    match qseries::findpoly(&x, &y, deg_x, deg_y, 10) {
        Some(rel) => {
            let s = format_findpoly_result(&rel);
            println!("The polynomial is");
            println!("{}", s);
            // If check provided, verify (re-expand to check order and compare)
            // For now, just note check was requested
            if let Some(_check_order) = check {
                println!("Verification requested (check={})", _check_order);
            }
            Ok(Value::String(s))
        }
        None => { println!("NO polynomial relation found."); Ok(Value::None) }
    }
    ```

11. **findcong** -- Garvan: `proc(QS, T, [LM], [XSET])` -- 2 to 4 args
    ```
    expect_args_range(name, args, 2, 4)?;
    fps = extract_series(name, args, 0)?;
    t = extract_i64(name, args, 1)?;
    lm = if args.len() >= 3 { Some(extract_i64(name, args, 2)?) } else { None };
    xset: HashSet<i64> = if args.len() >= 4 { extract_i64_list(name, args, 3)?.into_iter().collect() } else { HashSet::new() };
    let results = qseries::findcong_garvan(&fps, t, lm, &xset);
    if results.is_empty() { println!("NO CONGRUENCES FOUND."); }
    for c in &results {
        println!("[{}, {}, {}]", c.residue_b, c.modulus_m, c.divisor_r);
    }
    // Return as list of [B, A, R] triples
    Ok(Value::List(results.iter().map(|c| Value::List(vec![
        Value::Integer(QInt::from(c.residue_b)),
        Value::Integer(QInt::from(c.modulus_m)),
        Value::Integer(QInt::from(c.divisor_r)),
    ])).collect()))
    ```

**Part C: Update get_signature function** (~lines 2749-2761):
Update signatures to match new Garvan calling conventions:
- "findlincombo" => "(f, L, SL, q, topshift)"
- "findhomcombo" => "(f, L, q, n, topshift)"
- "findnonhomcombo" => "(f, L, q, n, topshift)"
- "findlincombomodp" => "(f, L, SL, p, q, topshift)"
- "findhomcombomodp" => "(f, L, p, q, n, topshift)"
- "findhom" => "(L, q, n, topshift)"
- "findnonhom" => "(L, q, n, topshift)"
- "findhommodp" => "(L, p, q, n, topshift)"
- "findmaxind" => "(L, T)"
- "findpoly" => "(x, y, q, dx, dy) or (x, y, q, dx, dy, check)"
- "findcong" => "(QS, T) or (QS, T, LM) or (QS, T, LM, XSET)"
Keep findprod unchanged.

**Part D: Add `use std::collections::HashSet;`** at the top of the dispatch function or import section, needed for findcong's XSET parameter.

**Part E: Update existing unit tests** (~lines 4505-4625):
The existing unit tests call the old signatures and will break. Update them to use the new Garvan signatures:

- `dispatch_findlincombo_returns_list_or_none`: Change to 5-arg call with SL and q. Expect Value::String (not Value::List) on success.
- `dispatch_findhom_returns_matrix`: Change to 4-arg call with q. Expect Value::List of Value::String.
- `dispatch_findcong_returns_list_of_dicts`: Change to 2-arg (series, T) call. Expect Value::List of Value::List (triples), not Value::Dict.
- `dispatch_findmaxind_returns_list`: Keep 2-arg but adjust expectations.
- `dispatch_findpoly_returns_dict_or_none`: Change to 5-arg (x, y, q, dx, dy). Expect Value::String on success, not Value::Dict.

Add NEW unit tests:
- `dispatch_findlincombo_duplicate_sl_errors`: Test that duplicate labels in SL produce an error.
- `dispatch_findlincombomodp_non_prime_errors`: Test that p=4 produces an error.
- `dispatch_findcong_with_lm`: Test findcong(series, T, LM) 3-arg form.
- `dispatch_findhomcombo_maple_style`: Test 5-arg findhomcombo with q parameter.
- `dispatch_findhommodp_p_before_q`: Test 5-arg findhommodp with p before q.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --lib 2>&1 | tail -20`
All unit tests pass including the updated and new ones.
  </verify>
  <done>
All 11 relation discovery functions accept Garvan's exact signatures:
- findlincombo: 5 args with SL, prints "12*F1 + 13*F2" output
- findlincombomodp: 6 args with SL, p before q, validates prime
- findhomcombo/findnonhomcombo: 5 args each, no SL, uses X[i] labels
- findhomcombomodp: 6 args, no SL, p before q, validates prime
- findhom/findnonhom: 4 args with q parameter, polynomial output in X[i]
- findhommodp: 5 args, p before q, validates prime
- findmaxind: 2 args (L, T), no q
- findpoly: 5-6 args with q, optional check, fixed topshift=10
- findcong: 2-4 args, auto-scans moduli, prints [B, A, R] triples
No-solution cases print message and return Value::None.
Duplicate SL labels and non-prime p produce errors.
All unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p qsym-cli --lib` passes with zero failures
- All 11 function dispatch blocks match Garvan's verified signatures
- SL-based output uses symbolic labels; non-SL functions use X[i] labels
- findcong uses auto-scan algorithm and [B, A, R] triple format
- Old calling conventions produce WrongArgCount errors (no backward compat per Phase 35 decision)
</verification>

<success_criteria>
- findlincombo(f, L, SL, q, topshift) prints formatted linear combo with SL labels
- findhomcombo, findnonhomcombo, findhomcombomodp have NO SL parameter (uses X[i])
- All modp functions have p BEFORE q
- findcong(QS, T) auto-scans moduli 2..floor(sqrt(T)) and outputs [B, A, R] triples
- findpoly uses optional check parameter, not topshift
- findmaxind(L, T) is 2-arg with no q
- Duplicate SL labels error, non-prime p errors
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-relation-discovery-signatures/36-02-SUMMARY.md`
</output>
