---
phase: 40-documentation
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - manual/chapters/13-worked-examples.typ
autonomous: true
requirements: [DOC-01]

must_haves:
  truths:
    - "All REPL examples in chapter 13 use Garvan-canonical function signatures"
    - "No v1.x integer-triple aqprod calls remain"
    - "findcong uses the new auto-discover form findcong(QS, T), not the old moduli-list form"
    - "sift uses the Garvan form sift(f, q, n, k, T)"
    - "prodmake and etamake use the Garvan form with explicit q argument"
    - "findlincombo uses the Garvan form with symbolic labels SL and explicit q"
    - "Expected REPL outputs reflect descending power order (Phase 39 display change)"
  artifacts:
    - path: "manual/chapters/13-worked-examples.typ"
      provides: "Worked examples with all Garvan-canonical signatures and corrected outputs"
      contains: "aqprod(q, q, infinity"
  key_links:
    - from: "manual/chapters/13-worked-examples.typ"
      to: "crates/qsym-cli/src/help.rs"
      via: "all function signatures must match help.rs canonical forms"
      pattern: "aqprod\\(q, q"
---

<objective>
Rewrite all REPL examples in chapter 13 (Worked Examples) to use Garvan-canonical function signatures and update expected outputs to reflect descending power order.

Purpose: Chapter 13 contains ~15 instances of v1.x legacy function calls (integer-triple aqprod, 2-arg prodmake/etamake, old findcong/sift/findlincombo forms). Per user decision, legacy signatures are replaced entirely with Garvan-canonical forms. Expected outputs must also reflect the Phase 39 display change to descending power order.

Output: Updated 13-worked-examples.typ with all Garvan-canonical signatures and correct expected outputs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-documentation/40-CONTEXT.md
@.planning/phases/40-documentation/40-RESEARCH.md
@manual/chapters/13-worked-examples.typ
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite all REPL examples in chapter 13 with Garvan-canonical signatures</name>
  <files>manual/chapters/13-worked-examples.typ</files>
  <action>
Go through chapter 13 section by section. For each REPL example, replace the old v1.x function call with the Garvan-canonical form. Also update expected output strings to use descending power order (highest power first, matching Phase 39 display). The surrounding mathematical narrative and references remain unchanged -- only the REPL calls, their descriptions, and expected outputs change.

**Section: Euler's Pentagonal Theorem (lines 28-69)**

Line 32 `#repl`:
- Old: `aqprod(1, 1, 1, infinity, 20)`
- New: `aqprod(q, q, infinity, 20)`
- This computes (q;q)_inf to 20 terms. Update expected output to descending order:
  `"1 - q - q^2 + q^5 + q^7 - q^12 - q^15 + O(q^20)"` -> reverse to descending:
  `"-q^15 - q^12 + q^7 + q^5 - q^2 - q + 1 + O(q^20)"` (verify ordering against actual engine behavior -- the O(q^20) term stays at the end)
- Update Step 1 description (line 30): change "using `aqprod`" to keep it, but the call changes.

Line 42 `#repl`:
- Old: `prodmake(%, 10)`
- New: `prodmake(%, q, 10)`
- Expected output: unchanged (product exponent map format not affected by display order). Keep: `"{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}"`

Line 50 `#repl`:
- Old: `etamake(aqprod(1, 1, 1, infinity, 50), 10)`
- New: `etamake(aqprod(q, q, infinity, 50), q, 10)`
- Expected output: unchanged `"{1: 1}"`

Lines 59-62 `#repl-block`:
- Old: `f := aqprod(1, 1, 1, infinity, 20):`
- New: `f := aqprod(q, q, infinity, 20):`
- Rest of block unchanged (partition_gf(20), f * g). Expected output "1 + O(q^20)" unchanged.

**Section: Ramanujan's Partition Congruences (lines 72-127)**

Line 95 `#repl`: partition_gf(200) -- unchanged (no signature change).

Lines 101 `#repl`:
- Old: `findcong(f, [5, 7, 11])`
- New: `findcong(f, 200)`
- The Garvan findcong auto-discovers ALL congruences up to T terms. It no longer takes a moduli list.
- Update expected output to Garvan format: `"[[4, 5, 5], [5, 7, 7], [6, 11, 11]]"` (Garvan outputs [B, A, R] triples where p(A*n+B) = 0 mod R)
- Update the narrative (lines 98-105): Change "Use `findcong` to automatically discover congruences modulo 5, 7, and 11" to "Use `findcong` to automatically discover all congruences up to 200 terms". Change the triple description from "[m, j, d] means p(m n + j) = 0 mod d" to "[B, A, R] means p(A*n + B) = 0 mod R".

Lines 110-111 `#repl`:
- Old: `sift(f, 5, 4)`
- New: `sift(f, q, 5, 4, 200)`
- Expected output needs descending power order. Old ascending:
  `"5 + 30*q + 135*q^2 + 490*q^3 + ..."`
  New descending: reverse the terms so highest power is first:
  `"173525*q^9 + 75175*q^8 + 31185*q^7 + 12310*q^6 + 4565*q^5 + 1575*q^4 + 490*q^3 + 135*q^2 + 30*q + 5 + O(q^10)"`
  (Verify the number of terms shown -- sift with T=200 and modulus 5 yields floor(200/5)=40 terms, but the O(q^10) truncation in the output suggests the display truncates. Keep the same number of displayed terms as before but in descending order.)

Lines 117-118 `#repl`:
- Old: `findcong(partition_gf(500), [13, 17, 19, 23])`
- New: `findcong(partition_gf(500), 500, 23)`
- Using the 3-arg form with LM=23 to cap the modulus search at 23 (equivalent to checking primes up to 23). This still finds the Ramanujan congruences but also shows no new ones for 13-23.
- Actually, to show that NO congruences exist for primes 13-23 specifically while the Ramanujan ones for 5,7,11 are found at lower moduli, use `findcong(partition_gf(500), 500, 23)` and note the output includes only [4,5,5], [5,7,7], [6,11,11] -- nothing for 13,17,19,23.
- Expected output: `"[[4, 5, 5], [5, 7, 7], [6, 11, 11]]"` (same three congruences, none for 13+)
- Update narrative (lines 115-121): Change "Check whether primes beyond 11 yield simple congruences" to "Extending the search to moduli up to 23 confirms no new congruences beyond Ramanujan's three". Change "The empty result confirms..." to "The output contains only the three Ramanujan congruences, confirming that no congruences of the form $p(ell n + delta) equiv 0 space (mod ell)$ exist for $ell in {13, 17, 19, 23}$."

**Section: Jacobi Triple Product Identity (lines 129-181)**

Line 150 `#repl`: `theta3(50)` -- unchanged.

Lines 156-158 `#repl-block`:
- Old: `b := aqprod(1, 1, 2, infinity, 50) * aqprod(-1, 1, 1, infinity, 50)^2:`
- New: `b := aqprod(q^2, q^2, infinity, 50) * aqprod(-q, q^2, infinity, 50)^2:`
- This now correctly expresses the product side (q^2;q^2)_inf * (-q;q^2)_inf^2 using Garvan's explicit base parameter, matching the mathematical formula exactly.
- Expected output: "O(q^50)" unchanged (still a - b = 0).
- Update Step 2 description (lines 153-154): Change "The right-hand side at $z = 1$ is $(q^2; q^2)_oo dot (-q; q^2)_oo^2$" -- this was already correct mathematically. The code now matches the math directly.

Line 165 `#repl`:
- Old: `prodmake(a, 20)`
- New: `prodmake(a, q, 20)`
- Expected output: unchanged `"{1: 0, 2: 1, 3: 0, ...}"` (map format unaffected by display order).

Line 172 `#repl`:
- Old: `etamake(a, 10)`
- New: `etamake(a, q, 10)`
- Expected output: unchanged `"{1: -2, 2: 5, 4: -2}"`.

**Section: Rogers-Ramanujan via Bailey Chains (lines 184-245)**

Line 211 `#repl`: `bailey_weak_lemma(1, 1, 1, 0, 10, 30)` -- UNCHANGED (Bailey functions use integer-triple encoding for a parameter, not affected by v2.0 aqprod changes).

Line 220 `#repl`: `bailey_apply_lemma(1, 1, 1, 0, 1, 1, 1, 1, 1, 2, 10, 30)` -- UNCHANGED.

Line 226 `#repl`: `bailey_chain(1, 1, 1, 0, 1, 1, 1, 1, 1, 2, 2, 10, 30)` -- UNCHANGED.

Lines 236-239 `#repl-block`:
- Old: `rhs := aqprod(1, 1, 4, infinity, 30) * aqprod(1, 1, 1, infinity, 30):`
- New: `rhs := aqprod(q^4, q, infinity, 30) * aqprod(q, q, infinity, 30):`
- Note: These old calls used (1,1,4) = q^4 with implicit base q, and (1,1,1) = q with implicit base q. New Garvan form makes the base explicit.
- `bailey_discover(lhs, rhs, 1, 3, 30)` -- UNCHANGED (integer-triple encoding for a).

**Section: Hypergeometric Transformations (lines 248-307)**

All calls in this section use integer-triple encoding which is UNCHANGED in v2.0:
- Line 272 `#repl`: `phi([(1,1,2), (1,1,3)], [(1,1,5)], 1, 1, 1, 30)` -- UNCHANGED.
- Line 279 `#repl`: `heine1(...)` -- UNCHANGED.
- Line 288 `#repl`: `heine2(...)` -- UNCHANGED.
- Lines 294-298 `#repl-block`: `find_transformation_chain(...)` -- UNCHANGED.

**Section: Mock Theta Function Relations (lines 310-377)**

Lines 339-340 `#repl-block`: mock_theta_f3(50), mock_theta_psi3(50) -- UNCHANGED.
Lines 343-346 `#repl-block`: theta4(50), partition_gf(50) -- UNCHANGED.

Line 351 `#repl`:
- Old: `findlincombo(rhs, [mf, mpsi], 0)`
- New: `findlincombo(rhs, [mf, mpsi], [F, Psi], q, 0)`
- Expected output: `"1*F + 4*Psi"` (now uses symbolic labels instead of raw coefficients)
- Update the narrative (line 353-355): Change "`[1, 4]` confirm Watson's relation: $"rhs" = 1 dot f(q) + 4 dot psi(q)$" to "`1*F + 4*Psi` confirms Watson's relation: $"rhs" = 1 dot f(q) + 4 dot psi(q)$. The symbolic labels F and Psi match the basis series in order."

Line 359 `#repl`: `rhs - mf - 4 * mpsi` -- UNCHANGED (pure arithmetic). Expected output "O(q^50)" unchanged.

Line 368 `#repl`: `appell_lerch_m(1, 1, 30)` -- UNCHANGED (integer encoding).
- Expected output needs descending power order: reverse the series.
  Old: `"1 + q + 2*q^2 + 2*q^3 + 4*q^4 + ..."`
  New descending: `"164*q^19 + 136*q^18 + 104*q^17 + 86*q^16 + 66*q^15 + 54*q^14 + 40*q^13 + 34*q^12 + 24*q^11 + 20*q^10 + 14*q^9 + 12*q^8 + 8*q^7 + 7*q^6 + 4*q^5 + 4*q^4 + 2*q^3 + 2*q^2 + q + 1 + O(q^20)"`

**IMPORTANT NOTES for the executor:**
1. Only change REPL call syntax and expected outputs. Do NOT rewrite mathematical context paragraphs, theorem statements, or references.
2. For expected outputs: the engine now displays in descending power order (Phase 39). Reverse the coefficient order for all polynomial/series outputs. Map outputs ({...}) are NOT affected.
3. Where outputs are placeholder `"([...], [...])"` or similar, leave them as-is (they were already approximate).
4. Cross-reference Garvan's actual Maple worksheets where applicable per user decision. For example, note that the Jacobi triple product section now uses aqprod with explicit q^2 base, matching Garvan's qseries calling convention exactly.
  </action>
  <verify>Read the file and check:
1. Search for `aqprod(1,` or `aqprod(-1,` -- should find zero instances (all replaced with q-monomial forms)
2. Search for `prodmake(%, ` or `prodmake(a, ` (without q arg) -- should find zero 2-arg forms
3. Search for `etamake(` and verify all have explicit q argument
4. Search for `sift(f, 5` -- should be `sift(f, q, 5` instead
5. Search for `findcong(f, [` -- should find zero instances (old moduli-list form gone)
6. Search for `findlincombo(rhs, [mf, mpsi], 0)` -- should be gone, replaced with SL+q form
7. Verify bailey/phi/heine calls are unchanged (they should be)</verify>
  <done>All ~15 legacy function calls in chapter 13 replaced with Garvan-canonical forms. aqprod uses q-monomial args, prodmake/etamake have explicit q, sift has 5-arg form, findcong uses auto-discover, findlincombo uses symbolic labels. Expected outputs updated to descending power order. Bailey, hypergeometric, and mock theta functions that already used correct signatures are left unchanged.</done>
</task>

</tasks>

<verification>
- Zero instances of v1.x integer-triple aqprod calls in chapter 13
- Zero instances of 2-arg prodmake/etamake in chapter 13
- findcong uses findcong(QS, T) form, not findcong(f, [moduli]) form
- sift uses sift(f, q, n, k, T) form
- findlincombo uses findlincombo(f, L, SL, q, topshift) form
- All polynomial/series expected outputs in descending power order
- Bailey chain, hypergeometric, and mock theta functions unchanged (correct already)
</verification>

<success_criteria>
- Every REPL example in chapter 13 uses Garvan-canonical function signatures matching help.rs
- No v1.x legacy signatures remain anywhere in the file
- Expected outputs are consistent with Phase 39 descending display order
- Mathematical narrative, theorem statements, and references are preserved unchanged
- Cross-references to Garvan's Maple worksheets appear where applicable per user decision
</success_criteria>

<output>
After completion, create `.planning/phases/40-documentation/40-05-SUMMARY.md`
</output>
