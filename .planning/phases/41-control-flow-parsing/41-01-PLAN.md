---
phase: 41-control-flow-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/parser.rs
autonomous: true
requirements: [SCRIPT-07]

must_haves:
  truths:
    - "All 6 comparison operators (=, <>, <, >, <=, >=) parse into Compare AST nodes"
    - "Boolean and/or parse into BoolOp AST nodes with correct precedence (and tighter than or)"
    - "Boolean not parses as prefix into Not AST node"
    - "Comparison operators bind tighter than boolean not"
    - "Arithmetic operators bind tighter than comparison operators"
    - "Existing arithmetic and assignment expressions parse identically after binding power renumbering"
  artifacts:
    - path: "crates/qsym-cli/src/token.rs"
      provides: "22 new Token variants (13 keywords + 3 boolean + 6 comparison)"
      contains: "Token::For"
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "CompOp enum, BoolBinOp enum, Compare/BoolOp/Not/ForLoop/IfExpr AST variants"
      contains: "CompOp"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Keyword matching for 16 new words, multi-char operator lexing for <, >, <=, >=, <>, ="
      contains: "Token::LessEq"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Renumbered binding powers, infix comparison/boolean parsing, prefix not"
      contains: "Token::And => Some((5, 6))"
  key_links:
    - from: "crates/qsym-cli/src/lexer.rs"
      to: "crates/qsym-cli/src/token.rs"
      via: "keyword match producing Token variants"
      pattern: "Token::(For|If|And|Or|Not|Equal|Less)"
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "constructing Compare/BoolOp/Not AST nodes from tokens"
      pattern: "AstNode::(Compare|BoolOp|Not)"
---

<objective>
Add all tokens, AST types, lexer keyword/operator recognition, and parser support for comparison operators (=, <>, <, >, <=, >=), boolean operators (and, or, not), and renumber binding powers to make room for the new operator precedence levels.

Purpose: Establishes the complete type and operator infrastructure needed for control flow parsing. Without these tokens and operators, for-loop and if-conditional parsing cannot reference comparison/boolean expressions in conditions.

Output: Token enum with 22 new variants, AST with CompOp/BoolBinOp enums and Compare/BoolOp/Not/ForLoop/IfExpr node variants, lexer recognizing all keywords and multi-char operators, parser with correct Maple-compatible precedence for all operators.
</objective>

<execution_context>
@.planning/phases/41-control-flow-parsing/41-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/parser.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Token variants, AST types, and lexer extensions</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/ast.rs
    crates/qsym-cli/src/lexer.rs
  </files>
  <action>
**token.rs** -- Add 22 new Token variants to the Token enum, BEFORE the Eof variant:

Control flow keywords (13): `For`, `From`, `To`, `By`, `Do`, `Od`, `While`, `If`, `Then`, `Elif`, `Else`, `Fi`, `End` (reserve `end` for future `end do`/`end if` support).

Boolean keywords (3): `And`, `Or`, `Not`.

Comparison operators (6): `Equal` (=), `NotEqual` (<>), `Less` (<), `Greater` (>), `LessEq` (<=), `GreaterEq` (>=).

Each variant gets a doc comment matching the research examples. Add tests for `Token::Equal != Token::Assign`, `Token::Less != Token::Greater`, `Token::And != Token::Or`.

**ast.rs** -- Add new enums and AstNode variants:

1. Add `CompOp` enum: `Eq`, `NotEq`, `Less`, `Greater`, `LessEq`, `GreaterEq` (derive Debug, Clone, Copy, PartialEq, Eq).

2. Add `BoolBinOp` enum: `And`, `Or` (derive Debug, Clone, Copy, PartialEq, Eq).

3. Add AstNode variants:
   - `Compare { op: CompOp, lhs: Box<AstNode>, rhs: Box<AstNode> }` -- comparison expressions
   - `Not(Box<AstNode>)` -- boolean NOT prefix
   - `BoolOp { op: BoolBinOp, lhs: Box<AstNode>, rhs: Box<AstNode> }` -- boolean AND/OR
   - `ForLoop { var: String, from: Box<AstNode>, to: Box<AstNode>, by: Option<Box<AstNode>>, body: Vec<Stmt> }` -- for loop (AST structure defined now, parsing in Plan 02)
   - `IfExpr { condition: Box<AstNode>, then_body: Vec<Stmt>, elif_branches: Vec<(AstNode, Vec<Stmt>)>, else_body: Option<Vec<Stmt>> }` -- conditional (AST structure defined now, parsing in Plan 02)

Add unit tests for Compare, BoolOp, Not, ForLoop, IfExpr construction.

**lexer.rs** -- Extend tokenization:

1. In the identifier keyword match (currently only matches "infinity"), add ALL 16 new keyword words: `for`, `from`, `to`, `by`, `do`, `od`, `while`, `if`, `then`, `elif`, `else`, `fi`, `end`, `and`, `or`, `not`. Each maps to its Token variant. Keep `infinity` and the `_` => Ident fallthrough.

2. Add multi-character operator lexing BEFORE the unknown-character fallback, AFTER the `:` handler. Order matters:
   - `<` handler: check for `<=` (LessEq, 2 chars), `<>` (NotEqual, 2 chars), else Less (1 char)
   - `>` handler: check for `>=` (GreaterEq, 2 chars), else Greater (1 char)
   - `=` handler: always Equal (1 char) -- `:=` is already handled by the `:` handler above

3. Add lexer tests:
   - `"x < 5"` -> [Ident("x"), Less, Integer(5), Eof]
   - `"x <= 5"` -> [Ident("x"), LessEq, Integer(5), Eof]
   - `"x <> 5"` -> [Ident("x"), NotEqual, Integer(5), Eof]
   - `"x > 5"` -> [Ident("x"), Greater, Integer(5), Eof]
   - `"x >= 5"` -> [Ident("x"), GreaterEq, Integer(5), Eof]
   - `"x = 5"` -> [Ident("x"), Equal, Integer(5), Eof]
   - `"x := 5"` -> [Ident("x"), Assign, Integer(5), Eof] (unchanged behavior)
   - `"for n from 1 to 5 do n od"` -> [For, Ident("n"), From, Integer(1), To, Integer(5), Do, Ident("n"), Od, Eof]
   - `"if x and y or not z"` -> [If, Ident("x"), And, Ident("y"), Or, Not, Ident("z"), Eof]
   - `"x = 5"` vs `"x := 5"` verify Equal vs Assign
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli token:: lexer:: ast:: 2>&1 | tail -20`

All token, lexer, and ast module tests pass. No compilation errors.
  </verify>
  <done>
22 new Token variants exist. CompOp, BoolBinOp enums and 5 new AstNode variants exist. Lexer tokenizes all 16 keywords and 6 comparison operators correctly, with proper greedy matching for multi-char operators. Existing lexer tests still pass (`:=` still produces Assign, `:` still produces Colon).
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser binding power renumbering and comparison/boolean operator parsing</name>
  <files>
    crates/qsym-cli/src/parser.rs
  </files>
  <action>
**Renumber binding powers** in `infix_bp()` and `expr_bp()` to make room for boolean and comparison operators. The new layout (from research):

```
Assignment:       l_bp=2,  r_bp=1   (right-associative, UNCHANGED)
or:               l_bp=3,  r_bp=4   (left-associative, NEW)
and:              l_bp=5,  r_bp=6   (left-associative, NEW)
not:              prefix r_bp=7     (prefix unary, NEW)
comparisons:      l_bp=9,  r_bp=10  (non-associative, NEW)
Add/Sub:          l_bp=11, r_bp=12  (left-associative, WAS 3,4)
Mul/Div:          l_bp=13, r_bp=14  (left-associative, WAS 5,6)
Prefix neg:       r_bp=15           (WAS 7)
Pow (^):          l_bp=17, r_bp=18  (non-associative, WAS 9,10)
Function call:    l_bp=19           (WAS 11)
```

1. Update `infix_bp()`:
   - `Token::Or => Some((3, 4))`
   - `Token::And => Some((5, 6))`
   - `Token::Equal | Token::NotEqual | Token::Less | Token::Greater | Token::LessEq | Token::GreaterEq => Some((9, 10))`
   - `Token::Plus | Token::Minus => Some((11, 12))` (was 3,4)
   - `Token::Star | Token::Slash => Some((13, 14))` (was 5,6)
   - `Token::Caret => Some((17, 18))` (was 9,10)

2. Update `expr_bp()` prefix section:
   - Change `Token::Minus` prefix r_bp from 7 to 15: `self.expr_bp(15)?`
   - Add `Token::Not` prefix: `self.advance(); let rhs = self.expr_bp(7)?; AstNode::Not(Box::new(rhs))`

3. Update `expr_bp()` function call l_bp from 11 to 19: `if 19 < min_bp { break; }`

4. Update `expr_bp()` infix binary operator section to handle the NEW operator tokens:
   - After consuming the operator token and parsing RHS, construct the correct AST node:
     - For `Token::Equal|NotEqual|Less|Greater|LessEq|GreaterEq`: build `AstNode::Compare { op: CompOp::X, lhs, rhs }`
     - For `Token::And|Or`: build `AstNode::BoolOp { op: BoolBinOp::X, lhs, rhs }`
     - Keep existing `Token::Plus|Minus|Star|Slash|Caret` building `AstNode::BinOp { op: BinOp::X, lhs, rhs }`

   The cleanest approach: split the infix match into two branches. One for arithmetic ops (producing BinOp), one for comparison ops (producing Compare), one for boolean ops (producing BoolOp). OR, restructure the single infix block to produce the correct AstNode variant based on the op_token.

5. Add non-associativity check for comparison operators: after constructing a Compare node, check if the next token is also a comparison operator. If so, emit error: "comparison operators are non-associative: use parentheses". This mirrors the existing `^` non-associativity check.

6. Update `token_name()` with entries for ALL 22 new token variants (see research for the full list).

7. Add parser tests:
   - `parse_expr("x < 5")` produces `AstNode::Compare { op: CompOp::Less, lhs: Variable("x"), rhs: Integer(5) }`
   - `parse_expr("x <> 0")` produces `AstNode::Compare { op: CompOp::NotEq, ... }`
   - `parse_expr("x = 5")` produces `AstNode::Compare { op: CompOp::Eq, ... }`
   - `parse_expr("x <= 5")` produces `AstNode::Compare { op: CompOp::LessEq, ... }`
   - `parse_expr("x > 5")` produces `AstNode::Compare { op: CompOp::Greater, ... }`
   - `parse_expr("x >= 5")` produces `AstNode::Compare { op: CompOp::GreaterEq, ... }`
   - `parse_expr("a and b")` produces `AstNode::BoolOp { op: BoolBinOp::And, ... }`
   - `parse_expr("a or b")` produces `AstNode::BoolOp { op: BoolBinOp::Or, ... }`
   - `parse_expr("not x")` produces `AstNode::Not(Variable("x"))`
   - Precedence: `parse_expr("a > 0 and b < 10 or c = 5")` produces `BoolOp::Or` at top with `BoolOp::And` on left
   - Precedence: `parse_expr("not x > 5")` produces `Not(Compare(Greater, ...))` -- not binds looser than >
   - Precedence: `parse_expr("a + b < c * d")` produces `Compare(Less, BinOp(Add,...), BinOp(Mul,...))`
   - Non-associativity: `parse("a < b < c")` returns error containing "non-associative"
   - Assignment still works: `parse_expr("x := 5")` still produces `AstNode::Assign { ... }`
   - ALL existing parser tests pass unchanged (binding power renumbering preserves relative ordering)
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -30`

ALL tests pass (both new and existing). Specifically verify:
- All existing arithmetic/assignment/function-call tests still pass (renumbering is transparent)
- New comparison/boolean tests pass
- Non-associativity error for chained comparisons works
  </verify>
  <done>
Parser binding powers renumbered to Maple-compatible layout. All 6 comparison operators parse into Compare AST nodes. Boolean and/or parse into BoolOp nodes with correct precedence (and tighter than or). Prefix not parses into Not node. Comparisons are non-associative (chaining errors). All existing parser tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- ALL tests pass (existing + new)
2. No compilation warnings in token.rs, ast.rs, lexer.rs, parser.rs
3. `parse_expr("a + b < c * d and not x = 0 or y >= 1")` parses with correct precedence tree
4. `:=` (assignment) and `=` (comparison) are cleanly disambiguated
</verification>

<success_criteria>
- 22 new Token variants added and recognized by lexer
- CompOp, BoolBinOp enums and Compare/BoolOp/Not/ForLoop/IfExpr AstNode variants exist
- All 6 comparison + 3 boolean operators parse with correct Maple precedence
- Binding power renumbering preserves all existing parser behavior
- Non-associative comparison operators reject chaining with clear error
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/41-control-flow-parsing/41-01-SUMMARY.md`
</output>
