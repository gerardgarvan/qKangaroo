---
phase: 41-control-flow-parsing
plan: 02
type: execute
wave: 2
depends_on: [41-01]
files_modified:
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements: [SCRIPT-01, SCRIPT-06]

must_haves:
  truths:
    - "for n from 1 to 5 do print(n) od parses into ForLoop AST node"
    - "for n to 5 do n od parses with default from=1"
    - "for n from 1 to 10 by 2 do n od parses with by clause"
    - "for-loop body can contain multiple semicolon-separated statements"
    - "if x > 0 then A fi parses into IfExpr with no elif or else"
    - "if x > 0 then A elif x = 0 then B else C fi parses with elif and else branches"
    - "if-block body can contain multiple semicolon-separated statements"
    - "REPL waits for od when user types for...do without od"
    - "REPL waits for fi when user types if...then without fi"
  artifacts:
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "ForLoop and IfExpr prefix parsing, parse_stmt_sequence method"
      contains: "Token::For =>"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "Extended is_incomplete for for/od and if/fi nesting"
      contains: "for"
  key_links:
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "constructing ForLoop and IfExpr AST nodes"
      pattern: "AstNode::(ForLoop|IfExpr)"
    - from: "crates/qsym-cli/src/parser.rs parse_stmt_sequence"
      to: "crates/qsym-cli/src/parser.rs expr_bp"
      via: "calling expr_bp(0) for each statement in the body"
      pattern: "self\\.expr_bp\\(0\\)"
    - from: "crates/qsym-cli/src/repl.rs is_incomplete"
      to: "keyword nesting detection"
      via: "word-level scanning for for/do/od and if/fi pairs"
      pattern: "for|od|if|fi"
---

<objective>
Add for-loop and if/elif/else/fi parsing as prefix atoms in the Pratt parser, with a new `parse_stmt_sequence` method for multi-statement bodies, and extend REPL multiline detection to track for/od and if/fi nesting.

Purpose: Completes control flow parsing so users can write Maple-style for-loops and conditionals that parse into correct AST nodes. This is parse-only -- evaluation is deferred to Phase 42.

Output: ForLoop and IfExpr parsed from input, statement sequences in bodies, REPL multiline working for control flow.
</objective>

<execution_context>
@.planning/phases/41-control-flow-parsing/41-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-control-flow-parsing/41-01-SUMMARY.md
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/repl.rs
@crates/qsym-cli/src/ast.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: For-loop and if/elif/else parsing with statement sequences</name>
  <files>
    crates/qsym-cli/src/parser.rs
  </files>
  <action>
**1. Add `parse_stmt_sequence` method to Parser impl:**

```rust
/// Parse a sequence of statements until one of the terminator tokens is seen.
/// The terminating token is NOT consumed.
/// Statements are separated by `;` or `:` (both consumed as terminators).
fn parse_stmt_sequence(&mut self, terminators: &[Token]) -> Result<Vec<Stmt>, ParseError>
```

Logic:
- Loop:
  - Skip consecutive `;` and `:` (empty statements)
  - If current token matches any terminator OR is Eof, break
  - Parse an expression via `self.expr_bp(0)?`
  - Check next token: if `;`, consume and record Semi terminator. If `:`, consume and record Colon. If a terminator token or Eof, record Implicit. Otherwise, record Implicit (last stmt before terminator doesn't need `;`).
  - Push Stmt { node, terminator }
- Return Vec<Stmt>

The terminator tokens to pass will be:
- For for-loop body: `[Token::Od]`
- For if-then body: `[Token::Elif, Token::Else, Token::Fi]`
- For elif-then body: `[Token::Elif, Token::Else, Token::Fi]`
- For else body: `[Token::Fi]`

**2. Add `Token::For` prefix parsing in `expr_bp` NUD section:**

Add a match arm for `Token::For` in the prefix section (before the `_` catch-all error):

```
Token::For => {
    self.advance(); // consume 'for'
    // Variable name (required)
    let var_name = match self.peek().clone() {
        Token::Ident(name) => { self.advance(); name }
        _ => return Err(ParseError::new("expected variable name after 'for'", self.peek_span()))
    };
    // Optional 'from' clause (default: Integer(1))
    let from_expr = if *self.peek() == Token::From {
        self.advance(); // consume 'from'
        self.expr_bp(0)?
    } else {
        AstNode::Integer(1) // default from value
    };
    // Required 'to' clause
    self.expect(&Token::To, "'to' in for loop")?;
    let to_expr = self.expr_bp(0)?;
    // Optional 'by' clause (default: None)
    let by_expr = if *self.peek() == Token::By {
        self.advance(); // consume 'by'
        Some(Box::new(self.expr_bp(0)?))
    } else {
        None
    };
    // Required 'do' keyword
    self.expect(&Token::Do, "'do' in for loop")?;
    // Parse body statements until 'od'
    let body = self.parse_stmt_sequence(&[Token::Od])?;
    self.expect(&Token::Od, "'od' to close for loop")?;
    AstNode::ForLoop {
        var: var_name,
        from: Box::new(from_expr),
        to: Box::new(to_expr),
        by: by_expr,
        body,
    }
}
```

**3. Add `Token::If` prefix parsing in `expr_bp` NUD section:**

```
Token::If => {
    self.advance(); // consume 'if'
    let condition = self.expr_bp(0)?;
    self.expect(&Token::Then, "'then' after if condition")?;
    let then_body = self.parse_stmt_sequence(&[Token::Elif, Token::Else, Token::Fi])?;
    let mut elif_branches = Vec::new();
    while *self.peek() == Token::Elif {
        self.advance(); // consume 'elif'
        let elif_cond = self.expr_bp(0)?;
        self.expect(&Token::Then, "'then' after elif condition")?;
        let elif_body = self.parse_stmt_sequence(&[Token::Elif, Token::Else, Token::Fi])?;
        elif_branches.push((elif_cond, elif_body));
    }
    let else_body = if *self.peek() == Token::Else {
        self.advance(); // consume 'else'
        Some(self.parse_stmt_sequence(&[Token::Fi])?)
    } else {
        None
    };
    self.expect(&Token::Fi, "'fi' to close if expression")?;
    AstNode::IfExpr {
        condition: Box::new(condition),
        then_body,
        elif_branches,
        else_body,
    }
}
```

**4. Update `parse_line` to allow control-flow keyword terminators:**

The current `parse_line` method has an `else` branch that errors on unexpected tokens after a statement. After renumbering, tokens like `Od`, `Fi`, `Elif`, `Else`, `Then` might appear in that position when we are NOT inside a stmt_sequence (e.g., user types `od` at top level). These should still error via the existing "expected ';', ':', or end of input" message since they are unexpected outside of a block context. No change needed -- the error message is already appropriate.

**5. Add comprehensive parser tests:**

For-loop tests:
- `parse_expr("for n from 1 to 5 do n od")` -> ForLoop { var: "n", from: Integer(1), to: Integer(5), by: None, body: [Stmt(Variable("n"), Implicit)] }
- `parse_expr("for n to 10 do n od")` -> ForLoop { var: "n", from: Integer(1) (default), to: Integer(10), ... }
- `parse_expr("for k from 0 to 8 by 2 do k od")` -> ForLoop { by: Some(Integer(2)), ... }
- Multi-statement body: `parse_expr("for n from 1 to 3 do x := n; x od")` -> body has 2 statements, first with Semi terminator
- Body with colon suppression: `parse_expr("for n from 1 to 3 do x := n: x od")` -> first stmt has Colon terminator
- `parse_expr("for n from 1 to 5 do print(n) od")` -> body contains FuncCall

If-conditional tests:
- Simple if/fi: `parse_expr("if x > 0 then 1 fi")` -> IfExpr with no elif, no else
- If/else/fi: `parse_expr("if x > 0 then 1 else 0 fi")` -> IfExpr with else_body Some
- If/elif/else/fi: `parse_expr("if x > 0 then 1 elif x = 0 then 0 else -1 fi")` -> elif_branches.len() == 1, else_body Some
- Multiple elif: `parse_expr("if a then 1 elif b then 2 elif c then 3 fi")` -> elif_branches.len() == 2, else_body None
- Multi-statement body: `parse_expr("if x > 0 then a := 1; a else b := 2; b fi")` -> then_body has 2 stmts, else_body has 2 stmts

Error tests:
- `parse("for 3 from 1 to 5 do x od")` errors "expected variable name after 'for'"
- `parse("for n from 1 do n od")` errors "expected 'to'"
- `parse("for n from 1 to 5 n od")` errors "expected 'do'"
- `parse("for n from 1 to 5 do n")` errors "expected 'od'" (or end-of-input before od)
- `parse("if x > 0 1 fi")` errors "expected 'then'"
- `parse("if x > 0 then 1")` errors "expected 'fi'" (or end-of-input before fi)

Nested control flow:
- `parse_expr("for n from 1 to 3 do if n > 1 then n fi od")` -> ForLoop body contains IfExpr
- `parse_expr("if x > 0 then for n from 1 to 5 do n od fi")` -> IfExpr then_body contains ForLoop
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli parser:: 2>&1 | tail -30`

All parser tests pass, including new for-loop, if-conditional, and nested control flow tests.
  </verify>
  <done>
ForLoop and IfExpr parse correctly as prefix atoms in the Pratt parser. parse_stmt_sequence handles multi-statement bodies with ;/: terminators. Optional from (defaults to 1) and optional by clause work. If/elif/else chains parse with any number of elif branches. Nested for-in-if and if-in-for work. All error cases produce clear messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: REPL multiline detection for for/od and if/fi nesting</name>
  <files>
    crates/qsym-cli/src/repl.rs
  </files>
  <action>
Extend `ReplHelper::is_incomplete()` to detect unclosed `for...od` and `if...fi` blocks, in addition to the existing bracket counting.

The current implementation is a simple character-level scanner counting `(` and `[`. For keyword detection, we need a lightweight word-level scan. The approach:

1. Keep the existing bracket depth counter.

2. Add keyword depth tracking. Scan words (sequences of `[a-zA-Z_][a-zA-Z0-9_]*`) and track:
   - `for_depth`: incremented by `for`, decremented by `od`
   - `if_depth`: incremented by `if`, decremented by `fi`

3. Return `true` if bracket_depth > 0 OR for_depth > 0 OR if_depth > 0.

Implementation approach -- iterate over characters, building up word tokens when alphabetic, and on word boundaries check the accumulated word:

```rust
fn is_incomplete(input: &str) -> bool {
    let mut bracket_depth: i32 = 0;
    let mut for_depth: i32 = 0;
    let mut if_depth: i32 = 0;
    let mut word = String::new();
    let mut in_string = false;
    let mut string_char = ' ';

    for ch in input.chars() {
        // Track string literals to avoid matching keywords inside strings
        if in_string {
            if ch == string_char {
                in_string = false;
            }
            continue;
        }
        if ch == '"' || ch == '\'' {
            in_string = true;
            string_char = ch;
            // Flush any accumulated word first
            Self::check_keyword(&word, &mut for_depth, &mut if_depth);
            word.clear();
            continue;
        }
        // Comment handling: skip rest of line after #
        if ch == '#' {
            Self::check_keyword(&word, &mut for_depth, &mut if_depth);
            word.clear();
            // Skip to newline -- but we're iterating chars, so just
            // set a flag. Actually simpler: just flush the word and
            // let the rest be scanned. '#' won't form valid keywords
            // so it's fine. But 'for' in a comment would be wrong.
            // Better: break out and scan remaining for \n.
            // Simplest approach: pre-strip comments from each line.
            break; // TODO: handle multi-line. Actually, is_incomplete
                   // receives the full accumulated input including newlines.
        }

        if ch.is_ascii_alphanumeric() || ch == '_' {
            word.push(ch);
        } else {
            Self::check_keyword(&word, &mut for_depth, &mut if_depth);
            word.clear();
            match ch {
                '(' | '[' => bracket_depth += 1,
                ')' | ']' => bracket_depth -= 1,
                _ => {}
            }
        }
    }
    // Flush final word
    Self::check_keyword(&word, &mut for_depth, &mut if_depth);

    bracket_depth > 0 || for_depth > 0 || if_depth > 0
}

fn check_keyword(word: &str, for_depth: &mut i32, if_depth: &mut i32) {
    match word {
        "for" => *for_depth += 1,
        "od" => *for_depth -= 1,
        "if" => *if_depth += 1,
        "fi" => *if_depth -= 1,
        _ => {}
    }
}
```

IMPORTANT: Handle comments properly. The input may contain `# comment with for keyword`. To avoid false matches, when encountering `#`, skip all characters until the next `\n` (or end of input). This requires restructuring the loop slightly -- instead of `break`, continue scanning but skip comment content.

Better implementation: iterate with index-based loop or pre-process to strip comments. Or: track `in_comment` state that resets on `\n`.

Add tests:
- `is_incomplete("for n from 1 to 5 do")` -> true (no `od`)
- `is_incomplete("for n from 1 to 5 do n od")` -> false (balanced)
- `is_incomplete("if x > 0 then")` -> true (no `fi`)
- `is_incomplete("if x > 0 then 1 fi")` -> false (balanced)
- `is_incomplete("if x > 0 then 1 elif x = 0 then")` -> true (still no `fi`)
- `is_incomplete("for n from 1 to 3 do if n > 1 then n fi")` -> true (nested: fi closes if but od still missing)
- `is_incomplete("for n from 1 to 3 do if n > 1 then n fi od")` -> false (both closed)
- Existing bracket tests still pass
- `is_incomplete("# for")` -> false (keyword in comment ignored)
- `is_incomplete("\"for\"")` -> false (keyword in string ignored)
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli repl:: 2>&1 | tail -30`

All repl tests pass including new keyword-nesting tests and existing bracket tests.
  </verify>
  <done>
REPL multiline detection correctly tracks for/od and if/fi nesting depth alongside existing bracket counting. Keywords inside strings and comments are ignored. Typing `for n from 1 to 5 do` at the REPL prompt triggers continuation mode until `od` is entered.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- ALL tests pass (existing + new from both plans)
2. `for n from 1 to 5 do print(n) od` parses into ForLoop AST node
3. `if x > 0 then A elif x = 0 then B else C fi` parses into IfExpr AST node
4. Multi-statement bodies work with `;` and `:` separators
5. Nested for-in-if and if-in-for parse correctly
6. REPL detects incomplete for/if blocks
7. No regression in any existing functionality
</verification>

<success_criteria>
- ForLoop AST node: var, from (with default), to, optional by, body as Vec<Stmt>
- IfExpr AST node: condition, then_body, elif_branches (any number), optional else_body
- parse_stmt_sequence handles ;/: separated statements with keyword terminators
- Nested control flow (for-in-if, if-in-for) parses correctly
- REPL is_incomplete tracks for/od and if/fi depth
- All existing tests pass unchanged
- Clear error messages for missing keywords (to, do, od, then, fi)
</success_criteria>

<output>
After completion, create `.planning/phases/41-control-flow-parsing/41-02-SUMMARY.md`
</output>
