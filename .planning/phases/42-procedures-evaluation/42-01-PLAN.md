---
phase: 42-procedures-evaluation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements: [SCRIPT-04, SCRIPT-05]

must_haves:
  truths:
    - "for n from 1 to 5 do n^2 od evaluates and returns 25 (last iteration)"
    - "if 3 > 2 then 1 else 0 fi evaluates and returns 1"
    - "if/elif/else chains evaluate only the matching branch"
    - "Boolean operators short-circuit: false and X does not evaluate X"
    - "Comparison operators work on integers and rationals: 3 < 5 returns true"
    - "RETURN(42) at top level produces a clear error message"
    - "For-loop variable is scoped: after for n from 1 to 3 do n od, n is restored"
    - "not true returns false, not false returns true"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "eval_compare, eval_bool_op, eval_for_loop, eval_if_expr, eval_stmt_sequence, EarlyReturn, RETURN handling"
      contains: "EarlyReturn"
  key_links:
    - from: "eval_expr AstNode::Compare"
      to: "eval_compare()"
      via: "match arm dispatches to helper"
      pattern: "eval_compare"
    - from: "eval_expr AstNode::ForLoop"
      to: "eval_for_loop()"
      via: "match arm dispatches to helper"
      pattern: "eval_for_loop"
    - from: "eval_expr AstNode::IfExpr"
      to: "eval_if_expr()"
      via: "match arm dispatches to helper"
      pattern: "eval_if_expr"
    - from: "eval_expr AstNode::FuncCall RETURN"
      to: "EvalError::EarlyReturn"
      via: "special-case check before dispatch"
      pattern: "EarlyReturn"
---

<objective>
Implement evaluation for all control flow AST nodes (Compare, BoolOp, Not, ForLoop, IfExpr) and add RETURN early-exit support.

Purpose: Phase 41 parsed these constructs into AST nodes but left evaluation as stubs returning "control flow not yet implemented". This plan replaces those stubs with working evaluation so that for-loops iterate, if/elif/else branches select, comparisons produce booleans, boolean operators short-circuit, and RETURN unwinds via EvalError::EarlyReturn. This is prerequisite for Plan 02 (procedures), which needs working control flow in procedure bodies.

Output: eval.rs with 6 new evaluation functions, EarlyReturn error variant, RETURN special-case handling, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-procedures-evaluation/42-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/environment.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Control flow evaluation and comparison operators</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Replace the catch-all stub at the bottom of eval_expr() (the match arm for Compare/Not/BoolOp/ForLoop/IfExpr that returns "control flow not yet implemented") with individual match arms dispatching to new helper functions. Implement all of the following:

1. **eval_compare(op: CompOp, left: Value, right: Value) -> Result<Value, EvalError>**
   - Integer vs Integer: direct comparison using QInt's Ord impl
   - Integer vs Rational or vice versa: promote Integer to Rational, then compare
   - Rational vs Rational: compare using QRat's Ord impl
   - Symbol vs Symbol: equality check on name strings (for `=` and `<>` only); for ordering ops (`<`, `>`, `<=`, `>=`) on symbols, return TypeError
   - Bool vs Bool: equality check only (for `=` and `<>`); ordering on bools is TypeError
   - All other combinations: return TypeError with message "cannot compare {left_type} and {right_type}"
   - All 6 CompOp variants: Eq, NotEq, Less, Greater, LessEq, GreaterEq
   - Return Value::Bool(result)

2. **eval_not(inner: Value) -> Result<Value, EvalError>** (inline in match arm is fine)
   - Value::Bool(b) => Ok(Value::Bool(!b))
   - Other => TypeError "operand of 'not' must be bool, got {type}"

3. **eval_bool_op(op: BoolBinOp, lhs: &AstNode, rhs: &AstNode, env) -> Result<Value, EvalError>** -- NOTE: this must take AST nodes (not Values) for short-circuit evaluation.
   - For And: evaluate lhs. If Value::Bool(false), return false immediately (do NOT evaluate rhs). If Value::Bool(true), evaluate rhs and return it. If lhs is not Bool, TypeError.
   - For Or: evaluate lhs. If Value::Bool(true), return true immediately. If Value::Bool(false), evaluate rhs and return it. If lhs is not Bool, TypeError.
   - After evaluating rhs, if rhs is not Bool, TypeError.
   - The BoolOp match arm in eval_expr must pass AST nodes, not pre-evaluated values.

4. **eval_stmt_sequence(stmts: &[Stmt], env: &mut Environment) -> Result<Value, EvalError>**
   - Iterate through statements, evaluating each with eval_expr
   - Return the value of the last statement
   - If stmts is empty, return Value::None
   - IMPORTANT: propagate EvalError::EarlyReturn upward (do NOT catch it here)

5. **eval_for_loop(var, from, to, by, body, env) -> Result<Value, EvalError>**
   - Evaluate `from` and `to` to i64 (using extract_i64-style conversion: Value::Integer -> to_i64, else TypeError)
   - Evaluate `by` to i64 if present, default to 1
   - Validate step != 0, error if so
   - Save the current value of the loop variable (env.variables.remove(var))
   - Loop: while (step > 0 && i <= end) || (step < 0 && i >= end)
     - Set var = Value::Integer(QInt::from(i))
     - Evaluate body via eval_stmt_sequence
     - If eval_stmt_sequence returns Err(EarlyReturn), propagate it (do NOT catch -- only procedures catch EarlyReturn)
     - i += step
   - After loop (or on any error), restore the loop variable's old value
   - Return the value from the last iteration (or Value::None if zero iterations)
   - Use a closure or manual try-block pattern to ensure restore happens on ALL paths (success, error, EarlyReturn)

6. **eval_if_expr(condition, then_body, elif_branches, else_body, env) -> Result<Value, EvalError>**
   - Evaluate condition. Call is_truthy() to test.
   - If truthy: eval_stmt_sequence(then_body, env)
   - Else: iterate elif_branches, evaluate each condition, if truthy eval its body
   - If no branch matches and else_body exists: eval_stmt_sequence(else_body, env)
   - If no branch matches and no else: return Value::None
   - Propagate EarlyReturn errors (do NOT catch)

7. **is_truthy(val: &Value) -> Result<bool, EvalError>**
   - Value::Bool(b) => Ok(b)
   - Value::Integer(n) => Ok(n != 0) -- Maple treats nonzero as true
   - Other => Err(EvalError::Other("expected boolean or integer in condition, got {type}"))

8. **EvalError::EarlyReturn(Value)** -- Add new variant to EvalError enum.
   - Display impl: "Error: RETURN used outside of a procedure"
   - This message only appears if EarlyReturn propagates to the top level

9. **RETURN special handling in FuncCall** -- In the eval_expr FuncCall arm, BEFORE the existing argument evaluation and dispatch:
   - Check if name == "RETURN"
   - If so: expect exactly 1 argument (raw AST arg), evaluate it, return Err(EvalError::EarlyReturn(val))
   - This must happen BEFORE the loop that evaluates all args and before the call to dispatch()
   - Restructure the FuncCall arm: check RETURN first, then evaluate args, then dispatch

Add comprehensive tests in eval.rs #[cfg(test)] module:
- test_compare_integers: 3 < 5 is true, 5 < 3 is false, 3 = 3 is true, 3 <> 3 is false
- test_compare_rationals: 1/3 < 1/2 is true
- test_compare_mixed_int_rat: 1 < 3/2 is true
- test_compare_symbols_eq: symbol "x" = symbol "x" is true, "x" = "y" is false
- test_not_bool: not true = false, not false = true
- test_bool_and_short_circuit: false and (error) returns false without evaluating rhs
- test_bool_or_short_circuit: true or (error) returns true without evaluating rhs
- test_for_loop_basic: for n from 1 to 5 do n^2 od returns 25
- test_for_loop_scoping: loop variable restored after loop
- test_for_loop_by: for n from 0 to 10 by 2 do n od returns 10
- test_for_loop_empty: for n from 5 to 1 do n od returns None (zero iterations)
- test_if_then_fi: if true then 42 fi returns 42
- test_if_else: if false then 1 else 2 fi returns 2
- test_if_elif_else: test all branch selection
- test_return_top_level: RETURN(5) produces EarlyReturn error
- test_is_truthy: Bool(true) -> true, Bool(false) -> false, Integer(0) -> false, Integer(1) -> true
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli`
All existing tests pass plus all new control flow evaluation tests pass.
  </verify>
  <done>
All 5 control flow AST nodes evaluate correctly. Comparisons produce Value::Bool. Boolean operators short-circuit. For-loops iterate with scoped variables. If/elif/else selects the correct branch. RETURN produces EarlyReturn error. EarlyReturn at top level gives clear error message. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (existing + new)
2. Manual verification via test cases:
   - Compare: `3 < 5` -> true, `5 = 5` -> true
   - BoolOp: `true and false` -> false, `true or false` -> true
   - ForLoop: `for n from 1 to 5 do n^2 od` -> 25
   - IfExpr: `if 3 > 2 then 1 else 0 fi` -> 1
   - RETURN: `RETURN(5)` at top level -> error about RETURN outside procedure
</verification>

<success_criteria>
- The 5 control flow AST nodes (Compare, BoolOp, Not, ForLoop, IfExpr) all evaluate correctly instead of returning "not yet implemented"
- For-loop variables are properly scoped (saved/restored)
- Boolean short-circuit evaluation works
- RETURN(value) produces EarlyReturn that can be caught by procedures (Plan 02)
- All existing 629+ tests still pass
- At least 15 new tests covering control flow evaluation
</success_criteria>

<output>
After completion, create `.planning/phases/42-procedures-evaluation/42-01-SUMMARY.md`
</output>
