---
phase: 42-procedures-evaluation
plan: 02
type: execute
wave: 2
depends_on: [42-01]
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements: [SCRIPT-02, SCRIPT-03, SCRIPT-05]

must_haves:
  truths:
    - "User can define f := proc(n) local k; k := n*n; k; end and call f(5) to get 25"
    - "Local variable k does not leak into global scope after calling f(5)"
    - "RETURN(value) inside a procedure exits early and returns the value"
    - "RETURN inside nested for-loop inside procedure correctly unwinds to procedure boundary"
    - "option remember causes memoized return on repeated calls with same arguments"
    - "Procedure display shows proc(params) ... end proc"
    - "Multiline proc definitions work in REPL (proc/end tracked for continuation)"
    - "User-defined procedures shadow built-in functions when assigned"
  artifacts:
    - path: "crates/qsym-cli/src/token.rs"
      provides: "Token::Proc, Token::Local, Token::OptionKw variants"
      contains: "Proc"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "proc, local, option keyword mapping"
      contains: "\"proc\""
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode::ProcDef variant"
      contains: "ProcDef"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "proc(...) local ...; option ...; body; end parsing"
      contains: "Token::Proc"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Procedure struct, Value::Procedure, call_procedure(), memo table"
      contains: "Procedure"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "Display for Value::Procedure"
      contains: "Procedure"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "proc/end depth tracking in is_incomplete"
      contains: "proc_depth"
  key_links:
    - from: "parser.rs Token::Proc prefix"
      to: "AstNode::ProcDef"
      via: "parse proc(...) local/option/body/end"
      pattern: "ProcDef"
    - from: "eval.rs AstNode::ProcDef"
      to: "Value::Procedure"
      via: "eval creates Procedure struct"
      pattern: "Value::Procedure"
    - from: "eval.rs AstNode::FuncCall"
      to: "call_procedure()"
      via: "check env for Value::Procedure before dispatch()"
      pattern: "call_procedure"
    - from: "call_procedure()"
      to: "EvalError::EarlyReturn"
      via: "catches EarlyReturn at procedure boundary"
      pattern: "EarlyReturn.*Ok"
    - from: "call_procedure()"
      to: "proc.memo"
      via: "Rc<RefCell<HashMap>> shared memo table"
      pattern: "memo.*borrow"
    - from: "eval.rs AstNode::Assign"
      to: "Value::Procedure name"
      via: "assignment sets procedure name field"
      pattern: "Procedure.*name"
---

<objective>
Add procedure definition parsing, the Value::Procedure runtime type, procedure calling with local variable scoping, memoization (option remember), and REPL multiline support for proc/end.

Purpose: This is the core of Maple-compatible user-defined procedures. Users can write `f := proc(n) local k; k := n*n; k; end` and call `f(5)` to get 25. Procedures support local variables (scoped via save/restore), early return via RETURN() (using EarlyReturn from Plan 01), and memoization via `option remember`. This enables Garvan-style procedure definitions from qmaple.pdf.

Output: 7 files modified -- tokens, lexer, AST, parser, evaluator, formatter, and REPL -- with comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-procedures-evaluation/42-RESEARCH.md
@.planning/phases/42-procedures-evaluation/42-01-SUMMARY.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-cli/src/repl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tokens, lexer, AST, and parser for proc definitions</name>
  <files>crates/qsym-cli/src/token.rs, crates/qsym-cli/src/lexer.rs, crates/qsym-cli/src/ast.rs, crates/qsym-cli/src/parser.rs</files>
  <action>
**token.rs:** Add 3 new token variants in the "Control flow keywords" section, after the `End` variant:
```rust
/// `proc` procedure definition keyword.
Proc,
/// `local` local variable declaration keyword.
Local,
/// `option` procedure option keyword (e.g., `option remember`).
OptionKw,
```
Use `OptionKw` (not `Option`) to avoid collision with Rust's Option type.

**lexer.rs:** Add keyword mappings in the match block (after "end" => Token::End):
```rust
"proc" => Token::Proc,
"local" => Token::Local,
"option" => Token::OptionKw,
```

**ast.rs:** Add a new AstNode variant after IfExpr:
```rust
/// Procedure definition: `proc(params) [local vars;] [option opts;] body; end [proc]`.
ProcDef {
    params: Vec<String>,
    locals: Vec<String>,
    options: Vec<String>,
    body: Vec<Stmt>,
},
```

**parser.rs:** Add proc as a prefix parsing case in expr_bp(), in the prefix match section before the `_ =>` catch-all. The pattern follows the same structure as ForLoop and IfExpr:

```
Token::Proc => {
    self.advance(); // consume 'proc'
    self.expect(&Token::LParen, "'(' after 'proc'")?;
    // Parse parameter list (comma-separated identifiers, possibly empty)
    let params = parse comma-separated idents until RParen;
    self.expect(&Token::RParen, "')' to close proc parameters")?;

    // Optional: local declarations
    let locals = if peek == Token::Local {
        advance; parse comma-separated idents; expect Semi;
        names
    } else { vec![] };

    // Optional: option declarations
    let options = if peek == Token::OptionKw {
        advance; parse comma-separated idents; expect Semi;
        names
    } else { vec![] };

    // Body statements until 'end'
    let body = self.parse_stmt_sequence(&[Token::End])?;
    self.expect(&Token::End, "'end' to close proc")?;

    // Optional 'proc' after 'end' (Maple allows "end proc")
    if peek == Token::Proc { self.advance(); }

    AstNode::ProcDef { params, locals, options, body }
}
```

For parsing the comma-separated identifier list (params, locals, options), create a helper method `parse_ident_list(&mut self) -> Result<Vec<String>, ParseError>` that:
- Returns empty vec if next token is not Ident
- Otherwise, collects identifiers separated by commas
- Stops when next token is not Comma (does NOT consume the terminator)

Also add `Token::Proc`, `Token::Local`, `Token::OptionKw` to the `token_name()` function:
```rust
Token::Proc => "'proc'".to_string(),
Token::Local => "'local'".to_string(),
Token::OptionKw => "'option'".to_string(),
```

Add parser tests:
- test_parse_proc_simple: `proc(n) n*n; end` parses to ProcDef with params=["n"], no locals, no options, body with one stmt
- test_parse_proc_locals: `proc(n) local k; k := n; end` parses with locals=["k"]
- test_parse_proc_option_remember: `proc(n) option remember; n; end` parses with options=["remember"]
- test_parse_proc_full: `proc(n) local k; option remember; k := n*n; k; end` parses correctly
- test_parse_proc_end_proc: `proc(n) n; end proc` accepts optional `proc` after `end`
- test_parse_proc_empty_params: `proc() 42; end` parses with empty params
- test_parse_proc_multiple_locals: `proc(a, b) local x, y, z; x; end` parses with 3 locals
- test_parse_proc_assign: `f := proc(n) n; end` parses as Assign { name: "f", value: ProcDef }

Add lexer tests:
- test_lex_proc_keyword: "proc" lexes to Token::Proc
- test_lex_local_keyword: "local" lexes to Token::Local
- test_lex_option_keyword: "option" lexes to Token::OptionKw
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli`
All existing tests pass plus all new parser/lexer tests pass. Specifically: `cargo test -p qsym-cli -- proc` shows new proc-related tests passing.
  </verify>
  <done>
Three new tokens (Proc, Local, OptionKw) are lexed. AstNode::ProcDef is defined. Parser handles `proc(params) [local ...;] [option ...;] body; end [proc]` syntax. All 8+ new parser tests pass. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Procedure evaluation, calling, memoization, format, and REPL multiline</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/src/format.rs, crates/qsym-cli/src/repl.rs</files>
  <action>
**eval.rs -- Procedure struct and Value::Procedure:**

Add imports at the top of eval.rs:
```rust
use std::cell::RefCell;
use std::rc::Rc;
use std::collections::HashMap;
```
(HashMap may already be imported -- check and avoid duplicates.)

Define the Procedure struct (near the Value enum):
```rust
/// A user-defined procedure (stored as AST, re-evaluated on each call).
#[derive(Clone, Debug)]
pub struct Procedure {
    /// Display name (set when assigned to a variable via :=).
    pub name: String,
    /// Formal parameter names.
    pub params: Vec<String>,
    /// Local variable names declared with `local`.
    pub locals: Vec<String>,
    /// Whether `option remember` was specified.
    pub remember: bool,
    /// Body statements (AST, re-evaluated on each call).
    pub body: Vec<Stmt>,
    /// Shared memoization table (keyed by Debug-string of args).
    pub memo: Rc<RefCell<HashMap<String, Value>>>,
}
```

Add `Value::Procedure(Procedure)` variant to the Value enum (after JacobiProduct).

Update `Value::type_name()` to return "procedure" for Value::Procedure.

**eval.rs -- ProcDef evaluation:**

Add match arm in eval_expr for AstNode::ProcDef:
```rust
AstNode::ProcDef { params, locals, options, body } => {
    let remember = options.iter().any(|o| o == "remember");
    Ok(Value::Procedure(Procedure {
        name: String::new(), // unnamed until assigned
        params: params.clone(),
        locals: locals.clone(),
        remember,
        body: body.clone(),
        memo: Rc::new(RefCell::new(HashMap::new())),
    }))
}
```

**eval.rs -- Assignment sets procedure name:**

In the Assign arm of eval_expr, after `let val = eval_expr(value, env)?;` and before `env.set_var(name, val.clone())`, add:
```rust
// Set procedure name when assigned to a variable
let val = if let Value::Procedure(mut proc) = val {
    proc.name = name.clone();
    Value::Procedure(proc)
} else {
    val
};
```

**eval.rs -- Procedure call dispatch:**

Restructure the FuncCall arm in eval_expr. The new order is:
1. Check for RETURN special case (from Plan 01)
2. Check if name refers to a Value::Procedure in env
3. Fall through to built-in dispatch()

For step 2: `if let Some(Value::Procedure(proc_val)) = env.get_var(name).cloned()`:
- Evaluate all arguments
- Call `call_procedure(&proc_val, &evaluated, env)`
- Return the result

Implement `call_procedure(proc: &Procedure, args: &[Value], env: &mut Environment) -> Result<Value, EvalError>`:

1. **Arity check:** args.len() must equal proc.params.len(). Error: "procedure '{name}' expects {n} arguments, got {m}"

2. **Memo lookup:** If proc.remember, compute memo key as `format!("{:?}", args)`. Check `proc.memo.borrow().get(&key).cloned()`. If found, return cached value.

3. **Save variables:** For each name in params AND locals, save `(name, env.variables.remove(name))` into a Vec.

4. **Bind parameters:** For each (param_name, arg_value) pair, call `env.set_var(param_name, arg_value.clone())`.
   - Locals are intentionally NOT initialized -- accessing an unset local will produce a Symbol (Maple behavior).

5. **Execute body:** Call `eval_stmt_sequence(&proc.body, env)`.
   - Match the result:
     - Ok(val) => result is val
     - Err(EvalError::EarlyReturn(val)) => result is val (RETURN caught here)
     - Err(other) => propagate error (but restore variables first!)
   - Use a helper or let-binding to ensure restore happens on all paths.

6. **Restore variables:** For each saved (name, old_val): if old_val is Some(v), set_var(name, v); if None, variables.remove(name).

7. **Memo store:** If proc.remember and result is Ok, insert (key, result.clone()) into proc.memo.borrow_mut().

8. **Return result.**

CRITICAL: Variable restore MUST happen on all paths (success, EarlyReturn, error). Structure the code so restore is in a single place executed unconditionally. Pattern:
```rust
let result = match eval_stmt_sequence(&proc.body, env) {
    Ok(val) => Ok(val),
    Err(EvalError::EarlyReturn(val)) => Ok(val),
    Err(e) => Err(e),
};
// Restore always runs
for (name, old) in saved { ... }
// Memo store
if proc.remember { if let Ok(ref val) = result { ... } }
result
```

**format.rs -- Procedure display:**

Add a match arm in `format_value()` for Value::Procedure:
```rust
Value::Procedure(proc) => {
    let params = proc.params.join(", ");
    if proc.name.is_empty() {
        format!("proc({}) ... end proc", params)
    } else {
        format!("proc({}) ... end proc", params)
    }
}
```

Add a match arm in `format_latex()` for Value::Procedure:
```rust
Value::Procedure(proc) => {
    format!("\\text{{proc}}({})", proc.params.join(", "))
}
```

**repl.rs -- Multiline proc/end tracking:**

In the `is_incomplete()` method of ReplHelper:
1. Add `let mut proc_depth: i32 = 0;` alongside the existing for_depth and if_depth.
2. In `check_keyword()`, add: `"proc" => *proc_depth += 1,` and `"end" => *proc_depth -= 1,`
3. Update `check_keyword` signature to accept `proc_depth: &mut i32` parameter.
4. Update the return: `bracket_depth > 0 || for_depth > 0 || if_depth > 0 || proc_depth > 0`
5. Update all 4 call sites of check_keyword to pass &mut proc_depth.

NOTE on "end" vs "od"/"fi": The keyword "end" is used to close proc bodies (and potentially `end do`/`end if` in modern Maple, but q-Kangaroo currently uses od/fi). Since od already decrements for_depth and fi decrements if_depth, adding `"end" => proc_depth -= 1` specifically handles the proc/end case. If someone writes `end` without a preceding `proc`, proc_depth goes negative, which is fine (the > 0 check handles it).

**eval.rs -- Tests:**

Add comprehensive tests:
- test_proc_simple: `f := proc(n) n*n; end; f(5)` returns 25
- test_proc_local_scoping: `f := proc(n) local k; k := n*n; k; end; f(5)` returns 25, then verify `k` is not in env.variables (or returns Symbol("k"))
- test_proc_local_not_leaking: after calling proc with local k, accessing k returns Symbol("k")
- test_proc_return_early: `f := proc(n) RETURN(n*2); 999; end; f(5)` returns 10 (not 999)
- test_proc_return_in_for_loop: `f := proc(n) for k from 1 to 100 do if k = n then RETURN(k*k) fi od end; f(7)` returns 49
- test_proc_option_remember: define proc with option remember, call twice with same arg, second call should return same value (test by verifying memo table has entry)
- test_proc_memoized_fib: `fib := proc(n) option remember; if n <= 1 then RETURN(n) fi; fib(n-1) + fib(n-2); end; fib(10)` returns 55
- test_proc_wrong_arg_count: calling f(1,2) when f takes 1 param gives error
- test_proc_shadows_builtin: define `numbpart := proc(n) n*2; end; numbpart(5)` returns 10 (not the built-in)
- test_proc_empty_body: `f := proc() end; f()` returns None
- test_proc_multiple_stmts: `f := proc(n) local a, b; a := n; b := a + 1; b; end; f(5)` returns 6
- test_proc_nested_for_if: `f := proc(n) local s; s := 0; for k from 1 to n do if k > 2 then s := s + k fi od; s; end; f(5)` returns 3+4+5 = 12
- test_proc_restore_on_error: if proc body errors, variables are still restored

Add REPL tests:
- test_validator_proc_incomplete: `is_incomplete("f := proc(n)")` returns true
- test_validator_proc_complete: `is_incomplete("f := proc(n) n end")` returns false
- test_validator_proc_multiline: `is_incomplete("f := proc(n)\n  n;\n")` returns true, `is_incomplete("f := proc(n)\n  n;\nend")` returns false
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli`
All tests pass. Specifically verify:
- `cargo test -p qsym-cli -- proc` shows all procedure-related tests passing
- `cargo test -p qsym-cli -- validator_proc` shows REPL multiline tests passing
- `cargo test -p qsym-cli -- memo` or `cargo test -p qsym-cli -- fib` shows memoization working
  </verify>
  <done>
Users can define procedures with `proc(params) [local vars;] [option remember;] body; end [proc]`. Procedures can be assigned to variables and called. Local variables do not leak. RETURN(value) exits procedures early, even from nested control flow. Option remember caches results. Procedure values display as "proc(params) ... end proc". REPL correctly detects incomplete proc definitions for multiline input. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- ALL tests pass (existing + Plan 01 + Plan 02)
2. End-to-end scenario tests (verified via test functions):
   - `f := proc(n) local k; k := n*n; k; end; f(5)` -> 25, k is symbol after
   - `g := proc(n) for k from 1 to 100 do if k = n then RETURN(k*k) fi od end; g(7)` -> 49
   - `fib := proc(n) option remember; if n <= 1 then RETURN(n) fi; fib(n-1) + fib(n-2); end; fib(10)` -> 55
   - `for n from 1 to 5 do n^2 od` -> 25
   - `if 3 > 2 then 1 else 0 fi` -> 1
</verification>

<success_criteria>
- proc/local/option tokens lex correctly
- proc definitions parse into AstNode::ProcDef
- Value::Procedure stores procedure data with shared memo table
- call_procedure() implements local scoping via save/restore
- EarlyReturn is caught at procedure boundary only
- Memoization works for option remember procedures
- format_value shows "proc(params) ... end proc"
- REPL tracks proc/end for multiline continuation
- All 629+ existing tests still pass
- At least 15 new tests covering procedures, locals, RETURN, memoization
</success_criteria>

<output>
After completion, create `.planning/phases/42-procedures-evaluation/42-02-SUMMARY.md`
</output>
