---
phase: 43-expression-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [SERIES-03, UTIL-01, UTIL-02]

must_haves:
  truths:
    - "q^(n*n) evaluates correctly when n is a loop variable producing Rational values"
    - "q^(k*(3*k+1)/2) evaluates correctly for integer k values"
    - "floor(7/3) returns 2 and floor(-7/3) returns -3"
    - "legendre(2, 5) returns -1"
    - "L(3, 7) resolves to legendre(3, 7) and returns the correct Legendre symbol"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "eval_pow Rational arms, floor dispatch, legendre dispatch, L alias"
      contains: "Value::Rational(r)) =>"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entries for floor and legendre"
      contains: "floor"
  key_links:
    - from: "eval_pow Symbol^Rational arm"
      to: "FormalPowerSeries::monomial"
      via: "denom==1 check then numer extraction"
      pattern: "denom.*==.*1"
    - from: "resolve_alias"
      to: "legendre dispatch"
      via: "L -> legendre mapping"
      pattern: "\"l\" => \"legendre\""
---

<objective>
Add runtime Rational exponent support to eval_pow (so q^(n*n) works in for-loops), plus floor() and legendre()/L() builtin functions.

Purpose: SERIES-03 fixes the type gap where integer division produces Rational values that fail in exponentiation. UTIL-01 and UTIL-02 add number-theoretic builtins needed by qmaple.pdf examples.
Output: eval.rs with 5 new eval_pow arms + 2 new dispatch entries + alias + help entries, all tested.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-expression-operations/43-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: eval_pow Rational exponent arms</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add 5 new match arms to `eval_pow()` BEFORE the existing catch-all `_ => Err(EvalError::TypeError { ... })` arm (currently at line ~1865):

1. **Symbol ^ Rational**: Check `r.denom() == &rug::Integer::from(1)`, extract integer exponent via `r.numer().to_i64()`, then create monomial via `FormalPowerSeries::monomial(sym_id, QRat::one(), exp, POLYNOMIAL_ORDER)`. If denom != 1, return descriptive error "exponent must be an integer, got {r}".

2. **Series ^ Rational**: Same denom==1 check, delegate to existing `series_pow(fps, exp)`.

3. **Integer ^ Rational**: Same denom==1 check, delegate to existing `(Integer, Integer)` arm by constructing `Value::Integer(QInt(r.numer().clone()))`.

4. **Rational ^ Rational**: Same denom==1 check, delegate to existing `(Rational, Integer)` arm.

5. **JacobiProduct ^ Rational**: Same denom==1 check, scale exponents in factor list and normalize via `normalize_jacobi_product()`.

All 5 arms follow the same pattern: check denom==1, extract i64, delegate to existing logic. Use `r.0.denom()` and `r.0.numer()` (the inner rug::Rational is accessed via `.0` on the QRat newtype).

Add tests (in the existing `#[cfg(test)]` module near the other eval_pow tests around line 4466):
- `eval_pow_symbol_rational_integer_exponent`: `q^(4/2)` should produce same as `q^2`
- `eval_pow_symbol_rational_non_integer_errors`: `q^(3/2)` should error
- `eval_pow_series_rational`: `(series)^(6/3)` should work
- `eval_pow_integer_rational`: `2^(6/2)` should give 8
- `eval_pow_rational_base_rational_exp`: `(1/2)^(4/2)` should give 1/4
- `eval_pow_jacobi_rational`: JacobiProduct ^ (4/2) should scale exponents
- `eval_pow_loop_exponent`: Test that `q^(n*n)` works for n=3, verifying the for-loop exponent use case (create env, set n=3, evaluate `q^(3*3)` via eval_pow with Rational(9/1))
  </action>
  <verify>Run `cd /c/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli eval_pow_ -- --nocapture` and confirm all new tests pass alongside existing ones.</verify>
  <done>All 5 eval_pow Rational arms implemented. q^(Rational with denom=1) produces correct series/integer/rational/JacobiProduct. Non-integer rationals produce clear error messages. 7+ new tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: floor(), legendre(), L alias, signatures, help entries</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/src/help.rs</files>
  <action>
**In eval.rs dispatch():**

1. Add `"floor"` match arm:
   - `expect_args(name, args, 1)?`
   - Match on `args[0]`: `Value::Integer(_)` returns as-is, `Value::Rational(r)` uses `rug::Integer::new()` + `.assign(r.0.floor_ref())` then wraps in `Value::Integer(QInt(result))`. Other types return ArgType error with expected "number (integer or rational)".

2. Add `"legendre"` match arm:
   - `expect_args(name, args, 2)?`
   - Extract both args as integers. Use `extract_i64(name, args, 0)?` for m and `extract_i64(name, args, 1)?` for p.
   - Validate p >= 3 and p is odd: `if p < 3 || p % 2 == 0 { return Err(...) }`
   - Compute: `let m_int = rug::Integer::from(m); let p_int = rug::Integer::from(p); let result = m_int.legendre(&p_int);`
   - Return `Value::Integer(QInt::from(result as i64))`

**In eval.rs resolve_alias():**
   - Add `"l" => "legendre".to_string()` to the match (lowercase, since the function does `.to_lowercase()`)

**In eval.rs get_signature():**
   - Add `"floor" => "(x)".to_string()`
   - Add `"legendre" => "(m, p)".to_string()`

**In eval.rs ALL_FUNCTION_NAMES:**
   - Add `"floor"`, `"legendre"` to the array (add a new comment group like `// Pattern P: Number theory`)

**In eval.rs ALL_ALIAS_NAMES:**
   - Add `"L"` to the alias array

**In help.rs general_help():**
   - Add a new "Number Theory:" category section after the "Identity Proving:" section (before Commands):
     ```
     Number Theory:
       floor          - floor of a rational number
       legendre       - Legendre symbol (m/p) for odd prime p
     ```

**In help.rs FUNC_HELP array:**
   - Add FuncHelp entry for "floor":
     - signature: `"floor(x)"`
     - description: `"Compute the floor (greatest integer <= x) of a number.\n  For integers, returns the input unchanged. For rationals, returns the largest integer <= x.\n  Alias: none."`
     - example: `"q> floor(-7/3)"`
     - example_output: `"-3"`
   - Add FuncHelp entry for "legendre":
     - signature: `"legendre(m, p)"`
     - description: `"Compute the Legendre symbol (m/p) where p is an odd prime >= 3.\n  Returns -1, 0, or 1. Uses GMP's optimized algorithm.\n  Alias: L(m, p). Note: p is not checked for primality."`
     - example: `"q> legendre(2, 5)"`
     - example_output: `"-1"`

**In help.rs function_help():**
   - Add redirect: `"L"` -> lookup `"legendre"` (similar to partition_count -> numbpart pattern)

**Tests in eval.rs:**
   - `dispatch_floor_integer`: `floor(7)` returns 7
   - `dispatch_floor_rational_positive`: `floor(7/3)` returns 2
   - `dispatch_floor_rational_negative`: `floor(-7/3)` returns -3
   - `dispatch_floor_exact_integer_rational`: `floor(6/3)` returns 2
   - `dispatch_floor_wrong_type`: `floor(series)` returns error
   - `dispatch_legendre_basic`: `legendre(2, 5)` returns -1
   - `dispatch_legendre_zero`: `legendre(5, 5)` returns 0
   - `dispatch_legendre_one`: `legendre(1, 7)` returns 1
   - `dispatch_legendre_invalid_p`: `legendre(2, 4)` errors (even p)
   - `dispatch_legendre_alias_l`: test that resolve_alias("L") returns "legendre"

**Tests in help.rs (if test module exists):**
   - Verify `function_help("floor")` returns Some
   - Verify `function_help("legendre")` returns Some
   - Verify `function_help("L")` returns Some (via redirect)
  </action>
  <verify>Run `cd /c/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -5` and confirm all tests pass (including new floor/legendre tests and existing all_function_names_count test).</verify>
  <done>floor() returns correct integer floor for positive/negative rationals. legendre(m, p) returns {-1, 0, 1} correctly. L resolves to legendre. All registration points updated (dispatch, get_signature, ALL_FUNCTION_NAMES, ALL_ALIAS_NAMES, general_help, FUNC_HELP, function_help redirect). 10+ new tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (existing + new)
2. `cargo test -p qsym-cli eval_pow_` -- Rational exponent tests pass
3. `cargo test -p qsym-cli dispatch_floor` -- floor tests pass
4. `cargo test -p qsym-cli dispatch_legendre` -- legendre tests pass
5. `cargo test -p qsym-cli resolve_alias` -- L alias test passes
6. `cargo test -p qsym-cli all_function_names` -- count check passes
</verification>

<success_criteria>
- q^(Rational_with_denom_1) works for Symbol, Series, Integer, Rational, JacobiProduct
- q^(non-integer Rational) produces clear error
- floor(7/3) = 2, floor(-7/3) = -3
- legendre(2, 5) = -1, legendre(5, 5) = 0, legendre(1, 7) = 1
- L(m, p) resolves to legendre(m, p)
- help floor and help legendre show documentation
- All 682+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-expression-operations/43-01-SUMMARY.md`
</output>
