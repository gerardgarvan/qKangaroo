---
phase: 43-expression-operations
plan: 02
type: execute
wave: 2
depends_on: [43-01]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [SERIES-01, SERIES-02]

must_haves:
  truths:
    - "series(aqprod(q,q,50), q, 10) returns a series truncated to O(q^10)"
    - "series(f, q, 100) on a series computed to O(q^20) returns O(q^20), not O(q^100)"
    - "expand(JAC(1,5) * JAC(4,5)) converts JacobiProduct to series form"
    - "expand(series_value) returns the series unchanged"
    - "expand(3) returns 3 unchanged"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "series() and expand() dispatch entries"
      contains: "\"series\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entries for series and expand"
      contains: "series"
  key_links:
    - from: "series dispatch"
      to: "FormalPowerSeries::from_coeffs"
      via: "filtered BTreeMap with min(T, original) truncation"
      pattern: "from_coeffs"
    - from: "expand dispatch"
      to: "jacobi_product_to_fps"
      via: "JacobiProduct conversion using default_order or explicit T"
      pattern: "jacobi_product_to_fps"
---

<objective>
Add series(expr, q, T) for re-truncating computed series and expand(expr) for converting JacobiProduct values to polynomial/series form.

Purpose: SERIES-01 lets users control truncation order post-computation (essential for qmaple.pdf examples that compute at high precision then display at low). SERIES-02 lets users expand product expressions without the verbose jac2series syntax.
Output: eval.rs with 2 new dispatch entries + help entries, all tested.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-expression-operations/43-RESEARCH.md
@.planning/phases/43-expression-operations/43-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: series() dispatch, expand() dispatch, signatures, and ALL_FUNCTION_NAMES</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
**Add "series" to dispatch():**

Accept 3 arguments: `expect_args(name, args, 3)?`
- Arg 0: the expression to truncate. Must be a Series (use `extract_series`), BUT also accept JacobiProduct (convert first) and Integer/Rational (wrap as constant series).
- Arg 1: the variable symbol (validated but not used -- the series already has its variable). Use `extract_symbol_id(name, args, 1, env)?`.
- Arg 2: the target truncation order T. Use `extract_i64(name, args, 2)?`.

Implementation for Series input:
```rust
let effective_order = order.min(fps.truncation_order());
let new_coeffs: BTreeMap<i64, QRat> = fps.iter()
    .filter(|(&k, _)| k < effective_order)
    .map(|(&k, v)| (k, v.clone()))
    .collect();
Ok(Value::Series(FormalPowerSeries::from_coeffs(
    fps.variable(), new_coeffs, effective_order
)))
```

For JacobiProduct input: first convert via `jacobi_product_to_fps(&factors, env.sym_q, order)`, then apply the truncation logic above (but the converted FPS already has the target order, so just return it).

For Integer/Rational input: wrap as constant series -- `FormalPowerSeries::from_coeffs(env.sym_q, {0 => value}, order)`.

Edge case: if T <= 0, return zero series `FormalPowerSeries::zero(env.sym_q, 0)`.

**Add "expand" to dispatch():**

Accept 1 argument (simple form) OR 3 arguments (with explicit q and T for JacobiProduct):
- Use `expect_args_range(name, args, 1, 3)?` (the function already exists).
- 1-arg form:
  - `Value::Series(_)` -> return as-is (already expanded)
  - `Value::JacobiProduct(factors)` -> convert via `jacobi_product_to_fps(&factors, env.sym_q, env.default_order)`
  - `Value::Integer(_)` | `Value::Rational(_)` -> return as-is
  - Other types -> error
- 3-arg form (`expand(expr, q, T)`):
  - Arg 0: JacobiProduct (or Series, pass through)
  - Arg 1: symbol (validated via `extract_symbol_id`)
  - Arg 2: truncation order T (via `extract_i64`)
  - Convert JacobiProduct with explicit order T instead of default_order

**Add to get_signature():**
- `"series" => "(expr, q, T)".to_string()`
- `"expand" => "(expr) or (expr, q, T)".to_string()`

**Add to ALL_FUNCTION_NAMES:**
- Add `"series"`, `"expand"` (add to a new comment group like `// Pattern Q: Expression operations`, or append to existing Pattern A)

**Add BTreeMap import if not already present:**
- `use std::collections::BTreeMap;` -- check if it's already imported. If using `fps.iter().filter().collect()` into BTreeMap, the import is needed.

**Tests:**
- `dispatch_series_truncate_down`: Create a series to O(q^20), call series with T=10, verify truncation_order is 10 and no coefficients >= 10 exist
- `dispatch_series_truncate_up_capped`: Create a series to O(q^10), call series with T=100, verify truncation_order is still 10 (min semantics)
- `dispatch_series_jacobi_product`: Call series on a JacobiProduct, verify it converts and truncates
- `dispatch_series_integer`: Call series(3, q, 10), verify returns constant series
- `dispatch_expand_series_identity`: expand(series) returns same series
- `dispatch_expand_jacobi_product`: expand(JAC(1,5)*JAC(4,5)) returns a Series value
- `dispatch_expand_integer_identity`: expand(3) returns 3
- `dispatch_expand_3arg_jacobi`: expand(JP, q, 15) converts with explicit order 15
- `dispatch_expand_wrong_type`: expand(true) errors
  </action>
  <verify>Run `cd /c/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -5` and confirm all tests pass.</verify>
  <done>series(expr, q, T) correctly truncates series with min(T, original) semantics. expand(expr) converts JacobiProduct to series using default_order, and expand(expr, q, T) uses explicit T. Integer/Rational/Series inputs handled gracefully. 9+ new tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Help entries for series and expand</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
**In general_help():**
Add a new "Expression Operations:" category section. Place it after "Jacobi Products:" and before "Series Analysis:" (logically, these are expression-level operations distinct from series analysis which examines series properties):

```
Expression Operations:
  series         - truncate a series to O(q^T): series(f, q, T)
  expand         - expand products into polynomial/series form
```

**In FUNC_HELP array:**

Add FuncHelp entry for "series":
- name: "series"
- signature: "series(expr, q, T)"
- description: "Truncate a q-series to O(q^T). If expr is already computed to order N, the result has order min(T, N).\n  Also accepts Jacobi products (converts then truncates) and integers/rationals (wraps as constant series).\n  The q argument is for Maple compatibility and is validated but not used."
- example: "q> f := aqprod(q, q, infinity, 50): series(f, q, 10)"
- example_output: "-q^7 - q^5 + q^2 + q + 1 + O(q^10)"

Add FuncHelp entry for "expand":
- name: "expand"
- signature: "expand(expr) or expand(expr, q, T)"
- description: "Expand a product expression into polynomial or series form.\n  For Series values, returns unchanged. For Jacobi products, converts to q-series.\n  The 1-argument form uses the current precision; the 3-argument form uses explicit truncation order T."
- example: "q> expand(JAC(1,5) * JAC(4,5), q, 20)"
- example_output: "... + q^7 - q^4 - q + 1 + O(q^20)"

**Tests in help.rs test module:**
- Verify `function_help("series")` returns Some
- Verify `function_help("expand")` returns Some
- Verify general_help() output contains "Expression Operations:" category
- Verify general_help() output contains "series" and "expand"
  </action>
  <verify>Run `cd /c/cygwin64/home/Owner/Kangaroo && export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli help -- --nocapture` and confirm all help tests pass.</verify>
  <done>Help entries for series() and expand() added to general_help listing and FUNC_HELP array. `help series` and `help expand` produce documentation with signatures, descriptions, and examples. 4+ new tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (existing + Plan 01 + new)
2. `cargo test -p qsym-cli dispatch_series` -- series tests pass
3. `cargo test -p qsym-cli dispatch_expand` -- expand tests pass
4. `cargo test -p qsym-cli help` -- help tests pass including new entries
5. `cargo test -p qsym-cli all_function_names` -- count check passes with added functions
</verification>

<success_criteria>
- series(aqprod(q,q,50), q, 10) produces truncated O(q^10) output
- series(f, q, 100) on O(q^20) series caps at O(q^20)
- expand(JAC(1,5)*JAC(4,5)) produces a Series value
- expand(series) returns series unchanged
- expand(3) returns 3
- expand(JP, q, T) uses explicit T
- help series and help expand show documentation
- All 682+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-expression-operations/43-02-SUMMARY.md`
</output>
