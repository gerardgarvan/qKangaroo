---
phase: 44-polynomial-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/poly/cyclotomic.rs
  - crates/qsym-core/src/poly/factor.rs
  - crates/qsym-core/src/poly/mod.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements: [POLY-01]

must_haves:
  truths:
    - "factor(1 - q^6) returns (1-q)(1+q)(1-q+q^2)(1+q+q^2)"
    - "factor() works on polynomial produced by series computation (e.g. expand(aqprod(q,q,5)))"
    - "factor() rejects truncated series with clear error message"
    - "factor() extracts content (rational scalar) before factoring"
    - "factor appears in tab completion and help system"
  artifacts:
    - path: "crates/qsym-core/src/poly/cyclotomic.rs"
      provides: "Cyclotomic polynomial generation via recursive division"
      contains: "fn cyclotomic_poly"
    - path: "crates/qsym-core/src/poly/factor.rs"
      provides: "Factorization algorithm and result type"
      contains: "pub struct Factorization"
    - path: "crates/qsym-core/src/poly/mod.rs"
      provides: "Module declarations for cyclotomic and factor"
      contains: "pub mod cyclotomic"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "factor dispatch in CLI evaluator"
      contains: "\"factor\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entry for factor"
      contains: "name: \"factor\""
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "Tab completion for factor"
      contains: "\"factor\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/poly/factor.rs"
      via: "factor_over_q() call in dispatch"
      pattern: "factor_over_q"
    - from: "crates/qsym-core/src/poly/factor.rs"
      to: "crates/qsym-core/src/poly/cyclotomic.rs"
      via: "cyclotomic_poly() calls during trial division"
      pattern: "cyclotomic_poly"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "FormalPowerSeries"
      via: "FPS-to-QRatPoly conversion before factoring"
      pattern: "fps_to_qratpoly\\|POLYNOMIAL_ORDER"
---

<objective>
Implement `factor(poly)` for factoring q-polynomials into cyclotomic and irreducible factors over the rationals.

Purpose: Enables users to decompose polynomials like `1-q^6` into their irreducible factors `(1-q)(1+q)(1-q+q^2)(1+q+q^2)`, which is essential for q-series identity verification and the Garvan tutorial workflow.

Output: Two new core modules (cyclotomic.rs, factor.rs), CLI dispatch/help/completion for `factor`.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-polynomial-operations/44-RESEARCH.md
@.planning/phases/43-expression-operations/43-02-SUMMARY.md
@crates/qsym-core/src/poly/mod.rs
@crates/qsym-core/src/poly/arithmetic.rs
@crates/qsym-core/src/lib.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/repl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core cyclotomic and factoring modules</name>
  <files>
    crates/qsym-core/src/poly/cyclotomic.rs
    crates/qsym-core/src/poly/factor.rs
    crates/qsym-core/src/poly/mod.rs
  </files>
  <action>
Create two new modules in `crates/qsym-core/src/poly/`:

**cyclotomic.rs** -- Cyclotomic polynomial computation:
- `pub fn cyclotomic_poly(n: usize) -> QRatPoly` -- Compute the nth cyclotomic polynomial Phi_n(x) via recursive division: start with x^n - 1, divide by Phi_d(x) for each proper divisor d of n. Use `QRatPoly::exact_div()` for each division (it already exists in arithmetic.rs).
- Helper `fn divisors(n: usize) -> Vec<usize>` -- Return all divisors of n in ascending order.
- Helper `fn x_n_minus_1(n: usize) -> QRatPoly` -- Construct x^n - 1 using `QRatPoly::from_i64_coeffs`. The coefficients array is [-1, 0, 0, ..., 0, 1] with n+1 elements.
- Base case: Phi_1(x) = x - 1 (i.e., `from_i64_coeffs(&[-1, 1])`).
- Include unit tests: `cyclotomic_poly(1) = x-1`, `cyclotomic_poly(2) = x+1`, `cyclotomic_poly(3) = x^2+x+1`, `cyclotomic_poly(4) = x^2+1`, `cyclotomic_poly(6) = x^2-x+1`, `cyclotomic_poly(12) = x^4-x^2+1`.

**factor.rs** -- Polynomial factoring over Q[x]:
- `pub struct Factorization` with fields:
  - `pub scalar: QRat` -- content factor
  - `pub factors: Vec<(QRatPoly, usize)>` -- irreducible factors with multiplicities, sorted by degree ascending
- `pub fn factor_over_q(poly: &QRatPoly) -> Factorization` -- Main entry point:
  1. Handle zero/constant cases (return scalar only, empty factors list).
  2. Extract content via `poly.content()`, get primitive part via `poly.primitive_part()`.
  3. If leading coefficient of primitive_part is negative, negate both scalar and primitive_part (so we factor a monic-positive polynomial).
  4. Trial-divide by cyclotomic polynomials Phi_n for n from `degree` down to 1. For each n: check if `euler_phi(n) <= remaining.degree()`, if so compute `remaining.div_rem(&phi_n)` -- if remainder is zero, record the factor and increment multiplicity, repeat (same n) for higher multiplicities. Then move to next smaller n.
  5. If remainder is not constant after all cyclotomic trial divisions, include it as a single irreducible factor.
  6. Sort factors by degree ascending, then by first differing coefficient for same-degree tiebreaking.
- `impl Factorization`:
  - `pub fn display_with_var(&self, var: &str) -> String` -- Format like `(1-q)(1+q)(1-q+q^2)(1+q+q^2)`. Each factor is displayed as a parenthesized polynomial with the given variable name. Multiplicities > 1 shown as `^N` suffix. If scalar != 1, prepend the scalar. Use the convention: display polynomial terms in DESCENDING degree order within each factor.
- Helper `fn euler_phi(n: usize) -> usize` -- Euler's totient function.
- Helper function to format a single QRatPoly as a string with a named variable (e.g., "q"): iterate coefficients, build terms like "q^3", "-q^2", "1", etc. Handle coefficient of 1/-1 specially (omit the "1" for non-constant terms).
- Include unit tests:
  - `factor_over_q(x^6 - 1)` produces factors Phi_1, Phi_2, Phi_3, Phi_6 each with multiplicity 1
  - `factor_over_q(x^4 - 1)` produces (x-1)(x+1)(x^2+1)
  - `factor_over_q(2*x^2 - 2)` produces scalar=2, factors (x-1)(x+1)
  - `factor_over_q(x^2 + x + 1)` produces a single factor Phi_3
  - `factor_over_q(1 - x)` produces scalar=-1, factor (x-1) -- test negative leading coeff handling

**mod.rs** -- Add module declarations:
- Add `pub mod cyclotomic;` and `pub mod factor;` to the existing module declarations.
- Add `pub use factor::{Factorization, factor_over_q};` to re-exports.

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core -- poly::cyclotomic --nocapture && cargo test -p qsym-core -- poly::factor --nocapture`

All cyclotomic and factoring tests pass. Verify that `factor_over_q` on x^6-1 produces 4 factors (Phi_1, Phi_2, Phi_3, Phi_6).
  </verify>
  <done>
cyclotomic_poly(n) produces correct polynomials for n=1..12. factor_over_q correctly decomposes x^6-1 into (x-1)(x+1)(x^2+x+1)(x^2-x+1). Content extraction works (2x^2-2 gives scalar=2). display_with_var produces formatted output with "q" variable. All core tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI factor() dispatch, help, and tab completion</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/help.rs
    crates/qsym-cli/src/repl.rs
  </files>
  <action>
**eval.rs** -- Add `factor` dispatch and FPS-to-QRatPoly conversion:

1. Add a helper function `fn fps_to_qratpoly(fps: &FormalPowerSeries) -> Result<QRatPoly, String>`:
   - Check `fps.truncation_order() == POLYNOMIAL_ORDER`. If not, return `Err("cannot factor truncated series -- use expand() to get an exact polynomial")`.
   - Check `fps.is_zero()`. If so, return `Err("cannot factor zero polynomial")`.
   - Check min exponent >= 0 (via `fps.iter().next()`). If negative, return `Err(format!("polynomial has negative exponent q^{}", min_exp))`.
   - Get max exponent from `fps.iter().last()`.
   - Build dense coefficient vector of length `max_exp + 1`, filling from FPS sparse map.
   - Return `Ok(QRatPoly::from_vec(coeffs))`.

2. Add `"factor"` arm in the dispatch function, in a new section `// Polynomial Operations (POLY-01)` placed AFTER the Number Theory section and BEFORE the Unknown function fallback:
   - `expect_args(name, args, 1)?;`
   - Match on `&args[0]`:
     - `Value::Series(fps)` -> call `fps_to_qratpoly(fps)`, map error to `EvalError::Other`, call `qsym_core::poly::factor_over_q(&qrp)`, format result with `factorization.display_with_var("q")`, return `Ok(Value::String(display_string))`.
     - `Value::Integer(n)` -> if zero, error; otherwise create constant QRatPoly, factor it (result is just scalar), return as String.
     - Other types -> return ArgType error expecting "polynomial series or integer".

3. Add `"factor"` to `get_signature()`: `"factor" => "(poly)".to_string()`.

4. Add `"factor"` to `ALL_FUNCTION_NAMES` in the `// Pattern Q: Expression operations` section.

5. Add unit tests in `#[cfg(test)]` module:
   - Test factor of 1-q^6 polynomial: construct FPS with coefficients {0: 1, 6: -1} and POLYNOMIAL_ORDER, dispatch "factor", verify output string contains "(1-q)" and "(1+q)" and "(1-q+q^2)" and "(1+q+q^2)".
   - Test factor of truncated series returns error.
   - Test factor of constant returns the constant.

**help.rs** -- Add `factor` help entry:
1. Add a new group comment `// Group 14: Polynomial Operations (1)` after Group 13 (Expression Operations).
2. Add FuncHelp entry:
   - name: "factor"
   - signature: "factor(poly)"
   - description: "Factor a polynomial in q into irreducible factors over the rationals.\n  The argument must be an exact polynomial (not a truncated series). Use expand() to convert products first."
   - example: "q> factor(1 - q^6)"
   - example_output: "(1-q)(1+q)(1-q+q^2)(1+q+q^2)"
3. Add `"Polynomial Operations:"` category to `general_help()` with `factor` listed under it, placed after Expression Operations and before Number Theory.
4. Update FUNC_HELP count from 93 to 94 in the doc comment, array size assertion, and test expectations.
5. Add test for the new category: `assert!(text.contains("Polynomial Operations:"))`.

**repl.rs** -- Add `factor` to tab completion:
1. Add `"factor"` to `canonical_function_names()` in a new group comment `// Group 11: Polynomial Operations (1)` (after Group 10).
2. Update the count assertion from 95 to 96.

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli --nocapture 2>&1 | tail -20`

All CLI tests pass including:
- factor dispatch tests (1-q^6 factorization output matches expected form)
- help entry count is 94
- tab completion count is 96
- All existing 715 tests still pass
  </verify>
  <done>
`factor(1 - q^6)` in CLI produces `(1-q)(1+q)(1-q+q^2)(1+q+q^2)`. factor() rejects truncated series with clear error. factor appears in help under "Polynomial Operations" category. factor appears in tab completion. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-core -- poly::cyclotomic` -- all cyclotomic polynomial tests pass
2. `cargo test -p qsym-core -- poly::factor` -- all factoring tests pass
3. `cargo test -p qsym-cli` -- all CLI tests pass including factor dispatch, help, and completion
4. Manual verification: the factorization of 1-q^6 produces exactly the 4 cyclotomic factors shown in success criteria
</verification>

<success_criteria>
- factor(1 - q^6) returns a string showing (1-q)(1+q)(1-q+q^2)(1+q+q^2) (order may vary by degree)
- factor() on a computed polynomial (e.g., from expand(aqprod(q,q,5))) produces meaningful factors
- factor() on truncated series returns a clear error message
- factor appears in help system under "Polynomial Operations" category
- factor appears in tab completion (96 canonical names)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/44-polynomial-operations/44-01-SUMMARY.md`
</output>
