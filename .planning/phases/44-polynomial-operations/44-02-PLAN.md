---
phase: 44-polynomial-operations
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
autonomous: true
requirements: [POLY-02]

must_haves:
  truths:
    - "subs(q=1, series_expr) evaluates to a rational number (sum of all coefficients)"
    - "subs(q=q^2, series_expr) transforms q-exponents (every exponent multiplied by 2)"
    - "subs(q=rational, series_expr) evaluates the polynomial at that rational point"
    - "subs intercepts the Compare AST node before evaluation (q=1 does not become Bool)"
    - "subs appears in tab completion and help system"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "subs AST interception and substitution dispatch"
      contains: "\"subs\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entry for subs"
      contains: "name: \"subs\""
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "Tab completion for subs"
      contains: "\"subs\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "AstNode::Compare"
      via: "AST-level interception in FuncCall branch before arg evaluation"
      pattern: "CompOp::Eq.*subs"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "FormalPowerSeries"
      via: "coefficient summation for q=rational, exponent scaling for q=q^k"
      pattern: "fps\\.iter\\(\\)|truncation_order"
---

<objective>
Implement `subs(var=val, expr)` for substituting values into q-series expressions, with AST-level interception to handle the `q=value` syntax correctly.

Purpose: Enables users to evaluate series at specific points (e.g., `subs(q=1, f)` to sum coefficients) and perform exponent transformations (e.g., `subs(q=q^2, f)` to double all exponents), both essential for the Garvan tutorial workflow.

Output: Modified eval.rs with subs AST interception and three substitution modes, help entry, tab completion.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-polynomial-operations/44-RESEARCH.md
@.planning/phases/44-polynomial-operations/44-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/repl.rs
@crates/qsym-core/src/series/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: subs() AST interception and substitution logic</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
Add `subs(var=val, expr)` with AST-level interception in the FuncCall branch of `eval_expr`.

1. **AST interception** -- In `eval_expr`, in the `AstNode::FuncCall { name, args }` branch, AFTER the RETURN check (line ~1043) and BEFORE the user-procedure check (line ~1057), add a special case for "subs":

```
if name == "subs" {
    if args.len() != 2 {
        return Err(EvalError::WrongArgCount { ... "2" ... "subs(var=val, expr)" });
    }
    // args[0] must be a Compare with CompOp::Eq
    match &args[0] {
        AstNode::Compare { op: CompOp::Eq, lhs, rhs } => {
            let var_name = match lhs.as_ref() {
                AstNode::Variable(name) => name.clone(),
                _ => return Err(EvalError::Other("subs: left side of = must be a variable name".into())),
            };
            let sub_value = eval_expr(rhs, env)?;
            let target = eval_expr(&args[1], env)?;
            return perform_substitution(&var_name, sub_value, target, env);
        }
        _ => return Err(EvalError::Other(
            "subs: first argument must be var=value (e.g., subs(q=1, expr))".into()
        )),
    }
}
```

This MUST go before the user-procedure check so a variable named "subs" cannot shadow the builtin. Import `CompOp` from `crate::ast` at the top of eval.rs if not already imported.

2. **perform_substitution function** -- Add a new function:

```rust
fn perform_substitution(
    var_name: &str,
    sub_value: Value,
    target: Value,
    env: &Environment,
) -> Result<Value, EvalError> {
```

Logic based on (sub_value, target) combination:

**Case A: subs(q=rational_number, Series)**
- var_name must match the series variable (check using `env.symbols.name(fps.variable())` equals var_name). If mismatch, return the target unchanged.
- Evaluate the FPS at the rational point: iterate over `fps.iter()`, for each (exponent, coefficient), compute `coefficient * val^exponent` and accumulate. Use `rug::Rational::pow(exp as u32)` for positive exponents. For exp=0, just add the coefficient.
- Handle negative exponents: compute `val^|exp|` then invert (error if val is zero and exp < 0).
- Return `Value::Rational(result)` (or `Value::Integer` if denominator is 1).

**Case B: subs(q=integer, Series)** -- Same as Case A but convert integer to Rational first.

**Case C: subs(q=Series_that_is_q_power, Series)** -- Exponent scaling.
- Detect if sub_value is a `Value::Series(fps2)` representing `q^k` for some positive integer k. Check: fps2 has exactly one nonzero term, that term's coefficient is 1, and the variable matches. Extract k from the exponent.
- Create new FPS: for each (exp, coeff) in target FPS, insert (exp * k, coeff) in new BTreeMap.
- Truncation order: if target's truncation_order == POLYNOMIAL_ORDER, keep POLYNOMIAL_ORDER. Otherwise multiply by k.
- Return `Value::Series(new_fps)`.

**Case D: subs on non-Series target**
- If target is Integer, Rational, or other non-Series value, just return target unchanged (substituting into a constant is a no-op).

**Case E: subs(q=0, Series)** -- Return the constant term (exponent 0 coefficient) as Integer or Rational.

3. **Add to get_signature()**: `"subs" => "(var=val, expr)".to_string()`.

4. **Add "subs" to ALL_FUNCTION_NAMES** in the `// Pattern Q: Expression operations` section (or create a new `// Pattern R: Substitution` section).

5. **Unit tests** (add to `#[cfg(test)]` module):
   - Test `subs(q=1, 1 + q + q^2)` returns Integer(3) -- sum of coefficients.
   - Test `subs(q=0, 1 + q + q^2)` returns Integer(1) -- constant term.
   - Test `subs(q=1/2, 1 + q + q^2)` returns Rational(7/4) -- 1 + 1/2 + 1/4.
   - Test subs with q^2 scaling: FPS {0:1, 1:1, 2:1} with q->q^2 produces {0:1, 2:1, 4:1}.
   - Test subs on truncated series with q->q^2 scales truncation_order.
   - Test subs on non-series target returns target unchanged.
   - Test subs with wrong arg count returns error.
   - Test subs without `=` in first arg returns error.

Note: For the unit tests that test the AST interception, you cannot call `dispatch()` since subs is intercepted before dispatch. Instead, test the `perform_substitution()` function directly for the substitution logic, and create integration tests using `parse()` + `eval_expr()` to test the full AST interception path. Alternatively, create helper FPS values and call `perform_substitution()` directly.

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- subs --nocapture`

All subs-related tests pass. Verify that AST interception works (subs is handled before arg evaluation, q=1 does not become Bool).
  </verify>
  <done>
subs(q=1, series) correctly sums all coefficients to produce a rational/integer result. subs(q=q^2, series) correctly scales exponents and truncation order. subs(q=0, series) returns constant term. AST interception works -- q=1 is parsed as Compare but intercepted before evaluation. Error messages are clear for wrong arg count and missing = syntax. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: subs help entry and tab completion</name>
  <files>
    crates/qsym-cli/src/help.rs
    crates/qsym-cli/src/repl.rs
  </files>
  <action>
**help.rs** -- Add `subs` help entry:
1. Add to the `// Group 14: Polynomial Operations` section (created in plan 44-01) a new FuncHelp entry:
   - name: "subs"
   - signature: "subs(var=val, expr)"
   - description: "Substitute a value for a variable in an expression.\n  subs(q=1, f) evaluates the series at q=1 (sums all coefficients).\n  subs(q=q^2, f) transforms exponents (multiplies all exponents by 2).\n  subs(q=r, f) evaluates the polynomial at the rational point r."
   - example: "q> subs(q=1, 1 + q + q^2 + q^3)"
   - example_output: "4"
2. Update the group comment from `// Group 14: Polynomial Operations (1)` to `// Group 14: Polynomial Operations (2)`.
3. Update FUNC_HELP count from 94 to 95 in the doc comment, array size assertion, and test expectations.
4. Update `general_help()` to list `subs` under the "Polynomial Operations:" category line.
5. Add test: verify `help_for("subs")` returns Some and contains "Substitute".

**repl.rs** -- Add `subs` to tab completion:
1. Add `"subs"` to `canonical_function_names()` in the `// Group 11: Polynomial Operations` section (created in plan 44-01).
2. Update the count assertion from 96 to 97.

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- help --nocapture && cargo test -p qsym-cli -- repl --nocapture`

Help entry count is 95, tab completion count is 97. subs appears in Polynomial Operations category. All tests pass.
  </verify>
  <done>
subs appears in help system under "Polynomial Operations" category with clear documentation of all three substitution modes. subs appears in tab completion (97 canonical names). FUNC_HELP count is 95. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli -- subs` -- all subs tests pass
2. `cargo test -p qsym-cli -- help` -- help count is 95, subs help entry exists
3. `cargo test -p qsym-cli -- repl` -- completion count is 97
4. `cargo test -p qsym-cli` -- all CLI tests pass (no regressions)
5. Manual verification: subs(q=1, series) returns sum of coefficients, subs(q=q^2, series) doubles exponents
</verification>

<success_criteria>
- subs(q=1, series_expr) returns the sum of all coefficients as a rational/integer
- subs(q=q^2, series_expr) returns a new series with all exponents doubled and truncation_order doubled
- subs(q=1/2, 1 + q + q^2) returns 7/4
- subs with non-= first argument returns clear error message
- subs appears in help under "Polynomial Operations" with documentation of all three modes
- subs appears in tab completion (97 canonical names)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/44-polynomial-operations/44-02-SUMMARY.md`
</output>
