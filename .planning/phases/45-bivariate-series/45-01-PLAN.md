---
phase: 45-bivariate-series
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-core/src/series/bivariate.rs
  - crates/qsym-core/src/series/mod.rs
  - crates/qsym-core/src/lib.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
autonomous: true
requirements: [BIVAR-04]

must_haves:
  truths:
    - "BivariateSeries struct exists with BTreeMap<i64, FormalPowerSeries> mapping z-exponents to q-series"
    - "Value::BivariateSeries variant exists in the CLI Value enum"
    - "Add, subtract, multiply, and negate operations work on BivariateSeries values"
    - "BivariateSeries values display correctly as Laurent polynomials in the outer variable"
    - "Mixed arithmetic (BivariateSeries + scalar, BivariateSeries * scalar) works"
  artifacts:
    - path: "crates/qsym-core/src/series/bivariate.rs"
      provides: "BivariateSeries struct, add, sub, mul, negate, scalar_mul functions"
      min_lines: 120
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::BivariateSeries variant, arithmetic dispatch arms"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_bivariate and format_bivariate_latex functions"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/series/bivariate.rs"
      via: "use qsym_core::series::bivariate::BivariateSeries"
      pattern: "BivariateSeries"
    - from: "crates/qsym-cli/src/format.rs"
      to: "crates/qsym-core/src/series/bivariate.rs"
      via: "format_bivariate function"
      pattern: "format_bivariate"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/format.rs"
      via: "format_value match arm for BivariateSeries"
      pattern: "Value::BivariateSeries"
---

<objective>
Create the BivariateSeries data structure in qsym-core and integrate it into the CLI as a new Value variant with full arithmetic support and display formatting.

Purpose: This is the foundation for bivariate q-series -- all subsequent work (tripleprod/quinprod/winquist dispatch) depends on this struct and its CLI integration existing.
Output: BivariateSeries struct with arithmetic, Value::BivariateSeries variant, display formatting, and passing tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-bivariate-series/45-RESEARCH.md
@crates/qsym-core/src/series/mod.rs
@crates/qsym-core/src/series/arithmetic.rs
@crates/qsym-core/src/lib.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: BivariateSeries struct and arithmetic in qsym-core</name>
  <files>
    crates/qsym-core/src/series/bivariate.rs
    crates/qsym-core/src/series/mod.rs
  </files>
  <action>
Create a new file `crates/qsym-core/src/series/bivariate.rs` with:

1. **BivariateSeries struct:**
```rust
use std::collections::BTreeMap;
use crate::number::QRat;
use crate::symbol::SymbolId;
use super::FormalPowerSeries;
use super::arithmetic;

#[derive(Clone, Debug)]
pub struct BivariateSeries {
    pub outer_variable: String,
    pub terms: BTreeMap<i64, FormalPowerSeries>,
    pub inner_variable: SymbolId,
    pub truncation_order: i64,
}
```

2. **Constructor methods:**
   - `zero(outer_variable: String, inner_variable: SymbolId, truncation_order: i64) -> Self` -- empty BTreeMap
   - `from_single_term(outer_variable: String, z_exp: i64, fps: FormalPowerSeries) -> Self` -- single z^k term, extracting inner_variable and truncation_order from the fps
   - `is_zero(&self) -> bool` -- terms is empty
   - `truncation_order(&self) -> i64` -- returns truncation_order field
   - `outer_variable(&self) -> &str` -- returns outer_variable

3. **Arithmetic functions (all as free functions, matching the pattern in `arithmetic.rs`):**

   - `pub fn bivariate_negate(a: &BivariateSeries) -> BivariateSeries` -- negate every FPS coefficient
   - `pub fn bivariate_add(a: &BivariateSeries, b: &BivariateSeries) -> BivariateSeries` -- assert outer_variable and inner_variable match, use min truncation order, merge BTreeMaps adding FPS values for matching z-exponents, filter out zero FPS entries
   - `pub fn bivariate_sub(a: &BivariateSeries, b: &BivariateSeries) -> BivariateSeries` -- implemented as add(a, negate(b))
   - `pub fn bivariate_mul(a: &BivariateSeries, b: &BivariateSeries) -> BivariateSeries` -- assert variables match, convolution: for each (za, fa) in a.terms and (zb, fb) in b.terms, add arithmetic::mul(&fa, &fb) to result at z_exp = za + zb. Filter out zero entries.
   - `pub fn bivariate_scalar_mul(s: &QRat, a: &BivariateSeries) -> BivariateSeries` -- multiply each FPS coefficient by the scalar via arithmetic::scalar_mul, filter zeros
   - `pub fn bivariate_fps_mul(fps: &FormalPowerSeries, a: &BivariateSeries) -> BivariateSeries` -- multiply each FPS coefficient by the given FPS via arithmetic::mul (this is for Series * BivariateSeries). Use min truncation order.

4. **PartialEq and Eq impls** -- compare outer_variable, inner_variable, truncation_order, and terms fields.

5. **Unit tests module** in the same file:
   - Test zero creation and is_zero
   - Test negate: create a BivariateSeries with one term, negate, check coefficient is negated
   - Test add: two BivariateSeries with overlapping and non-overlapping z-exponents, verify merge
   - Test add cancellation: two series that cancel to zero at a z-exponent, verify that entry is removed
   - Test sub: basic subtraction
   - Test mul: two simple series (e.g., (z + z^{-1}) * (z - z^{-1}) = z^2 - z^{-2}), verify convolution
   - Test scalar_mul: multiply all coefficients by 2
   - Test mismatched outer variable panics (should_panic)
   - Use SymbolRegistry to create a test SymbolId for q

In `crates/qsym-core/src/series/mod.rs`, add at the top (after `pub mod generator;`):
```rust
pub mod bivariate;
```
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-core bivariate -- --nocapture`
All bivariate tests pass. No compilation errors.
  </verify>
  <done>
BivariateSeries struct exists in qsym-core with add, sub, mul, negate, scalar_mul, fps_mul functions. All unit tests pass. Module is exported via `series::bivariate`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Value::BivariateSeries variant, arithmetic dispatch, and display formatting</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/format.rs
  </files>
  <action>
**In `crates/qsym-cli/src/eval.rs`:**

1. Add import at top: `use qsym_core::series::bivariate::{self as bv, BivariateSeries};`

2. Add variant to `Value` enum (after `Procedure`):
```rust
/// Bivariate series: Laurent polynomial in outer variable with FPS coefficients.
BivariateSeries(BivariateSeries),
```

3. Add to `type_name()` match:
```rust
Value::BivariateSeries(_) => "bivariate_series",
```

4. **Extend `eval_negate`:** Add arm before the catch-all:
```rust
Value::BivariateSeries(bs) => Ok(Value::BivariateSeries(bv::bivariate_negate(&bs))),
```

5. **Extend `eval_add`:** Add arms for BivariateSeries + BivariateSeries, BivariateSeries + scalar (Integer/Rational), and BivariateSeries + Series. Place these BEFORE the catch-all `_ =>` arm.
   - `(Value::BivariateSeries(a), Value::BivariateSeries(b))` -- call `bv::bivariate_add(a, b)`, wrap in Value::BivariateSeries
   - `(Value::BivariateSeries(bs), _) if value_to_qrat(&right).is_some()` -- create a BivariateSeries with single z^0 term containing the constant FPS, then add
   - `(_, Value::BivariateSeries(bs)) if value_to_qrat(&left).is_some()` -- same but reversed
   - `(Value::BivariateSeries(bs), Value::Series(fps))` -- create BivariateSeries with z^0 = fps, then add. Use min of truncation orders.
   - `(Value::Series(fps), Value::BivariateSeries(bs))` -- same reversed

6. **Extend `eval_sub`:** Same pattern as eval_add but using `bv::bivariate_sub`.

7. **Extend `eval_mul`:** Same pattern:
   - `(Value::BivariateSeries(a), Value::BivariateSeries(b))` -- `bv::bivariate_mul`
   - `(Value::BivariateSeries(bs), _) if value_to_qrat(&right).is_some()` -- `bv::bivariate_scalar_mul`
   - `(_, Value::BivariateSeries(bs)) if value_to_qrat(&left).is_some()` -- `bv::bivariate_scalar_mul`
   - `(Value::BivariateSeries(bs), Value::Series(fps))` -- `bv::bivariate_fps_mul`
   - `(Value::Series(fps), Value::BivariateSeries(bs))` -- `bv::bivariate_fps_mul`

8. **Extend `eval_div`:** NOT needed for now -- bivariate division is not in requirements. If users try it, the catch-all TypeError arm handles it.

9. **Extend `eval_pow`:** NOT needed -- bivariate power is not in requirements.

10. **Extend comparison dispatch** in eval_compare if there is one: BivariateSeries should produce a TypeError for comparisons (same as JacobiProduct).

**In `crates/qsym-cli/src/format.rs`:**

1. Add import: `use qsym_core::series::bivariate::BivariateSeries;`

2. Add arm to `format_value` match (after JacobiProduct, before Procedure):
```rust
Value::BivariateSeries(bs) => format_bivariate(bs, symbols),
```

3. Implement `format_bivariate(bs: &BivariateSeries, symbols: &SymbolRegistry) -> String`:
   - Make `format_series` `pub(crate)` if it's currently private, so bivariate formatter can call it.
   - Iterate over `bs.terms` in **descending** z-exponent order (`.iter().rev()`)
   - For each `(z_exp, fps)`:
     - Format the z-power part:
       - z_exp == 0: no z variable shown
       - z_exp == 1: `{outer_var}`
       - z_exp == -1: `{outer_var}^(-1)`
       - z_exp > 1: `{outer_var}^{z_exp}`
       - z_exp < -1: `{outer_var}^({z_exp})`
     - Single-term FPS (1 nonzero coeff): display inline like `q^3*z^2` or `-q*z^(-1)` (no parens)
     - Multi-term FPS: display as `(fps_str)*z^k` (parenthesized)
     - z^0 term: just `fps_str` without z part
   - Separate terms with ` + ` (the negative sign in the fps_str handles subtraction display)
   - End with ` + O({inner_var}^{trunc})` unless truncation_order >= POLYNOMIAL_ORDER
   - If all terms are empty (zero bivariate), display as `O({inner_var}^{trunc})`

4. Add arm to `format_latex` match:
```rust
Value::BivariateSeries(bs) => format_bivariate_latex(bs, symbols),
```

5. Implement `format_bivariate_latex` -- similar logic but with LaTeX syntax: `z^{k}`, `\frac{}{}`, `+ O(q^{N})`.

6. **Tests in format.rs:**
   - Test format of a simple BivariateSeries with 2 z-terms (e.g., z^1 -> q, z^{-1} -> q)
   - Test format of a zero BivariateSeries
   - Test format_latex of a BivariateSeries

7. **Tests in eval.rs:**
   - Test eval_add of two BivariateSeries values
   - Test eval_mul of BivariateSeries by integer scalar
   - Test eval_negate of BivariateSeries
   - Test type_name returns "bivariate_series"
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -5`
All existing + new tests pass. No compilation errors.
  </verify>
  <done>
Value::BivariateSeries variant exists. Arithmetic operators (add, sub, mul, negate) dispatch correctly for BivariateSeries operands including mixed operations with scalars and Series. Display formatting shows Laurent polynomial form with q-series coefficients. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-core bivariate` -- all core struct and arithmetic tests pass
2. `cargo test -p qsym-cli` -- all CLI tests pass (existing + new bivariate tests)
3. `cargo build -p qsym-cli` -- no compilation warnings related to bivariate
</verification>

<success_criteria>
- BivariateSeries struct in qsym-core with working add/sub/mul/negate/scalar_mul
- Value::BivariateSeries variant in CLI with arithmetic dispatch
- Display formatting shows bivariate series as Laurent polynomials
- All existing tests continue to pass (no regressions)
- New unit tests cover bivariate arithmetic and formatting
</success_criteria>

<output>
After completion, create `.planning/phases/45-bivariate-series/45-01-SUMMARY.md`
</output>
