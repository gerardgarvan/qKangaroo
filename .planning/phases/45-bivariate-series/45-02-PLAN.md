---
phase: 45-bivariate-series
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [BIVAR-01, BIVAR-02]

must_haves:
  truths:
    - "tripleprod(z, q, 10) with symbolic z produces a BivariateSeries showing Laurent polynomial in z"
    - "quinprod(z, q, 10) with symbolic z produces a BivariateSeries showing Laurent polynomial in z"
    - "tripleprod(q, q, 10) still produces a univariate FPS (existing behavior preserved)"
    - "quinprod(q^2, q, 20) still produces a univariate FPS (existing behavior preserved)"
    - "Bivariate tripleprod evaluated at z=q^m matches numeric tripleprod(q^m, q, T)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "compute_tripleprod_bivariate and compute_quinprod_bivariate functions, updated dispatch"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated help text mentioning symbolic z support"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch tripleprod"
      to: "compute_tripleprod_bivariate"
      via: "Symbol detection in first arg"
      pattern: "is_symbolic.*tripleprod_bivariate"
    - from: "crates/qsym-cli/src/eval.rs dispatch quinprod"
      to: "compute_quinprod_bivariate"
      via: "Symbol detection in first arg"
      pattern: "is_symbolic.*quinprod_bivariate"
    - from: "compute_tripleprod_bivariate"
      to: "BivariateSeries"
      via: "constructs BivariateSeries from sum formula"
      pattern: "BivariateSeries"
---

<objective>
Implement bivariate dispatch for tripleprod and quinprod -- when the first argument is a symbolic variable (different from q), compute via sum-form identities and return a BivariateSeries.

Purpose: This is the core mathematical functionality -- users can explore product identities with symbolic z parameters, matching Garvan's Maple capabilities.
Output: Working tripleprod(z, q, T) and quinprod(z, q, T) with symbolic z, plus validation tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-bivariate-series/45-RESEARCH.md
@.planning/phases/45-bivariate-series/45-01-SUMMARY.md
@crates/qsym-core/src/series/bivariate.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: tripleprod and quinprod bivariate computation and dispatch</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
Add two computation functions and update the tripleprod/quinprod dispatch in `crates/qsym-cli/src/eval.rs`:

**1. Add `compute_tripleprod_bivariate` function** (place near the dispatch function or in a helper section):

```rust
/// Compute tripleprod(z, q, T) with symbolic z via Jacobi triple product sum form.
///
/// Uses the Garvan convention:
///   (z;q)_inf * (q/z;q)_inf * (q;q)_inf = sum_{n=-inf}^{inf} (-1)^n * z^n * q^{n(n-1)/2}
///
/// Each term contributes (-1)^n at z^n with q-exponent n*(n-1)/2.
/// Include all n where n*(n-1)/2 < truncation_order and n*(n-1)/2 >= 0.
fn compute_tripleprod_bivariate(
    outer_var: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();

    // Bound: n*(n-1)/2 < T. For positive n: n < (1 + sqrt(1 + 8T))/2.
    // For negative n: |n|*(|n|+1)/2 < T (since n*(n-1)/2 = |n|*(|n|+1)/2 when n < 0).
    // Use a generous bound and filter.
    let bound = ((1.0 + (1.0 + 8.0 * truncation_order as f64).sqrt()) / 2.0).ceil() as i64 + 1;

    for n in -bound..=bound {
        let q_exp = n * (n - 1) / 2;  // Garvan convention: n*(n-1)/2
        if q_exp < 0 || q_exp >= truncation_order {
            continue;
        }
        // Contribution: (-1)^n at z^n, q^{n*(n-1)/2}
        let sign = if n % 2 == 0 { QRat::one() } else { -QRat::one() };

        let entry = terms.entry(n).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old = entry.coeff(q_exp);
        entry.set_coeff(q_exp, old + sign);
    }

    // Remove zero entries
    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**CRITICAL sign convention note:** The Garvan convention is `(z;q)_inf * (q/z;q)_inf * (q;q)_inf = sum_n (-1)^n z^n q^{n(n-1)/2}`. This uses `n*(n-1)/2`, NOT `n*(n+1)/2`. The difference matters:
- n=0: (-1)^0 * z^0 * q^0 = 1 (constant term)
- n=1: (-1)^1 * z^1 * q^0 = -z
- n=-1: (-1)^{-1} * z^{-1} * q^1 = -z^{-1}*q
- n=2: (-1)^2 * z^2 * q^1 = z^2*q
- n=-2: (-1)^{-2} * z^{-2} * q^3 = z^{-2}*q^3

**2. Add `compute_quinprod_bivariate` function:**

```rust
/// Compute quinprod(z, q, T) with symbolic z via quintuple product sum form.
///
/// quinprod(z, q, T) = sum_{m=-inf}^{inf} (z^{3m} - z^{-3m-1}) * q^{m(3m+1)/2}
///
/// Each m contributes two terms:
///   +1 at z^{3m} with q-exponent m*(3m+1)/2
///   -1 at z^{-3m-1} with q-exponent m*(3m+1)/2
fn compute_quinprod_bivariate(
    outer_var: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();

    // Bound: m*(3m+1)/2 < T. Roughly |m| < sqrt(2T/3).
    let bound = ((1.0 + (1.0 + 24.0 * truncation_order as f64).sqrt()) / 6.0).ceil() as i64 + 1;

    for m in -bound..=bound {
        let q_exp = m * (3 * m + 1) / 2;
        if q_exp < 0 || q_exp >= truncation_order {
            continue;
        }

        // +1 at z^{3m}
        let z_exp_pos = 3 * m;
        let entry = terms.entry(z_exp_pos).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old = entry.coeff(q_exp);
        entry.set_coeff(q_exp, old + QRat::one());

        // -1 at z^{-3m-1}
        let z_exp_neg = -3 * m - 1;
        let entry2 = terms.entry(z_exp_neg).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old2 = entry2.coeff(q_exp);
        entry2.set_coeff(q_exp, old2 - QRat::one());
    }

    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**3. Update the tripleprod dispatch** to detect symbolic z:

Replace the current "tripleprod" match arm. The NEW logic:
```rust
"tripleprod" => {
    if args.len() == 3 && matches!(&args[0], Value::Series(_) | Value::Symbol(_)) {
        // Maple: tripleprod(z, q, T)
        // Check if first arg is a Symbol with a DIFFERENT name from the q-variable
        let is_symbolic_outer = match (&args[0], &args[1]) {
            (Value::Symbol(z_name), Value::Symbol(q_name)) => z_name != q_name,
            _ => false,
        };

        if is_symbolic_outer {
            // Bivariate path: symbolic z
            let outer_name = match &args[0] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let sym = extract_symbol_id(name, args, 1, env)?;
            let order = extract_i64(name, args, 2)?;
            let result = compute_tripleprod_bivariate(&outer_name, sym, order);
            Ok(Value::BivariateSeries(result))
        } else {
            // Existing monomial path (z is q-monomial or Symbol("q") treated as q^1)
            let monomial = extract_monomial_from_arg(name, args, 0)?;
            let sym = extract_symbol_id(name, args, 1, env)?;
            let order = extract_i64(name, args, 2)?;
            let result = qseries::tripleprod(&monomial, sym, order);
            Ok(Value::Series(result))
        }
    } else {
        // Legacy: tripleprod(coeff_num, coeff_den, power, order) -- keep unchanged
        expect_args(name, args, 4)?;
        // ... existing legacy code unchanged ...
    }
}
```

**4. Update the quinprod dispatch** similarly:
Same `is_symbolic_outer` detection. If symbolic, call `compute_quinprod_bivariate`, else fall through to existing monomial path.

**5. Validation tests:**

Add these tests to the `#[cfg(test)]` module:

a. **`dispatch_tripleprod_bivariate_basic`:** Call `dispatch("tripleprod", &[Value::Symbol("z".into()), Value::Symbol("q".into()), Value::Integer(QInt::from(10i64))], &mut env)`. Assert result is `Value::BivariateSeries`. Check that the z^0 coefficient is 1 (the constant term from n=0).

b. **`dispatch_tripleprod_bivariate_preserves_univariate`:** Call `dispatch("tripleprod", &[Value::Symbol("q".into()), Value::Symbol("q".into()), Value::Integer(QInt::from(10i64))], &mut env)`. Assert result is `Value::Series` (NOT BivariateSeries), confirming that Symbol("q") with q-variable "q" still goes to the monomial path.

c. **`dispatch_quinprod_bivariate_basic`:** Call with `Value::Symbol("z")`, assert result is `Value::BivariateSeries`.

d. **`dispatch_quinprod_bivariate_preserves_univariate`:** Call with `Value::Symbol("q")`, assert result is `Value::Series`.

e. **`tripleprod_bivariate_sign_convention_validation`:** This is the CRITICAL correctness test. Compute `tripleprod_bivariate("z", q, 20)`. Then for m in {1, 2, 3}, manually evaluate the bivariate result at z=q^m by summing over z-exponents: for each (z_exp, fps), shift fps by z_exp*m (multiply by q^{z_exp*m}), sum all shifted fps values. Compare this against `qseries::tripleprod(&QMonomial::q_power(m), sym_q, 20)`. The results should match exactly (same nonzero coefficients up to the common truncation order).

   Implementation approach for evaluation:
   ```rust
   // For the bivariate result, evaluate at z = q^m
   let bv = compute_tripleprod_bivariate("z", env.sym_q, 20);
   let mut eval_result = FormalPowerSeries::zero(env.sym_q, 20);
   for (&z_exp, fps) in &bv.terms {
       // z^{z_exp} evaluated at z=q^m gives q^{z_exp*m}
       let shifted = arithmetic::shift(fps, z_exp * m);
       // Truncate shifted to match truncation order
       let mut truncated = FormalPowerSeries::zero(env.sym_q, 20);
       for (&k, c) in shifted.iter() {
           if k >= 0 && k < 20 {
               truncated.set_coeff(k, c.clone());
           }
       }
       eval_result = arithmetic::add(&eval_result, &truncated);
   }
   // Compare against numeric tripleprod
   let numeric = qseries::tripleprod(&QMonomial::q_power(m), env.sym_q, 20);
   for k in 0..20 {
       assert_eq!(eval_result.coeff(k), numeric.coeff(k), "mismatch at q^{} for m={}", k, m);
   }
   ```
   Test for m = 1, 2, 3.

f. **`quinprod_bivariate_validation`:** Similar validation for quinprod -- evaluate bivariate at z=q^m and compare against numeric quinprod for m = 1, 2.

g. **`tripleprod_bivariate_symmetry`:** Verify that tripleprod bivariate has the expected symmetry: coefficient of z^n should be (-1)^n * q^{n(n-1)/2} (single monomial per z-exponent).

h. **`bivariate_tripleprod_arithmetic`:** Compute `t1 = tripleprod(z, q, 10)`, `t2 = tripleprod(z, q, 10)`, verify `t1 + t2` is `2 * t1` and `t1 - t1` is zero.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli tripleprod_bivariate quinprod_bivariate -- --nocapture`
All bivariate dispatch and validation tests pass. Especially the sign convention validation test MUST pass.
Then run full test suite: `cargo test -p qsym-cli` to confirm no regressions.
  </verify>
  <done>
tripleprod(z, q, T) with symbolic z returns BivariateSeries via sum formula. quinprod(z, q, T) with symbolic z returns BivariateSeries. Existing monomial paths preserved. Sign convention validated by cross-checking bivariate-evaluated-at-q^m against numeric tripleprod/quinprod.
  </done>
</task>

<task type="auto">
  <name>Task 2: Winquist bivariate dispatch and help updates</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/help.rs
  </files>
  <action>
**1. Implement `compute_winquist_bivariate` in `crates/qsym-cli/src/eval.rs`:**

Winquist has TWO symbolic variables (a, b). The research suggests using `BTreeMap<(i64, i64), FPS>` for (a-exp, b-exp) -> q-coeff. However, since BivariateSeries only supports one outer variable, use a NESTED approach:

The Winquist product is:
```
(q;q)^2 * (a;q)(q/a;q) * (b;q)(q/b;q) * (ab;q)(q/(ab);q) * (a/b;q)(qb/a;q)
```

This factors as:
```
tripleprod(a, q, T) * tripleprod(b, q, T) * tripleprod(ab, q, T) * tripleprod(a/b, q, T) * (q;q)^{-2}_inf
```
Wait -- that's not right either. Winquist has 10 factors total (2 euler + 8 pochhammer), not 4 triple products.

**Better approach for Winquist bivariate:** Since Winquist involves TWO symbolic outer variables, we need a different representation. The simplest correct approach: when BOTH a and b are symbolic, compute using the Winquist sum form. Store result as a `Value::Dict` with structured output, OR use a nested representation.

**Practical approach:** Use a `Vec` of terms, each being `(a_exp, b_exp, q_coeff: FPS)`, stored in a new `MultivariateSeries` struct. But this adds significant complexity.

**Simpler, pragmatic approach chosen:** For Phase 45, handle Winquist bivariate by supporting the case where ONLY ONE of a, b is symbolic (the other is a q-monomial). This reduces to a single-variable BivariateSeries. When ONE argument is symbolic:
- If a is symbolic and b is a monomial: compute tripleprod(a, q, T) * tripleprod(a*b_monomial, q, T) ... but this doesn't factor cleanly.

**Actually simplest correct approach:** Compute Winquist with two symbolic variables by representing it as a list of (a-exponent, b-exponent, q-coefficient-FPS) triples, formatted as a readable sum. Use the Winquist sum formula:

The Winquist identity double sum (from Winquist 1969, see Garvan):
```
W(a,b,q) = sum over specific index set of:
  sign * a^{r} * b^{s} * q^{exponent}
```

The exact double-sum form per the research has LOW confidence. So use the **product factoring approach** instead:

**Product factoring approach:** Winquist(a, b, q, T) with symbolic a, b can be computed as:
1. Compute tp_a = tripleprod_bivariate(a, q, T) -- BivariateSeries in a
2. Compute tp_b = tripleprod_bivariate(b, q, T) -- BivariateSeries in b
3. But we can't multiply these because they have different outer variables.

**Final decision:** For Winquist with two symbolic args, return a helpful error message explaining that only one symbolic variable is supported, and suggest using `winquist(a, q^2, q, T)` where one arg is a q-monomial. For the case of ONE symbolic arg, route to a specialized function that computes Winquist with the other arg as a concrete monomial:

When ONE arg is symbolic (say a), and b is a monomial:
- We can compute the full product form with symbolic a but concrete b. This means:
  - Compute each of the 10 factors. Factors involving only b and q give concrete FPS. Factors involving a give bivariate.
  - Actually this is still complex. The simplest MVP: compute Winquist bivariate for ONE symbolic variable by:
    1. Compute all 10 factors as before, but for the factors involving the symbolic variable, use bivariate computation.
    2. Multiply bivariate * FPS and bivariate * bivariate as we've implemented.

This is doable! When a is symbolic and b = b_c * q^{b_p}:
- Factor (q;q)_inf^2: plain FPS (euler squared)
- Factor (a;q)_inf: this is sum_n (-1)^n a^n q^{n(n-1)/2} ... which is exactly tripleprod_bivariate(a, q, T) / (q;q)_inf. Hmm, that's circular.

**Even simpler approach:** Use the Winquist double-sum identity. Despite LOW confidence in the exact formula, we can VERIFY the result by checking specific substitutions a=q^r, b=q^s against the existing numeric winquist function.

Actually, let me reconsider. The research warns the double sum has LOW confidence. The safest approach:

**Compute Winquist bivariate via direct product multiplication with bivariate intermediate results.**

When a is symbolic (outer var) and b = b_c * q^{b_p} (concrete monomial):
- (q;q)_inf^2: FPS
- (a_c*q^{a_p};q)_inf where a_c=1, a_p depends on a being q^0... wait, a is symbolic, not q-monomial.

This doesn't work with the existing product infrastructure which requires concrete coefficients.

**FINAL DECISION for Winquist:** Implement Winquist bivariate using a `BTreeMap<(i64,i64), FormalPowerSeries>` approach stored in a **new Value variant `Value::MultivariateSeries`**... No, that's too much for this plan.

**Pragmatic final decision:** For Winquist with symbolic args, use the PRODUCT-OF-TRIPLEPROD approach. Winquist can be expressed (approximately) as a product involving triple products. But this factorization isn't exact.

**TRULY FINAL approach:** Use a sum-of-products-of-bivariate approach. The Winquist identity is:

```
W(a,b,q) = (q;q)^2 * TP(a,q) * TP(b,q) * TP(ab,q) * TP(a/b,q) / (q;q)^2
```

Wait, no. Actually:
```
W(a,b,q) = (q;q)^2 * (a;q)(q/a;q) * (b;q)(q/b;q) * (ab;q)(q/ab;q) * (a/b;q)(qa/b;q)
```

This IS `(q;q)^2 * TP(a) * TP(b) * TP(ab) * TP(a/b) / (q;q)^4`... No, tripleprod(a) = (a;q)(q/a;q)(q;q), so (a;q)(q/a;q) = TP(a)/(q;q).

So: W(a,b,q) = (q;q)^2 * [TP(a)/(q;q)] * [TP(b)/(q;q)] * [TP(ab)/(q;q)] * [TP(a/b)/(q;q)]
            = TP(a) * TP(b) * TP(ab) * TP(a/b) / (q;q)^2

**THIS IS CORRECT!** Winquist factors as:
```
winquist(a,b,q,T) = tripleprod(a,q,T) * tripleprod(b,q,T) * tripleprod(a*b,q,T) * tripleprod(a/b,q,T) / euler(q,T)^2
```

For symbolic a and b: we can compute tripleprod(a) and tripleprod(b) as BivariateSeries. But tripleprod(a*b) and tripleprod(a/b) involve PRODUCTS of two symbolic variables, which is a multivariate case.

**OK, definitively:** Implement a simple version where Winquist with symbolic args returns an error saying "symbolic variables in winquist require specifying concrete q-monomials; use winquist(q^m, q^n, q, T)". This aligns with the research recommendation to "defer Winquist bivariate to a follow-up and focus on tripleprod + quinprod first" if the sum form is too complex.

**WAIT** -- looking at the requirements again: BIVAR-03 says "winquist(a, b, q, T) with symbolic a, b produces multivariate series". This IS a requirement. But the research itself flags LOW confidence on the sum formula.

**Resolution:** Implement Winquist bivariate for the case where ONE variable is symbolic (reduces to BivariateSeries), and for TWO symbolic variables, use the decomposition:

For TWO symbolic variables a, b: We cannot do tripleprod(a*b) as bivariate in one variable. So instead, express the result as a **List** of term-groups, or simply compute a **Dict** representation.

**ACTUALLY the cleanest approach for two symbolic vars:** Express Winquist as the sum form. The Winquist identity sum form from the paper is:

W(a,b,q) = sum_{m,n in Z} w(m,n) * a^{f(m,n)} * b^{g(m,n)} * q^{h(m,n)}

where the exact functions f,g,h and sign w require careful derivation. Since confidence is LOW, implement the following instead:

Compute Winquist bivariate using the **product-of-bivariate** approach for ONE symbolic var:

When `a` is symbolic and `b` is concrete monomial `b_c*q^{b_p}`:
1. euler_sq = (q;q)^2 as FPS
2. tp_a_part = tripleprod_bivariate(a, q, T) -- BivariateSeries in a
3. The remaining factors all have concrete coefficients once b is fixed:
   - (b;q)(q/b;q) = tripleprod(b, q, T) / (q;q) -- concrete FPS
   - (ab;q)(q/(ab);q): substitute a -> a, but (ab;q)_inf with symbolic a and concrete b is tricky...

This still doesn't work cleanly. The factors involving BOTH a and another concrete value can't be split.

**FINAL FINAL approach:** For BIVAR-03, implement Winquist with TWO symbolic variables by storing the result as a **Dict** (key-value map), where each key is a string like "a^r*b^s" and the value is the q-series FPS coefficient. Use a BTreeMap<(i64,i64), FPS> internally, then convert to Dict for display. This is a practical compromise that satisfies the requirement.

Implementation: Add a helper `compute_winquist_bivariate_double` that uses the double-sum approach with a VERIFICATION STEP:

The Winquist double sum (standard form from Andrews-Garvan):
```
W(a,b,q) = sum_{m in Z} sum_{n in Z} (-1)^{m+n} *
  [ a^{2m} * b^{3n} * q^{m(5m-1)/2 + n(5n-1)/2 + 2mn}
  - a^{2m+1} * b^{3n+1} * q^{m(5m+3)/2 + n(5n+3)/2 + (2m+1)(n) + ...} ]
```

Actually this formula is uncertain. Use the KNOWN factored form for verification:

Compute Winquist at specific values (a=q^1, b=q^2) using both the sum form and the existing numeric function. If they match, the sum form is correct.

**Given the complexity:** Implement Winquist two-variable as a Dict of (a^r*b^s -> FPS) using a brute-force approach:

1. Compute the 10 individual Pochhammer factors as formal products of (1 - coeff_i * a^{ai} * b^{bi} * q^{qi+step*n}) for n=0,1,2,...
2. Multiply them together, tracking (a-exp, b-exp, q-exp) triples.

This is essentially computing a trivariate product. Represent intermediates as `BTreeMap<(i64,i64), FPS>` and multiply factor by factor.

Each Pochhammer factor `(c * a^{a_e} * b^{b_e} * q^{q_e}; q)_inf` expands as:
```
prod_{n>=0} (1 - c * a^{a_e} * b^{b_e} * q^{q_e + n})
```

For the factors of Winquist:
- (a; q)_inf: c=1, a_e=1, b_e=0, each factor is (1 - a * q^n) for n=0,1,...
- (q/a; q)_inf: c=1, a_e=-1, b_e=0, factors (1 - a^{-1} * q^{1+n})
- (b; q)_inf: c=1, a_e=0, b_e=1
- etc.

Multiplying `BTreeMap<(i64,i64), FPS>` values factor by factor is feasible:
```
result = {(0,0) -> FPS::one()}  // start with 1
for each Pochhammer factor:
  // Factor is (1 - c * a^{ae} * b^{be} * q^{offset + step*k}) for k=0,1,...
  for k in 0..max_k:
    // Multiply current result by (1 - c * a^ae * b^be * q^{offset+step*k})
    new_result = result.clone()
    for each ((ar, br), fps) in result:
      shifted_fps = shift(fps, offset+step*k) * (-c)
      new_ar = ar + ae
      new_br = br + be
      add shifted_fps to new_result[(new_ar, new_br)]
    result = new_result (filter zeros)
```

This is O(factors * terms * k_range) which can be large. But for T=10-20 it's manageable.

**IMPLEMENT THIS:** Create `compute_winquist_multivariate` that returns a `Vec<(i64, i64, FormalPowerSeries)>` representing `sum_{r,s} coeff(r,s)(q) * a^r * b^s`. Convert to `Value::Dict` for display.

**Actually, more organized:** Store as `Value::List` of `Value::Dict` entries, or introduce the concept directly in format.

**Cleanest path:** Introduce a small `MultivariateLaurent` type locally in eval.rs (not in qsym-core since this is specialized for Winquist):

```rust
struct MultivariateLaurent {
    var_names: Vec<String>,  // ["a", "b"]
    terms: BTreeMap<Vec<i64>, FormalPowerSeries>,  // [a_exp, b_exp] -> q-coeff
    inner_variable: SymbolId,
    truncation_order: i64,
}
```

Then format it for display and wrap in a `Value::String` (rendered output). This avoids adding a new Value variant.

**EVEN SIMPLER:** Compute the multivariate result, format it as a String, and return `Value::String(formatted)`. Users can see the result but can't do arithmetic on it (which isn't required for BIVAR-03 -- BIVAR-04 only requires arithmetic on bivariate series, and winquist is trivariate).

**Implementation plan for Winquist bivariate:**

```rust
fn compute_winquist_multivariate(
    a_var: &str,
    b_var: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> String {
    // Represent current product as BTreeMap<(i64,i64), FPS>
    // Start with {(0,0): 1 + O(q^T)}
    type Terms = BTreeMap<(i64, i64), FormalPowerSeries>;
    let mut result: Terms = BTreeMap::new();
    result.insert((0, 0), FormalPowerSeries::one(inner_var, truncation_order));

    // The 10 factors of Winquist:
    // (q;q)_inf^2: a_e=0, b_e=0, base=1, step=1, coeff=1 (TWO copies)
    // (a;q)_inf: a_e=1, b_e=0, base=0, step=1, coeff=1
    // (q/a;q)_inf = (a^{-1}*q;q)_inf: a_e=-1, b_e=0, base=1, step=1, coeff=1
    // (b;q)_inf: a_e=0, b_e=1, base=0, step=1, coeff=1
    // (q/b;q)_inf: a_e=0, b_e=-1, base=1, step=1, coeff=1
    // (ab;q)_inf: a_e=1, b_e=1, base=0, step=1, coeff=1
    // (q/(ab);q)_inf: a_e=-1, b_e=-1, base=2, step=1, coeff=1
    // Wait -- (q/(ab);q)_inf = (a^{-1}b^{-1}q;q)_inf, starting base=1? Let me recheck.
    // (ab;q)_inf means prod_{n>=0}(1 - ab*q^n). First factor n=0: (1-ab).
    // Hmm but if a and b are both "bare" symbols (not multiplied by q-powers), then
    // the first factor (1 - a*b*q^0) = (1 - ab) is non-series. We need to track this.
    //
    // Actually for symbolic a, b: (a;q)_inf = prod_{n>=0}(1-a*q^n). The n=0 term is (1-a).
    // This is a polynomial factor in a. Our multivariate product can handle it.

    // Each factor: (a_e, b_e, base_q_exp, q_step, scalar_coeff)
    // Factor k=0,1,2,...: (1 - coeff * a^{a_e} * b^{b_e} * q^{base + step*k})
    let factors: Vec<(i64, i64, i64, i64, QRat)> = vec![
        // (q;q)_inf: prod(1 - q^{1+n}) for n=0,1,... => a_e=0,b_e=0,base=1,step=1
        (0, 0, 1, 1, QRat::one()),
        // (q;q)_inf again (squared)
        (0, 0, 1, 1, QRat::one()),
        // (a;q)_inf: prod(1 - a*q^n) for n=0,1,...
        (1, 0, 0, 1, QRat::one()),
        // (q/a;q)_inf = prod(1 - a^{-1}*q^{1+n}) for n=0,1,...
        (-1, 0, 1, 1, QRat::one()),
        // (b;q)_inf: prod(1 - b*q^n)
        (0, 1, 0, 1, QRat::one()),
        // (q/b;q)_inf: prod(1 - b^{-1}*q^{1+n})
        (0, -1, 1, 1, QRat::one()),
        // (ab;q)_inf: prod(1 - a*b*q^n)
        (1, 1, 0, 1, QRat::one()),
        // (q/(ab);q)_inf: prod(1 - a^{-1}*b^{-1}*q^{2+n})
        // Wait: q/(ab) = a^{-1}*b^{-1}*q. So (q/(ab);q)_inf = prod(1 - a^{-1}*b^{-1}*q^{1+n})
        (-1, -1, 1, 1, QRat::one()),
        // Wait, that's only 8 factors + 2 euler = 10. But Winquist has:
        // (a*b^{-1};q)_inf: prod(1 - a*b^{-1}*q^n)
        (1, -1, 0, 1, QRat::one()),
        // (a^{-1}*b*q;q)_inf: prod(1 - a^{-1}*b*q^{1+n})
        // Actually: the 8th factor is (q*b/a; q)_inf = (a^{-1}*b*q; q)_inf
        (-1, 1, 1, 1, QRat::one()),
    ];

    // Multiply each factor into result
    for (a_e, b_e, base, step, coeff) in &factors {
        // How many sub-factors (k values) do we need?
        let max_k = if *step > 0 && *base < truncation_order {
            ((truncation_order - base + step - 1) / step) + 1
        } else {
            1
        };

        for k in 0..max_k {
            let q_exp = base + step * k;
            if q_exp >= truncation_order {
                break;
            }
            // Multiply result by (1 - coeff * a^{a_e} * b^{b_e} * q^{q_exp})
            // This means: new = old - coeff * shift_and_relabel(old, a_e, b_e, q_exp)
            let mut additions: Terms = BTreeMap::new();
            for (&(ar, br), fps) in &result {
                let new_ar = ar + a_e;
                let new_br = br + b_e;
                let shifted = arithmetic::shift(fps, q_exp);
                let neg_coeff_shifted = arithmetic::scalar_mul(&(-coeff.clone()), &shifted);
                // Truncate to our order
                let mut truncated = FormalPowerSeries::zero(inner_var, truncation_order);
                for (&p, c) in neg_coeff_shifted.iter() {
                    if p < truncation_order {
                        truncated.set_coeff(p, c.clone());
                    }
                }
                let entry = additions.entry((new_ar, new_br)).or_insert_with(||
                    FormalPowerSeries::zero(inner_var, truncation_order)
                );
                *entry = arithmetic::add(entry, &truncated);
            }
            // Merge additions into result
            for ((ar, br), fps) in additions {
                let entry = result.entry((ar, br)).or_insert_with(||
                    FormalPowerSeries::zero(inner_var, truncation_order)
                );
                *entry = arithmetic::add(entry, &fps);
            }
            // Clean up zeros
            result.retain(|_, fps| !fps.is_zero());
        }
    }

    // Format the result as a string
    format_multivariate_result(&result, a_var, b_var, inner_var, truncation_order, symbols)
}
```

WAIT - this approach has a problem: the `symbols` SymbolRegistry reference isn't available in this helper. Also this is getting very complex for a single task. Let me simplify.

**REVISED SIMPLER APPROACH for Winquist:**

Given the complexity of the multivariate product expansion (10 nested Pochhammer factors with 2 symbolic variables), and the LOW confidence on the sum form, implement Winquist bivariate as follows:

1. When BOTH a and b are symbolic: Return an error `"winquist with two symbolic variables is not yet supported; use concrete q-monomials like winquist(q, q^2, q, 10)"`. This is honest about the limitation.

2. When ONE of a, b is symbolic and the other is a concrete monomial: This still requires multivariate handling because even with one symbolic var, the product factors involve that var in multiple ways. BUT we can compute it as a BivariateSeries:

When `a` is symbolic and `b = b_c * q^{b_p}` is concrete:
- Use the same multivariate product approach but with (a_e only, no b_e), since b is substituted.
- Each factor becomes `(1 - scalar * a^{a_e} * q^{q_exp})` where the scalar incorporates b_c^{b_e}.
- This IS a BivariateSeries computation! Each factor multiplied into the running BivariateSeries.

Implement `compute_winquist_one_symbolic`:
```rust
fn compute_winquist_one_symbolic(
    outer_var: &str,  // the symbolic variable name
    other_monomial: &QMonomial,  // the concrete one
    which_is_symbolic: char,  // 'a' or 'b'
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    // Build the 10 factors, substituting the concrete monomial
    // and keeping the symbolic one as the outer variable.
    // Each factor is (1 - c * outer^{exp} * q^{offset+step*k}) for k=0,1,...
    // Multiply into a running BivariateSeries.
    // Start with BivariateSeries = {0: 1+O(q^T)}
    ...
}
```

Actually this is STILL complex. For a cleaner implementation:

**SIMPLEST VIABLE APPROACH:**

For Winquist bivariate, use the **decomposition into triple products**:

```
winquist(a, b, q, T) = tripleprod(a, q, T) * tripleprod(b, q, T) *
                        tripleprod(a*b, q, T) * tripleprod(a/b, q, T) / (q;q)^2_inf
```

Wait, let me verify: tripleprod(z) = (z;q)(q/z;q)(q;q). So:
- tripleprod(a) * tripleprod(b) * tripleprod(ab) * tripleprod(a/b)
  = [(a;q)(q/a;q)(q;q)] * [(b;q)(q/b;q)(q;q)] * [(ab;q)(q/ab;q)(q;q)] * [(a/b;q)(qb/a;q)(q;q)]
  = (q;q)^4 * (a;q)(q/a;q) * (b;q)(q/b;q) * (ab;q)(q/ab;q) * (a/b;q)(qb/a;q)

And winquist = (q;q)^2 * same 8 pochhammer factors.

So winquist = tripleprod(a) * tripleprod(b) * tripleprod(ab) * tripleprod(a/b) / (q;q)^2.

For symbolic a and b:
- tripleprod(a) = BivariateSeries in a
- tripleprod(b) = BivariateSeries in b
- tripleprod(a*b) and tripleprod(a/b) = need multivariate

Still can't do it with single-variable BivariateSeries.

**FINAL RESOLUTION:** For BIVAR-03, implement Winquist with one symbolic var using the product factoring. When both are symbolic, return a descriptive error. This gives partial support and is honest about limitations. Update help text to document this.

When `a` is symbolic and `b = b_c * q^{b_p}`:
```
winquist(a, b, q, T) = tripleprod(a, q, T) * tripleprod_univar(b, q, T) *
                        tripleprod_with_shift(a, b, q, T) * tripleprod_with_shift(a, 1/b, q, T) / (q;q)^2
```

Where `tripleprod_with_shift(a, b, q, T)` means tripleprod(a*b) which, with symbolic a and concrete b=b_c*q^{b_p}, becomes:

tripleprod(a*b, q, T) = (a*b; q)(q/(a*b); q)(q; q)
For the sum form: sum_n (-1)^n (a*b)^n q^{n(n-1)/2} = sum_n (-1)^n * b_c^n * a^n * q^{n(n-1)/2 + n*b_p}

This IS a BivariateSeries in a! Each term is at z-exp = n, q-exp = n*(n-1)/2 + n*b_p, with coefficient (-1)^n * b_c^n.

Similarly tripleprod(a/b, q, T) = sum_n (-1)^n (a/b)^n q^{n(n-1)/2} = sum_n (-1)^n * (1/b_c)^n * a^n * q^{n(n-1)/2 - n*b_p}

So:
```rust
fn compute_tripleprod_bivariate_shifted(
    outer_var: &str,
    shift_coeff: &QRat,  // b_c^n factor per z-exponent
    shift_power: i64,     // extra q-power per z-exponent (b_p * n)
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    // sum_n (-1)^n * shift_coeff^n * z^n * q^{n(n-1)/2 + shift_power*n}
    ...
}
```

Then: winquist(a_symbolic, b_concrete, q, T) =
  bv_mul(bv_mul(bv_mul(tp_a, tp_ab_shifted), tp_a_over_b_shifted), fps_to_bv(euler_sq_inv * tp_b_concrete))

Where:
- tp_a = compute_tripleprod_bivariate(a, q, T)  // plain symbolic
- tp_ab_shifted = compute_tripleprod_bivariate_shifted(a, b_c, b_p, q, T)  // a*b symbolic
- tp_a_over_b_shifted = compute_tripleprod_bivariate_shifted(a, 1/b_c, -b_p, q, T)  // a/b symbolic
- tp_b_concrete = qseries::tripleprod(b_monomial, q, T)  // plain FPS
- euler_sq_inv = invert(euler * euler)  // plain FPS
- Multiply: tp_a * tp_ab * tp_aoverb (all bivariate) * (tp_b / euler^2) (FPS)

This works! All bivariate multiplications have the SAME outer variable (a), and the FPS multiplications use bivariate_fps_mul.

**IMPLEMENT THIS for Winquist one-symbolic-var.** For two-symbolic-vars, return error.

**Symmetry note:** If `b` is symbolic and `a` is concrete, swap roles.

Now, the implementation in dispatch:

```rust
"winquist" => {
    if args.len() == 4 && matches!(&args[2], Value::Symbol(_)) {
        let sym = extract_symbol_id(name, args, 2, env)?;
        let order = extract_i64(name, args, 3)?;

        // Check which args are symbolic
        let a_is_symbolic = match (&args[0], &args[2]) {
            (Value::Symbol(a_name), Value::Symbol(q_name)) => a_name != q_name,
            _ => false,
        };
        let b_is_symbolic = match (&args[1], &args[2]) {
            (Value::Symbol(b_name), Value::Symbol(q_name)) => b_name != q_name,
            _ => false,
        };

        if a_is_symbolic && b_is_symbolic {
            return Err(EvalError::Other(
                "winquist with two symbolic variables is not yet supported; \
                 use a q-monomial for one argument, e.g. winquist(a, q^2, q, 10)".to_string()
            ));
        } else if a_is_symbolic {
            let outer_name = match &args[0] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let b_mono = extract_monomial_from_arg(name, args, 1)?;
            let result = compute_winquist_one_symbolic(&outer_name, &b_mono, sym, order);
            Ok(Value::BivariateSeries(result))
        } else if b_is_symbolic {
            let outer_name = match &args[1] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let a_mono = extract_monomial_from_arg(name, args, 0)?;
            let result = compute_winquist_one_symbolic_b(&outer_name, &a_mono, sym, order);
            Ok(Value::BivariateSeries(result))
        } else {
            // Both are concrete monomials -- existing path
            let a = extract_monomial_from_arg(name, args, 0)?;
            let b = extract_monomial_from_arg(name, args, 1)?;
            let result = qseries::winquist(&a, &b, sym, order);
            Ok(Value::Series(result))
        }
    } else {
        // Legacy path unchanged
        ...
    }
}
```

Implement `compute_winquist_one_symbolic(outer_var, b_mono, inner_var, trunc_order) -> BivariateSeries`:
1. Compute tp_a = tripleprod_bivariate(outer_var, inner_var, trunc_order) -- a's triple product
2. Compute tp_ab = tripleprod_bivariate_shifted(outer_var, &b_mono.coeff, b_mono.power, inner_var, trunc_order) -- (a*b)'s triple product
3. Compute tp_a_over_b = tripleprod_bivariate_shifted(outer_var, &(QRat::one() / b_mono.coeff.clone()), -b_mono.power, inner_var, trunc_order) -- (a/b)'s triple product
4. Compute tp_b = qseries::tripleprod(&b_mono, inner_var, trunc_order) -- concrete FPS
5. Compute euler_sq = euler^2 as FPS, then euler_sq_inv = invert(euler_sq)
6. scalar_fps = arithmetic::mul(&tp_b, &euler_sq_inv)
7. result = bv_mul(bv_mul(bv_mul(tp_a, tp_ab), tp_a_over_b), bv_from_fps(scalar_fps))
   Where bv_from_fps converts an FPS to a BivariateSeries with a single z^0 term.

Actually step 7: bv::bivariate_fps_mul(&scalar_fps, &bv_mul_result) is cleaner.

Implement `compute_winquist_one_symbolic_b` similarly but with a and b roles swapped.

Implement `compute_tripleprod_bivariate_shifted`:
```rust
fn compute_tripleprod_bivariate_shifted(
    outer_var: &str,
    shift_coeff: &QRat,  // multiplier per z-exponent power
    shift_power: i64,     // additional q-shift per z-exponent
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    // sum_n (-1)^n * shift_coeff^n * z^n * q^{n*(n-1)/2 + shift_power*n}
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();
    let bound = ((1.0 + (1.0 + 8.0 * truncation_order as f64).sqrt()) / 2.0).ceil() as i64 + 2;

    // Need tighter bound accounting for shift_power
    // q_exp = n*(n-1)/2 + shift_power*n = n*(n-1+2*shift_power)/2
    // We need q_exp >= 0 and q_exp < truncation_order
    // Use generous bound and filter

    let mut shift_coeff_pow = QRat::one(); // shift_coeff^0
    let inv_shift_coeff = if !shift_coeff.is_zero() {
        QRat::one() / shift_coeff.clone()
    } else {
        QRat::zero()
    };

    // Positive n
    let mut sc_pos = QRat::one();
    for n in 0..=(bound + shift_power.unsigned_abs() as i64) {
        let q_exp = n * (n - 1) / 2 + shift_power * n;
        if q_exp >= truncation_order { break; }
        if q_exp >= 0 {
            let sign = if n % 2 == 0 { sc_pos.clone() } else { -sc_pos.clone() };
            let entry = terms.entry(n).or_insert_with(||
                FormalPowerSeries::zero(inner_var, truncation_order)
            );
            let old = entry.coeff(q_exp);
            entry.set_coeff(q_exp, old + sign);
        }
        sc_pos = sc_pos * shift_coeff.clone();
    }

    // Negative n
    let mut sc_neg = inv_shift_coeff.clone(); // shift_coeff^{-1}
    for n_abs in 1..=(bound + shift_power.unsigned_abs() as i64) {
        let n = -(n_abs as i64);
        let q_exp = n * (n - 1) / 2 + shift_power * n;
        if q_exp >= truncation_order { break; } // may not work for negative n
        if q_exp >= 0 && q_exp < truncation_order {
            let sign = if n % 2 == 0 { sc_neg.clone() } else { -sc_neg.clone() };
            let entry = terms.entry(n).or_insert_with(||
                FormalPowerSeries::zero(inner_var, truncation_order)
            );
            let old = entry.coeff(q_exp);
            entry.set_coeff(q_exp, old + sign);
        }
        sc_neg = sc_neg * inv_shift_coeff.clone();
    }

    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**Tests for Winquist bivariate:**

a. `dispatch_winquist_one_symbolic_a`: Call winquist(z, q^2, q, 10) with z symbolic, q^2 as monomial. Assert result is BivariateSeries.

b. `dispatch_winquist_one_symbolic_b`: Call winquist(q, z, q, 10) with z symbolic. Assert BivariateSeries.

c. `winquist_bivariate_validation`: Compute winquist(z, q^2, q, T) as bivariate, evaluate at z=q (i.e., substitute a=q) by shifting each z^n term by n and summing. Compare against numeric winquist(q, q^2, q, T). Must match.

d. `dispatch_winquist_two_symbolic_error`: Call winquist(a, b, q, 10) with both a, b symbolic. Assert returns EvalError.

e. `dispatch_winquist_preserves_univariate`: Call winquist(q, q^2, q, 10) with both as monomial series. Assert result is Value::Series (existing behavior).

**2. Update help entries in `crates/qsym-cli/src/help.rs`:**

Update the help entries for tripleprod, quinprod, and winquist to mention symbolic z support:

- tripleprod: Update description to mention: "When z is a symbolic variable (different from q), returns a bivariate Laurent polynomial in z with q-series coefficients." Update example to include `tripleprod(z, q, 10)`.
- quinprod: Same pattern.
- winquist: Update description to mention: "When one of a, b is symbolic, returns a bivariate Laurent polynomial. Two symbolic variables not yet supported." Update example.

Do NOT change the count assertion (`FUNC_HELP.len() == 95`) -- no new functions are being added, just updated descriptions.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -10`
All tests pass including:
- Bivariate tripleprod/quinprod dispatch and validation
- Winquist one-symbolic-var dispatch and validation
- Winquist two-symbolic-var error
- Existing univariate paths preserved
- Help text tests pass (count unchanged)
  </verify>
  <done>
tripleprod(z, q, T) and quinprod(z, q, T) produce BivariateSeries when z is symbolic. winquist(a, b_mono, q, T) produces BivariateSeries when one arg is symbolic. Sign conventions validated by cross-checking against numeric evaluation. Help text updated. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli tripleprod` -- bivariate and univariate tripleprod tests pass
2. `cargo test -p qsym-cli quinprod` -- bivariate and univariate quinprod tests pass
3. `cargo test -p qsym-cli winquist` -- bivariate and univariate winquist tests pass
4. `cargo test -p qsym-cli` -- full CLI test suite passes (no regressions)
5. The critical sign-convention validation tests pass (bivariate evaluated at z=q^m matches numeric)
</verification>

<success_criteria>
- tripleprod(z, q, 10) with symbolic z returns BivariateSeries with correct coefficients
- quinprod(z, q, 10) with symbolic z returns BivariateSeries with correct coefficients
- winquist(a, q^2, q, 10) with symbolic a returns BivariateSeries
- tripleprod(q, q, 10) still returns univariate FPS (no regression)
- Cross-validation: bivariate result evaluated at z=q^m matches numeric tripleprod/quinprod/winquist
- Help text mentions symbolic z support for all three functions
</success_criteria>

<output>
After completion, create `.planning/phases/45-bivariate-series/45-02-SUMMARY.md`
</output>
