---
phase: 45-bivariate-series
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [BIVAR-01, BIVAR-02]

must_haves:
  truths:
    - "tripleprod(z, q, 10) with symbolic z produces a BivariateSeries showing Laurent polynomial in z"
    - "quinprod(z, q, 10) with symbolic z produces a BivariateSeries showing Laurent polynomial in z"
    - "tripleprod(q, q, 10) still produces a univariate FPS (existing behavior preserved)"
    - "quinprod(q^2, q, 20) still produces a univariate FPS (existing behavior preserved)"
    - "Bivariate tripleprod evaluated at z=q^m matches numeric tripleprod(q^m, q, T)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "compute_tripleprod_bivariate and compute_quinprod_bivariate functions, updated dispatch"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated help text mentioning symbolic z support for tripleprod and quinprod"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch tripleprod"
      to: "compute_tripleprod_bivariate"
      via: "Symbol detection in first arg"
      pattern: "is_symbolic.*tripleprod_bivariate"
    - from: "crates/qsym-cli/src/eval.rs dispatch quinprod"
      to: "compute_quinprod_bivariate"
      via: "Symbol detection in first arg"
      pattern: "is_symbolic.*quinprod_bivariate"
    - from: "compute_tripleprod_bivariate"
      to: "BivariateSeries"
      via: "constructs BivariateSeries from sum formula"
      pattern: "BivariateSeries"
---

<objective>
Implement bivariate dispatch for tripleprod and quinprod -- when the first argument is a symbolic variable (different from q), compute via sum-form identities and return a BivariateSeries. Update help text for both functions.

Purpose: This is the core mathematical functionality -- users can explore product identities with symbolic z parameters, matching Garvan's Maple capabilities.
Output: Working tripleprod(z, q, T) and quinprod(z, q, T) with symbolic z, plus validation tests and updated help.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-bivariate-series/45-RESEARCH.md
@.planning/phases/45-bivariate-series/45-01-SUMMARY.md
@crates/qsym-core/src/series/bivariate.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: tripleprod and quinprod bivariate computation and dispatch</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
Add two computation functions and update the tripleprod/quinprod dispatch in `crates/qsym-cli/src/eval.rs`:

**1. Add `compute_tripleprod_bivariate` function** (place near the dispatch function or in a helper section):

```rust
/// Compute tripleprod(z, q, T) with symbolic z via Jacobi triple product sum form.
///
/// Uses the Garvan convention:
///   (z;q)_inf * (q/z;q)_inf * (q;q)_inf = sum_{n=-inf}^{inf} (-1)^n * z^n * q^{n(n-1)/2}
///
/// Each term contributes (-1)^n at z^n with q-exponent n*(n-1)/2.
/// Include all n where n*(n-1)/2 < truncation_order and n*(n-1)/2 >= 0.
fn compute_tripleprod_bivariate(
    outer_var: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();

    // Bound: n*(n-1)/2 < T. For positive n: n < (1 + sqrt(1 + 8T))/2.
    // For negative n: |n|*(|n|+1)/2 < T (since n*(n-1)/2 = |n|*(|n|+1)/2 when n < 0).
    // Use a generous bound and filter.
    let bound = ((1.0 + (1.0 + 8.0 * truncation_order as f64).sqrt()) / 2.0).ceil() as i64 + 1;

    for n in -bound..=bound {
        let q_exp = n * (n - 1) / 2;  // Garvan convention: n*(n-1)/2
        if q_exp < 0 || q_exp >= truncation_order {
            continue;
        }
        // Contribution: (-1)^n at z^n, q^{n*(n-1)/2}
        let sign = if n % 2 == 0 { QRat::one() } else { -QRat::one() };

        let entry = terms.entry(n).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old = entry.coeff(q_exp);
        entry.set_coeff(q_exp, old + sign);
    }

    // Remove zero entries
    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**CRITICAL sign convention note:** The Garvan convention is `(z;q)_inf * (q/z;q)_inf * (q;q)_inf = sum_n (-1)^n z^n q^{n(n-1)/2}`. This uses `n*(n-1)/2`, NOT `n*(n+1)/2`. The difference matters:
- n=0: (-1)^0 * z^0 * q^0 = 1 (constant term)
- n=1: (-1)^1 * z^1 * q^0 = -z
- n=-1: (-1)^{-1} * z^{-1} * q^1 = -z^{-1}*q
- n=2: (-1)^2 * z^2 * q^1 = z^2*q
- n=-2: (-1)^{-2} * z^{-2} * q^3 = z^{-2}*q^3

**2. Add `compute_quinprod_bivariate` function:**

```rust
/// Compute quinprod(z, q, T) with symbolic z via quintuple product sum form.
///
/// quinprod(z, q, T) = sum_{m=-inf}^{inf} (z^{3m} - z^{-3m-1}) * q^{m(3m+1)/2}
///
/// Each m contributes two terms:
///   +1 at z^{3m} with q-exponent m*(3m+1)/2
///   -1 at z^{-3m-1} with q-exponent m*(3m+1)/2
fn compute_quinprod_bivariate(
    outer_var: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();

    // Bound: m*(3m+1)/2 < T. Roughly |m| < sqrt(2T/3).
    let bound = ((1.0 + (1.0 + 24.0 * truncation_order as f64).sqrt()) / 6.0).ceil() as i64 + 1;

    for m in -bound..=bound {
        let q_exp = m * (3 * m + 1) / 2;
        if q_exp < 0 || q_exp >= truncation_order {
            continue;
        }

        // +1 at z^{3m}
        let z_exp_pos = 3 * m;
        let entry = terms.entry(z_exp_pos).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old = entry.coeff(q_exp);
        entry.set_coeff(q_exp, old + QRat::one());

        // -1 at z^{-3m-1}
        let z_exp_neg = -3 * m - 1;
        let entry2 = terms.entry(z_exp_neg).or_insert_with(||
            FormalPowerSeries::zero(inner_var, truncation_order)
        );
        let old2 = entry2.coeff(q_exp);
        entry2.set_coeff(q_exp, old2 - QRat::one());
    }

    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**3. Update the tripleprod dispatch** to detect symbolic z:

Replace the current "tripleprod" match arm. The NEW logic:
```rust
"tripleprod" => {
    if args.len() == 3 && matches!(&args[0], Value::Series(_) | Value::Symbol(_)) {
        // Maple: tripleprod(z, q, T)
        // Check if first arg is a Symbol with a DIFFERENT name from the q-variable
        let is_symbolic_outer = match (&args[0], &args[1]) {
            (Value::Symbol(z_name), Value::Symbol(q_name)) => z_name != q_name,
            _ => false,
        };

        if is_symbolic_outer {
            // Bivariate path: symbolic z
            let outer_name = match &args[0] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let sym = extract_symbol_id(name, args, 1, env)?;
            let order = extract_i64(name, args, 2)?;
            let result = compute_tripleprod_bivariate(&outer_name, sym, order);
            Ok(Value::BivariateSeries(result))
        } else {
            // Existing monomial path (z is q-monomial or Symbol("q") treated as q^1)
            let monomial = extract_monomial_from_arg(name, args, 0)?;
            let sym = extract_symbol_id(name, args, 1, env)?;
            let order = extract_i64(name, args, 2)?;
            let result = qseries::tripleprod(&monomial, sym, order);
            Ok(Value::Series(result))
        }
    } else {
        // Legacy: tripleprod(coeff_num, coeff_den, power, order) -- keep unchanged
        expect_args(name, args, 4)?;
        // ... existing legacy code unchanged ...
    }
}
```

**4. Update the quinprod dispatch** similarly:
Same `is_symbolic_outer` detection. If symbolic, call `compute_quinprod_bivariate`, else fall through to existing monomial path.

**5. Validation tests:**

Add these tests to the `#[cfg(test)]` module:

a. **`dispatch_tripleprod_bivariate_basic`:** Call `dispatch("tripleprod", &[Value::Symbol("z".into()), Value::Symbol("q".into()), Value::Integer(QInt::from(10i64))], &mut env)`. Assert result is `Value::BivariateSeries`. Check that the z^0 coefficient is 1 (the constant term from n=0).

b. **`dispatch_tripleprod_bivariate_preserves_univariate`:** Call `dispatch("tripleprod", &[Value::Symbol("q".into()), Value::Symbol("q".into()), Value::Integer(QInt::from(10i64))], &mut env)`. Assert result is `Value::Series` (NOT BivariateSeries), confirming that Symbol("q") with q-variable "q" still goes to the monomial path.

c. **`dispatch_quinprod_bivariate_basic`:** Call with `Value::Symbol("z")`, assert result is `Value::BivariateSeries`.

d. **`dispatch_quinprod_bivariate_preserves_univariate`:** Call with `Value::Symbol("q")`, assert result is `Value::Series`.

e. **`tripleprod_bivariate_sign_convention_validation`:** This is the CRITICAL correctness test. Compute `tripleprod_bivariate("z", q, 20)`. Then for m in {1, 2, 3}, manually evaluate the bivariate result at z=q^m by summing over z-exponents: for each (z_exp, fps), shift fps by z_exp*m (multiply by q^{z_exp*m}), sum all shifted fps values. Compare this against `qseries::tripleprod(&QMonomial::q_power(m), sym_q, 20)`. The results should match exactly (same nonzero coefficients up to the common truncation order).

   Implementation approach for evaluation:
   ```rust
   // For the bivariate result, evaluate at z = q^m
   let bv = compute_tripleprod_bivariate("z", env.sym_q, 20);
   let mut eval_result = FormalPowerSeries::zero(env.sym_q, 20);
   for (&z_exp, fps) in &bv.terms {
       // z^{z_exp} evaluated at z=q^m gives q^{z_exp*m}
       let shifted = arithmetic::shift(fps, z_exp * m);
       // Truncate shifted to match truncation order
       let mut truncated = FormalPowerSeries::zero(env.sym_q, 20);
       for (&k, c) in shifted.iter() {
           if k >= 0 && k < 20 {
               truncated.set_coeff(k, c.clone());
           }
       }
       eval_result = arithmetic::add(&eval_result, &truncated);
   }
   // Compare against numeric tripleprod
   let numeric = qseries::tripleprod(&QMonomial::q_power(m), env.sym_q, 20);
   for k in 0..20 {
       assert_eq!(eval_result.coeff(k), numeric.coeff(k), "mismatch at q^{} for m={}", k, m);
   }
   ```
   Test for m = 1, 2, 3.

f. **`quinprod_bivariate_validation`:** Similar validation for quinprod -- evaluate bivariate at z=q^m and compare against numeric quinprod for m = 1, 2.

g. **`tripleprod_bivariate_symmetry`:** Verify that tripleprod bivariate has the expected symmetry: coefficient of z^n should be (-1)^n * q^{n(n-1)/2} (single monomial per z-exponent).

h. **`bivariate_tripleprod_arithmetic`:** Compute `t1 = tripleprod(z, q, 10)`, `t2 = tripleprod(z, q, 10)`, verify `t1 + t2` is `2 * t1` and `t1 - t1` is zero.

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli tripleprod_bivariate quinprod_bivariate -- --nocapture`
All bivariate dispatch and validation tests pass. Especially the sign convention validation test MUST pass.
Then run full test suite: `cargo test -p qsym-cli` to confirm no regressions.
  </verify>
  <done>
tripleprod(z, q, T) with symbolic z returns BivariateSeries via sum formula. quinprod(z, q, T) with symbolic z returns BivariateSeries. Existing monomial paths preserved. Sign convention validated by cross-checking bivariate-evaluated-at-q^m against numeric tripleprod/quinprod.
  </done>
</task>

<task type="auto">
  <name>Task 2: Help text updates for tripleprod and quinprod</name>
  <files>
    crates/qsym-cli/src/help.rs
  </files>
  <action>
Update the help entries for tripleprod and quinprod to mention symbolic z support:

1. **tripleprod help**: Update description to add a line mentioning: "When z is a symbolic variable (different from q), returns a bivariate Laurent polynomial in z with q-series coefficients." Add an example: `tripleprod(z, q, 10)`.

2. **quinprod help**: Same pattern -- add mention of symbolic z producing bivariate output, with example.

3. Do NOT change the count assertion (`FUNC_HELP.len() == 95`) -- no new functions are being added, just updated descriptions.

4. **Tests:**
   - Verify existing help tests still pass.
   - Add test: verify `help_for("tripleprod")` description contains "symbolic" or "bivariate".
   - Add test: verify `help_for("quinprod")` description contains "symbolic" or "bivariate".

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- help --nocapture`
Help count unchanged at 95. tripleprod and quinprod help text mentions symbolic z. All tests pass.
  </verify>
  <done>
Help entries for tripleprod and quinprod updated to document symbolic z support. No new functions added. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli tripleprod` -- bivariate and univariate tripleprod tests pass
2. `cargo test -p qsym-cli quinprod` -- bivariate and univariate quinprod tests pass
3. `cargo test -p qsym-cli -- help` -- help count unchanged, symbolic z mentioned
4. `cargo test -p qsym-cli` -- full CLI test suite passes (no regressions)
5. The critical sign-convention validation tests pass (bivariate evaluated at z=q^m matches numeric)
</verification>

<success_criteria>
- tripleprod(z, q, 10) with symbolic z returns BivariateSeries with correct coefficients
- quinprod(z, q, 10) with symbolic z returns BivariateSeries with correct coefficients
- tripleprod(q, q, 10) still returns univariate FPS (no regression)
- Cross-validation: bivariate result evaluated at z=q^m matches numeric tripleprod/quinprod
- Help text mentions symbolic z support for tripleprod and quinprod
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/45-bivariate-series/45-02-SUMMARY.md`
</output>
