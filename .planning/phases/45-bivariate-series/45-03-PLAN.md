---
phase: 45-bivariate-series
plan: 03
type: execute
wave: 3
depends_on: ["45-01", "45-02"]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [BIVAR-03]

must_haves:
  truths:
    - "winquist(z, q^2, q, 10) with symbolic z produces a BivariateSeries in z"
    - "winquist(q, z, q, 10) with symbolic z (b position) produces a BivariateSeries in z"
    - "winquist(a, b, q, 10) with two symbolic variables returns clear error message"
    - "winquist(q, q^2, q, 10) still produces a univariate FPS (existing behavior preserved)"
    - "Bivariate winquist evaluated at z=q matches numeric winquist(q, q^2, q, T)"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "compute_winquist_one_symbolic, compute_tripleprod_bivariate_shifted, updated winquist dispatch"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated winquist help text mentioning symbolic variable support"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch winquist"
      to: "compute_winquist_one_symbolic"
      via: "Symbol detection in first or second arg"
      pattern: "is_symbolic.*winquist"
    - from: "compute_winquist_one_symbolic"
      to: "compute_tripleprod_bivariate_shifted"
      via: "Decomposition: winquist = TP(a) * TP(ab) * TP(a/b) * TP(b) / (q;q)^2"
      pattern: "tripleprod_bivariate_shifted"
---

<objective>
Implement bivariate dispatch for winquist -- when ONE argument is symbolic and the other is a concrete q-monomial, compute via tripleprod decomposition and return a BivariateSeries. When BOTH are symbolic, return a clear error.

Purpose: Enables users to explore Winquist's identity with one symbolic parameter, matching the primary use case from Garvan's tutorial.
Output: Working winquist(z, q^2, q, T) and winquist(q, z, q, T) with one symbolic arg, error for two symbolic args, updated help.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-bivariate-series/45-RESEARCH.md
@.planning/phases/45-bivariate-series/45-01-SUMMARY.md
@.planning/phases/45-bivariate-series/45-02-SUMMARY.md
@crates/qsym-core/src/series/bivariate.rs
@crates/qsym-core/src/qseries/products.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Winquist bivariate dispatch via tripleprod decomposition</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
Implement Winquist bivariate for the case where ONE of a, b is symbolic and the other is a concrete q-monomial.

**Mathematical basis:** Winquist factors as:
```
winquist(a,b,q,T) = tripleprod(a,q,T) * tripleprod(b,q,T) * tripleprod(a*b,q,T) * tripleprod(a/b,q,T) / euler(q,T)^2
```

Because tripleprod(z) = (z;q)(q/z;q)(q;q), we have:
- (a;q)(q/a;q) = TP(a) / (q;q)
- (b;q)(q/b;q) = TP(b) / (q;q)
- (ab;q)(q/(ab);q) = TP(ab) / (q;q)
- (a/b;q)(qb/a;q) = TP(a/b) / (q;q)
- winquist = (q;q)^2 * [TP(a)/(q;q)] * [TP(b)/(q;q)] * [TP(ab)/(q;q)] * [TP(a/b)/(q;q)]
           = TP(a) * TP(b) * TP(ab) * TP(a/b) / (q;q)^2

When `a` is symbolic and `b = b_c * q^{b_p}` is a concrete monomial:
- TP(a) = compute_tripleprod_bivariate(a, q, T) -- BivariateSeries in a
- TP(ab) = compute_tripleprod_bivariate_shifted(a, b_c, b_p, q, T) -- BivariateSeries in a
- TP(a/b) = compute_tripleprod_bivariate_shifted(a, 1/b_c, -b_p, q, T) -- BivariateSeries in a
- TP(b) = qseries::tripleprod(b_mono, q, T) -- concrete FPS
- euler^2 = concrete FPS
- Result = bv_mul(bv_mul(tp_a, tp_ab), tp_a_over_b) * (tp_b / euler^2) -- all bivariate ops have same outer var

**1. Add `compute_tripleprod_bivariate_shifted` function:**

This computes `sum_n (-1)^n * shift_coeff^n * z^n * q^{n*(n-1)/2 + shift_power*n}` -- a generalized triple product sum form where the z variable is "shifted" by a concrete monomial factor.

```rust
fn compute_tripleprod_bivariate_shifted(
    outer_var: &str,
    shift_coeff: &QRat,  // scalar coefficient per z-exponent (b_c^n)
    shift_power: i64,     // additional q-shift per z-exponent (b_p * n)
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    let mut terms: BTreeMap<i64, FormalPowerSeries> = BTreeMap::new();

    // q_exp for term n = n*(n-1)/2 + shift_power*n
    // Use generous bound and filter
    let base_bound = ((1.0 + (1.0 + 8.0 * truncation_order as f64).sqrt()) / 2.0).ceil() as i64;
    let extra = shift_power.unsigned_abs() as i64;
    let bound = base_bound + extra + 2;

    let inv_shift = if !shift_coeff.is_zero() {
        QRat::one() / shift_coeff.clone()
    } else {
        QRat::zero()
    };

    // Positive n (n = 0, 1, 2, ...)
    let mut coeff_pow = QRat::one(); // shift_coeff^0
    for n in 0..=bound {
        let q_exp = n * (n - 1) / 2 + shift_power * n;
        if q_exp >= truncation_order {
            // For positive shift_power, q_exp grows monotonically so we can break
            if shift_power >= 0 { break; }
            // For negative shift_power, q_exp may dip then rise, so continue
        }
        if q_exp >= 0 && q_exp < truncation_order {
            let sign_coeff = if n % 2 == 0 { coeff_pow.clone() } else { -coeff_pow.clone() };
            let entry = terms.entry(n).or_insert_with(||
                FormalPowerSeries::zero(inner_var, truncation_order)
            );
            let old = entry.coeff(q_exp);
            entry.set_coeff(q_exp, old + sign_coeff);
        }
        coeff_pow = coeff_pow * shift_coeff.clone();
    }

    // Negative n (n = -1, -2, -3, ...)
    let mut neg_pow = inv_shift.clone(); // shift_coeff^{-1}
    for n_abs in 1..=bound {
        let n = -(n_abs as i64);
        let q_exp = n * (n - 1) / 2 + shift_power * n;
        if q_exp >= truncation_order {
            if shift_power <= 0 { break; }
        }
        if q_exp >= 0 && q_exp < truncation_order {
            let sign_coeff = if n % 2 == 0 { neg_pow.clone() } else { -neg_pow.clone() };
            let entry = terms.entry(n).or_insert_with(||
                FormalPowerSeries::zero(inner_var, truncation_order)
            );
            let old = entry.coeff(q_exp);
            entry.set_coeff(q_exp, old + sign_coeff);
        }
        neg_pow = neg_pow * inv_shift.clone();
    }

    terms.retain(|_, fps| !fps.is_zero());

    BivariateSeries {
        outer_variable: outer_var.to_string(),
        terms,
        inner_variable: inner_var,
        truncation_order,
    }
}
```

**2. Add `compute_winquist_one_symbolic` function:**

```rust
/// Compute winquist(a, b, q, T) where `a` is the symbolic outer variable and `b` is a concrete monomial.
/// Uses decomposition: W = TP(a) * TP(ab) * TP(a/b) * TP(b) / (q;q)^2
fn compute_winquist_one_symbolic(
    outer_var: &str,
    b_mono: &QMonomial,
    inner_var: SymbolId,
    truncation_order: i64,
) -> BivariateSeries {
    // 1. TP(a) -- plain bivariate tripleprod
    let tp_a = compute_tripleprod_bivariate(outer_var, inner_var, truncation_order);

    // 2. TP(a*b) -- shifted: coeff = b_c^n, power shift = b_p*n
    let tp_ab = compute_tripleprod_bivariate_shifted(
        outer_var, &b_mono.coeff, b_mono.power, inner_var, truncation_order
    );

    // 3. TP(a/b) -- shifted: coeff = (1/b_c)^n, power shift = (-b_p)*n
    let inv_b_coeff = QRat::one() / b_mono.coeff.clone();
    let tp_a_over_b = compute_tripleprod_bivariate_shifted(
        outer_var, &inv_b_coeff, -b_mono.power, inner_var, truncation_order
    );

    // 4. TP(b) -- concrete univariate FPS
    let tp_b = qseries::tripleprod(b_mono, inner_var, truncation_order);

    // 5. euler^2 = (q;q)^2 -- concrete FPS
    let euler = qseries::euler(inner_var, truncation_order);
    let euler_sq = arithmetic::mul(&euler, &euler);

    // 6. scalar_fps = TP(b) / (q;q)^2
    // Note: We need to invert euler_sq. Use the FPS inversion: 1/euler_sq.
    // Since euler starts with 1 + ..., euler_sq also starts with 1, so it's invertible.
    let euler_sq_inv = arithmetic::invert(&euler_sq);
    let scalar_fps = arithmetic::mul(&tp_b, &euler_sq_inv);

    // 7. Multiply bivariate parts: TP(a) * TP(ab) * TP(a/b)
    let bv_product = bv::bivariate_mul(
        &bv::bivariate_mul(&tp_a, &tp_ab),
        &tp_a_over_b
    );

    // 8. Multiply by scalar FPS
    bv::bivariate_fps_mul(&scalar_fps, &bv_product)
}
```

**Note on `arithmetic::invert`:** If this function doesn't exist, implement FPS inversion as follows: given FPS f with f(0) = 1, compute g such that f*g = 1 + O(q^T). This is a standard O(T^2) algorithm: g[0] = 1, g[n] = -sum_{k=1}^{n} f[k]*g[n-k]. Check if `arithmetic::invert` or a similar function exists in `crates/qsym-core/src/series/arithmetic.rs`. If not, implement it there first.

**Alternative if invert doesn't exist:** Compute euler_sq_inv directly: (q;q)^{-2} as a power series. Use `qseries::euler` to get (q;q), then compute its inverse by the coefficient recurrence. Or compute `1/((q;q)^2)` by noting that `(q;q)^{-1} = sum_n p(n) q^n` where p(n) is the partition function. So `(q;q)^{-2} = (sum p(n) q^n)^2` = convolution. But it's simpler to just implement generic FPS inversion.

**3. Update the winquist dispatch:**

In the "winquist" match arm, add symbol detection BEFORE the existing monomial extraction:

```rust
"winquist" => {
    if args.len() == 4 && matches!(&args[2], Value::Symbol(_)) {
        // Check which args are symbolic
        let a_is_symbolic = match (&args[0], &args[2]) {
            (Value::Symbol(a_name), Value::Symbol(q_name)) => a_name != q_name,
            _ => false,
        };
        let b_is_symbolic = match (&args[1], &args[2]) {
            (Value::Symbol(b_name), Value::Symbol(q_name)) => b_name != q_name,
            _ => false,
        };

        if a_is_symbolic && b_is_symbolic {
            return Err(EvalError::Other(
                "winquist with two symbolic variables is not yet supported; \
                 use a q-monomial for one argument, e.g. winquist(a, q^2, q, 10)".into()
            ));
        } else if a_is_symbolic {
            // a is symbolic, b is concrete
            let outer_name = match &args[0] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let b_mono = extract_monomial_from_arg(name, args, 1)?;
            let sym = extract_symbol_id(name, args, 2, env)?;
            let order = extract_i64(name, args, 3)?;
            let result = compute_winquist_one_symbolic(&outer_name, &b_mono, sym, order);
            Ok(Value::BivariateSeries(result))
        } else if b_is_symbolic {
            // b is symbolic, a is concrete -- swap roles
            // winquist is symmetric in a, b up to sign conventions
            // Compute with b as outer var, a as concrete monomial
            let outer_name = match &args[1] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
            let a_mono = extract_monomial_from_arg(name, args, 0)?;
            let sym = extract_symbol_id(name, args, 2, env)?;
            let order = extract_i64(name, args, 3)?;
            let result = compute_winquist_one_symbolic(&outer_name, &a_mono, sym, order);
            Ok(Value::BivariateSeries(result))
        } else {
            // Both are concrete monomials -- existing path
            let a = extract_monomial_from_arg(name, args, 0)?;
            let b = extract_monomial_from_arg(name, args, 1)?;
            let sym = extract_symbol_id(name, args, 2, env)?;
            let order = extract_i64(name, args, 3)?;
            let result = qseries::winquist(&a, &b, sym, order);
            Ok(Value::Series(result))
        }
    } else {
        // Legacy path or wrong arg count -- keep existing behavior
        // ... unchanged ...
    }
}
```

**Important note on symmetry:** When b is symbolic and a is concrete, we can reuse `compute_winquist_one_symbolic` with the roles swapped because the Winquist product is symmetric in the sense that the factoring W = TP(a)*TP(b)*TP(ab)*TP(a/b)/(q;q)^2 is the same as W = TP(b)*TP(a)*TP(ba)*TP(b/a)/(q;q)^2 (since TP(a/b) and TP(b/a) differ only by sign patterns that cancel in the product). Verify this in the tests.

**4. Unit tests:**

a. **`dispatch_winquist_one_symbolic_a`:** Call winquist(z, q^2, q, 10) where z is Symbol("z"), q^2 is a series. Assert result is `Value::BivariateSeries`. Check it has nonzero terms.

b. **`dispatch_winquist_one_symbolic_b`:** Call winquist(q, z, q, 10) where z is Symbol("z") in position 1. Assert result is `Value::BivariateSeries`.

c. **`winquist_bivariate_validation`:** CRITICAL correctness test. Compute winquist(z, q^2, q, 15) as bivariate. Evaluate at z=q by shifting each (z_exp, fps) by z_exp*1 and summing. Compare against numeric winquist(q, q^2, q, 15). Results must match for all coefficients up to q^14.

d. **`winquist_two_symbolic_error`:** Call winquist(a, b, q, 10) with both Symbol("a") and Symbol("b"). Assert returns EvalError with message containing "two symbolic variables".

e. **`winquist_preserves_univariate`:** Call winquist(q, q^2, q, 10) where both args are q-monomials. Assert result is `Value::Series` (existing behavior).

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- winquist --nocapture`
All winquist tests pass. The validation test (bivariate evaluated at z=q matches numeric) is the key correctness check.
Then: `cargo test -p qsym-cli` -- full suite passes.
  </verify>
  <done>
winquist(z, q^2, q, T) with one symbolic arg returns BivariateSeries. Two-symbolic-arg case returns clear error. Validation against numeric winquist confirms correctness. Existing univariate path preserved. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Winquist help text update</name>
  <files>
    crates/qsym-cli/src/help.rs
  </files>
  <action>
Update the winquist help entry to mention symbolic variable support:

1. Find the existing FuncHelp entry for "winquist" in FUNC_HELP.
2. Update description to add: "When one of a, b is a symbolic variable (different from q), returns a bivariate Laurent polynomial. Two symbolic variables not yet supported."
3. Add an example showing symbolic usage: `winquist(z, q^2, q, 10)`.
4. Do NOT change FUNC_HELP count (still 95).

**Test:** Verify `help_for("winquist")` description contains "symbolic" or "bivariate".

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli -- help --nocapture`
Help count unchanged at 95. winquist help mentions symbolic variable support. All tests pass.
  </verify>
  <done>
Winquist help entry updated to document one-symbolic-variable support and two-symbolic-variable limitation. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli -- winquist` -- all winquist tests pass (bivariate and univariate)
2. `cargo test -p qsym-cli -- help` -- help count unchanged, winquist mentions symbolic
3. `cargo test -p qsym-cli` -- full CLI test suite passes (no regressions)
4. The critical validation test (winquist bivariate at z=q matches numeric) MUST pass
</verification>

<success_criteria>
- winquist(z, q^2, q, 10) with one symbolic arg returns BivariateSeries
- winquist(q, z, q, 10) with symbolic in b position returns BivariateSeries
- winquist(a, b, q, 10) with two symbolic args returns clear error message
- winquist(q, q^2, q, 10) still returns univariate FPS (no regression)
- Cross-validation: bivariate evaluated at z=q matches numeric winquist
- Help text mentions symbolic variable support
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/45-bivariate-series/45-03-SUMMARY.md`
</output>
