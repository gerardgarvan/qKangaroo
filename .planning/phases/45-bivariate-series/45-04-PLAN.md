---
phase: 45-bivariate-series
plan: 04
type: execute
wave: 1
depends_on: ["45-03"]
files_modified:
  - crates/qsym-core/src/series/trivariate.rs
  - crates/qsym-core/src/series/mod.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [BIVAR-03]
gap_closure: true

must_haves:
  truths:
    - "winquist(a, b, q, 10) with BOTH a and b symbolic returns a trivariate result displaying terms like c(q)*a^r*b^s"
    - "Trivariate result evaluated at a=1, b=1 matches numeric winquist(1, 1, q, T) = (q;q)^2 * prod 8 factors at a=b=1"
    - "Trivariate result evaluated at a=c1*q^m1, b=c2*q^m2 matches numeric winquist(c1*q^m1, c2*q^m2, q, T)"
    - "Existing one-symbolic and zero-symbolic winquist paths still work unchanged"
  artifacts:
    - path: "crates/qsym-core/src/series/trivariate.rs"
      provides: "TrivariateSeries struct with BTreeMap<(i64,i64), FPS>, negate function"
      min_lines: 50
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::TrivariateSeries variant, compute_winquist_two_symbolic, dispatch update"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_trivariate and format_trivariate_latex functions"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated winquist help removing two-symbolic limitation note"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs dispatch winquist"
      to: "compute_winquist_two_symbolic"
      via: "a_is_symbolic && b_is_symbolic branch calls compute_winquist_two_symbolic"
      pattern: "compute_winquist_two_symbolic"
    - from: "crates/qsym-cli/src/format.rs format_value"
      to: "format_trivariate"
      via: "Value::TrivariateSeries(ts) => format_trivariate(ts, symbols)"
      pattern: "format_trivariate"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-core/src/series/trivariate.rs"
      via: "use qsym_core::series::trivariate::TrivariateSeries"
      pattern: "trivariate::TrivariateSeries"
---

<objective>
Close gap BIVAR-03: implement winquist(a, b, q, T) with BOTH a and b symbolic, returning a trivariate series (Laurent polynomial in a, b with q-series coefficients).

Purpose: Completes BIVAR-03 requirement and Success Criterion #3 for Phase 45. Users can fully explore Winquist's identity with both parameters as free variables.
Output: Working `winquist(a, b, q, 10)` producing a `TrivariateSeries` displayed as terms `c(q)*a^r*b^s`, cross-validated against numeric winquist.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-bivariate-series/45-VERIFICATION.md
@.planning/phases/45-bivariate-series/45-03-SUMMARY.md
@crates/qsym-core/src/series/bivariate.rs
@crates/qsym-core/src/series/mod.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TrivariateSeries struct in qsym-core and Value variant + format + negate in qsym-cli</name>
  <files>
    crates/qsym-core/src/series/trivariate.rs
    crates/qsym-core/src/series/mod.rs
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/format.rs
  </files>
  <action>
**1. Create `crates/qsym-core/src/series/trivariate.rs`:**

Define a struct for trivariate formal power series -- Laurent polynomial in two outer variables (a, b) with FPS coefficients in the inner variable (q):

```rust
//! Trivariate formal power series: Laurent polynomial in two outer variables
//! (a, b) with FormalPowerSeries coefficients in the inner (q) variable.
//!
//! Represents f(a, b, q) = sum_{r,s} c_{r,s}(q) * a^r * b^s + O(q^N)

use std::collections::BTreeMap;
use crate::number::QRat;
use crate::symbol::SymbolId;
use super::FormalPowerSeries;
use super::arithmetic;

#[derive(Clone, Debug)]
pub struct TrivariateSeries {
    /// Name of the first outer variable (e.g., "a").
    pub outer_var_a: String,
    /// Name of the second outer variable (e.g., "b").
    pub outer_var_b: String,
    /// Terms: (a_exponent, b_exponent) -> FPS coefficient in q.
    pub terms: BTreeMap<(i64, i64), FormalPowerSeries>,
    /// Symbol for the inner variable (e.g., q).
    pub inner_variable: SymbolId,
    /// Truncation order for the inner variable.
    pub truncation_order: i64,
}
```

Add methods:
- `zero(outer_var_a, outer_var_b, inner_variable, truncation_order) -> Self`
- `is_zero(&self) -> bool`
- `truncation_order(&self) -> i64`

Add one free function:
- `trivariate_negate(a: &TrivariateSeries) -> TrivariateSeries` -- negate every FPS coefficient

Implement `PartialEq` and `Eq` (same pattern as BivariateSeries).

Add unit tests in a `#[cfg(test)] mod tests`:
- `zero_creation_and_is_zero`: Create zero trivariate, assert `is_zero()`.
- `negate_trivariate`: Create a single-term trivariate at (1, 2), negate, verify coefficient sign.
- `equality`: Create two identical trivariate series, assert `==`.

**2. Update `crates/qsym-core/src/series/mod.rs`:**

Add `pub mod trivariate;` after the existing `pub mod bivariate;` line.

**3. Add `Value::TrivariateSeries` variant in `crates/qsym-cli/src/eval.rs`:**

In the `Value` enum (around line 91), add:
```rust
/// Trivariate series: Laurent polynomial in two outer variables with FPS coefficients.
TrivariateSeries(TrivariateSeries),
```

In `type_name()` (around line 96), add:
```rust
Value::TrivariateSeries(_) => "trivariate_series",
```

Add the import at the top of eval.rs alongside the bivariate import:
```rust
use qsym_core::series::trivariate::{self as tv, TrivariateSeries};
```

Add negate dispatch in `eval_negate` (right after the BivariateSeries arm around line 1534):
```rust
Value::TrivariateSeries(ts) => Ok(Value::TrivariateSeries(tv::trivariate_negate(&ts))),
```

NOTE: Do NOT add trivariate arms for add/sub/mul at this point. The only operation users need on the raw trivariate winquist result is display and negate. If needed later, add/sub/mul can be added in a separate plan. Trying `t + t` where t is trivariate should return a TypeError for now.

**4. Add `format_trivariate` and `format_trivariate_latex` in `crates/qsym-cli/src/format.rs`:**

Add a match arm in `format_value`:
```rust
Value::TrivariateSeries(ts) => format_trivariate(ts, symbols),
```

Add a match arm in `format_latex`:
```rust
Value::TrivariateSeries(ts) => format_trivariate_latex(ts, symbols),
```

Implement `format_trivariate(ts: &TrivariateSeries, symbols: &SymbolRegistry) -> String`:

Strategy: Sort terms by descending (a_exp, b_exp) (lexicographic, descending on both). For each term `(a_exp, b_exp, fps)`:
- Compute the variable part string: combine `a^r` and `b^s` parts using `format_z_power` (reuse the existing function, or write a small helper `format_var_power(var, exp)`).
  - If a_exp == 0 and b_exp == 0: just show the FPS string (constant in a, b).
  - Otherwise: show `coeff*a^r*b^s` with parenthesization for multi-term FPS coefficients.
- Use the same sign-handling logic as `format_bivariate`: first term has no leading `+`, subsequent terms get ` + ` or ` - `.
- Strip the truncation `O(q^T)` from each FPS coefficient string (use existing `strip_truncation`).
- Append `+ O(q^T)` at the end.

The display should look like:
```
(q + q^2)*a^2*b + q*a*b^(-1) - a^(-1)*b^(-1)*q^3 + ... + O(q^10)
```

Variable power formatting helper (reuse `format_z_power` by calling it twice):
- `a^r*b^s` where either can be 0 (omit that variable), 1 (just variable name), or general (var^exp).
- Combined: if both nonzero, join with `*`. If one is zero, just show the other.

Implement `format_trivariate_latex(ts: &TrivariateSeries, symbols: &SymbolRegistry) -> String` following the same pattern but using LaTeX syntax (reuse `format_z_power_latex` and `fps_to_latex_inner`).

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-core trivariate -- --nocapture
cargo test -p qsym-cli -- --nocapture 2>&1 | tail -5
```
All qsym-core trivariate tests pass. Full qsym-cli suite compiles and passes (the new Value variant is handled in all match arms).
  </verify>
  <done>
TrivariateSeries struct exists in qsym-core with BTreeMap<(i64,i64), FPS>, negate, and tests. Value::TrivariateSeries variant compiles with type_name, format_value, format_latex, and negate dispatch. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: compute_winquist_two_symbolic and dispatch + cross-validation tests + help update</name>
  <files>
    crates/qsym-cli/src/eval.rs
    crates/qsym-cli/src/help.rs
  </files>
  <action>
**1. Implement `compute_winquist_two_symbolic` in `crates/qsym-cli/src/eval.rs`:**

This function computes `winquist(a, b, q, T)` where both a and b are symbolic, returning a `TrivariateSeries`. It uses the same direct Pochhammer factor approach as `compute_winquist_one_symbolic` (proven to work in Plan 45-03), but now each factor shifts BOTH a and b exponents.

```rust
/// Compute winquist(a, b, q, T) where BOTH `a` and `b` are symbolic outer variables.
///
/// Uses the 10-factor product decomposition (Garvan convention):
///   W(a,b,q) = (q;q)^2 * (a)(q/a)(b)(q/b)(ab)(q^2/(ab))(a/b)(qb/a)
/// where (x) denotes (x;q)_inf.
///
/// Returns a TrivariateSeries: BTreeMap<(a_exp, b_exp), FPS in q>.
fn compute_winquist_two_symbolic(
    outer_var_a: &str,
    outer_var_b: &str,
    inner_var: SymbolId,
    truncation_order: i64,
) -> TrivariateSeries {
```

The 10 Pochhammer factors and their (a_power, b_power, q_offset) signatures:
```
Factor 1: (a; q)         -> (1, 0, 0)   -- involves a only
Factor 2: (q/a; q)       -> (-1, 0, 1)  -- involves a only
Factor 3: (b; q)         -> (0, 1, 0)   -- involves b only
Factor 4: (q/b; q)       -> (0, -1, 1)  -- involves b only
Factor 5: (ab; q)        -> (1, 1, 0)   -- involves both
Factor 6: (q^2/(ab); q)  -> (-1, -1, 2) -- involves both
Factor 7: (a/b; q)       -> (1, -1, 0)  -- involves both
Factor 8: (qb/a; q)      -> (-1, 1, 1)  -- involves both
Factor 9: (q; q) factor 1 -> (0, 0, 1)  -- pure q
Factor 10: (q; q) factor 2 -> (0, 0, 1) -- pure q (second copy of euler)
```

All 10 factors are now "trivariate" because the data structure is `BTreeMap<(i64,i64), FPS>`. Even the "pure q" factors are representable (they sit at key (0, 0)).

**Algorithm (factor-by-factor product, same pattern as compute_winquist_one_symbolic):**

All 10 factors use the same structure: `prod_{k>=0}(1 - coeff * a^{ap} * b^{bp} * q^{off+k})`.

For the 8 factors involving a and/or b (factors 1-8):
- Use the same combined factor loop as one-symbolic, but with 2D exponent shifts.
- At each step k for factor f with spec `(coeff, ap, bp, off)`:
  - The factor `(1 - coeff * a^{ap} * b^{bp} * q^{off+k})` multiplies the current trivariate.
  - For each existing term `((ra, rb), fps_j)` in the running product:
    - Identity part: keep `((ra, rb), fps_j)`.
    - Product part: add `((ra + ap, rb + bp), -coeff * q^{off+k} * fps_j)` using the same `fps_shift_internal` helper.

For the 2 copies of `(q;q)_inf` (factors 9, 10):
- These have `ap = 0, bp = 0` so they do NOT shift the (a, b) exponents. They only shift q-exponents.
- They are processed identically via the same loop (the (0, 0) shift is a no-op on outer exponents).
- Equivalently, the two `(q;q)` factors can be multiplied at the end as a single concrete FPS `(q;q)^2`, just like in `compute_winquist_one_symbolic`. This is more efficient because it avoids expanding the trivariate terms for each euler factor step. **Use this approach: process the 8 a/b-involving factors in the loop, then multiply all trivariate FPS coefficients by `(q;q)^2` at the end.**

**Implementation details:**

- Use the same global q-shift technique as `compute_winquist_one_symbolic` to handle negative q-offsets. The minimum q_offset across the 8 bivariate factors is `min(0, 1, 0, 1, 0, 2, 0, 1) = 0`. Wait -- factor 7 has `(a/b;q) = (1, -1, 0)`. There are no negative offsets among the 8 factors. The offsets are `0, 1, 0, 1, 0, 2, 0, 1` -- all non-negative. So q_shift = 0 and no internal shift is needed. Proceed without the q_shift complexity.

- Use `add_to_tv_terms` helper (analogous to `add_to_bv_terms`) that accumulates FPS at `(ra, rb)` keys in a `BTreeMap<(i64, i64), FormalPowerSeries>`.

```rust
fn add_to_tv_terms(
    terms: &mut BTreeMap<(i64, i64), FormalPowerSeries>,
    key: (i64, i64),
    fps: &FormalPowerSeries,
) {
    if let Some(existing) = terms.remove(&key) {
        let sum = arithmetic::add(&existing, fps);
        if !sum.is_zero() { terms.insert(key, sum); }
    } else {
        terms.insert(key, fps.clone());
    }
}
```

- The 8 factor specs (coeff_is_1, a_power, b_power, q_offset):

```rust
let tv_specs: [(QRat, i64, i64, i64); 8] = [
    (QRat::one(),  1,  0, 0),   // (a;q)
    (QRat::one(), -1,  0, 1),   // (q/a;q)
    (QRat::one(),  0,  1, 0),   // (b;q)
    (QRat::one(),  0, -1, 1),   // (q/b;q)
    (QRat::one(),  1,  1, 0),   // (ab;q)
    (QRat::one(), -1, -1, 2),   // (q^2/(ab);q)
    (QRat::one(),  1, -1, 0),   // (a/b;q)
    (QRat::one(), -1,  1, 1),   // (qb/a;q)
];
```

All coefficients are 1 (since a and b have coefficient 1 as bare symbols). This simplifies the product: the `-coeff` term is always `-1`.

- Factor loop:
```rust
let mut terms: BTreeMap<(i64, i64), FormalPowerSeries> = BTreeMap::new();
{
    let one_fps = FormalPowerSeries::one(inner_var, truncation_order);
    terms.insert((0, 0), one_fps);
}

for &(ref _coeff, ap, bp, q_offset) in &tv_specs {
    for k in 0.. {
        let true_exp = q_offset + k;
        if true_exp >= truncation_order { break; }

        let mut new_terms: BTreeMap<(i64, i64), FormalPowerSeries> = BTreeMap::new();
        for (&(ra, rb), f_j) in &terms {
            // Identity part
            add_to_tv_terms(&mut new_terms, (ra, rb), f_j);
            // Product part: -(1) * a^{ap} * b^{bp} * q^{true_exp} * f_j
            let shifted_key = (ra + ap, rb + bp);
            let neg_one = -QRat::one();
            let contrib = fps_shift_internal(f_j, true_exp, &neg_one, inner_var, truncation_order);
            if !contrib.is_zero() {
                add_to_tv_terms(&mut new_terms, shifted_key, &contrib);
            }
        }
        terms = new_terms;
    }
}
```

- After the 8-factor loop, multiply every FPS coefficient by `(q;q)^2`:
```rust
let euler = qseries::euler(inner_var, truncation_order);  // or euler_function_generator
let euler_sq = arithmetic::mul(&euler, &euler);

let mut final_terms: BTreeMap<(i64, i64), FormalPowerSeries> = BTreeMap::new();
for ((ra, rb), fps) in terms {
    let product = arithmetic::mul(&euler_sq, &fps);
    if !product.is_zero() {
        final_terms.insert((ra, rb), product);
    }
}
```

- Return:
```rust
TrivariateSeries {
    outer_var_a: outer_var_a.to_string(),
    outer_var_b: outer_var_b.to_string(),
    terms: final_terms,
    inner_variable: inner_var,
    truncation_order,
}
```

**Performance note:** The Winquist product has 8 symbolic factors. With T=10, the factor loop has ~80 iterations (8 factors x ~10 q-terms each). At each step the term count can grow. For T=10, the (a, b) exponent range is roughly [-10, 10] x [-10, 10] = ~400 possible keys. With FPS operations on each, this is ~32000 FPS additions. Each FPS has ~10 terms. Total: ~320K rational operations. This should complete in well under 1 second.

For T=20, the ranges double but the computation is still feasible (~160 factors x ~1600 keys = ~256K steps). For T>30, warn that it may be slow. No explicit limit needed -- just note in help text.

**2. Update winquist dispatch (lines 2906-2910 in eval.rs):**

Replace the error branch:
```rust
if a_is_symbolic && b_is_symbolic {
    return Err(EvalError::Other(
        "winquist with two symbolic variables is not yet supported; ..."
    ));
}
```

With:
```rust
if a_is_symbolic && b_is_symbolic {
    let a_name = match &args[0] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
    let b_name = match &args[1] { Value::Symbol(s) => s.clone(), _ => unreachable!() };
    let sym = extract_symbol_id(name, args, 2, env)?;
    let order = extract_i64(name, args, 3)?;
    let result = compute_winquist_two_symbolic(&a_name, &b_name, sym, order);
    Ok(Value::TrivariateSeries(result))
}
```

**3. Unit tests (add to the existing `#[cfg(test)]` module in eval.rs):**

a. **`dispatch_winquist_two_symbolic`:** Call `winquist(a, b, q, 5)` where both a and b are `Value::Symbol`. Assert result is `Value::TrivariateSeries`. Assert it has nonzero terms. Assert the (0, 0) term exists (constant in a, b) and has nonzero q-coefficients.

b. **`winquist_two_symbolic_eval_at_1_1`:** CRITICAL correctness test. Compute `winquist(a, b, q, 10)` as trivariate. "Evaluate" at a=1, b=1 by summing all FPS values (since 1^r * 1^s = 1 for any r, s). Compare against numeric `winquist(1, 1, q, 10)` which equals `(q;q)^2 * (1;q)^2 * (q;q)^2 * (1;q)^2` -- but note: (1; q)_inf = prod(1 - q^k) = (q;q)_inf. So winquist(1, 1, q) = (q;q)^10. Compute the reference: euler(q, T)^10 via repeated multiplication. Verify coefficients match up to q^9.

Actually, be careful. `winquist(a, b, q) = (q;q)^2 * (a;q)(q/a;q)(b;q)(q/b;q)(ab;q)(q^2/(ab);q)(a/b;q)(qb/a;q)`. At a=1: `(1;q) = prod(1-q^k) = 0` since the k=0 term is `(1-1)=0`. So winquist(1, 1, q) = 0. This makes sense: the product has a zero factor.

Instead, use a=q^2, b=q^3 evaluation. Compute trivariate, then evaluate: for each `((ra, rb), fps)`, compute the shifted FPS `q^{2*ra + 3*rb} * fps` and sum all. Compare against numeric `winquist(q^2, q^3, q, T)`.

To evaluate at a = c_a * q^{p_a}, b = c_b * q^{p_b}: for each `((ra, rb), fps)`, the contribution is `c_a^{ra} * c_b^{rb} * fps * q^{p_a*ra + p_b*rb}`. With c_a = c_b = 1, p_a = 2, p_b = 3: contribution is `fps` shifted by `2*ra + 3*rb`.

The shift `2*ra + 3*rb` can be negative for negative ra, rb. Need to only keep terms where `q_exp + shift >= 0`.

```rust
#[test]
fn winquist_two_symbolic_cross_validation() {
    let mut env = make_env();
    // Compute trivariate
    let args = vec![
        Value::Symbol("a".to_string()),
        Value::Symbol("b".to_string()),
        Value::Symbol("q".to_string()),
        Value::Integer(QInt::from(10i64)),
    ];
    let result = dispatch_function("winquist", args, &mut env).unwrap();
    let ts = match &result {
        Value::TrivariateSeries(ts) => ts,
        _ => panic!("expected TrivariateSeries"),
    };

    // Evaluate at a = q^2, b = q^3 by shifting and summing
    let trunc = ts.truncation_order;
    let mut evaluated = FormalPowerSeries::zero(env.sym_q, trunc);
    for (&(ra, rb), fps) in &ts.terms {
        let shift = 2 * ra + 3 * rb;
        for (&p, v) in fps.iter() {
            let new_p = p + shift;
            if new_p >= 0 && new_p < trunc {
                let old = evaluated.coeff(new_p);
                evaluated.set_coeff(new_p, old + v.clone());
            }
        }
    }

    // Compute numeric reference
    let a_mono = QMonomial::new(QRat::one(), 2);
    let b_mono = QMonomial::new(QRat::one(), 3);
    let reference = qseries::winquist(&a_mono, &b_mono, env.sym_q, trunc);

    // Compare coefficients
    for k in 0..trunc {
        assert_eq!(
            evaluated.coeff(k), reference.coeff(k),
            "Mismatch at q^{}: trivariate eval = {}, numeric = {}",
            k, evaluated.coeff(k), reference.coeff(k)
        );
    }
}
```

c. **`winquist_two_symbolic_display_not_empty`:** Compute winquist(a, b, q, 5), format the result via `format_value`, assert the string contains "a" and "b" and "q" and is not just `O(q^5)`.

d. **`winquist_preserves_one_symbolic`:** Verify that `winquist(z, q^2, q, 5)` still returns `Value::BivariateSeries` (not TrivariateSeries). This confirms the one-symbolic path is unchanged.

e. **`winquist_preserves_numeric`:** Verify that `winquist(q, q^2, q, 5)` still returns `Value::Series`. Unchanged from existing test.

**4. Update winquist help entry in `crates/qsym-cli/src/help.rs`:**

Find the FuncHelp entry for "winquist" (around line 197). Update:
- `description`: Remove "Two symbolic variables are not yet supported." Replace with "When both a and b are symbolic variables (different from q), returns a trivariate series."
- Keep the existing example `winquist(z, q^2, q, 10)` and add another: `winquist(a, b, q, 10)`.
- Update the existing test `function_help_winquist_mentions_bivariate` to also check for "trivariate" or "both".

Build environment: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"` before cargo commands.
  </action>
  <verify>
Run:
```
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cd /c/cygwin64/home/Owner/Kangaroo
cargo test -p qsym-core trivariate -- --nocapture
cargo test -p qsym-cli -- winquist --nocapture
cargo test -p qsym-cli -- help --nocapture
cargo test -p qsym-cli
```
All trivariate tests pass. Cross-validation test passes (trivariate evaluated at a=q^2, b=q^3 matches numeric winquist). Help test passes. Full CLI test suite passes with no regressions.
  </verify>
  <done>
winquist(a, b, q, T) with both a and b symbolic returns a TrivariateSeries. Cross-validation against numeric winquist confirms correctness. Display shows terms like `c(q)*a^r*b^s`. Help text updated. One-symbolic and numeric paths unchanged. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-core trivariate` -- TrivariateSeries struct tests pass (zero, negate, equality)
2. `cargo test -p qsym-cli -- winquist` -- all winquist tests pass, including new two-symbolic dispatch and cross-validation
3. `cargo test -p qsym-cli -- help` -- help count unchanged, winquist help mentions trivariate/both symbolic
4. `cargo test -p qsym-cli` -- full CLI test suite passes (no regressions)
5. The CRITICAL test: trivariate winquist evaluated at a=q^2, b=q^3 matches numeric winquist(q^2, q^3, q, T) coefficient by coefficient
</verification>

<success_criteria>
- winquist(a, b, q, 10) with both a and b symbolic returns Value::TrivariateSeries with nonzero terms
- Display output contains variable names a, b, and q with power notation
- Cross-validation: trivariate evaluated at concrete a=q^2, b=q^3 matches numeric winquist
- winquist(z, q^2, q, 10) still returns BivariateSeries (one-symbolic path preserved)
- winquist(q, q^2, q, 10) still returns Series (numeric path preserved)
- Help text documents two-symbolic support
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/45-bivariate-series/45-04-SUMMARY.md`
</output>
