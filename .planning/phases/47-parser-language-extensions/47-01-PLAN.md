---
phase: 47-parser-language-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/token.rs
  - crates/qsym-cli/src/lexer.rs
  - crates/qsym-cli/src/parser.rs
autonomous: true
requirements: [LANG-01, LANG-05]

must_haves:
  truths:
    - "User types etamake(\",q,100) with ditto and it resolves to the previous result"
    - "User types \" + 1 and gets the previous result plus 1"
    - "Bare \" followed by a delimiter is parsed as ditto, not a string literal"
    - "\"hello\" still parses as a string literal (no regression)"
    - "proc(n) option remember; local k; k := n; end parses without error"
    - "proc(n) local k; option remember; k := n; end still parses (existing order)"
    - "proc(n) local k; k := n; end still parses (no option)"
    - "proc(n) option remember; n; end still parses (no local)"
  artifacts:
    - path: "crates/qsym-cli/src/token.rs"
      provides: "Token::Ditto variant"
      contains: "Ditto"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Ditto lexing with byte-lookahead disambiguation"
      contains: "Token::Ditto"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Ditto NUD mapping to AstNode::LastResult, option/local loop"
      contains: "Token::Ditto"
  key_links:
    - from: "crates/qsym-cli/src/lexer.rs"
      to: "Token::Ditto"
      via: "byte-lookahead after double-quote"
      pattern: "is_ditto"
    - from: "crates/qsym-cli/src/parser.rs"
      to: "AstNode::LastResult"
      via: "NUD match on Token::Ditto"
      pattern: "Token::Ditto"
---

<objective>
Add the ditto operator (`"`) for referencing the last computed result and allow `option`/`local` in either order in procedure definitions.

Purpose: Maple compatibility -- `"` is Maple's ditto, and Maple allows option/local in either order.
Output: Modified token.rs, lexer.rs, parser.rs with tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-parser-language-extensions/47-RESEARCH.md
@crates/qsym-cli/src/token.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Token::Ditto and lexer disambiguation</name>
  <files>
    crates/qsym-cli/src/token.rs
    crates/qsym-cli/src/lexer.rs
  </files>
  <action>
1. In `token.rs`, add a `Ditto` variant to the `Token` enum, right after the existing `Percent` variant. Add doc comment: `/// '"' ditto operator (Maple-style reference to last result).`

2. In `lexer.rs`, modify the string literal section (the `if b == b'"' {` block starting around line 40). BEFORE entering the string-literal parsing logic, add a byte-lookahead check. After seeing `"`, peek at the next byte (`bytes[pos + 1]` if in bounds, else 0). If the next byte is one of: `,`, `)`, `;`, `:`, `+`, `-`, `*`, `/`, `^`, `]`, `<`, `>`, `=`, ` `, `\t`, `\n`, `\r`, or EOF (pos+1 >= bytes.len()), emit `Token::Ditto` with span `(pos, pos+1)`, increment pos by 1, and `continue`. Otherwise, fall through to existing string literal parsing.

   The key insight: `"` as ditto always appears where an expression is expected and is immediately followed by a delimiter/operator, not by printable string content. `etamake(",q,100)` has `"` followed by `,`. `" + 1` has `"` followed by ` `.

3. Add lexer tests:
   - `test_ditto_before_comma`: `tokens(r#"f(",q,100)"#)` should produce `[Ident("f"), LParen, Ditto, Comma, Ident("q"), Comma, Integer(100), RParen, Eof]`
   - `test_ditto_before_rparen`: `tokens(r#"f(")"#)` should produce `[Ident("f"), LParen, Ditto, RParen, Eof]`
   - `test_ditto_before_semicolon`: `tokens(r#"""#` + `;`) should produce `[Ditto, Semi, Eof]` (use raw string for the bare `"` followed by `;`)
   - `test_ditto_before_space_plus`: input `r#"" + 1"#` should produce `[Ditto, Plus, Integer(1), Eof]`
   - `test_ditto_at_eof`: input is just a single `"` char -> `[Ditto, Eof]`
   - `test_string_literal_still_works`: `r#""hello""#` should still produce `[StringLit("hello"), Eof]`
   - `test_empty_string_still_works`: `r#""""#` should produce `[StringLit(""), Eof]` (two quotes with nothing between = empty string, not ditto)

   For the empty string case: after `"`, the next byte is another `"`. This is NOT in the ditto-delimiter list, so it falls through to string parsing, which immediately sees the closing `"` and produces an empty StringLit. This is correct.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli token:: -- --nocapture 2>&1 | tail -5` and `cargo test -p qsym-cli lexer::tests::test_ditto -- --nocapture 2>&1 | tail -10` and `cargo test -p qsym-cli lexer::tests::test_string -- --nocapture 2>&1 | tail -5` -- all pass.
  </verify>
  <done>Token::Ditto variant exists. Bare `"` followed by delimiter/operator/EOF lexes as Ditto. String literals `"hello"` and `""` lex correctly. 7+ new lexer tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Parser ditto NUD, option/local reorder, and token_name update</name>
  <files>
    crates/qsym-cli/src/parser.rs
  </files>
  <action>
1. In `parser.rs`, in the `token_name` function, add a case for the new `Token::Ditto`: `Token::Ditto => "'\"' (ditto)".to_string(),`

2. In the `expr_bp` NUD section, add a match arm for `Token::Ditto` right after the `Token::Percent` arm:
   ```
   Token::Ditto => {
       self.advance();
       AstNode::LastResult
   }
   ```
   This reuses the existing `AstNode::LastResult` node (same as `%`). No evaluator changes needed -- `AstNode::LastResult` already resolves to `env.last_result`.

3. In the `Token::Proc` handling block, replace the two sequential if-blocks for `local` and `option` (lines ~248-265) with a loop:
   ```rust
   let mut locals = vec![];
   let mut options = vec![];
   loop {
       if *self.peek() == Token::Local {
           self.advance();
           locals.extend(self.parse_ident_list()?);
           self.expect(&Token::Semi, "';' after local declarations")?;
       } else if *self.peek() == Token::OptionKw {
           self.advance();
           options.extend(self.parse_ident_list()?);
           self.expect(&Token::Semi, "';' after option declarations")?;
       } else {
           break;
       }
   }
   ```
   This accepts `local` before `option`, `option` before `local`, only `local`, only `option`, neither, or even multiple of each.

4. Add parser tests:
   - `test_ditto_as_expression`: `parse_expr(r#"""#)` (single `"` char) should produce `AstNode::LastResult`. Use the helper: pass input as the bare `"` followed by nothing (but this needs to lex as Ditto+Eof). Actually, since `"` at EOF lexes as Ditto, `parse_expr` with input `"\""` (a Rust string containing one double-quote) should work. Use: `let node = parse_expr("\x22");` or write `parse_expr(&String::from('"'))`.
   - `test_ditto_in_function_arg`: Parse `"etamake(\",q,100)"` -- note you need to construct this input carefully. The input string is: `etamake("` + `,q,100)`. In Rust: `parse_expr("etamake(\x22,q,100)")`. Should produce `AstNode::FuncCall { name: "etamake", args: [AstNode::LastResult, AstNode::Variable("q"), AstNode::Integer(100)] }`.
   - `test_ditto_in_arithmetic`: `parse_expr("\x22 + 1")` should produce `AstNode::BinOp { op: Add, lhs: AstNode::LastResult, rhs: AstNode::Integer(1) }`.
   - `test_proc_option_before_local`: `parse_expr("proc(n) option remember; local k; k; end")` should produce `ProcDef { params: ["n"], locals: ["k"], options: ["remember"], body: [k] }`.
   - `test_proc_local_before_option`: `parse_expr("proc(n) local k; option remember; k; end")` should produce same ProcDef structure (locals=["k"], options=["remember"]).
   - `test_proc_option_only`: `parse_expr("proc(n) option remember; n; end")` -- options=["remember"], locals=[].
   - `test_proc_local_only`: `parse_expr("proc(n) local k; k; end")` -- locals=["k"], options=[].
   - `test_proc_neither_local_nor_option`: `parse_expr("proc(n) n; end")` -- locals=[], options=[].

5. Run ALL existing parser tests to ensure no regressions. The test_parse_proc_full test (existing) tests local-then-option and must still pass.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli parser::tests -- --nocapture 2>&1 | tail -20` -- all pass including new ditto and option/local reorder tests. Then run the full test suite: `cargo test -p qsym-cli 2>&1 | tail -5` -- all pass.
  </verify>
  <done>Ditto `"` parses to AstNode::LastResult. Procedures accept option/local in either order. All existing tests pass (no regressions). 8+ new parser tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass
2. Lexer correctly disambiguates: `"hello"` -> StringLit, bare `"` before delimiter -> Ditto
3. Parser maps Ditto to AstNode::LastResult (reusing existing evaluation path)
4. Proc definitions accept: local-then-option, option-then-local, option-only, local-only, neither
5. No changes needed to eval.rs -- AstNode::LastResult already resolves via env.last_result
</verification>

<success_criteria>
- `cargo test -p qsym-cli` passes with zero failures
- Token::Ditto exists and is lexed from bare `"` with byte-lookahead
- AstNode::LastResult is produced for both `%` and `"`
- Procedure parser accepts option/local in either order
- String literal parsing is not broken
</success_criteria>

<output>
After completion, create `.planning/phases/47-parser-language-extensions/47-01-SUMMARY.md`
</output>
