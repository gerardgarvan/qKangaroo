---
phase: 47-parser-language-extensions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
autonomous: true
requirements: [LANG-04]

must_haves:
  truths:
    - "q^(1/4) evaluates to a FractionalPowerSeries displayed as q^(1/4)"
    - "theta2(q,100)/q^(1/4) produces a series with integer exponents (fractional shift removed)"
    - "FractionalPowerSeries supports addition and subtraction with matching denominators"
    - "FractionalPowerSeries supports multiplication and division with series and scalars"
    - "Display shows q^(k/d) for fractional exponents, q^k when k is a multiple of d"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::FractionalPowerSeries variant, eval_pow fractional case, arithmetic ops"
      contains: "FractionalPowerSeries"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_value and format_latex arms for FractionalPowerSeries"
      contains: "FractionalPowerSeries"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "Value::FractionalPowerSeries"
      via: "eval_pow Symbol^Rational with denom > 1"
      pattern: "FractionalPowerSeries"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "eval_div"
      via: "Series / FractionalPowerSeries rescaling"
      pattern: "FractionalPowerSeries"
    - from: "crates/qsym-cli/src/format.rs"
      to: "format_fractional_series"
      via: "format_value match arm"
      pattern: "FractionalPowerSeries"
---

<objective>
Add fractional q-power support: `q^(1/4)`, `q^(1/3)`, and arithmetic with fractional-exponent series like `theta2(q,100)/q^(1/4)`.

Purpose: Enable manipulation of theta functions with fractional q-prefactors, matching Maple's behavior.
Output: Modified eval.rs and format.rs with Value::FractionalPowerSeries variant and tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-parser-language-extensions/47-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-core/src/series/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Value::FractionalPowerSeries variant and eval_pow fractional case</name>
  <files>
    crates/qsym-cli/src/eval.rs
  </files>
  <action>
1. Add a new variant to the `Value` enum:
   ```rust
   /// Fractional power series: inner FPS with exponent k representing q^(k/denom).
   /// For example, q^(1/4) is stored as monomial at k=1 with denom=4.
   FractionalPowerSeries {
       inner: FormalPowerSeries,
       denom: i64,
   },
   ```

2. In `Value::type_name()`, add: `Value::FractionalPowerSeries { .. } => "fractional_power_series",`

3. Modify `eval_pow` for the `(Value::Symbol(name), Value::Rational(r))` arm (around line 1978). Instead of erroring when `denom != 1`, handle fractional exponents:
   ```rust
   (Value::Symbol(name), Value::Rational(r)) => {
       let numer = r.0.numer().to_i64().ok_or_else(|| EvalError::Other(
           "exponent numerator too large".to_string(),
       ))?;
       let denom = r.0.denom().to_i64().ok_or_else(|| EvalError::Other(
           "exponent denominator too large".to_string(),
       ))?;
       if denom == 1 {
           // Integer exponent (existing behavior)
           let sym_id = env.symbols.intern(name);
           let fps = FormalPowerSeries::monomial(sym_id, QRat::one(), numer, POLYNOMIAL_ORDER);
           Ok(Value::Series(fps))
       } else {
           // Fractional exponent: q^(p/d)
           let sym_id = env.symbols.intern(name);
           let fps = FormalPowerSeries::monomial(sym_id, QRat::one(), numer, POLYNOMIAL_ORDER);
           Ok(Value::FractionalPowerSeries { inner: fps, denom })
       }
   }
   ```

4. Add arithmetic operations for FractionalPowerSeries. In the `eval_binop` function (or wherever `BinOp::Div` is handled), add cases for:

   a. **Series / FractionalPowerSeries**: This is the primary use case (`theta2(q,100) / q^(1/4)`). Implementation:
      - Extract the FPS `divisor_inner` and `denom` from the FractionalPowerSeries.
      - The divisor is a monomial q^(p/d) stored as inner monomial at exponent p with denominator d.
      - Rescale the numerator series: multiply all exponent keys by `denom`. So q^1 becomes q^(4/4) represented as key 4, q^9 becomes key 36, etc.
      - Rescale the divisor inner series keys by 1 (it's already in the fractional space). Actually, the divisor inner has key=p (the numerator of the fraction). Division by monomial at key p means shifting all keys down by p.
      - Perform `arithmetic::div(&rescaled_numerator, &rescaled_divisor, truncation_order * denom)` or more simply: since the divisor is a monomial, just subtract p from all numerator keys.
      - The result is a FractionalPowerSeries with the divided inner FPS and the same denom.

      Simplified implementation for monomial divisor:
      ```rust
      // Series / FractionalPowerSeries
      (Value::Series(fps), Value::FractionalPowerSeries { inner: div_fps, denom }) => {
          // div_fps should be a monomial q^p (the numerator exponent)
          // Rescale the series: multiply all keys by denom
          let mut rescaled = BTreeMap::new();
          for (&k, coeff) in fps.coeffs() {
              rescaled.insert(k * denom, coeff.clone());
          }
          let rescaled_fps = FormalPowerSeries::from_coeffs_with_symbol(
              fps.symbol(), rescaled, fps.truncation_order() * denom
          );
          // Divide by the inner monomial (shift exponents)
          let result = arithmetic::div(&rescaled_fps, &div_fps, rescaled_fps.truncation_order());
          Ok(Value::FractionalPowerSeries { inner: result, denom: *denom })
      }
      ```

      Note: You'll need to check the exact FormalPowerSeries API. The key methods are:
      - `fps.coeffs()` returns `&BTreeMap<i64, QRat>` (the internal coefficient map)
      - `fps.symbol()` returns `SymbolId`
      - `fps.truncation_order()` returns `i64`
      - Use `FormalPowerSeries::from_raw(symbol, coeffs_btreemap, truncation_order)` or construct manually.

      Look at how FPS is constructed elsewhere in eval.rs for the exact constructor pattern. If there's no `from_raw` or `from_coeffs_with_symbol`, construct one by building a new FPS using `FormalPowerSeries::zero(symbol, trunc)` and then inserting coefficients via the available API, or by using `FormalPowerSeries::new(...)`.

   b. **FractionalPowerSeries * FractionalPowerSeries**: Unify denominators (LCD), rescale both, multiply inner FPSes.

   c. **FractionalPowerSeries * Series** and **Series * FractionalPowerSeries**: Rescale the regular series by denom, multiply, result is FractionalPowerSeries.

   d. **FractionalPowerSeries * Integer** and **Integer * FractionalPowerSeries**: Scale coefficients.

   e. **FractionalPowerSeries + FractionalPowerSeries**: Same denom required (or unify via LCD). Add inner FPSes.

   f. **FractionalPowerSeries - FractionalPowerSeries**: Same as add but subtract.

   g. **Neg(FractionalPowerSeries)**: Negate inner coefficients.

   For each operation, check whether the result simplifies back to a regular Series (all exponent keys are multiples of denom). If so, rescale back and return Value::Series. Helper function:
   ```rust
   fn simplify_fractional(inner: FormalPowerSeries, denom: i64) -> Value {
       // Check if all keys are multiples of denom
       if inner.coeffs().keys().all(|&k| k % denom == 0) {
           let mut simplified = BTreeMap::new();
           for (&k, coeff) in inner.coeffs() {
               simplified.insert(k / denom, coeff.clone());
           }
           // Reconstruct FPS with simplified keys
           // ... using appropriate constructor
           Value::Series(simplified_fps)
       } else {
           Value::FractionalPowerSeries { inner, denom }
       }
   }
   ```

5. Add tests:
   - `test_eval_pow_symbol_fractional`: `q^(1/4)` -> FractionalPowerSeries { denom: 4, inner has monomial at key 1 }
   - `test_eval_pow_symbol_fractional_third`: `q^(1/3)` -> FractionalPowerSeries { denom: 3, inner monomial at key 1 }
   - `test_eval_pow_symbol_fractional_two_thirds`: `q^(2/3)` -> FractionalPowerSeries { denom: 3, inner monomial at key 2 }
   - `test_eval_div_series_by_fractional`: Construct a simple series (e.g., `q + q^2`) and divide by `q^(1/2)`. Result should be FractionalPowerSeries with denom=2, inner keys at 1 (from q^(2/2) / q^(1/2) = q^(1/2)) and 3 (from q^(4/2) / q^(1/2) = q^(3/2)). Actually: q -> key 2 in rescaled, q^2 -> key 4. Divide by monomial at key 1: keys become 1 and 3. So result inner has keys 1 and 3 with denom 2, representing q^(1/2) + q^(3/2).
   - `test_eval_fractional_simplifies_to_series`: `q^(1/2) * q^(1/2)` should simplify back to `q` (a regular Series).
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli eval::tests::test_eval_pow_symbol_fractional -- --nocapture 2>&1 | tail -10` and `cargo test -p qsym-cli eval::tests::test_eval_div_series_by_fractional -- --nocapture 2>&1 | tail -10` -- all pass. Then `cargo test -p qsym-cli 2>&1 | tail -5` -- no regressions.
  </verify>
  <done>Value::FractionalPowerSeries variant exists. q^(1/4) evaluates correctly. Series divided by fractional power works. Arithmetic operations handle FractionalPowerSeries. Simplification back to Series when all keys are multiples of denom. 5+ new tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: FractionalPowerSeries display formatting</name>
  <files>
    crates/qsym-cli/src/format.rs
  </files>
  <action>
1. In `format_value`, add a match arm for `Value::FractionalPowerSeries { inner, denom }`:
   ```rust
   Value::FractionalPowerSeries { inner, denom } => {
       format_fractional_series(inner, *denom, symbols)
   }
   ```

2. Implement `format_fractional_series(fps: &FormalPowerSeries, denom: i64, symbols: &SymbolRegistry) -> String`:
   - Get the variable name from `symbols.name(fps.symbol())`.
   - Iterate over the coefficients in order (same as `format_series`).
   - For each `(k, coeff)`:
     - If `k % denom == 0`: display as `var^(k/denom)` which simplifies to `var^N` where N = k/denom. Use the same formatting as regular series for integer exponents.
     - If `k % denom != 0`: display as `var^(k/denom)`. Reduce the fraction k/denom to lowest terms using GCD. If reduced numerator is 1 and reduced denominator is the original denom, show `var^(1/d)`. Otherwise show `var^(p/d)`.
   - Handle special exponent cases:
     - k/denom == 0: coefficient only (constant term)
     - k/denom == 1: just `var` (no exponent)
     - Otherwise: `var^(p/d)` or `var^N`
   - Handle coefficient formatting the same way as regular series: skip `1*`, show `-` for negatives, use `+` separators.
   - Add truncation indicator `+ O(var^(T/denom))` at the end, where T is the truncation order. But only if truncation_order < POLYNOMIAL_ORDER.

   Follow the existing `format_series` function as a template for term formatting, sign handling, and O(...) display. The key difference is the exponent display.

3. In `format_latex`, add a corresponding arm:
   ```rust
   Value::FractionalPowerSeries { inner, denom } => {
       format_fractional_series_latex(inner, *denom, symbols)
   }
   ```
   Implement `format_fractional_series_latex` following the pattern of `fps_to_latex`. For LaTeX, fractional exponents display as `q^{k/d}` or `q^{\frac{k}{d}}`.

4. Add tests:
   - `test_format_fractional_simple`: A FractionalPowerSeries with denom=4, inner monomial at key 1 with coeff 1, should format as `q^(1/4)`.
   - `test_format_fractional_multiple_terms`: Inner has keys 1 (coeff 2) and 3 (coeff -1) with denom=2 -> `2*q^(1/2) - q^(3/2)`.
   - `test_format_fractional_integer_exponent`: Inner has key 4 (coeff 1) with denom=4 -> `q` (since 4/4 = 1).
   - `test_format_fractional_mixed_exponents`: Inner has keys 2 (coeff 1) and 4 (coeff 1) with denom=4 -> `q^(1/2) + q`.
   - `test_format_fractional_with_truncation`: Verify O(...) term shows correctly.
   - `test_format_fractional_reduces_fraction`: Inner has key 2, denom=4, coeff 1 -> `q^(1/2)` (2/4 reduces to 1/2).
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli format::tests::test_format_fractional -- --nocapture 2>&1 | tail -15` -- all formatting tests pass. Then `cargo test -p qsym-cli 2>&1 | tail -5` -- full suite green.
  </verify>
  <done>FractionalPowerSeries displays with q^(p/d) notation. Integer exponents simplify to q^N. Fractions reduce to lowest terms. O(...) truncation shown. LaTeX formatting works. 6+ new format tests pass. Full test suite green.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass
2. `q^(1/4)` evaluates to FractionalPowerSeries and displays as `q^(1/4)`
3. `theta2(q,100)/q^(1/4)` produces a series with fractional exponents displayed correctly
4. Arithmetic between FractionalPowerSeries and regular Series works (rescaling + unification)
5. Results simplify back to regular Series when all exponents are integer multiples
6. LaTeX output shows fractional exponents correctly
</verification>

<success_criteria>
- `cargo test -p qsym-cli` passes with zero failures
- Value::FractionalPowerSeries variant exists with inner FPS and denom
- q^(1/4) evaluates and displays correctly
- Series / q^(1/4) produces correct fractional series
- Display formats q^(k/d) with fraction reduction
- No regressions in existing series formatting
</success_criteria>

<output>
After completion, create `.planning/phases/47-parser-language-extensions/47-03-SUMMARY.md`
</output>
