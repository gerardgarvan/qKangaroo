---
phase: 48-function-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [FIX-01, FIX-02]

must_haves:
  truths:
    - "aqprod(q,q,5) returns full polynomial 1 - q - q^2 + q^5 + q^7 - q^12 - q^15 without O(...) truncation"
    - "aqprod(q,q,5,20) still works with explicit 4-arg truncation order"
    - "theta3(q,100) returns the same series as theta3(100) (i.e. standard theta3 with explicit variable)"
    - "theta3(q,q,100) returns the same series as theta3(100) (3-arg Garvan form with a=q)"
    - "theta2(q,100) and theta4(q,100) accept 2-arg Garvan form"
    - "theta3(10) legacy 1-arg form still works unchanged"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Fixed aqprod 3-arg dispatch, multi-arity theta2/3/4 dispatch (1, 2, and 3-arg)"
      contains: "POLYNOMIAL_ORDER"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated signatures for aqprod and theta functions"
      contains: "theta3(T) or theta3(q, T) or theta3(a, q, T)"
  key_links:
    - from: "eval.rs aqprod 3-arg branch"
      to: "qseries::aqprod"
      via: "POLYNOMIAL_ORDER as truncation_order"
      pattern: "qseries::aqprod.*POLYNOMIAL_ORDER"
    - from: "eval.rs theta 2-arg branch"
      to: "extract_symbol_id + qseries::theta3"
      via: "symbol extraction then core call"
      pattern: "extract_symbol_id.*theta"
    - from: "eval.rs theta 3-arg branch"
      to: "extract_symbol_id(args[1]) + qseries::theta3"
      via: "extract variable from second arg, ignore first arg when a==q"
      pattern: "args.len\\(\\) == 3"
---

<objective>
Fix aqprod 3-arg truncation bug and add Garvan 2-arg and 3-arg signatures for theta2/3/4.

Purpose: FIX-01 fixes aqprod(q,q,n) to return the full finite polynomial instead of truncating to O(q^n). FIX-02 adds theta3(q,T) 2-arg and theta3(a,q,T) 3-arg Garvan conventions so users can use any of Garvan's calling forms.
Output: Modified eval.rs with correct aqprod dispatch and multi-arity theta dispatch (1/2/3-arg), updated help.rs signatures.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/cygwin64/home/Owner/Kangaroo/.planning/ROADMAP.md
@C:/cygwin64/home/Owner/Kangaroo/.planning/STATE.md
@C:/cygwin64/home/Owner/Kangaroo/.planning/phases/48-function-fixes/48-RESEARCH.md
@C:/cygwin64/home/Owner/Kangaroo/crates/qsym-cli/src/eval.rs
@C:/cygwin64/home/Owner/Kangaroo/crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix aqprod 3-arg truncation and add theta 1/2/3-arg dispatch</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
**FIX-01: aqprod truncation fix (line ~3020)**

In the `"aqprod"` dispatch, find the 3-arg branch:
```rust
if args.len() == 3 {
    let n = extract_i64(name, args, 2)?;
    let result = qseries::aqprod(&monomial, sym, PochhammerOrder::Finite(n), n);
    Ok(Value::Series(result))
}
```
Change `n` (the second argument to aqprod) to `POLYNOMIAL_ORDER`:
```rust
if args.len() == 3 {
    let n = extract_i64(name, args, 2)?;
    let result = qseries::aqprod(&monomial, sym, PochhammerOrder::Finite(n), POLYNOMIAL_ORDER);
    Ok(Value::Series(result))
}
```
This makes `aqprod(q,q,5)` produce the exact polynomial `(q;q)_5` with the POLYNOMIAL_ORDER sentinel, so it displays without `O(...)`. The 4-arg form `aqprod(q,q,n,order)` remains unchanged.

**FIX-02: theta2/3/4 multi-arity dispatch (lines ~3398-3417)**

Replace each of the three theta function dispatches. Currently each uses `expect_args(name, args, 1)`. Change to multi-arity dispatch supporting 1-arg (legacy), 2-arg (Garvan), and 3-arg (Garvan `theta3(a,q,T)`) forms.

For `"theta2"`, replace:
```rust
"theta2" => {
    expect_args(name, args, 1)?;
    let order = extract_i64(name, args, 0)?;
    let result = qseries::theta2(env.sym_q, order);
    Ok(Value::Series(result))
}
```
With:
```rust
"theta2" => {
    if args.len() == 1 {
        // theta2(T) -- legacy 1-arg form
        let order = extract_i64(name, args, 0)?;
        let result = qseries::theta2(env.sym_q, order);
        Ok(Value::Series(result))
    } else if args.len() == 2 {
        // theta2(q, T) -- Garvan 2-arg form
        let sym = extract_symbol_id(name, args, 0, env)?;
        let order = extract_i64(name, args, 1)?;
        let result = qseries::theta2(sym, order);
        Ok(Value::Series(result))
    } else if args.len() == 3 {
        // theta2(a, q, T) -- Garvan 3-arg form
        // When a == q (same variable), reduces to standard theta2
        let sym = extract_symbol_id(name, args, 1, env)?;
        let order = extract_i64(name, args, 2)?;
        let result = qseries::theta2(sym, order);
        Ok(Value::Series(result))
    } else {
        Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "1, 2, or 3".to_string(),
            got: args.len(),
            signature: get_signature(name),
        })
    }
}
```

Apply the identical pattern for `"theta3"` (using `qseries::theta3`) and `"theta4"` (using `qseries::theta4`).

**Note on 3-arg semantics:** The 3-arg form `theta3(a, q, T)` where `a` is the first arg is used in Garvan's convention. When `a == q` (the common case tested by the roadmap success criterion `theta3(q,q,100)`), this reduces to standard theta3. The implementation extracts the variable from `args[1]` (the q parameter) and uses it for the core call, effectively ignoring the first arg `a` when it equals `q`. For the generalized case where `a != q`, the existing `theta(z, q, T)` function already handles that -- this 3-arg form on theta3 just ensures `theta3(q,q,100)` works as users expect from Garvan's examples.

**Update get_signature() (line ~5404-5406)**

Change the three theta signature entries:
- `"theta2" => "(order)"` to `"theta2" => "(T) or (q, T) or (a, q, T)"`
- `"theta3" => "(order)"` to `"theta3" => "(T) or (q, T) or (a, q, T)"`
- `"theta4" => "(order)"` to `"theta4" => "(T) or (q, T) or (a, q, T)"`

**Add tests** at the end of the `#[cfg(test)]` module:

1. `dispatch_aqprod_maple_3arg_polynomial_order`: Call `aqprod` with Symbol("q"), Symbol("q"), Integer(5). Assert result is Series. Extract FPS, verify `truncation_order() == POLYNOMIAL_ORDER` (1_000_000_000). Verify specific coefficients: coeff(0)=1, coeff(1)=-1, coeff(2)=-1, coeff(5)=1, coeff(7)=1, coeff(12)=-1, coeff(15)=-1, and coeff(3)=0 (not present).

2. `dispatch_aqprod_4arg_unchanged`: Call `aqprod` with Symbol("q"), Symbol("q"), Integer(5), Integer(10). Assert result is Series with truncation_order == 10 (the explicit 4-arg form is unchanged).

3. `dispatch_theta3_2arg`: Call `theta3` with Symbol("q"), Integer(20). Assert result matches calling theta3 with just Integer(20) -- same coefficients at 0, 1, 4, 9.

4. `dispatch_theta3_3arg`: Call `theta3` with Symbol("q"), Symbol("q"), Integer(100). Assert result is Series and matches calling theta3 with just Integer(100) -- same coefficients at 0, 1, 4, 9, 16. This tests the roadmap success criterion that `theta3(q,q,100)` returns the same series as `theta3(100)`.

5. `dispatch_theta2_2arg`: Call `theta2` with Symbol("q"), Integer(10). Assert result is Series (not error).

6. `dispatch_theta4_2arg`: Call `theta4` with Symbol("q"), Integer(10). Assert result is Series (not error).

7. `dispatch_theta3_1arg_unchanged`: Call `theta3` with Integer(20). Assert still works (regression test -- should already pass but good to have).
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli dispatch_aqprod_maple_3arg_polynomial_order dispatch_aqprod_4arg_unchanged dispatch_theta3_2arg dispatch_theta3_3arg dispatch_theta2_2arg dispatch_theta4_2arg dispatch_theta3_1arg_unchanged -- --nocapture`
All 7 new tests pass.
  </verify>
  <done>aqprod(q,q,5) returns exact polynomial with POLYNOMIAL_ORDER sentinel; theta2/3/4 accept 1-arg, 2-arg, and 3-arg forms; theta3(q,q,100) returns same series as theta3(100); all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update help entries for aqprod and theta signatures</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
**Update aqprod help entry** (help.rs line ~165):
Change `signature` from `"aqprod(a, q, n) or aqprod(a, q, infinity, T)"` to `"aqprod(a, q, n) or aqprod(a, q, infinity, T) or aqprod(a, q, n, T)"`.
Update `description` to mention that the 3-arg form computes the full exact polynomial.

**Update theta2 help entry** (help.rs line ~271):
Change `signature` from `"theta2(order)"` to `"theta2(T) or theta2(q, T) or theta2(a, q, T)"`.
Update `description` to mention the 2-arg Garvan form and the 3-arg form where a is the first parameter.

**Update theta3 help entry** (help.rs line ~278):
Change `signature` from `"theta3(order)"` to `"theta3(T) or theta3(q, T) or theta3(a, q, T)"`.
Update `description` to mention the 2-arg Garvan form and the 3-arg form.

**Update theta4 help entry** (help.rs line ~285):
Change `signature` from `"theta4(order)"` to `"theta4(T) or theta4(q, T) or theta4(a, q, T)"`.
Update `description` to mention the 2-arg Garvan form and the 3-arg form.

**Update the help test** `every_canonical_function_has_help_entry` -- no changes needed since function names are unchanged, only signatures.

No new entries needed since all four functions already exist in FUNC_HELP.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli --lib help -- --nocapture`
All help tests pass.
  </verify>
  <done>Help entries for aqprod and theta2/3/4 reflect the new argument forms including 3-arg theta3(a, q, T).</done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-cli
```
All existing + new tests pass.

Manual REPL verification (optional):
```
q> aqprod(q,q,5)
# Should display: -q^15 - q^12 + q^7 + q^5 - q^2 - q + 1  (no O(...))

q> theta3(q,20)
# Should display same as theta3(20)

q> theta3(q,q,100)
# Should display same as theta3(100) -- 3-arg Garvan form
```
</verification>

<success_criteria>
- aqprod(q,q,5) returns 1 - q - q^2 + q^5 + q^7 - q^12 - q^15 as exact polynomial (no O(...))
- aqprod(q,q,5,20) still returns truncated series with O(q^20) (4-arg unchanged)
- theta3(q,100) returns same series as theta3(100)
- theta3(q,q,100) returns same series as theta3(100) (3-arg Garvan form)
- theta2(q,T) and theta4(q,T) both accepted (2-arg and 3-arg)
- All 763+ CLI tests pass plus 7 new tests
</success_criteria>

<output>
After completion, create `.planning/phases/48-function-fixes/48-01-SUMMARY.md`
</output>
