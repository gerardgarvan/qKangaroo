---
phase: 48-function-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [FIX-05, LANG-03]

must_haves:
  truths:
    - "qfactor(f,100) with Integer second arg returns same result as qfactor(f,q,100)"
    - "qfactor(f,q) with Symbol second arg still works (existing behavior)"
    - "min(3,1,4,1,5) returns Integer 1"
    - "min(1/3, 1/2) returns Rational 1/3"
    - "max(3,1,4,1,5) returns Integer 5"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "qfactor 2-arg Integer detection, min and max variadic functions"
      contains: "\"min\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entries for min, max; updated qfactor signature"
      contains: "min"
  key_links:
    - from: "eval.rs qfactor 2-arg branch"
      to: "match &args[1] for Symbol vs Integer"
      via: "type-based disambiguation"
      pattern: "Value::Integer.*qfactor"
    - from: "eval.rs min function"
      to: "extract_qrat for comparison"
      via: "QRat Ord comparison, return original Value"
      pattern: "extract_qrat.*min_val"
---

<objective>
Add qfactor 2-arg Garvan signature and implement min/max variadic functions.

Purpose: FIX-05 lets users call qfactor(f,100) without explicitly naming the variable. LANG-03 adds min() for integer/rational comparison. Research recommends also adding max() since it's trivially identical.
Output: Modified eval.rs with qfactor disambiguation and min/max dispatch, updated help.rs.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/cygwin64/home/Owner/Kangaroo/.planning/ROADMAP.md
@C:/cygwin64/home/Owner/Kangaroo/.planning/STATE.md
@C:/cygwin64/home/Owner/Kangaroo/.planning/phases/48-function-fixes/48-RESEARCH.md
@C:/cygwin64/home/Owner/Kangaroo/crates/qsym-cli/src/eval.rs
@C:/cygwin64/home/Owner/Kangaroo/crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add qfactor 2-arg Integer detection and min/max functions</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
**FIX-05: qfactor 2-arg disambiguation (line ~3558-3580)**

Replace the 2-arg branch of qfactor. Currently:
```rust
if args.len() == 2 {
    let fps = extract_series(name, args, 0)?;
    let _sym = extract_symbol_id(name, args, 1, env)?;
    let result = qseries::qfactor(&fps);
    Ok(q_factorization_to_value(&result))
}
```

Change to:
```rust
if args.len() == 2 {
    let fps = extract_series(name, args, 0)?;
    match &args[1] {
        Value::Symbol(_) => {
            // qfactor(f, q) -- existing form, explicit variable
            let _sym = extract_symbol_id(name, args, 1, env)?;
        }
        Value::Integer(_) => {
            // qfactor(f, T) -- Garvan 2-arg form, implicit variable q
            let _t = extract_i64(name, args, 1)?;
        }
        other => {
            return Err(EvalError::ArgType {
                function: name.to_string(),
                arg_index: 1,
                expected: "Symbol or Integer".to_string(),
                got: other.type_name().to_string(),
            });
        }
    }
    let result = qseries::qfactor(&fps);
    Ok(q_factorization_to_value(&result))
}
```

Update `get_signature()` for qfactor (line ~5419):
Change `"(f, q) or (f, q, T)"` to `"(f, q) or (f, T) or (f, q, T)"`.

**LANG-03: min and max functions**

Add in the Number Theory section (after `"legendre"`, before the closing match fallthrough), two new match arms:

```rust
"min" => {
    if args.is_empty() {
        return Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "1 or more".to_string(),
            got: 0,
            signature: get_signature(name),
        });
    }
    let mut min_idx = 0;
    let mut min_val = extract_qrat(name, args, 0)?;
    for i in 1..args.len() {
        let val = extract_qrat(name, args, i)?;
        if val < min_val {
            min_val = val;
            min_idx = i;
        }
    }
    Ok(args[min_idx].clone())
}

"max" => {
    if args.is_empty() {
        return Err(EvalError::WrongArgCount {
            function: name.to_string(),
            expected: "1 or more".to_string(),
            got: 0,
            signature: get_signature(name),
        });
    }
    let mut max_idx = 0;
    let mut max_val = extract_qrat(name, args, 0)?;
    for i in 1..args.len() {
        let val = extract_qrat(name, args, i)?;
        if val > max_val {
            max_val = val;
            max_idx = i;
        }
    }
    Ok(args[max_idx].clone())
}
```

**Update get_signature() for min/max:**
Add two entries before the `_ => String::new()` fallthrough:
```rust
"min" => "(a, b, ...) -- minimum of integer/rational values".to_string(),
"max" => "(a, b, ...) -- maximum of integer/rational values".to_string(),
```

**Update ALL_FUNCTION_NAMES (line ~5574):**
Add `"min", "max"` to Pattern P (Number theory), changing:
```rust
"floor", "legendre",
```
to:
```rust
"floor", "legendre", "min", "max",
```
Update the function count comment from `84 functions` to `86 functions`.

**Add tests** at the end of the `#[cfg(test)]` module:

1. `dispatch_qfactor_2arg_integer`: Create a series via `qbin` (e.g., qbin(5,2,20)), then call `qfactor` with [series, Integer(100)]. Assert result is Dict with "scalar", "factors", "is_exact" keys.

2. `dispatch_qfactor_2arg_symbol_still_works`: Call `qfactor` with [series, Symbol("q")]. Assert result is Dict (regression test).

3. `dispatch_min_integers`: Call `min` with [Integer(3), Integer(1), Integer(4), Integer(1), Integer(5)]. Assert result is Integer(1).

4. `dispatch_min_rationals`: Call `min` with [Rational(1/3), Rational(1/2)]. Assert result is Rational(1/3).

5. `dispatch_min_mixed`: Call `min` with [Integer(2), Rational(3/2)]. Assert result is Rational(3/2).

6. `dispatch_min_single`: Call `min` with [Integer(7)]. Assert result is Integer(7).

7. `dispatch_min_empty_error`: Call `min` with []. Assert WrongArgCount error.

8. `dispatch_max_integers`: Call `max` with [Integer(3), Integer(1), Integer(5)]. Assert result is Integer(5).

9. `dispatch_max_rationals`: Call `max` with [Rational(1/3), Rational(1/2)]. Assert result is Rational(1/2).

10. `dispatch_min_preserves_integer_type`: Call `min` with [Integer(3), Integer(1)]. Assert result matches Value::Integer (not Rational) to avoid the "1/1" display pitfall.
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli dispatch_qfactor_2arg dispatch_min dispatch_max -- --nocapture`
All 10 new tests pass.
  </verify>
  <done>qfactor(f,100) works via Integer detection; min/max variadic functions return correct types; all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update help entries for qfactor, min, and max</name>
  <files>crates/qsym-cli/src/help.rs</files>
  <action>
**Update qfactor help entry** (help.rs line ~323):
Change `signature` from `"qfactor(f, q) or qfactor(f, q, T)"` to `"qfactor(f, q) or qfactor(f, T) or qfactor(f, q, T)"`.
Update `description` to mention the 2-arg form with implicit q variable.

**Update general help text** (help.rs line ~120-122):
Add `min` and `max` to the "Number Theory:" section listing:
```
Number Theory:
  floor          - floor of a rational number
  legendre       - Legendre symbol (m/p) for odd prime p
  min            - minimum of integer/rational values
  max            - maximum of integer/rational values
```

**Add min and max help entries** (help.rs, in FUNC_HELP array after the `legendre` entry, before the closing `];`):

```rust
FuncHelp {
    name: "min",
    signature: "min(a, b, ...)",
    description: "Return the minimum of one or more integer or rational arguments.\n  Accepts any mix of integers and rationals. Returns the original value type (Integer stays Integer, Rational stays Rational).",
    example: "q> min(3, 1, 4, 1, 5)",
    example_output: "1",
},
FuncHelp {
    name: "max",
    signature: "max(a, b, ...)",
    description: "Return the maximum of one or more integer or rational arguments.\n  Accepts any mix of integers and rationals. Returns the original value type (Integer stays Integer, Rational stays Rational).",
    example: "q> max(3, 1, 4, 1, 5)",
    example_output: "5",
},
```

**Update Group 12 comment** from `Group 12: Number Theory (2)` to `Group 12: Number Theory (4)`.

**Update `every_canonical_function_has_help_entry` test** (help.rs line ~1051):
Add `"min", "max"` to the canonical list. Update the count assertion from `assert_eq!(canonical.len(), 95, ...)` to `assert_eq!(canonical.len(), 97, ...)` (adding 2 new functions).

**Update `general_help_contains_number_theory_category` test** (help.rs line ~1117):
Add assertions:
```rust
assert!(text.contains("min"), "general_help missing min");
assert!(text.contains("max"), "general_help missing max");
```
  </action>
  <verify>
Run: `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli --lib help -- --nocapture`
All help tests pass including updated canonical function count.
  </verify>
  <done>Help entries exist for min, max; qfactor signature updated; all help tests pass with correct function count.</done>
</task>

</tasks>

<verification>
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test -p qsym-cli
```
All existing + new tests pass.

Manual REPL verification (optional):
```
q> f := aqprod(q,q,5): qfactor(f, 100)
# Should return {scalar: 1, factors: {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}, is_exact: true}

q> min(3, 1, 4, 1, 5)
# Should return: 1

q> min(1/3, 1/2)
# Should return: 1/3

q> max(3, 1, 4, 1, 5)
# Should return: 5
```
</verification>

<success_criteria>
- qfactor(f,100) with Integer 2nd arg returns same result as qfactor(f,q,100)
- qfactor(f,q) still works with Symbol 2nd arg
- min(3,1,4,1,5) returns Integer 1
- min(1/3,1/2) returns Rational 1/3
- max(3,1,4,1,5) returns Integer 5
- All 763+ CLI tests pass plus 10 new tests
</success_criteria>

<output>
After completion, create `.planning/phases/48-function-fixes/48-02-SUMMARY.md`
</output>
