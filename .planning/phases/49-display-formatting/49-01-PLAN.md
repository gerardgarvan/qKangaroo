---
phase: 49-display-formatting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [FIX-03]
must_haves:
  truths:
    - "qfactor(aqprod(q,q,5),q) displays (1-q)(1-q^2)(1-q^3)(1-q^4)(1-q^5) not {scalar: ...}"
    - "qfactor result with scalar != 1 shows scalar prefix like 3*(1-q)(1-q^2)"
    - "qfactor result with exponent > 1 shows (1-q^2)^3"
    - "qfactor result with negative exponent shows (1-q^2)^(-1)"
    - "Approximate factorization shows (approx) suffix"
    - "LaTeX output for qfactor uses proper notation"
    - "Arithmetic on QProduct gives helpful error message"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::QProduct variant, q_factorization_to_value returns QProduct, arithmetic error arms"
      contains: "QProduct"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_qproduct() and format_qproduct_latex() functions"
      contains: "format_qproduct"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated qfactor example_output"
      contains: "(1-q)(1-q^2)"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/format.rs"
      via: "Value::QProduct match arm in format_value() and format_latex()"
      pattern: "QProduct.*format_qproduct"
---

<objective>
Add `Value::QProduct` variant to the Value enum so that `qfactor()` results display as human-readable q-product notation like `(1-q)(1-q^2)(1-q^3)` instead of raw `{scalar: 1, factors: {...}, is_exact: true}`.

Purpose: FIX-03 -- users see mathematical notation for factorization results
Output: QProduct variant with plain-text and LaTeX formatting, updated tests and help
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-display-formatting/49-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Value::QProduct variant and update eval.rs</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
1. Add `Value::QProduct` variant to the Value enum (after `JacobiProduct`):
   ```rust
   /// Q-product factorization: scalar * prod (1-q^i)^{mult_i}.
   /// Stores factors as BTreeMap<i64, i64> (i -> multiplicity).
   QProduct {
       factors: BTreeMap<i64, i64>,
       scalar: QRat,
       is_exact: bool,
   },
   ```

2. Add type_name match arm:
   ```rust
   Value::QProduct { .. } => "qproduct",
   ```

3. Change `q_factorization_to_value()` (around line 5130) to return `Value::QProduct` instead of `Value::Dict`:
   ```rust
   fn q_factorization_to_value(qf: &qseries::QFactorization) -> Value {
       Value::QProduct {
           factors: qf.factors.clone(),
           scalar: qf.scalar.clone(),
           is_exact: qf.is_exact,
       }
   }
   ```

4. Add arithmetic error arms in `eval_add`, `eval_sub`, `eval_mul`, `eval_div` -- place them BEFORE the JacobiProduct arms (or alongside). Follow the JacobiProduct pattern exactly:
   ```rust
   (Value::QProduct { .. }, _) | (_, Value::QProduct { .. }) => {
       Err(EvalError::Other(format!(
           "cannot {} {} and {} -- qfactor result is a factorization, not a series",
           op_name, left.type_name(), right.type_name()
       )))
   }
   ```
   Where op_name is "add"/"subtract"/"multiply"/"divide" respectively. For eval_add/eval_sub/eval_mul/eval_div, use the same pattern as the JacobiProduct arms at lines ~1748, ~1865, and the mul/div equivalents. Note: `eval_mul` and `eval_div` don't use string op names -- they use the TypeError variant. Add the QProduct arms as `Err(EvalError::Other(...))` before the JacobiProduct arms.

5. Update ALL tests that match on `Value::Dict` for qfactor results. There are 4 tests to update:
   - `dispatch_qfactor_returns_dict_with_is_exact` (line ~7159): change `Value::Dict` match to `Value::QProduct { factors, scalar, is_exact }`, verify factors is non-empty BTreeMap, scalar is rational, is_exact is bool.
   - `integration_qfactor_qbin` (line ~7283): change `Value::Dict` match to `Value::QProduct { .. }` and assert the variant matches.
   - `dispatch_qfactor_2arg_integer` (line ~11105): change `Value::Dict` match to `Value::QProduct { factors, scalar, is_exact }`.
   - `dispatch_qfactor_2arg_symbol_still_works` (line ~11129): change `Value::Dict` match to `Value::QProduct { factors, scalar, is_exact }`.

   For all four, the new pattern is:
   ```rust
   if let Value::QProduct { factors, scalar, is_exact } = &val {
       assert!(!factors.is_empty(), "expected non-empty factors");
       // scalar and is_exact are accessible
   } else {
       panic!("expected QProduct, got {:?}", val);
   }
   ```

6. Add a new test for QProduct display formatting (integration test):
   ```rust
   #[test]
   fn integration_qfactor_displays_product_form() {
       use crate::parser::parse;
       use crate::format::format_value;
       let mut env = make_env();
       let stmts = parse("qfactor(aqprod(q, q, 5), q)").unwrap();
       let result = eval_stmt(&stmts[0], &mut env).unwrap().unwrap();
       let text = format_value(&result, &env.symbols);
       assert!(text.contains("(1-q)"), "expected (1-q) in: {}", text);
       assert!(text.contains("(1-q^5)"), "expected (1-q^5) in: {}", text);
       assert!(!text.contains("scalar"), "should not show raw dict: {}", text);
   }
   ```
  </action>
  <verify>Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass, no compile errors about non-exhaustive patterns.</verify>
  <done>Value::QProduct variant exists, q_factorization_to_value returns it, all 4 existing qfactor tests updated and passing, arithmetic error arms present, new integration test confirms product-form display.</done>
</task>

<task type="auto">
  <name>Task 2: Add QProduct format functions and update help</name>
  <files>crates/qsym-cli/src/format.rs, crates/qsym-cli/src/help.rs</files>
  <action>
1. In `format.rs`, add `format_qproduct()` function (after `format_jacobi_product`):
   ```rust
   /// Format a q-product factorization as human-readable string.
   /// Examples: "(1-q)(1-q^2)(1-q^3)^2", "3*(1-q)(1-q^2)", "1", "(1-q) (approx)"
   fn format_qproduct(factors: &BTreeMap<i64, i64>, scalar: &QRat, is_exact: bool) -> String {
       use std::cmp::Ordering;
       let mut out = String::new();

       if factors.is_empty() {
           return format!("{}", scalar);
       }

       // Handle scalar prefix
       let one = QRat::from(1);
       let neg_one = QRat::from(-1);
       if *scalar == neg_one {
           out.push('-');
       } else if *scalar != one {
           let _ = write!(out, "{}*", scalar);
       }

       // Factors in ascending order (BTreeMap guarantees this)
       for (&i, &mult) in factors {
           if i == 1 {
               out.push_str("(1-q)");
           } else {
               let _ = write!(out, "(1-q^{})", i);
           }
           if mult != 1 {
               if mult < 0 {
                   let _ = write!(out, "^({})", mult);
               } else {
                   let _ = write!(out, "^{}", mult);
               }
           }
       }

       if !is_exact {
           out.push_str(" (approx)");
       }

       out
   }
   ```
   Note: For QRat comparison, use the actual comparison approach from the codebase. Check how QRat equality works -- it should support `==` via PartialEq. If not, compare numer/denom directly. The key edge cases:
   - scalar == 1: omit prefix
   - scalar == -1: show "-" prefix
   - scalar == 0: show "0" (degenerate but handle)
   - other: show "scalar*" prefix

2. Add `format_qproduct_latex()` function:
   ```rust
   /// Format a q-product factorization as LaTeX.
   /// Examples: "(1-q)(1-q^{2})(1-q^{3})^{2}", "3 \cdot (1-q)(1-q^{2})"
   fn format_qproduct_latex(factors: &BTreeMap<i64, i64>, scalar: &QRat, is_exact: bool) -> String {
       let mut out = String::new();

       if factors.is_empty() {
           // Use LaTeX fraction for rational scalar
           return format_latex_qrat(scalar);
       }

       let one = QRat::from(1);
       let neg_one = QRat::from(-1);
       if *scalar == neg_one {
           out.push('-');
       } else if *scalar != one {
           let _ = write!(out, "{} \\cdot ", format_latex_qrat(scalar));
       }

       for (&i, &mult) in factors {
           if i == 1 {
               out.push_str("(1-q)");
           } else {
               let _ = write!(out, "(1-q^{{{}}})", i);
           }
           if mult != 1 {
               let _ = write!(out, "^{{{}}}", mult);
           }
       }

       if !is_exact {
           out.push_str("\\text{ (approx)}");
       }

       out
   }
   ```
   For `format_latex_qrat`, use the existing Rational LaTeX formatting pattern from the `format_latex` match arm for `Value::Rational` (lines ~807-820). Either extract a helper or inline the logic.

3. Add `use std::collections::BTreeMap;` to format.rs imports if not already present.

4. Add match arms in `format_value()` (line ~34):
   ```rust
   Value::QProduct { factors, scalar, is_exact } => format_qproduct(factors, scalar, *is_exact),
   ```

5. Add match arm in `format_latex()` (line ~803):
   ```rust
   Value::QProduct { factors, scalar, is_exact } => format_qproduct_latex(factors, scalar, *is_exact),
   ```

6. Add format tests in format.rs:
   ```rust
   #[test]
   fn format_qproduct_basic() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 1);
       factors.insert(2, 1);
       factors.insert(3, 1);
       let val = Value::QProduct { factors, scalar: QRat::from(1), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "(1-q)(1-q^2)(1-q^3)");
   }

   #[test]
   fn format_qproduct_with_exponents() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 2);
       factors.insert(3, -1);
       let val = Value::QProduct { factors, scalar: QRat::from(1), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "(1-q)^2(1-q^3)^(-1)");
   }

   #[test]
   fn format_qproduct_with_scalar() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 1);
       let val = Value::QProduct { factors, scalar: QRat::from(3), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "3*(1-q)");
   }

   #[test]
   fn format_qproduct_neg_one_scalar() {
       let mut factors = BTreeMap::new();
       factors.insert(2, 1);
       let val = Value::QProduct { factors, scalar: QRat::from(-1), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "-(1-q^2)");
   }

   #[test]
   fn format_qproduct_empty_factors() {
       let factors = BTreeMap::new();
       let val = Value::QProduct { factors, scalar: QRat::from(5), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "5");
   }

   #[test]
   fn format_qproduct_approx() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 1);
       let val = Value::QProduct { factors, scalar: QRat::from(1), is_exact: false };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "(1-q) (approx)");
   }

   #[test]
   fn format_qproduct_latex_basic() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 1);
       factors.insert(2, 3);
       let val = Value::QProduct { factors, scalar: QRat::from(1), is_exact: true };
       let symbols = SymbolRegistry::new();
       let text = format_latex(&val, &symbols);
       assert_eq!(text, "(1-q)(1-q^{2})^{3}");
   }
   ```

7. Update `help.rs` for qfactor (line ~325):
   - Change `description` to remove "Returns a dictionary with scalar, factors, and is_exact flag." and replace with "Returns a q-product factorization displayed as (1-q^i) factors."
   - Change `example_output` from `"{scalar: 1, factors: {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}, is_exact: true}"` to `"(1-q)(1-q^2)(1-q^3)(1-q^4)(1-q^5)"`
  </action>
  <verify>Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass including new format tests.</verify>
  <done>format_qproduct() and format_qproduct_latex() produce correct output for all edge cases (scalar=1, scalar=-1, other scalar, empty factors, exponents, approx). Help entry shows new format. LaTeX path works.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (including updated qfactor tests and new format tests)
2. Manual REPL test: `qfactor(aqprod(q,q,5), q)` displays `(1-q)(1-q^2)(1-q^3)(1-q^4)(1-q^5)`
3. `\latex` command after qfactor shows LaTeX notation
4. `?qfactor` help shows new example_output format
</verification>

<success_criteria>
- qfactor results display as `(1-q)(1-q^2)...` product form, not `{scalar: ..., factors: {...}}`
- LaTeX output uses proper q-product notation
- All existing tests updated and passing
- Edge cases handled: scalar=1 (omit), scalar=-1 (prefix -), exponents, empty factors, approx
</success_criteria>

<output>
After completion, create `.planning/phases/49-display-formatting/49-01-SUMMARY.md`
</output>
