---
phase: 49-display-formatting
plan: 02
type: execute
wave: 2
depends_on: [49-01]
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/format.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [FIX-04]
must_haves:
  truths:
    - "etamake(partition_gf(50),q,10) displays eta(tau)^(-1) not {factors: {1: -1}, q_shift: ...}"
    - "etamake with multiple factors shows eta(tau)^(-2) * eta(2*tau)^5 notation"
    - "etamake with non-zero q_shift shows q^(shift) * eta(...) prefix"
    - "LaTeX output for etamake uses \\eta(\\tau) notation"
    - "Arithmetic on EtaQuotient gives helpful error message"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "Value::EtaQuotient variant, eta_quotient_to_value returns EtaQuotient, arithmetic error arms"
      contains: "EtaQuotient"
    - path: "crates/qsym-cli/src/format.rs"
      provides: "format_eta_quotient() and format_eta_quotient_latex() functions"
      contains: "format_eta_quotient"
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Updated etamake example_output"
      contains: "eta(tau)"
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/format.rs"
      via: "Value::EtaQuotient match arm in format_value() and format_latex()"
      pattern: "EtaQuotient.*format_eta_quotient"
---

<objective>
Add `Value::EtaQuotient` variant to the Value enum so that `etamake()` results display as human-readable eta-notation like `eta(tau)^(-1)` or `eta(tau)^(-2) * eta(2*tau)^5 * eta(4*tau)^(-2)` instead of raw `{factors: {1: -1}, q_shift: 0}`.

Purpose: FIX-04 -- users see mathematical notation for eta-quotient results
Output: EtaQuotient variant with plain-text and LaTeX formatting, updated tests and help
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-display-formatting/49-RESEARCH.md
@.planning/phases/49-display-formatting/49-01-SUMMARY.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/format.rs
@crates/qsym-cli/src/help.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Value::EtaQuotient variant and update eval.rs</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
1. Add `Value::EtaQuotient` variant to the Value enum (after the `QProduct` variant added in Plan 01):
   ```rust
   /// Eta-quotient: prod eta(d*tau)^{r_d} * q^{q_shift}.
   /// Stores factors as BTreeMap<i64, i64> (d -> r_d).
   EtaQuotient {
       factors: BTreeMap<i64, i64>,
       q_shift: QRat,
   },
   ```

2. Add type_name match arm:
   ```rust
   Value::EtaQuotient { .. } => "eta_quotient",
   ```

3. Change `eta_quotient_to_value()` (around line 5081, after plan 01 shifts) to return `Value::EtaQuotient` instead of `Value::Dict`:
   ```rust
   fn eta_quotient_to_value(eq: &qseries::EtaQuotient) -> Value {
       Value::EtaQuotient {
           factors: eq.factors.clone(),
           q_shift: eq.q_shift.clone(),
       }
   }
   ```

4. Add arithmetic error arms in `eval_add`, `eval_sub`, `eval_mul`, `eval_div` -- place alongside the QProduct arms:
   ```rust
   (Value::EtaQuotient { .. }, _) | (_, Value::EtaQuotient { .. }) => {
       Err(EvalError::Other(format!(
           "cannot {} {} and {} -- etamake result is an eta-quotient, not a series",
           op_name, left.type_name(), right.type_name()
       )))
   }
   ```
   Use the same pattern as QProduct arms. For eval_mul and eval_div which may not use an op_name variable, use "multiply"/"divide" directly in the error message string.

5. Update the `dispatch_etamake_returns_dict` test (line ~7061):
   ```rust
   #[test]
   fn dispatch_etamake_returns_eta_quotient() {
       let mut env = make_env();
       let pgf = dispatch("partition_gf", &[Value::Integer(QInt::from(20i64))], &mut env).unwrap();
       let val = dispatch("etamake", &[
           pgf,
           Value::Symbol("q".to_string()),
           Value::Integer(QInt::from(10i64)),
       ], &mut env).unwrap();
       if let Value::EtaQuotient { factors, q_shift } = &val {
           assert!(!factors.is_empty(), "expected non-empty factors");
           // partition_gf is 1/(q;q)_inf so etamake should give eta(tau)^{-1}
           assert_eq!(factors.get(&1), Some(&-1), "expected factor 1 -> -1");
       } else {
           panic!("expected EtaQuotient, got {:?}", val);
       }
   }
   ```

6. Add a new integration test for EtaQuotient display formatting:
   ```rust
   #[test]
   fn integration_etamake_displays_eta_notation() {
       use crate::parser::parse;
       use crate::format::format_value;
       let mut env = make_env();
       let stmts = parse("etamake(partition_gf(50), q, 10)").unwrap();
       let result = eval_stmt(&stmts[0], &mut env).unwrap().unwrap();
       let text = format_value(&result, &env.symbols);
       assert!(text.contains("eta(tau)"), "expected eta(tau) in: {}", text);
       assert!(!text.contains("factors"), "should not show raw dict: {}", text);
   }
   ```
  </action>
  <verify>Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass, no compile errors about non-exhaustive patterns.</verify>
  <done>Value::EtaQuotient variant exists, eta_quotient_to_value returns it, etamake test updated and passing, arithmetic error arms present, new integration test confirms eta-notation display.</done>
</task>

<task type="auto">
  <name>Task 2: Add EtaQuotient format functions and update help</name>
  <files>crates/qsym-cli/src/format.rs, crates/qsym-cli/src/help.rs</files>
  <action>
1. In `format.rs`, add `format_eta_quotient()` function (after the `format_qproduct` functions from Plan 01):
   ```rust
   /// Format an eta-quotient as human-readable string.
   /// Examples: "eta(tau)^(-1)", "q^(1/24) * eta(tau)^(-2) * eta(2*tau)^5"
   fn format_eta_quotient(factors: &BTreeMap<i64, i64>, q_shift: &QRat) -> String {
       let mut parts = Vec::new();

       // q-shift prefix (if non-zero)
       let zero = QRat::from(0);
       if *q_shift != zero {
           let numer = q_shift.numer();
           let denom = q_shift.denom();
           if *denom == 1 {
               if *numer == 1 {
                   parts.push("q".to_string());
               } else {
                   parts.push(format!("q^{}", numer));
               }
           } else {
               parts.push(format!("q^({}/{})", numer, denom));
           }
       }

       // Eta factors in ascending d order (BTreeMap guarantees this)
       for (&d, &r_d) in factors {
           let eta_arg = if d == 1 {
               "tau".to_string()
           } else {
               format!("{}*tau", d)
           };
           if r_d == 1 {
               parts.push(format!("eta({})", eta_arg));
           } else {
               parts.push(format!("eta({})^({})", eta_arg, r_d));
           }
       }

       if parts.is_empty() {
           "1".to_string()
       } else {
           parts.join(" * ")
       }
   }
   ```
   Note: For QRat zero comparison, use `QRat::from(0)` and `==`, or check if `q_shift.numer()` is zero via `q_shift.0.cmp0() == Ordering::Equal`. Use whichever approach compiles. The numer/denom accessors are `.numer()` and `.denom()` returning `&rug::Integer`. Compare denom to 1 using `*denom == 1` or create a `rug::Integer::from(1)` for comparison.

2. Add `format_eta_quotient_latex()` function:
   ```rust
   /// Format an eta-quotient as LaTeX.
   /// Examples: "\\eta(\\tau)^{-1}", "q^{1/24} \\cdot \\eta(\\tau)^{-2} \\cdot \\eta(2\\tau)^{5}"
   fn format_eta_quotient_latex(factors: &BTreeMap<i64, i64>, q_shift: &QRat) -> String {
       let mut parts = Vec::new();

       let zero = QRat::from(0);
       if *q_shift != zero {
           let numer = q_shift.numer();
           let denom = q_shift.denom();
           if *denom == 1 {
               if *numer == 1 {
                   parts.push("q".to_string());
               } else {
                   parts.push(format!("q^{{{}}}", numer));
               }
           } else {
               parts.push(format!("q^{{{}/{}}}", numer, denom));
           }
       }

       for (&d, &r_d) in factors {
           let eta_arg = if d == 1 {
               "\\tau".to_string()
           } else {
               format!("{}\\tau", d)
           };
           if r_d == 1 {
               parts.push(format!("\\eta({})", eta_arg));
           } else {
               parts.push(format!("\\eta({})^{{{}}}", eta_arg, r_d));
           }
       }

       if parts.is_empty() {
           "1".to_string()
       } else {
           parts.join(" \\cdot ")
       }
   }
   ```

3. Add match arm in `format_value()`:
   ```rust
   Value::EtaQuotient { factors, q_shift } => format_eta_quotient(factors, q_shift),
   ```

4. Add match arm in `format_latex()`:
   ```rust
   Value::EtaQuotient { factors, q_shift } => format_eta_quotient_latex(factors, q_shift),
   ```

5. Add format tests in format.rs:
   ```rust
   #[test]
   fn format_eta_quotient_single() {
       let mut factors = BTreeMap::new();
       factors.insert(1, -1);
       let val = Value::EtaQuotient { factors, q_shift: QRat::from(0) };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "eta(tau)^(-1)");
   }

   #[test]
   fn format_eta_quotient_multiple() {
       let mut factors = BTreeMap::new();
       factors.insert(1, -2);
       factors.insert(2, 5);
       factors.insert(4, -2);
       let val = Value::EtaQuotient { factors, q_shift: QRat::from(0) };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "eta(tau)^(-2) * eta(2*tau)^5 * eta(4*tau)^(-2)");
   }

   #[test]
   fn format_eta_quotient_with_q_shift() {
       let mut factors = BTreeMap::new();
       factors.insert(1, 1);
       // q_shift = 1/24
       let q_shift = QRat(rug::Rational::from((1, 24)));
       let val = Value::EtaQuotient { factors, q_shift };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "q^(1/24) * eta(tau)");
   }

   #[test]
   fn format_eta_quotient_exponent_one() {
       let mut factors = BTreeMap::new();
       factors.insert(2, 1);
       let val = Value::EtaQuotient { factors, q_shift: QRat::from(0) };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "eta(2*tau)");
   }

   #[test]
   fn format_eta_quotient_empty() {
       let factors = BTreeMap::new();
       let val = Value::EtaQuotient { factors, q_shift: QRat::from(0) };
       let symbols = SymbolRegistry::new();
       let text = format_value(&val, &symbols);
       assert_eq!(text, "1");
   }

   #[test]
   fn format_eta_quotient_latex_basic() {
       let mut factors = BTreeMap::new();
       factors.insert(1, -2);
       factors.insert(2, 5);
       let val = Value::EtaQuotient { factors, q_shift: QRat::from(0) };
       let symbols = SymbolRegistry::new();
       let text = format_latex(&val, &symbols);
       assert_eq!(text, "\\eta(\\tau)^{-2} \\cdot \\eta(2\\tau)^{5}");
   }
   ```

6. Update `help.rs` for etamake (line ~339):
   - Change `description` to remove "Returns divisor-grouped exponents for eta(d*tau) factors." and replace with "Returns an eta-quotient displayed as eta(d*tau) factors."
   - Change `example_output` from `"{factors: {1: -1}, q_shift: 0, is_exact: true}"` to `"eta(tau)^(-1)"`
   Note: The old example_output mentions `is_exact: true` which is incorrect since EtaQuotient struct has no is_exact field. The new output fixes this inaccuracy.
  </action>
  <verify>Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cd /c/cygwin64/home/Owner/Kangaroo && cargo test -p qsym-cli 2>&1 | tail -5` -- all tests pass including new format tests.</verify>
  <done>format_eta_quotient() and format_eta_quotient_latex() produce correct output for all edge cases (single factor, multiple factors, q_shift, exponent=1, empty). Help entry shows new format. LaTeX path works.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (including updated etamake test and new format tests)
2. Manual REPL test: `etamake(partition_gf(50), q, 10)` displays `eta(tau)^(-1)` (since partition_gf = 1/(q;q)_inf)
3. `\latex` command after etamake shows `\eta(\tau)^{-1}` LaTeX notation
4. `?etamake` help shows new example_output format
</verification>

<success_criteria>
- etamake results display as `eta(tau)^(-1)` or `eta(tau)^(-2) * eta(2*tau)^5` notation, not `{factors: {...}, q_shift: ...}`
- LaTeX output uses `\eta(\tau)` notation
- All existing tests updated and passing
- Edge cases handled: single/multiple factors, q_shift, exponent=1, empty factors
</success_criteria>

<output>
After completion, create `.planning/phases/49-display-formatting/49-02-SUMMARY.md`
</output>
