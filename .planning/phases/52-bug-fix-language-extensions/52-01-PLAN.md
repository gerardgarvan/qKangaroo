---
phase: 52-bug-fix-language-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/lexer.rs
autonomous: true
requirements: [BUG-01, LANG-03, LANG-04]

must_haves:
  truths:
    - "1/aqprod(q,q,5) returns a series result without hanging"
    - "for n from 1 to 5 do q^n/aqprod(q,q,n) od completes in bounded time"
    - "Pasting Unicode math operators parses correctly instead of errors"
    - "print(expr) inside a for-loop displays each intermediate value"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "cap_poly_order helper, fixed eval_div, fixed series_div_general, print special-case"
      contains: "cap_poly_order"
    - path: "crates/qsym-cli/src/lexer.rs"
      provides: "Unicode normalization before tokenization"
      contains: "normalize_unicode"
  key_links:
    - from: "eval_div"
      to: "arithmetic::invert"
      via: "cap_poly_order helper caps POLYNOMIAL_ORDER before invert call"
      pattern: "cap_poly_order"
    - from: "eval_expr FuncCall"
      to: "format::format_value"
      via: "print special-case prints and returns last value"
      pattern: "\"print\""
    - from: "tokenize"
      to: "normalize_unicode"
      via: "called at start of tokenize before byte-level lexing"
      pattern: "normalize_unicode"
---

<objective>
Fix the POLYNOMIAL_ORDER division hang, add Unicode paste resilience, and add print() function.

Purpose: Three independent fixes that make the CLI usable for researchers running real Maple code with polynomial division, pasted Unicode, and intermediate output debugging.
Output: eval.rs with fixed division and print(), lexer.rs with Unicode normalization, plus tests for all three.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-bug-fix-language-extensions/52-RESEARCH.md
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/lexer.rs
@crates/qsym-cli/src/format.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix POLYNOMIAL_ORDER division hang in eval_div</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Fix the critical bug where dividing by a series with `truncation_order == POLYNOMIAL_ORDER` (1 billion) causes `arithmetic::invert()` to loop 1 billion times and hang.

1. Add a helper function `cap_poly_order` near the top of the division section (around line 2050):

```rust
/// Cap a series' truncation_order if it equals the POLYNOMIAL_ORDER sentinel.
/// Returns a truncated copy using `fallback` as the new order.
/// If the series is not POLYNOMIAL_ORDER, returns a clone unchanged.
fn cap_poly_order(fps: &FormalPowerSeries, fallback: i64) -> FormalPowerSeries {
    if fps.truncation_order() == POLYNOMIAL_ORDER {
        let mut coeffs = BTreeMap::new();
        for (&k, v) in fps.iter() {
            if k < fallback {
                coeffs.insert(k, v.clone());
            }
        }
        FormalPowerSeries::from_coeffs(fps.variable(), coeffs, fallback)
    } else {
        fps.clone()
    }
}
```

2. Fix the `(Value::Series(a), Value::Series(b))` arm in `eval_div` (line ~2052-2054):
   - Compute `effective_order`: if both are POLYNOMIAL_ORDER use `env.default_order`, if one is POLYNOMIAL_ORDER use the other's order, otherwise use `min(a,b)`.
   - Cap both a and b to effective_order before calling invert.
   - The result series should use effective_order as truncation.

```rust
(Value::Series(a), Value::Series(b)) => {
    let effective_order = match (a.truncation_order() == POLYNOMIAL_ORDER,
                                  b.truncation_order() == POLYNOMIAL_ORDER) {
        (true, true) => env.default_order,
        (true, false) => b.truncation_order(),
        (false, true) => a.truncation_order(),
        (false, false) => a.truncation_order().min(b.truncation_order()),
    };
    let a_work = cap_poly_order(a, effective_order);
    let b_work = cap_poly_order(b, effective_order);
    let inv = arithmetic::invert(&b_work);
    Ok(Value::Series(arithmetic::mul(&a_work, &inv)))
}
```

3. Fix the `(_, Value::Series(fps))` scalar/Series arm (line ~2076-2079):
   - If fps has POLYNOMIAL_ORDER, use env.default_order instead.

```rust
(_, Value::Series(fps)) if value_to_qrat(&left).is_some() => {
    let effective_order = if fps.truncation_order() == POLYNOMIAL_ORDER {
        env.default_order
    } else {
        fps.truncation_order()
    };
    let const_fps = value_to_constant_fps(&left, fps.variable(), effective_order).unwrap();
    let fps_work = cap_poly_order(fps, effective_order);
    let inv = arithmetic::invert(&fps_work);
    Ok(Value::Series(arithmetic::mul(&const_fps, &inv)))
}
```

4. Fix `series_div_general` (line ~2155-2175) to also cap POLYNOMIAL_ORDER before calling invert:
   - At the two `arithmetic::invert()` calls (lines ~2167 and ~2173), wrap the argument with cap_poly_order using the numerator's truncation_order as fallback (or 20 if numer is also POLYNOMIAL_ORDER).

```rust
fn series_div_general(numer: &FormalPowerSeries, denom_fps: &FormalPowerSeries) -> FormalPowerSeries {
    if let Some(min_ord) = denom_fps.min_order() {
        if denom_fps.num_nonzero() == 1 {
            let c = denom_fps.coeff(min_ord);
            let inv_c = QRat::one() / c;
            let shifted = arithmetic::shift(numer, -min_ord);
            return arithmetic::scalar_mul(&inv_c, &shifted);
        }
        if min_ord != 0 {
            let shifted_denom = arithmetic::shift(denom_fps, -min_ord);
            let fallback = if numer.truncation_order() == POLYNOMIAL_ORDER { 20 } else { numer.truncation_order() };
            let capped = cap_poly_order(&shifted_denom, fallback);
            let inv = arithmetic::invert(&capped);
            let shifted_numer = arithmetic::shift(numer, -min_ord);
            return arithmetic::mul(&shifted_numer, &inv);
        }
    }
    let fallback = if numer.truncation_order() == POLYNOMIAL_ORDER { 20 } else { numer.truncation_order() };
    let capped = cap_poly_order(denom_fps, fallback);
    let inv = arithmetic::invert(&capped);
    arithmetic::mul(numer, &inv)
}
```

5. Add tests at the bottom of eval.rs tests:
   - Test `1/aqprod(q,q,5)` completes and returns a series (not hang).
   - Test `cap_poly_order` with POLYNOMIAL_ORDER input produces capped output.
   - Test Series/Series division where one side is POLYNOMIAL_ORDER.
   - Test that normal (non-POLYNOMIAL_ORDER) divisions still work correctly.
  </action>
  <verify>
Run `cargo test --lib -p qsym-cli` -- all existing tests pass plus new division tests pass. Specifically look for the new poly-order-cap tests.
  </verify>
  <done>
`1/aqprod(q,q,5)` completes in bounded time (test runs in under 1 second), `cap_poly_order` correctly replaces POLYNOMIAL_ORDER with fallback, and existing division tests remain green.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Unicode normalization to lexer</name>
  <files>crates/qsym-cli/src/lexer.rs</files>
  <action>
Add a Unicode normalization pass at the start of `tokenize()` so that pasted Unicode math operators are silently replaced with their ASCII equivalents before byte-level lexing.

1. Add a `normalize_unicode` function before the `tokenize` function:

```rust
/// Replace common Unicode math operator lookalikes with ASCII equivalents.
/// This allows text pasted from PDFs and papers to parse correctly.
fn normalize_unicode(input: &str) -> String {
    input
        .replace('\u{2227}', "^")   // LOGICAL AND -> caret
        .replace('\u{00B7}', "*")   // MIDDLE DOT -> star
        .replace('\u{2212}', "-")   // MINUS SIGN -> hyphen-minus
        .replace('\u{00D7}', "*")   // MULTIPLICATION SIGN -> star
        .replace('\u{2013}', "-")   // EN DASH -> hyphen-minus
        .replace('\u{2014}', "-")   // EM DASH -> hyphen-minus
        .replace('\u{2018}', "'")   // LEFT SINGLE QUOTATION -> apostrophe
        .replace('\u{2019}', "'")   // RIGHT SINGLE QUOTATION -> apostrophe
        .replace('\u{201C}', "\"")  // LEFT DOUBLE QUOTATION -> double quote
        .replace('\u{201D}', "\"")  // RIGHT DOUBLE QUOTATION -> double quote
}
```

2. Modify the start of `tokenize()` to normalize input before byte-level processing:
   - Change `let bytes = input.as_bytes();` to:
   ```rust
   let normalized = normalize_unicode(input);
   let bytes = normalized.as_bytes();
   ```
   - Update the `source` field construction at the end: anywhere the function builds error messages or stores `input` as the source string, use `&normalized` instead.
   - The `Eof` token at the end uses `input.len()` for its span -- change to `normalized.len()`.

3. Add tests at the bottom of lexer.rs tests:
   - Test that `normalize_unicode` replaces all 10 Unicode chars correctly.
   - Test that `tokenize("q\u{2227}5")` produces `[Ident("q"), Caret, Integer(5), Eof]`.
   - Test that `tokenize("3 \u{00D7} 5")` produces `[Integer(3), Star, Integer(5), Eof]`.
   - Test that `tokenize("x \u{2212} 1")` produces `[Ident("x"), Minus, Integer(1), Eof]`.
   - Test that mixed Unicode and ASCII in same expression works.
   - Test that strings containing Unicode operators are NOT normalized (they're inside string delimiters handled before normalization, but since normalization happens first, the string content will be normalized -- this is acceptable behavior, document in test comment).
  </action>
  <verify>
Run `cargo test --lib -p qsym-cli` -- all existing lexer tests pass plus new Unicode normalization tests pass.
  </verify>
  <done>
Unicode operator characters (logical-and, middle-dot, minus-sign, multiplication-sign, en-dash, em-dash, smart quotes) are all normalized to ASCII before tokenization, and tests confirm correct token sequences.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add print() special-case function</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add `print()` as a special-case function in the `eval_expr` FuncCall match section, similar to how RETURN and subs are handled. The function needs access to `env.symbols` for `format_value()`, which is why it cannot go through `dispatch()`.

1. In `eval_expr`, in the `AstNode::FuncCall { name, args }` match arm, add a `print` special case AFTER the `subs` block (around line 1119) and BEFORE the procedure/dispatch section:

```rust
// Special-case: print(expr, ...) displays intermediate results
if name == "print" {
    if args.is_empty() {
        return Err(EvalError::WrongArgCount {
            function: "print".to_string(),
            expected: "at least 1".to_string(),
            got: 0,
            signature: "print(expr, ...)".to_string(),
        });
    }
    let mut last_val = Value::None;
    for arg in args {
        let val = eval_expr(arg, env)?;
        println!("{}", crate::format::format_value(&val, &env.symbols));
        last_val = val;
    }
    return Ok(last_val);
}
```

2. Add tests in the eval.rs test module:
   - Test that `print` with zero args returns WrongArgCount error.
   - Test that `print(42)` returns `Value::Integer(42)` (the return value, not the printed output -- stdout testing is tricky in unit tests, so just verify the return value).
   - Test that `print` with multiple args returns the last arg's value.
   - Test that `print` works with series values (returns the series).

Note: Do NOT add "print" to ALL_FUNCTION_NAMES or dispatch(). It is a special-case handled before dispatch, just like RETURN and subs. Do NOT add "print" to the repl keyword_names -- it is a function, not a keyword. It will be added to the function completion list in Phase 56 (Documentation).
  </action>
  <verify>
Run `cargo test --lib -p qsym-cli` -- all existing tests pass plus new print tests pass.
  </verify>
  <done>
`print(expr)` evaluates and displays its argument using format_value, returns the last value, and errors on zero arguments. Works inside for-loops and procedures because it uses println! directly.
  </done>
</task>

</tasks>

<verification>
Run the full CLI test suite:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib -p qsym-cli
```

All existing tests pass. New tests for:
- POLYNOMIAL_ORDER division capping (BUG-01)
- Unicode normalization (LANG-03)
- print() special-case (LANG-04)
</verification>

<success_criteria>
1. Division by exact polynomials (POLYNOMIAL_ORDER sentinel) completes in bounded time
2. Unicode operator characters are silently normalized to ASCII before tokenization
3. print() displays values during execution and returns the last value
4. All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/52-bug-fix-language-extensions/52-01-SUMMARY.md`
</output>
