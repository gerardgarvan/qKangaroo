---
phase: 52-bug-fix-language-extensions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/src/help.rs
autonomous: true
requirements: [LANG-01]

must_haves:
  truths:
    - "i:=0: while i<10 do i:=i+1 od: i; evaluates to 10"
    - "While-loops work with all comparison operators (=, <>, <, >, <=, >=)"
    - "while true do ... od with a million iterations hits safety limit and errors"
    - "Nested while inside for and if works correctly"
    - "REPL multi-line input detects unclosed while...od as incomplete"
  artifacts:
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode::WhileLoop variant"
      contains: "WhileLoop"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "While-loop parsing in expr_bp prefix section"
      contains: "Token::While"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "eval_while_loop function with 1M iteration safety limit"
      contains: "eval_while_loop"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "while keyword in is_incomplete and keyword_names"
      contains: "\"while\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "Help entry for while keyword"
      contains: "\"while\""
  key_links:
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "Token::While case in expr_bp creates AstNode::WhileLoop"
      pattern: "AstNode::WhileLoop"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "eval_while_loop"
      via: "AstNode::WhileLoop match arm calls eval_while_loop"
      pattern: "eval_while_loop"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "is_truthy"
      via: "eval_while_loop uses is_truthy for condition checking"
      pattern: "is_truthy"
---

<objective>
Add while-loop support (`while...do...od`) to the q-Kangaroo scripting language.

Purpose: Researchers need while-loops for algorithms where the iteration count is not known in advance (convergence loops, search loops). The Token::While already exists in the lexer; this plan wires it through parser, AST, evaluator, and REPL.
Output: Working while-loop with safety limit, REPL multiline support, help entry, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/agents/gsd-executor.md
@C:/Users/Owner/.claude/agents/gsd-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-bug-fix-language-extensions/52-RESEARCH.md
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
@crates/qsym-cli/src/repl.rs
@crates/qsym-cli/src/help.rs
@crates/qsym-cli/src/token.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WhileLoop AST node and parser support</name>
  <files>crates/qsym-cli/src/ast.rs, crates/qsym-cli/src/parser.rs</files>
  <action>
1. In `ast.rs`, add a `WhileLoop` variant to the `AstNode` enum, right after the `ForLoop` variant (line ~107):

```rust
/// While loop: `while condition do body od`.
WhileLoop {
    condition: Box<AstNode>,
    body: Vec<Stmt>,
},
```

2. In `parser.rs`, add a `Token::While` case in the `expr_bp` prefix match section. Place it right after the `Token::For` case (after line ~243, before `Token::Proc`). Mirror the for-loop pattern but simpler (no var/from/to/by):

```rust
Token::While => {
    self.advance(); // consume 'while'
    let condition = self.expr_bp(0)?;
    self.expect(&Token::Do, "'do' after while condition")?;
    let body = self.parse_stmt_sequence(&[Token::Od])?;
    self.expect(&Token::Od, "'od' to close while loop")?;
    AstNode::WhileLoop {
        condition: Box::new(condition),
        body,
    }
}
```

3. Add parser tests:
   - Test parsing `while x < 10 do x := x + 1 od` produces `AstNode::WhileLoop` with Compare condition and Assign body.
   - Test parsing `while true do x od` with boolean literal condition.
   - Test nested `while x > 0 do if x = 1 then x := 0 fi: x := x - 1 od` parses correctly.
   - Test error: `while x < 10 do x` (missing `od`) produces parse error.

4. Add AST tests in ast.rs:
   - Test `AstNode::WhileLoop` construction and field access.
  </action>
  <verify>
Run `cargo test --lib -p qsym-cli` -- all existing parser/AST tests pass plus new while-loop parser tests pass.
  </verify>
  <done>
`AstNode::WhileLoop` variant exists, parser correctly parses `while...do...od` syntax mirroring the for-loop pattern, and tests confirm correct AST construction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add while-loop evaluation, REPL support, and help</name>
  <files>crates/qsym-cli/src/eval.rs, crates/qsym-cli/src/repl.rs, crates/qsym-cli/src/help.rs</files>
  <action>
1. In `eval.rs`, add an `eval_while_loop` function in the control flow section (after `eval_for_loop`, around line ~1531):

```rust
/// Evaluate a while-loop.
///
/// Repeatedly evaluates the condition and executes the body while the condition
/// is truthy. Returns the value of the last body execution, or Value::None if
/// the loop body never executes.
///
/// Includes a safety limit of 1,000,000 iterations to prevent infinite loops.
fn eval_while_loop(
    condition: &AstNode,
    body: &[Stmt],
    env: &mut Environment,
) -> Result<Value, EvalError> {
    let mut last = Value::None;
    let max_iterations = 1_000_000;
    let mut count = 0u64;
    loop {
        let cond_val = eval_expr(condition, env)?;
        if !is_truthy(&cond_val)? {
            break;
        }
        last = eval_stmt_sequence(body, env)?;
        count += 1;
        if count >= max_iterations {
            return Err(EvalError::Other(
                "while loop exceeded maximum iteration count (1000000)".into()
            ));
        }
    }
    Ok(last)
}
```

Note: Unlike for-loops, while-loops do NOT introduce a new scope or save/restore any variable. They use whatever variables the condition and body reference directly.

2. In `eval_expr`, add the match arm for `AstNode::WhileLoop` right after the `AstNode::ForLoop` arm (after line ~1181):

```rust
AstNode::WhileLoop { condition, body } => {
    eval_while_loop(condition, body, env)
}
```

3. In `repl.rs`, update `is_incomplete` to track while-loop depth:
   - Add `let mut while_depth: i32 = 0;` alongside the existing `for_depth`, `if_depth`, `proc_depth` (line ~184).
   - In `check_keyword`, add: `"while" => *while_depth += 1,` (note: `od` already decrements `for_depth`, but while-loops also use `od` as terminator, so we need to handle this. Actually, the current code uses `"od" => *for_depth -= 1`. Since while also uses od, we need a combined depth. The simplest fix: rename `for_depth` to `do_depth` and have both `"for"` and `"while"` increment it, with `"od"` decrementing it.)

   Actually, simpler approach: modify `check_keyword` to accept a `while_depth` parameter too:
   ```rust
   fn check_keyword(word: &str, for_depth: &mut i32, if_depth: &mut i32, proc_depth: &mut i32) {
       match word {
           "for" | "while" => *for_depth += 1,
           "od" => *for_depth -= 1,
           "if" => *if_depth += 1,
           "fi" => *if_depth -= 1,
           "proc" => *proc_depth += 1,
           "end" => *proc_depth -= 1,
           _ => {}
       }
   }
   ```
   This is the cleanest approach: both `for` and `while` are closed by `od`, so they share the same depth counter. No signature change needed, just add `"while"` to the `"for"` match arm.

4. In `repl.rs`, add `"while"` to the `keyword_names` vec (around line 44-50):
   ```rust
   keyword_names: vec![
       "for", "from", "to", "by", "do", "od",
       "while",
       "if", "then", "elif", "else", "fi",
       "proc", "local", "end",
       "RETURN",
       "and", "or", "not",
   ],
   ```

5. In `help.rs`, add a help entry for `"while"` in the `function_help` match, right after the `"for"` entry:

```rust
"while" => return Some(String::from(
    "while condition do body od\n\n\
     \x20 Execute body repeatedly while condition is true.\n\
     \x20 Condition is re-evaluated before each iteration.\n\
     \x20 Body statements are separated by ; or :\n\n\
     \x20 Safety limit: 1,000,000 iterations maximum.\n\n\
     \x20 Examples:\n\
     \x20   i:=0: while i<10 do i:=i+1 od: i;\n\
     \x20   => 10\n\n\
     \x20   x:=1: while x<100 do x:=x*2 od: x;\n\
     \x20   => 128\n\n\
     \x20 See also: for, if"
)),
```

6. Add eval tests:
   - Test `i:=0: while i<10 do i:=i+1 od: i` evaluates to 10.
   - Test `x:=1: while x<100 do x:=x*2 od: x` evaluates to 128.
   - Test while-loop with zero iterations: `while false do 42 od` returns Value::None.
   - Test while-loop safety limit: construct a `while true do 1 od` and verify it returns an error containing "maximum iteration count".
   - Test while with all comparison operators: `<`, `>`, `<=`, `>=`, `=`, `<>`.
   - Test nested while inside for-loop.

7. Add repl tests:
   - Test `is_incomplete("while x < 10 do")` returns true.
   - Test `is_incomplete("while x < 10 do x od")` returns false.
   - Test `is_incomplete("for n from 1 to 3 do while x > 0 do x od")` returns true (for still open).
   - Test `is_incomplete("for n from 1 to 3 do while x > 0 do x od od")` returns false.

8. Add help test:
   - Test `function_help("while")` returns Some and contains "while condition do".
  </action>
  <verify>
Run `cargo test --lib -p qsym-cli` -- all existing tests pass plus new while-loop eval/repl/help tests pass.
  </verify>
  <done>
`while...do...od` loops work with all comparison operators, have a 1M iteration safety limit, REPL correctly detects incomplete while blocks for multi-line input, tab completion includes "while", and `?while` shows help text.
  </done>
</task>

</tasks>

<verification>
Run the full CLI test suite:
```bash
export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH"
cargo test --lib -p qsym-cli
```

All existing tests pass. New tests for:
- WhileLoop AST construction
- While-loop parsing (basic, nested, error cases)
- While-loop evaluation (basic, zero iterations, safety limit, all comparison ops)
- REPL is_incomplete for while/od blocks
- Help entry for while keyword
</verification>

<success_criteria>
1. `i:=0: while i<10 do i:=i+1 od: i;` evaluates to 10
2. While-loops work with all comparison operators (<, >, <=, >=, =, <>)
3. Infinite loops hit safety limit (1M iterations) and produce clear error
4. REPL multi-line input correctly detects unclosed while blocks
5. `?while` shows help text with syntax and examples
6. All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/52-bug-fix-language-extensions/52-02-SUMMARY.md`
</output>
