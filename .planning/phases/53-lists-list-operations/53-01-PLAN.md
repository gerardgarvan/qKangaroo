---
phase: 53-lists-list-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/ast.rs
  - crates/qsym-cli/src/parser.rs
  - crates/qsym-cli/src/eval.rs
autonomous: true
requirements: [LANG-02]

must_haves:
  truths:
    - "L := [1, 2, 3]; L[2] returns 2 (1-indexed Maple convention)"
    - "L[0] and L[4] on a 3-element list produce clear out-of-range errors"
    - "X[1] := 42; X[1] still works for table-style indexed variables (backward compat)"
    - "expr[i] works with arbitrary expression on the left (not just variables)"
    - "L[i] works with non-literal index expressions (e.g., L[n+1])"
  artifacts:
    - path: "crates/qsym-cli/src/ast.rs"
      provides: "AstNode::Index and AstNode::IndexAssign variants"
      contains: "Index"
    - path: "crates/qsym-cli/src/parser.rs"
      provides: "Subscript parsing emitting AstNode::Index instead of Variable(\"X[1]\")"
      contains: "AstNode::Index"
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "eval_expr handler for AstNode::Index (list indexing) and AstNode::IndexAssign"
      contains: "AstNode::Index"
  key_links:
    - from: "crates/qsym-cli/src/parser.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "Parser emits AstNode::Index for all X[i] syntax"
      pattern: "AstNode::Index"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "crates/qsym-cli/src/ast.rs"
      via: "eval_expr matches AstNode::Index and AstNode::IndexAssign"
      pattern: "AstNode::Index.*=>|AstNode::IndexAssign.*=>"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "Value::List"
      via: "Index handler checks if base is a list, then extracts element at i-1"
      pattern: "Value::List.*items"
---

<objective>
Add AstNode::Index to the AST and refactor the parser's subscript handling to emit it, replacing the string-munged Variable("X[1]") pattern. Update the evaluator to handle list indexing (1-indexed) and indexed assignment, with backward compatibility for table-style X[1] := 5 access.

Purpose: Enable `L := [1,2,3]; L[2]` to return 2 -- the core requirement for lists as first-class values (LANG-02). Without this, subscript access only works for literal variable name lookup, not runtime list values.

Output: Working list indexing with full backward compatibility for indexed variable assignment.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-lists-list-operations/53-RESEARCH.md
@crates/qsym-cli/src/ast.rs
@crates/qsym-cli/src/parser.rs
@crates/qsym-cli/src/eval.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AstNode::Index and AstNode::IndexAssign, refactor parser subscript handling</name>
  <files>crates/qsym-cli/src/ast.rs, crates/qsym-cli/src/parser.rs</files>
  <action>
**ast.rs changes:**

1. Add two new variants to the `AstNode` enum:

```rust
/// Subscript/index access: `expr[index]`.
Index {
    expr: Box<AstNode>,
    index: Box<AstNode>,
},
/// Indexed assignment: `expr[index] := value`.
IndexAssign {
    name: String,
    index: Box<AstNode>,
    value: Box<AstNode>,
},
```

Place `Index` after `List` and `IndexAssign` after `Index` for logical grouping.

2. Add a unit test `ast_index_construction` that creates an `AstNode::Index` and verifies its fields.

**parser.rs changes:**

3. Refactor the subscript section in `expr_bp` (around line 347-366). Currently:
```rust
if *self.peek() == Token::LBracket {
    if 19 < min_bp { break; }
    if let AstNode::Variable(ref name) = lhs {
        // ... string-munges to Variable("X[1]")
    }
    break;
}
```

Replace with:
```rust
if *self.peek() == Token::LBracket {
    if 19 < min_bp { break; }
    self.advance(); // consume [
    let index = self.expr_bp(0)?;
    self.expect(&Token::RBracket, "']' to close subscript")?;
    lhs = AstNode::Index {
        expr: Box::new(lhs),
        index: Box::new(index),
    };
    continue;
}
```

Key differences from old code:
- Works with ANY lhs expression, not just `AstNode::Variable`
- Allows arbitrary index expressions (not just integer literals)
- Emits `AstNode::Index` instead of `Variable("X[1]")`

4. Refactor the assignment section (around line 368-384). Currently it only matches `AstNode::Variable(name)` on the left side of `:=`. Add a second arm that matches `AstNode::Index`:

```rust
if *self.peek() == Token::Assign {
    if 2 < min_bp { break; }
    match lhs {
        AstNode::Variable(name) => {
            self.advance(); // consume :=
            let value = self.expr_bp(1)?;
            lhs = AstNode::Assign {
                name,
                value: Box::new(value),
            };
            continue;
        }
        AstNode::Index { expr, index } => {
            // IndexAssign: L[i] := value
            if let AstNode::Variable(name) = *expr {
                self.advance(); // consume :=
                let value = self.expr_bp(1)?;
                lhs = AstNode::IndexAssign {
                    name,
                    index,
                    value: Box::new(value),
                };
                continue;
            } else {
                let span = self.peek_span();
                return Err(ParseError::new(
                    "left side of ':=' must be a variable or indexed variable".to_string(),
                    span,
                ));
            }
        }
        _ => {
            let span = self.peek_span();
            return Err(ParseError::new(
                "left side of ':=' must be a variable or indexed variable".to_string(),
                span,
            ));
        }
    }
}
```

5. Add parser tests:
- `parse_list_indexing`: `parse("L[2]")` produces `AstNode::Index { expr: Variable("L"), index: Integer(2) }`
- `parse_index_assign`: `parse("L[1] := 5")` produces `AstNode::IndexAssign { name: "L", index: Integer(1), value: Integer(5) }`
- `parse_expression_index`: `parse("[1,2,3][2]")` produces `AstNode::Index { expr: List([...]), index: Integer(2) }`
- `parse_nested_index`: `parse("X[1]")` still parses successfully (no longer Variable("X[1]"), now Index)
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli ast:: -- --nocapture 2>&1 | tail -20` and `cargo test -p qsym-cli parse_ -- --nocapture 2>&1 | tail -30` to verify AST and parser tests pass.
  </verify>
  <done>
AstNode::Index and AstNode::IndexAssign exist in ast.rs. Parser emits AstNode::Index for all `expr[index]` syntax and AstNode::IndexAssign for `name[index] := value`. No more Variable("X[1]") string munging. All new and existing parser tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Evaluator handlers for Index and IndexAssign with backward compatibility</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
**Add AstNode::Index handler in eval_expr** (after the AstNode::List handler, around line 1058):

```rust
AstNode::Index { expr, index } => {
    let base = eval_expr(expr, env)?;
    let idx_val = eval_expr(index, env)?;
    let i = match &idx_val {
        Value::Integer(n) => n.0.to_i64().ok_or_else(|| EvalError::Other(
            "index too large".to_string()
        ))?,
        _ => return Err(EvalError::Other(
            format!("index must be an integer, got {}", idx_val.type_name())
        )),
    };
    match base {
        Value::List(items) => {
            // Maple uses 1-indexing
            if i < 1 || i as usize > items.len() {
                return Err(EvalError::Other(format!(
                    "list index {} out of range (list has {} elements)",
                    i, items.len()
                )));
            }
            Ok(items[(i - 1) as usize].clone())
        }
        Value::Symbol(ref name) => {
            // Backward compat: if X is unbound (became Symbol), fall back to
            // looking up "X[i]" as a variable name (table-style indexed variables)
            let key = format!("{}[{}]", name, i);
            match env.get_var(&key) {
                Some(val) => Ok(val.clone()),
                None => Err(EvalError::Other(format!(
                    "cannot index into symbol '{}' (not a list, and '{}' is not defined)",
                    name, key
                ))),
            }
        }
        _ => Err(EvalError::Other(format!(
            "cannot index into {}", base.type_name()
        ))),
    }
}
```

**Add AstNode::IndexAssign handler in eval_expr** (right after the Index handler):

```rust
AstNode::IndexAssign { name, index, value } => {
    let idx_val = eval_expr(index, env)?;
    let i = match &idx_val {
        Value::Integer(n) => n.0.to_i64().ok_or_else(|| EvalError::Other(
            "index too large".to_string()
        ))?,
        _ => return Err(EvalError::Other(
            format!("index must be an integer, got {}", idx_val.type_name())
        )),
    };
    let val = eval_expr(value, env)?;

    // Check if name is currently a list
    if let Some(Value::List(ref items)) = env.get_var(name) {
        // Mutate list element in place
        if i < 1 || i as usize > items.len() {
            return Err(EvalError::Other(format!(
                "list index {} out of range (list has {} elements)",
                i, items.len()
            )));
        }
        let mut new_items = items.clone();
        new_items[(i - 1) as usize] = val.clone();
        env.set_var(name, Value::List(new_items));
    } else {
        // Fall back to table-style: set "name[i]" as a variable
        let key = format!("{}[{}]", name, i);
        env.set_var(&key, val.clone());
    }
    Ok(val)
}
```

**Update the existing `subs_indexed_variable` test** (around line 11774) to work with the new Index semantics. The test currently checks `env.get_var("X[1]")` after parsing `X[1] := 42; X[1]`. After the refactor, `X[1] := 42` where X is not a list will still fall back to setting `"X[1]"` in the environment. So the test should still pass. Verify this is the case; if not, adjust the test to check the actual behavior (evaluating `X[1]` should still return 42).

**Add new tests:**

1. `eval_list_indexing`: Create `L := [10, 20, 30]; L[1]` returns 10, `L[2]` returns 20, `L[3]` returns 30.
2. `eval_list_index_out_of_range`: `L := [1, 2]; L[3]` returns error.
3. `eval_list_index_zero`: `L := [1, 2]; L[0]` returns error.
4. `eval_list_index_assign`: `L := [1, 2, 3]; L[2] := 99; L[2]` returns 99.
5. `eval_table_style_backward_compat`: `X[1] := 42; X[1]` returns 42 (X not previously defined as list -- falls back to table-style).
6. `eval_list_literal_index`: `[10, 20, 30][2]` returns 20 (direct indexing into list literal).
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli -- --nocapture 2>&1 | tail -30` to verify ALL tests pass, including the backward-compatible `subs_indexed_variable` test.
  </verify>
  <done>
`L := [1,2,3]; L[2]` returns `2`. `X[1] := 42; X[1]` still returns `42` for table-style variables. `L[2] := 99` mutates a list in place. Out-of-range and zero indices produce clear errors. All existing tests still pass (backward compatibility maintained).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (0 failures)
2. Manual check: `echo "L := [1,2,3]; L[2];" | cargo run -p qsym-cli --` outputs `2`
3. Manual check: `echo "X[1] := 42; X[1];" | cargo run -p qsym-cli --` outputs `42` (backward compat)
4. Manual check: `echo "[10,20,30][2];" | cargo run -p qsym-cli --` outputs `20` (literal index)
</verification>

<success_criteria>
- AstNode::Index and AstNode::IndexAssign exist in ast.rs
- Parser emits Index for all `expr[index]` patterns (no more Variable("X[1]") string munging)
- `L := [1,2,3]; L[2]` returns 2 (1-indexed, Maple convention)
- `X[1] := 42; X[1]` still works (backward compat)
- All existing tests pass without modification (or with minimal backward-compat adjustment)
</success_criteria>

<output>
After completion, create `.planning/phases/53-lists-list-operations/53-01-SUMMARY.md`
</output>
