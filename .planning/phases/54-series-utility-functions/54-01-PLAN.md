---
phase: 54-series-utility-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/qsym-cli/src/eval.rs
  - crates/qsym-cli/src/help.rs
  - crates/qsym-cli/src/repl.rs
  - crates/qsym-cli/tests/cli_integration.rs
autonomous: true
requirements: [SERIES-01, SERIES-02, SERIES-03, UTIL-01, UTIL-02, UTIL-03, UTIL-04]

must_haves:
  truths:
    - "coeff(aqprod(q,q,inf), q, 5) extracts the coefficient of q^5 from a series"
    - "coeff(42, q, 0) returns 42 and coeff(42, q, 1) returns 0 (constant handling)"
    - "degree(1+q+q^2, q) returns 2"
    - "numer(3/4) returns 3 and denom(3/4) returns 4"
    - "numer(42) returns 42 and denom(42) returns 1"
    - "modp(7, 3) returns 1 and modp(-7, 3) returns 2 (always non-negative)"
    - "mods(7, 3) returns 1 and mods(5, 3) returns -1 (symmetric mod)"
    - "type(42, integer) returns true and type(aqprod(q,q,inf), series) returns true"
    - "evalb(3 > 2) returns true and evalb(0) returns false"
    - "cat(a, b, c) returns abc as a symbol"
  artifacts:
    - path: "crates/qsym-cli/src/eval.rs"
      provides: "9 new dispatch arms: coeff, degree, numer, denom, modp, mods, type, evalb, cat"
      contains: "\"coeff\""
    - path: "crates/qsym-cli/src/help.rs"
      provides: "9 new FUNC_HELP entries, updated general_help categories"
      contains: "coeff"
    - path: "crates/qsym-cli/src/repl.rs"
      provides: "9 new tab completion entries"
      contains: "\"coeff\""
  key_links:
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qsym_core::series::FormalPowerSeries::coeff()"
      via: "fps.coeff(n) in coeff dispatch arm"
      pattern: "fps\\.coeff\\("
    - from: "crates/qsym-cli/src/eval.rs"
      to: "qsym_core::qseries::qdegree()"
      via: "qseries::qdegree(&fps) in degree dispatch arm"
      pattern: "qdegree"
    - from: "crates/qsym-cli/src/eval.rs"
      to: "QRat::numer()/denom()"
      via: "r.numer()/r.denom() in numer/denom dispatch arms"
      pattern: "r\\.numer\\(\\)|r\\.denom\\(\\)"
---

<objective>
Add 9 Maple-compatible functions to the CLI evaluator: coeff, degree, numer, denom, modp, mods, type, evalb, and cat.

Purpose: Researchers need to extract series coefficients (coeff/degree), decompose rationals (numer/denom), do modular arithmetic (modp/mods), check types (type), evaluate booleans (evalb), and concatenate names (cat) -- all standard Maple built-ins used in q-series research scripts.

Output: All 9 functions working with dispatch arms, help entries, tab completion, and tests.
</objective>

<execution_context>
@C:/Users/Owner/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-series-utility-functions/54-RESEARCH.md
@.planning/phases/53-lists-list-operations/53-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 9 dispatch arms, signatures, and ALL_FUNCTION_NAMES</name>
  <files>crates/qsym-cli/src/eval.rs</files>
  <action>
Add a new section in `dispatch()` between the "sort" arm (~line 5432) and the "Unknown function" catch-all (~line 5434), with the header:

```rust
// =================================================================
// Series Coefficient & Utility Functions
// =================================================================
```

Add these 9 dispatch arms following the research code examples exactly:

1. **coeff(f, q, n)** -- `expect_args(name, args, 3)`. Match `args[0]`: for `Value::Series(fps)`, extract symbol via `extract_symbol_id(name, args, 1, env)`, extract n via `extract_i64(name, args, 2)`. Guard `n < fps.truncation_order()` (error if beyond). Call `fps.coeff(n)`, return Integer if denom==1 else Rational. For `Value::Integer(n_val)`, if exponent==0 return the value, else return 0. Same for `Value::Rational`. Error on other types.

2. **degree(f, q)** -- `expect_args(name, args, 2)`. Extract symbol. For `Value::Series(fps)`, call `qseries::qdegree(fps)` -- Some(d) returns Integer(d), None returns Integer(0). For Integer/Rational return 0. Error on other types.

3. **numer(f)** -- `expect_args(name, args, 1)`. For Rational: `Integer(QInt(r.numer().clone()))`. For Integer: return as-is. Error on other types.

4. **denom(f)** -- `expect_args(name, args, 1)`. For Rational: `Integer(QInt(r.denom().clone()))`. For Integer: return Integer(1). Error on other types.

5. **modp(a, p)** -- `expect_args(name, args, 2)`. Extract both as i64. Error if p <= 0 ("modp: modulus must be positive"). Compute `((a % p) + p) % p`. Return Integer.

6. **mods(a, p)** -- `expect_args(name, args, 2)`. Extract both as i64. Error if p <= 0. Compute `r = ((a % p) + p) % p`. If `r * 2 > p` return `r - p`, else return `r`. Return Integer.

7. **type(expr, t)** -- `expect_args(name, args, 2)`. Extract type name from `args[1]` accepting both `Value::Symbol(s)` and `Value::String(s)`. Match against: "integer", "rational", "numeric" (Integer or Rational), "series", "list", "string", "boolean", "symbol"/"name", "procedure", "infinity". Unknown type names return false (not error). Return Bool.

8. **evalb(expr)** -- `expect_args(name, args, 1)`. For `Value::Bool(b)` return as-is. For `Value::Integer(n)` return Bool(!n.is_zero()). Error on other types with "evalb: expected boolean or integer, got {type}".

9. **cat(s1, s2, ...)** -- `expect_args_range(name, args, 1, 100)` (or check `args.is_empty()` and return WrongArgCount error). Build String by iterating args: Symbol -> push name, String -> push content, Integer -> push decimal string via `n.0.to_string()`, Rational -> push `"{}/{}"` format with numer/denom, Bool -> push "true"/"false". Other types -> push `arg.type_name()`. Return `Value::Symbol(result)`.

Also update `get_signature()` (~line 6060 area) with 9 new match arms:
- "coeff" => "(f, q, n) -- coefficient of q^n in series f"
- "degree" => "(f, q) -- highest degree of q in polynomial/series f"
- "numer" => "(x) -- numerator of rational number"
- "denom" => "(x) -- denominator of rational number"
- "modp" => "(a, p) -- a mod p (non-negative)"
- "mods" => "(a, p) -- a mod p (symmetric, centered at 0)"
- "type" => "(expr, t) -- check if expr has type t"
- "evalb" => "(expr) -- evaluate expression as boolean"
- "cat" => "(s1, s2, ...) -- concatenate arguments into a name"

Update `ALL_FUNCTION_NAMES` (~line 6242 area): add a new group comment "// Pattern V: Series Coefficient & Utility" with entries: "coeff", "degree", "numer", "denom", "modp", "mods", "type", "evalb", "cat".

Add unit tests in the `mod tests` section at the end of eval.rs (follow the dispatch test pattern from Phase 53):
- `dispatch_coeff_integer_constant`: coeff(42, q, 0) = 42, coeff(42, q, 1) = 0
- `dispatch_numer_rational`: numer(3/4) = 3
- `dispatch_denom_rational`: denom(3/4) = 4
- `dispatch_numer_integer`: numer(42) = 42
- `dispatch_denom_integer`: denom(42) = 1
- `dispatch_modp_basic`: modp(7, 3) = 1
- `dispatch_modp_negative`: modp(-7, 3) = 2
- `dispatch_mods_basic`: mods(7, 3) = 1
- `dispatch_mods_symmetric`: mods(5, 3) = -1
- `dispatch_type_integer`: type(42, Symbol("integer")) = true
- `dispatch_type_series_false`: type(42, Symbol("series")) = false
- `dispatch_evalb_true`: evalb(Bool(true)) = true
- `dispatch_evalb_zero`: evalb(Integer(0)) = false
- `dispatch_evalb_nonzero`: evalb(Integer(42)) = true
- `dispatch_cat_symbols`: cat(Symbol("a"), Symbol("b"), Symbol("c")) = Symbol("abc")
- `dispatch_cat_mixed`: cat(Symbol("x"), Integer(42)) = Symbol("x42")

Also add parse+eval integration tests:
- `eval_coeff_constant`: parse("coeff(42, q, 0)") = "42"
- `eval_degree_constant`: parse("degree(42, q)") = "0"
- `eval_modp_expr`: parse("modp(7, 3)") = "1"
- `eval_mods_expr`: parse("mods(5, 3)") = "-1"
- `eval_type_integer`: parse("type(42, integer)") = "true"
- `eval_evalb_comparison`: parse("evalb(3 > 2)") = "true"
- `eval_cat_expr`: parse("cat(a, b, c)") = "abc"
- `eval_numer_expr`: parse("numer(3/4)") = "3"
- `eval_denom_expr`: parse("denom(3/4)") = "4"
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli --lib` -- all existing + new unit tests pass.
  </verify>
  <done>All 9 dispatch arms implemented with correct Maple semantics, signatures registered, ALL_FUNCTION_NAMES updated, and 20+ unit tests passing.</done>
</task>

<task type="auto">
  <name>Task 2: Help entries, tab completion, general_help, count updates, and integration tests</name>
  <files>crates/qsym-cli/src/help.rs, crates/qsym-cli/src/repl.rs, crates/qsym-cli/tests/cli_integration.rs</files>
  <action>
**help.rs -- FUNC_HELP entries:**

Add 9 new FuncHelp entries to the FUNC_HELP array (before the closing `];`). Add them in a new group:

```
// -----------------------------------------------------------------------
// Group V: Series Coefficient & Utility Functions (9)
// -----------------------------------------------------------------------
```

Entries (follow exact FuncHelp struct format):
1. coeff: signature "coeff(f, q, n)", description about extracting coefficient of q^n, example "q> coeff(aqprod(q, q, infinity, 20), q, 5)", output the actual coefficient value.
2. degree: signature "degree(f, q)", description about highest degree, example "q> degree(1 + q + q^2, q)", output "2".
3. numer: signature "numer(x)", description about numerator, example "q> numer(3/4)", output "3".
4. denom: signature "denom(x)", description about denominator, example "q> denom(3/4)", output "4".
5. modp: signature "modp(a, p)", description about non-negative mod, example "q> modp(7, 3)", output "1".
6. mods: signature "mods(a, p)", description about symmetric mod, example "q> mods(5, 3)", output "-1".
7. type: signature "type(expr, t)", description about type checking, example "q> type(42, integer)", output "true".
8. evalb: signature "evalb(expr)", description about boolean evaluation, example "q> evalb(3 > 2)", output "true".
9. cat: signature "cat(s1, s2, ...)", description about name concatenation, example "q> cat(a, b, c)", output "abc".

**help.rs -- general_help():**

Add a new category in the general_help() string, after "List Operations:" and before "Series Analysis:":

```
Series Coefficients & Utility:
  coeff    - extract coefficient of q^n from a series: coeff(f, q, n)
  degree   - highest power of q with nonzero coefficient
  numer    - numerator of a rational number
  denom    - denominator of a rational number
  modp     - a mod p (non-negative result)
  mods     - a mod p (symmetric, centered at 0)
  type     - check expression type: type(expr, integer)
  evalb    - evaluate expression as boolean
  cat      - concatenate arguments into a name: cat(a, b, c)
```

**help.rs -- Update counts in tests:**

1. In `every_canonical_function_has_help_entry()` test (~line 1176): Add the 9 new names to the canonical vec: "coeff", "degree", "numer", "denom", "modp", "mods", "type", "evalb", "cat". Update the assertion from `assert_eq!(canonical.len(), 103, ...)` to `assert_eq!(canonical.len(), 112, ...)`.

2. In `func_help_count_matches_canonical()` test (~line 1224): Update from `103` to `112`.

3. Update the doc comment at top of help.rs from "103 functions" to "112 functions".

4. Add the new category "Series Coefficients & Utility:" to the `general_help_contains_all_categories` test (~line 1061).

**repl.rs -- canonical_function_names():**

Add 9 entries at the end (before the closing `]`), in a new group:

```rust
// Group V: Series Coefficients & Utility (9)
"coeff", "degree", "numer", "denom", "modp", "mods", "type", "evalb", "cat",
```

Update the doc comment from "All 105 canonical function names" to "All 114 canonical function names".

**cli_integration.rs -- Integration tests:**

Add integration tests using the `run(&["-c", "expr"])` pattern (same as existing tests):

1. `coeff_series`: run `coeff(aqprod(q, q, infinity, 20), q, 5)` -- assert output contains expected coefficient (check what it is -- partition coefficient p(5)... actually aqprod(q,q,inf) = (q;q)_inf = Euler function, coefficient of q^5 should be a specific value; the exact value can be derived from the pentagonal number theorem).
2. `coeff_constant`: run `coeff(42, q, 0)` -- assert output is "42".
3. `degree_polynomial`: run `degree(1 + q + q^2, q)` -- assert output is "2".
4. `numer_rational`: run `numer(3/4)` -- assert output is "3".
5. `denom_rational`: run `denom(3/4)` -- assert output is "4".
6. `modp_basic`: run `modp(7, 3)` -- assert output is "1".
7. `modp_negative`: run `modp(-7, 3)` -- assert output is "2".
8. `mods_basic`: run `mods(7, 3)` -- assert output is "1".
9. `mods_symmetric`: run `mods(5, 3)` -- assert output is "-1".
10. `type_integer`: run `type(42, integer)` -- assert output is "true".
11. `type_series`: run `type(aqprod(q,q,infinity), series)` -- assert output is "true".
12. `evalb_comparison`: run `evalb(3 > 2)` -- assert output is "true".
13. `cat_symbols`: run `cat(a, b, c)` -- assert output is "abc".
14. `cat_mixed`: run `cat(x, 42)` -- assert output is "x42".
  </action>
  <verify>
Run `export PATH="/c/mingw64-gcc/mingw64/bin:/c/cygwin64/bin:/c/Users/Owner/.cargo/bin:$PATH" && cargo test -p qsym-cli` -- all tests pass (lib + integration).
  </verify>
  <done>All 9 functions have help entries showing via `?funcname`, tab completion works, general help shows the new category, function counts updated to 112 FUNC_HELP / 114 canonical, and 14+ integration tests pass end-to-end.</done>
</task>

</tasks>

<verification>
1. `cargo test -p qsym-cli` -- all tests pass (existing 794+ plus ~40 new)
2. `cargo run -p qsym-cli -- -c "coeff(aqprod(q,q,infinity,20), q, 5)"` -- outputs a specific integer
3. `cargo run -p qsym-cli -- -c "degree(1 + q + q^2, q)"` -- outputs "2"
4. `cargo run -p qsym-cli -- -c "numer(3/4)"` -- outputs "3"
5. `cargo run -p qsym-cli -- -c "modp(-7, 3)"` -- outputs "2"
6. `cargo run -p qsym-cli -- -c "mods(5, 3)"` -- outputs "-1"
7. `cargo run -p qsym-cli -- -c "type(42, integer)"` -- outputs "true"
8. `cargo run -p qsym-cli -- -c "evalb(3 > 2)"` -- outputs "true"
9. `cargo run -p qsym-cli -- -c "cat(a, b, c)"` -- outputs "abc"
</verification>

<success_criteria>
- All 9 functions dispatch correctly with proper Maple semantics
- coeff guards truncation order and handles Integer/Rational constants
- modp always returns non-negative; mods returns symmetric range
- type accepts both Symbol and String as type name argument
- All existing 794+ tests still pass
- 30-40 new tests covering all functions and edge cases
- Help entries, tab completion, and general_help all updated
- Function counts: 112 FUNC_HELP, 114 ALL_FUNCTION_NAMES, 114 canonical_function_names
</success_criteria>

<output>
After completion, create `.planning/phases/54-series-utility-functions/54-01-SUMMARY.md`
</output>
